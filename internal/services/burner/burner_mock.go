// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package burner

import (
	"context"
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// BurnerMock implements Burner
type BurnerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBurn          func(ctx context.Context, w io.Writer, input <-chan []int16, channels int, sampleRate int) (err error)
	funcBurnOrigin    string
	inspectFuncBurn   func(ctx context.Context, w io.Writer, input <-chan []int16, channels int, sampleRate int)
	afterBurnCounter  uint64
	beforeBurnCounter uint64
	BurnMock          mBurnerMockBurn
}

// NewBurnerMock returns a mock for Burner
func NewBurnerMock(t minimock.Tester) *BurnerMock {
	m := &BurnerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BurnMock = mBurnerMockBurn{mock: m}
	m.BurnMock.callArgs = []*BurnerMockBurnParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mBurnerMockBurn struct {
	optional           bool
	mock               *BurnerMock
	defaultExpectation *BurnerMockBurnExpectation
	expectations       []*BurnerMockBurnExpectation

	callArgs []*BurnerMockBurnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BurnerMockBurnExpectation specifies expectation struct of the Burner.Burn
type BurnerMockBurnExpectation struct {
	mock               *BurnerMock
	params             *BurnerMockBurnParams
	paramPtrs          *BurnerMockBurnParamPtrs
	expectationOrigins BurnerMockBurnExpectationOrigins
	results            *BurnerMockBurnResults
	returnOrigin       string
	Counter            uint64
}

// BurnerMockBurnParams contains parameters of the Burner.Burn
type BurnerMockBurnParams struct {
	ctx        context.Context
	w          io.Writer
	input      <-chan []int16
	channels   int
	sampleRate int
}

// BurnerMockBurnParamPtrs contains pointers to parameters of the Burner.Burn
type BurnerMockBurnParamPtrs struct {
	ctx        *context.Context
	w          *io.Writer
	input      *<-chan []int16
	channels   *int
	sampleRate *int
}

// BurnerMockBurnResults contains results of the Burner.Burn
type BurnerMockBurnResults struct {
	err error
}

// BurnerMockBurnOrigins contains origins of expectations of the Burner.Burn
type BurnerMockBurnExpectationOrigins struct {
	origin           string
	originCtx        string
	originW          string
	originInput      string
	originChannels   string
	originSampleRate string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBurn *mBurnerMockBurn) Optional() *mBurnerMockBurn {
	mmBurn.optional = true
	return mmBurn
}

// Expect sets up expected params for Burner.Burn
func (mmBurn *mBurnerMockBurn) Expect(ctx context.Context, w io.Writer, input <-chan []int16, channels int, sampleRate int) *mBurnerMockBurn {
	if mmBurn.mock.funcBurn != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by Set")
	}

	if mmBurn.defaultExpectation == nil {
		mmBurn.defaultExpectation = &BurnerMockBurnExpectation{}
	}

	if mmBurn.defaultExpectation.paramPtrs != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by ExpectParams functions")
	}

	mmBurn.defaultExpectation.params = &BurnerMockBurnParams{ctx, w, input, channels, sampleRate}
	mmBurn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmBurn.expectations {
		if minimock.Equal(e.params, mmBurn.defaultExpectation.params) {
			mmBurn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBurn.defaultExpectation.params)
		}
	}

	return mmBurn
}

// ExpectCtxParam1 sets up expected param ctx for Burner.Burn
func (mmBurn *mBurnerMockBurn) ExpectCtxParam1(ctx context.Context) *mBurnerMockBurn {
	if mmBurn.mock.funcBurn != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by Set")
	}

	if mmBurn.defaultExpectation == nil {
		mmBurn.defaultExpectation = &BurnerMockBurnExpectation{}
	}

	if mmBurn.defaultExpectation.params != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by Expect")
	}

	if mmBurn.defaultExpectation.paramPtrs == nil {
		mmBurn.defaultExpectation.paramPtrs = &BurnerMockBurnParamPtrs{}
	}
	mmBurn.defaultExpectation.paramPtrs.ctx = &ctx
	mmBurn.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmBurn
}

// ExpectWParam2 sets up expected param w for Burner.Burn
func (mmBurn *mBurnerMockBurn) ExpectWParam2(w io.Writer) *mBurnerMockBurn {
	if mmBurn.mock.funcBurn != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by Set")
	}

	if mmBurn.defaultExpectation == nil {
		mmBurn.defaultExpectation = &BurnerMockBurnExpectation{}
	}

	if mmBurn.defaultExpectation.params != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by Expect")
	}

	if mmBurn.defaultExpectation.paramPtrs == nil {
		mmBurn.defaultExpectation.paramPtrs = &BurnerMockBurnParamPtrs{}
	}
	mmBurn.defaultExpectation.paramPtrs.w = &w
	mmBurn.defaultExpectation.expectationOrigins.originW = minimock.CallerInfo(1)

	return mmBurn
}

// ExpectInputParam3 sets up expected param input for Burner.Burn
func (mmBurn *mBurnerMockBurn) ExpectInputParam3(input <-chan []int16) *mBurnerMockBurn {
	if mmBurn.mock.funcBurn != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by Set")
	}

	if mmBurn.defaultExpectation == nil {
		mmBurn.defaultExpectation = &BurnerMockBurnExpectation{}
	}

	if mmBurn.defaultExpectation.params != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by Expect")
	}

	if mmBurn.defaultExpectation.paramPtrs == nil {
		mmBurn.defaultExpectation.paramPtrs = &BurnerMockBurnParamPtrs{}
	}
	mmBurn.defaultExpectation.paramPtrs.input = &input
	mmBurn.defaultExpectation.expectationOrigins.originInput = minimock.CallerInfo(1)

	return mmBurn
}

// ExpectChannelsParam4 sets up expected param channels for Burner.Burn
func (mmBurn *mBurnerMockBurn) ExpectChannelsParam4(channels int) *mBurnerMockBurn {
	if mmBurn.mock.funcBurn != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by Set")
	}

	if mmBurn.defaultExpectation == nil {
		mmBurn.defaultExpectation = &BurnerMockBurnExpectation{}
	}

	if mmBurn.defaultExpectation.params != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by Expect")
	}

	if mmBurn.defaultExpectation.paramPtrs == nil {
		mmBurn.defaultExpectation.paramPtrs = &BurnerMockBurnParamPtrs{}
	}
	mmBurn.defaultExpectation.paramPtrs.channels = &channels
	mmBurn.defaultExpectation.expectationOrigins.originChannels = minimock.CallerInfo(1)

	return mmBurn
}

// ExpectSampleRateParam5 sets up expected param sampleRate for Burner.Burn
func (mmBurn *mBurnerMockBurn) ExpectSampleRateParam5(sampleRate int) *mBurnerMockBurn {
	if mmBurn.mock.funcBurn != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by Set")
	}

	if mmBurn.defaultExpectation == nil {
		mmBurn.defaultExpectation = &BurnerMockBurnExpectation{}
	}

	if mmBurn.defaultExpectation.params != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by Expect")
	}

	if mmBurn.defaultExpectation.paramPtrs == nil {
		mmBurn.defaultExpectation.paramPtrs = &BurnerMockBurnParamPtrs{}
	}
	mmBurn.defaultExpectation.paramPtrs.sampleRate = &sampleRate
	mmBurn.defaultExpectation.expectationOrigins.originSampleRate = minimock.CallerInfo(1)

	return mmBurn
}

// Inspect accepts an inspector function that has same arguments as the Burner.Burn
func (mmBurn *mBurnerMockBurn) Inspect(f func(ctx context.Context, w io.Writer, input <-chan []int16, channels int, sampleRate int)) *mBurnerMockBurn {
	if mmBurn.mock.inspectFuncBurn != nil {
		mmBurn.mock.t.Fatalf("Inspect function is already set for BurnerMock.Burn")
	}

	mmBurn.mock.inspectFuncBurn = f

	return mmBurn
}

// Return sets up results that will be returned by Burner.Burn
func (mmBurn *mBurnerMockBurn) Return(err error) *BurnerMock {
	if mmBurn.mock.funcBurn != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by Set")
	}

	if mmBurn.defaultExpectation == nil {
		mmBurn.defaultExpectation = &BurnerMockBurnExpectation{mock: mmBurn.mock}
	}
	mmBurn.defaultExpectation.results = &BurnerMockBurnResults{err}
	mmBurn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBurn.mock
}

// Set uses given function f to mock the Burner.Burn method
func (mmBurn *mBurnerMockBurn) Set(f func(ctx context.Context, w io.Writer, input <-chan []int16, channels int, sampleRate int) (err error)) *BurnerMock {
	if mmBurn.defaultExpectation != nil {
		mmBurn.mock.t.Fatalf("Default expectation is already set for the Burner.Burn method")
	}

	if len(mmBurn.expectations) > 0 {
		mmBurn.mock.t.Fatalf("Some expectations are already set for the Burner.Burn method")
	}

	mmBurn.mock.funcBurn = f
	mmBurn.mock.funcBurnOrigin = minimock.CallerInfo(1)
	return mmBurn.mock
}

// When sets expectation for the Burner.Burn which will trigger the result defined by the following
// Then helper
func (mmBurn *mBurnerMockBurn) When(ctx context.Context, w io.Writer, input <-chan []int16, channels int, sampleRate int) *BurnerMockBurnExpectation {
	if mmBurn.mock.funcBurn != nil {
		mmBurn.mock.t.Fatalf("BurnerMock.Burn mock is already set by Set")
	}

	expectation := &BurnerMockBurnExpectation{
		mock:               mmBurn.mock,
		params:             &BurnerMockBurnParams{ctx, w, input, channels, sampleRate},
		expectationOrigins: BurnerMockBurnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmBurn.expectations = append(mmBurn.expectations, expectation)
	return expectation
}

// Then sets up Burner.Burn return parameters for the expectation previously defined by the When method
func (e *BurnerMockBurnExpectation) Then(err error) *BurnerMock {
	e.results = &BurnerMockBurnResults{err}
	return e.mock
}

// Times sets number of times Burner.Burn should be invoked
func (mmBurn *mBurnerMockBurn) Times(n uint64) *mBurnerMockBurn {
	if n == 0 {
		mmBurn.mock.t.Fatalf("Times of BurnerMock.Burn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBurn.expectedInvocations, n)
	mmBurn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBurn
}

func (mmBurn *mBurnerMockBurn) invocationsDone() bool {
	if len(mmBurn.expectations) == 0 && mmBurn.defaultExpectation == nil && mmBurn.mock.funcBurn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBurn.mock.afterBurnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBurn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Burn implements Burner
func (mmBurn *BurnerMock) Burn(ctx context.Context, w io.Writer, input <-chan []int16, channels int, sampleRate int) (err error) {
	mm_atomic.AddUint64(&mmBurn.beforeBurnCounter, 1)
	defer mm_atomic.AddUint64(&mmBurn.afterBurnCounter, 1)

	mmBurn.t.Helper()

	if mmBurn.inspectFuncBurn != nil {
		mmBurn.inspectFuncBurn(ctx, w, input, channels, sampleRate)
	}

	mm_params := BurnerMockBurnParams{ctx, w, input, channels, sampleRate}

	// Record call args
	mmBurn.BurnMock.mutex.Lock()
	mmBurn.BurnMock.callArgs = append(mmBurn.BurnMock.callArgs, &mm_params)
	mmBurn.BurnMock.mutex.Unlock()

	for _, e := range mmBurn.BurnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmBurn.BurnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBurn.BurnMock.defaultExpectation.Counter, 1)
		mm_want := mmBurn.BurnMock.defaultExpectation.params
		mm_want_ptrs := mmBurn.BurnMock.defaultExpectation.paramPtrs

		mm_got := BurnerMockBurnParams{ctx, w, input, channels, sampleRate}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBurn.t.Errorf("BurnerMock.Burn got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBurn.BurnMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.w != nil && !minimock.Equal(*mm_want_ptrs.w, mm_got.w) {
				mmBurn.t.Errorf("BurnerMock.Burn got unexpected parameter w, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBurn.BurnMock.defaultExpectation.expectationOrigins.originW, *mm_want_ptrs.w, mm_got.w, minimock.Diff(*mm_want_ptrs.w, mm_got.w))
			}

			if mm_want_ptrs.input != nil && !minimock.Equal(*mm_want_ptrs.input, mm_got.input) {
				mmBurn.t.Errorf("BurnerMock.Burn got unexpected parameter input, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBurn.BurnMock.defaultExpectation.expectationOrigins.originInput, *mm_want_ptrs.input, mm_got.input, minimock.Diff(*mm_want_ptrs.input, mm_got.input))
			}

			if mm_want_ptrs.channels != nil && !minimock.Equal(*mm_want_ptrs.channels, mm_got.channels) {
				mmBurn.t.Errorf("BurnerMock.Burn got unexpected parameter channels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBurn.BurnMock.defaultExpectation.expectationOrigins.originChannels, *mm_want_ptrs.channels, mm_got.channels, minimock.Diff(*mm_want_ptrs.channels, mm_got.channels))
			}

			if mm_want_ptrs.sampleRate != nil && !minimock.Equal(*mm_want_ptrs.sampleRate, mm_got.sampleRate) {
				mmBurn.t.Errorf("BurnerMock.Burn got unexpected parameter sampleRate, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBurn.BurnMock.defaultExpectation.expectationOrigins.originSampleRate, *mm_want_ptrs.sampleRate, mm_got.sampleRate, minimock.Diff(*mm_want_ptrs.sampleRate, mm_got.sampleRate))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBurn.t.Errorf("BurnerMock.Burn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmBurn.BurnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBurn.BurnMock.defaultExpectation.results
		if mm_results == nil {
			mmBurn.t.Fatal("No results are set for the BurnerMock.Burn")
		}
		return (*mm_results).err
	}
	if mmBurn.funcBurn != nil {
		return mmBurn.funcBurn(ctx, w, input, channels, sampleRate)
	}
	mmBurn.t.Fatalf("Unexpected call to BurnerMock.Burn. %v %v %v %v %v", ctx, w, input, channels, sampleRate)
	return
}

// BurnAfterCounter returns a count of finished BurnerMock.Burn invocations
func (mmBurn *BurnerMock) BurnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBurn.afterBurnCounter)
}

// BurnBeforeCounter returns a count of BurnerMock.Burn invocations
func (mmBurn *BurnerMock) BurnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBurn.beforeBurnCounter)
}

// Calls returns a list of arguments used in each call to BurnerMock.Burn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBurn *mBurnerMockBurn) Calls() []*BurnerMockBurnParams {
	mmBurn.mutex.RLock()

	argCopy := make([]*BurnerMockBurnParams, len(mmBurn.callArgs))
	copy(argCopy, mmBurn.callArgs)

	mmBurn.mutex.RUnlock()

	return argCopy
}

// MinimockBurnDone returns true if the count of the Burn invocations corresponds
// the number of defined expectations
func (m *BurnerMock) MinimockBurnDone() bool {
	if m.BurnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BurnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BurnMock.invocationsDone()
}

// MinimockBurnInspect logs each unmet expectation
func (m *BurnerMock) MinimockBurnInspect() {
	for _, e := range m.BurnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BurnerMock.Burn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterBurnCounter := mm_atomic.LoadUint64(&m.afterBurnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BurnMock.defaultExpectation != nil && afterBurnCounter < 1 {
		if m.BurnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BurnerMock.Burn at\n%s", m.BurnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BurnerMock.Burn at\n%s with params: %#v", m.BurnMock.defaultExpectation.expectationOrigins.origin, *m.BurnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBurn != nil && afterBurnCounter < 1 {
		m.t.Errorf("Expected call to BurnerMock.Burn at\n%s", m.funcBurnOrigin)
	}

	if !m.BurnMock.invocationsDone() && afterBurnCounter > 0 {
		m.t.Errorf("Expected %d calls to BurnerMock.Burn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BurnMock.expectedInvocations), m.BurnMock.expectedInvocationsOrigin, afterBurnCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BurnerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBurnInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BurnerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BurnerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBurnDone()
}
