// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package btt

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// BttMock implements Btt
type BttMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDisableCleanView          func(ctx context.Context) (err error)
	funcDisableCleanViewOrigin    string
	inspectFuncDisableCleanView   func(ctx context.Context)
	afterDisableCleanViewCounter  uint64
	beforeDisableCleanViewCounter uint64
	DisableCleanViewMock          mBttMockDisableCleanView

	funcEnableCleanMode          func(ctx context.Context) (err error)
	funcEnableCleanModeOrigin    string
	inspectFuncEnableCleanMode   func(ctx context.Context)
	afterEnableCleanModeCounter  uint64
	beforeEnableCleanModeCounter uint64
	EnableCleanModeMock          mBttMockEnableCleanMode

	funcFloatingPage          func() (s1 string)
	funcFloatingPageOrigin    string
	inspectFuncFloatingPage   func()
	afterFloatingPageCounter  uint64
	beforeFloatingPageCounter uint64
	FloatingPageMock          mBttMockFloatingPage

	funcHealth          func(ctx context.Context) (b1 bool)
	funcHealthOrigin    string
	inspectFuncHealth   func(ctx context.Context)
	afterHealthCounter  uint64
	beforeHealthCounter uint64
	HealthMock          mBttMockHealth

	funcHideClipboard          func(ctx context.Context) (err error)
	funcHideClipboardOrigin    string
	inspectFuncHideClipboard   func(ctx context.Context)
	afterHideClipboardCounter  uint64
	beforeHideClipboardCounter uint64
	HideClipboardMock          mBttMockHideClipboard

	funcHideFloating          func(ctx context.Context) (err error)
	funcHideFloatingOrigin    string
	inspectFuncHideFloating   func(ctx context.Context)
	afterHideFloatingCounter  uint64
	beforeHideFloatingCounter uint64
	HideFloatingMock          mBttMockHideFloating

	funcInstall          func(ctx context.Context) (err error)
	funcInstallOrigin    string
	inspectFuncInstall   func(ctx context.Context)
	afterInstallCounter  uint64
	beforeInstallCounter uint64
	InstallMock          mBttMockInstall

	funcIsAvailable          func(ctx context.Context, device string) (b1 bool, err error)
	funcIsAvailableOrigin    string
	inspectFuncIsAvailable   func(ctx context.Context, device string)
	afterIsAvailableCounter  uint64
	beforeIsAvailableCounter uint64
	IsAvailableMock          mBttMockIsAvailable

	funcIsRunning          func(ctx context.Context) (b1 bool, err error)
	funcIsRunningOrigin    string
	inspectFuncIsRunning   func(ctx context.Context)
	afterIsRunningCounter  uint64
	beforeIsRunningCounter uint64
	IsRunningMock          mBttMockIsRunning

	funcLoadDevices          func(ctx context.Context) (err error)
	funcLoadDevicesOrigin    string
	inspectFuncLoadDevices   func(ctx context.Context)
	afterLoadDevicesCounter  uint64
	beforeLoadDevicesCounter uint64
	LoadDevicesMock          mBttMockLoadDevices

	funcSelectClipboard          func(ctx context.Context, clipboard Clipboard) (err error)
	funcSelectClipboardOrigin    string
	inspectFuncSelectClipboard   func(ctx context.Context, clipboard Clipboard)
	afterSelectClipboardCounter  uint64
	beforeSelectClipboardCounter uint64
	SelectClipboardMock          mBttMockSelectClipboard

	funcSelectDevice          func(ctx context.Context, device string) (err error)
	funcSelectDeviceOrigin    string
	inspectFuncSelectDevice   func(ctx context.Context, device string)
	afterSelectDeviceCounter  uint64
	beforeSelectDeviceCounter uint64
	SelectDeviceMock          mBttMockSelectDevice

	funcSelectFloating          func(ctx context.Context, floating Floating) (err error)
	funcSelectFloatingOrigin    string
	inspectFuncSelectFloating   func(ctx context.Context, floating Floating)
	afterSelectFloatingCounter  uint64
	beforeSelectFloatingCounter uint64
	SelectFloatingMock          mBttMockSelectFloating

	funcSelectLanguage          func(ctx context.Context, language string) (err error)
	funcSelectLanguageOrigin    string
	inspectFuncSelectLanguage   func(ctx context.Context, language string)
	afterSelectLanguageCounter  uint64
	beforeSelectLanguageCounter uint64
	SelectLanguageMock          mBttMockSelectLanguage

	funcSelectViewMode          func(ctx context.Context, viewMode ViewMode) (err error)
	funcSelectViewModeOrigin    string
	inspectFuncSelectViewMode   func(ctx context.Context, viewMode ViewMode)
	afterSelectViewModeCounter  uint64
	beforeSelectViewModeCounter uint64
	SelectViewModeMock          mBttMockSelectViewMode

	funcSelectedClipboard          func(ctx context.Context) (c2 Clipboard, err error)
	funcSelectedClipboardOrigin    string
	inspectFuncSelectedClipboard   func(ctx context.Context)
	afterSelectedClipboardCounter  uint64
	beforeSelectedClipboardCounter uint64
	SelectedClipboardMock          mBttMockSelectedClipboard

	funcSelectedDevice          func(ctx context.Context) (s1 string, err error)
	funcSelectedDeviceOrigin    string
	inspectFuncSelectedDevice   func(ctx context.Context)
	afterSelectedDeviceCounter  uint64
	beforeSelectedDeviceCounter uint64
	SelectedDeviceMock          mBttMockSelectedDevice

	funcSelectedFloating          func(ctx context.Context) (f1 Floating, err error)
	funcSelectedFloatingOrigin    string
	inspectFuncSelectedFloating   func(ctx context.Context)
	afterSelectedFloatingCounter  uint64
	beforeSelectedFloatingCounter uint64
	SelectedFloatingMock          mBttMockSelectedFloating

	funcSelectedLanguage          func(ctx context.Context) (s1 string, err error)
	funcSelectedLanguageOrigin    string
	inspectFuncSelectedLanguage   func(ctx context.Context)
	afterSelectedLanguageCounter  uint64
	beforeSelectedLanguageCounter uint64
	SelectedLanguageMock          mBttMockSelectedLanguage

	funcSelectedViewMode          func(ctx context.Context) (v1 ViewMode, err error)
	funcSelectedViewModeOrigin    string
	inspectFuncSelectedViewMode   func(ctx context.Context)
	afterSelectedViewModeCounter  uint64
	beforeSelectedViewModeCounter uint64
	SelectedViewModeMock          mBttMockSelectedViewMode

	funcShowClipboard          func(ctx context.Context) (err error)
	funcShowClipboardOrigin    string
	inspectFuncShowClipboard   func(ctx context.Context)
	afterShowClipboardCounter  uint64
	beforeShowClipboardCounter uint64
	ShowClipboardMock          mBttMockShowClipboard

	funcShowFloating          func(ctx context.Context) (err error)
	funcShowFloatingOrigin    string
	inspectFuncShowFloating   func(ctx context.Context)
	afterShowFloatingCounter  uint64
	beforeShowFloatingCounter uint64
	ShowFloatingMock          mBttMockShowFloating

	funcStartListening          func(ctx context.Context) (err error)
	funcStartListeningOrigin    string
	inspectFuncStartListening   func(ctx context.Context)
	afterStartListeningCounter  uint64
	beforeStartListeningCounter uint64
	StartListeningMock          mBttMockStartListening

	funcStopListening          func(ctx context.Context) (err error)
	funcStopListeningOrigin    string
	inspectFuncStopListening   func(ctx context.Context)
	afterStopListeningCounter  uint64
	beforeStopListeningCounter uint64
	StopListeningMock          mBttMockStopListening

	funcStreamText          func(ctx context.Context) (ch1 <-chan string, ch2 <-chan error, err error)
	funcStreamTextOrigin    string
	inspectFuncStreamText   func(ctx context.Context)
	afterStreamTextCounter  uint64
	beforeStreamTextCounter uint64
	StreamTextMock          mBttMockStreamText

	funcText          func(ctx context.Context) (s1 string, err error)
	funcTextOrigin    string
	inspectFuncText   func(ctx context.Context)
	afterTextCounter  uint64
	beforeTextCounter uint64
	TextMock          mBttMockText

	funcToggleListening          func(ctx context.Context) (err error)
	funcToggleListeningOrigin    string
	inspectFuncToggleListening   func(ctx context.Context)
	afterToggleListeningCounter  uint64
	beforeToggleListeningCounter uint64
	ToggleListeningMock          mBttMockToggleListening

	funcUninstall          func(ctx context.Context) (err error)
	funcUninstallOrigin    string
	inspectFuncUninstall   func(ctx context.Context)
	afterUninstallCounter  uint64
	beforeUninstallCounter uint64
	UninstallMock          mBttMockUninstall
}

// NewBttMock returns a mock for Btt
func NewBttMock(t minimock.Tester) *BttMock {
	m := &BttMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DisableCleanViewMock = mBttMockDisableCleanView{mock: m}
	m.DisableCleanViewMock.callArgs = []*BttMockDisableCleanViewParams{}

	m.EnableCleanModeMock = mBttMockEnableCleanMode{mock: m}
	m.EnableCleanModeMock.callArgs = []*BttMockEnableCleanModeParams{}

	m.FloatingPageMock = mBttMockFloatingPage{mock: m}

	m.HealthMock = mBttMockHealth{mock: m}
	m.HealthMock.callArgs = []*BttMockHealthParams{}

	m.HideClipboardMock = mBttMockHideClipboard{mock: m}
	m.HideClipboardMock.callArgs = []*BttMockHideClipboardParams{}

	m.HideFloatingMock = mBttMockHideFloating{mock: m}
	m.HideFloatingMock.callArgs = []*BttMockHideFloatingParams{}

	m.InstallMock = mBttMockInstall{mock: m}
	m.InstallMock.callArgs = []*BttMockInstallParams{}

	m.IsAvailableMock = mBttMockIsAvailable{mock: m}
	m.IsAvailableMock.callArgs = []*BttMockIsAvailableParams{}

	m.IsRunningMock = mBttMockIsRunning{mock: m}
	m.IsRunningMock.callArgs = []*BttMockIsRunningParams{}

	m.LoadDevicesMock = mBttMockLoadDevices{mock: m}
	m.LoadDevicesMock.callArgs = []*BttMockLoadDevicesParams{}

	m.SelectClipboardMock = mBttMockSelectClipboard{mock: m}
	m.SelectClipboardMock.callArgs = []*BttMockSelectClipboardParams{}

	m.SelectDeviceMock = mBttMockSelectDevice{mock: m}
	m.SelectDeviceMock.callArgs = []*BttMockSelectDeviceParams{}

	m.SelectFloatingMock = mBttMockSelectFloating{mock: m}
	m.SelectFloatingMock.callArgs = []*BttMockSelectFloatingParams{}

	m.SelectLanguageMock = mBttMockSelectLanguage{mock: m}
	m.SelectLanguageMock.callArgs = []*BttMockSelectLanguageParams{}

	m.SelectViewModeMock = mBttMockSelectViewMode{mock: m}
	m.SelectViewModeMock.callArgs = []*BttMockSelectViewModeParams{}

	m.SelectedClipboardMock = mBttMockSelectedClipboard{mock: m}
	m.SelectedClipboardMock.callArgs = []*BttMockSelectedClipboardParams{}

	m.SelectedDeviceMock = mBttMockSelectedDevice{mock: m}
	m.SelectedDeviceMock.callArgs = []*BttMockSelectedDeviceParams{}

	m.SelectedFloatingMock = mBttMockSelectedFloating{mock: m}
	m.SelectedFloatingMock.callArgs = []*BttMockSelectedFloatingParams{}

	m.SelectedLanguageMock = mBttMockSelectedLanguage{mock: m}
	m.SelectedLanguageMock.callArgs = []*BttMockSelectedLanguageParams{}

	m.SelectedViewModeMock = mBttMockSelectedViewMode{mock: m}
	m.SelectedViewModeMock.callArgs = []*BttMockSelectedViewModeParams{}

	m.ShowClipboardMock = mBttMockShowClipboard{mock: m}
	m.ShowClipboardMock.callArgs = []*BttMockShowClipboardParams{}

	m.ShowFloatingMock = mBttMockShowFloating{mock: m}
	m.ShowFloatingMock.callArgs = []*BttMockShowFloatingParams{}

	m.StartListeningMock = mBttMockStartListening{mock: m}
	m.StartListeningMock.callArgs = []*BttMockStartListeningParams{}

	m.StopListeningMock = mBttMockStopListening{mock: m}
	m.StopListeningMock.callArgs = []*BttMockStopListeningParams{}

	m.StreamTextMock = mBttMockStreamText{mock: m}
	m.StreamTextMock.callArgs = []*BttMockStreamTextParams{}

	m.TextMock = mBttMockText{mock: m}
	m.TextMock.callArgs = []*BttMockTextParams{}

	m.ToggleListeningMock = mBttMockToggleListening{mock: m}
	m.ToggleListeningMock.callArgs = []*BttMockToggleListeningParams{}

	m.UninstallMock = mBttMockUninstall{mock: m}
	m.UninstallMock.callArgs = []*BttMockUninstallParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mBttMockDisableCleanView struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockDisableCleanViewExpectation
	expectations       []*BttMockDisableCleanViewExpectation

	callArgs []*BttMockDisableCleanViewParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockDisableCleanViewExpectation specifies expectation struct of the Btt.DisableCleanView
type BttMockDisableCleanViewExpectation struct {
	mock               *BttMock
	params             *BttMockDisableCleanViewParams
	paramPtrs          *BttMockDisableCleanViewParamPtrs
	expectationOrigins BttMockDisableCleanViewExpectationOrigins
	results            *BttMockDisableCleanViewResults
	returnOrigin       string
	Counter            uint64
}

// BttMockDisableCleanViewParams contains parameters of the Btt.DisableCleanView
type BttMockDisableCleanViewParams struct {
	ctx context.Context
}

// BttMockDisableCleanViewParamPtrs contains pointers to parameters of the Btt.DisableCleanView
type BttMockDisableCleanViewParamPtrs struct {
	ctx *context.Context
}

// BttMockDisableCleanViewResults contains results of the Btt.DisableCleanView
type BttMockDisableCleanViewResults struct {
	err error
}

// BttMockDisableCleanViewOrigins contains origins of expectations of the Btt.DisableCleanView
type BttMockDisableCleanViewExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDisableCleanView *mBttMockDisableCleanView) Optional() *mBttMockDisableCleanView {
	mmDisableCleanView.optional = true
	return mmDisableCleanView
}

// Expect sets up expected params for Btt.DisableCleanView
func (mmDisableCleanView *mBttMockDisableCleanView) Expect(ctx context.Context) *mBttMockDisableCleanView {
	if mmDisableCleanView.mock.funcDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("BttMock.DisableCleanView mock is already set by Set")
	}

	if mmDisableCleanView.defaultExpectation == nil {
		mmDisableCleanView.defaultExpectation = &BttMockDisableCleanViewExpectation{}
	}

	if mmDisableCleanView.defaultExpectation.paramPtrs != nil {
		mmDisableCleanView.mock.t.Fatalf("BttMock.DisableCleanView mock is already set by ExpectParams functions")
	}

	mmDisableCleanView.defaultExpectation.params = &BttMockDisableCleanViewParams{ctx}
	mmDisableCleanView.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDisableCleanView.expectations {
		if minimock.Equal(e.params, mmDisableCleanView.defaultExpectation.params) {
			mmDisableCleanView.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDisableCleanView.defaultExpectation.params)
		}
	}

	return mmDisableCleanView
}

// ExpectCtxParam1 sets up expected param ctx for Btt.DisableCleanView
func (mmDisableCleanView *mBttMockDisableCleanView) ExpectCtxParam1(ctx context.Context) *mBttMockDisableCleanView {
	if mmDisableCleanView.mock.funcDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("BttMock.DisableCleanView mock is already set by Set")
	}

	if mmDisableCleanView.defaultExpectation == nil {
		mmDisableCleanView.defaultExpectation = &BttMockDisableCleanViewExpectation{}
	}

	if mmDisableCleanView.defaultExpectation.params != nil {
		mmDisableCleanView.mock.t.Fatalf("BttMock.DisableCleanView mock is already set by Expect")
	}

	if mmDisableCleanView.defaultExpectation.paramPtrs == nil {
		mmDisableCleanView.defaultExpectation.paramPtrs = &BttMockDisableCleanViewParamPtrs{}
	}
	mmDisableCleanView.defaultExpectation.paramPtrs.ctx = &ctx
	mmDisableCleanView.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDisableCleanView
}

// Inspect accepts an inspector function that has same arguments as the Btt.DisableCleanView
func (mmDisableCleanView *mBttMockDisableCleanView) Inspect(f func(ctx context.Context)) *mBttMockDisableCleanView {
	if mmDisableCleanView.mock.inspectFuncDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("Inspect function is already set for BttMock.DisableCleanView")
	}

	mmDisableCleanView.mock.inspectFuncDisableCleanView = f

	return mmDisableCleanView
}

// Return sets up results that will be returned by Btt.DisableCleanView
func (mmDisableCleanView *mBttMockDisableCleanView) Return(err error) *BttMock {
	if mmDisableCleanView.mock.funcDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("BttMock.DisableCleanView mock is already set by Set")
	}

	if mmDisableCleanView.defaultExpectation == nil {
		mmDisableCleanView.defaultExpectation = &BttMockDisableCleanViewExpectation{mock: mmDisableCleanView.mock}
	}
	mmDisableCleanView.defaultExpectation.results = &BttMockDisableCleanViewResults{err}
	mmDisableCleanView.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDisableCleanView.mock
}

// Set uses given function f to mock the Btt.DisableCleanView method
func (mmDisableCleanView *mBttMockDisableCleanView) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmDisableCleanView.defaultExpectation != nil {
		mmDisableCleanView.mock.t.Fatalf("Default expectation is already set for the Btt.DisableCleanView method")
	}

	if len(mmDisableCleanView.expectations) > 0 {
		mmDisableCleanView.mock.t.Fatalf("Some expectations are already set for the Btt.DisableCleanView method")
	}

	mmDisableCleanView.mock.funcDisableCleanView = f
	mmDisableCleanView.mock.funcDisableCleanViewOrigin = minimock.CallerInfo(1)
	return mmDisableCleanView.mock
}

// When sets expectation for the Btt.DisableCleanView which will trigger the result defined by the following
// Then helper
func (mmDisableCleanView *mBttMockDisableCleanView) When(ctx context.Context) *BttMockDisableCleanViewExpectation {
	if mmDisableCleanView.mock.funcDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("BttMock.DisableCleanView mock is already set by Set")
	}

	expectation := &BttMockDisableCleanViewExpectation{
		mock:               mmDisableCleanView.mock,
		params:             &BttMockDisableCleanViewParams{ctx},
		expectationOrigins: BttMockDisableCleanViewExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDisableCleanView.expectations = append(mmDisableCleanView.expectations, expectation)
	return expectation
}

// Then sets up Btt.DisableCleanView return parameters for the expectation previously defined by the When method
func (e *BttMockDisableCleanViewExpectation) Then(err error) *BttMock {
	e.results = &BttMockDisableCleanViewResults{err}
	return e.mock
}

// Times sets number of times Btt.DisableCleanView should be invoked
func (mmDisableCleanView *mBttMockDisableCleanView) Times(n uint64) *mBttMockDisableCleanView {
	if n == 0 {
		mmDisableCleanView.mock.t.Fatalf("Times of BttMock.DisableCleanView mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDisableCleanView.expectedInvocations, n)
	mmDisableCleanView.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDisableCleanView
}

func (mmDisableCleanView *mBttMockDisableCleanView) invocationsDone() bool {
	if len(mmDisableCleanView.expectations) == 0 && mmDisableCleanView.defaultExpectation == nil && mmDisableCleanView.mock.funcDisableCleanView == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDisableCleanView.mock.afterDisableCleanViewCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDisableCleanView.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DisableCleanView implements Btt
func (mmDisableCleanView *BttMock) DisableCleanView(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmDisableCleanView.beforeDisableCleanViewCounter, 1)
	defer mm_atomic.AddUint64(&mmDisableCleanView.afterDisableCleanViewCounter, 1)

	mmDisableCleanView.t.Helper()

	if mmDisableCleanView.inspectFuncDisableCleanView != nil {
		mmDisableCleanView.inspectFuncDisableCleanView(ctx)
	}

	mm_params := BttMockDisableCleanViewParams{ctx}

	// Record call args
	mmDisableCleanView.DisableCleanViewMock.mutex.Lock()
	mmDisableCleanView.DisableCleanViewMock.callArgs = append(mmDisableCleanView.DisableCleanViewMock.callArgs, &mm_params)
	mmDisableCleanView.DisableCleanViewMock.mutex.Unlock()

	for _, e := range mmDisableCleanView.DisableCleanViewMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDisableCleanView.DisableCleanViewMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDisableCleanView.DisableCleanViewMock.defaultExpectation.Counter, 1)
		mm_want := mmDisableCleanView.DisableCleanViewMock.defaultExpectation.params
		mm_want_ptrs := mmDisableCleanView.DisableCleanViewMock.defaultExpectation.paramPtrs

		mm_got := BttMockDisableCleanViewParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDisableCleanView.t.Errorf("BttMock.DisableCleanView got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDisableCleanView.DisableCleanViewMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDisableCleanView.t.Errorf("BttMock.DisableCleanView got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDisableCleanView.DisableCleanViewMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDisableCleanView.DisableCleanViewMock.defaultExpectation.results
		if mm_results == nil {
			mmDisableCleanView.t.Fatal("No results are set for the BttMock.DisableCleanView")
		}
		return (*mm_results).err
	}
	if mmDisableCleanView.funcDisableCleanView != nil {
		return mmDisableCleanView.funcDisableCleanView(ctx)
	}
	mmDisableCleanView.t.Fatalf("Unexpected call to BttMock.DisableCleanView. %v", ctx)
	return
}

// DisableCleanViewAfterCounter returns a count of finished BttMock.DisableCleanView invocations
func (mmDisableCleanView *BttMock) DisableCleanViewAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDisableCleanView.afterDisableCleanViewCounter)
}

// DisableCleanViewBeforeCounter returns a count of BttMock.DisableCleanView invocations
func (mmDisableCleanView *BttMock) DisableCleanViewBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDisableCleanView.beforeDisableCleanViewCounter)
}

// Calls returns a list of arguments used in each call to BttMock.DisableCleanView.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDisableCleanView *mBttMockDisableCleanView) Calls() []*BttMockDisableCleanViewParams {
	mmDisableCleanView.mutex.RLock()

	argCopy := make([]*BttMockDisableCleanViewParams, len(mmDisableCleanView.callArgs))
	copy(argCopy, mmDisableCleanView.callArgs)

	mmDisableCleanView.mutex.RUnlock()

	return argCopy
}

// MinimockDisableCleanViewDone returns true if the count of the DisableCleanView invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockDisableCleanViewDone() bool {
	if m.DisableCleanViewMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DisableCleanViewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DisableCleanViewMock.invocationsDone()
}

// MinimockDisableCleanViewInspect logs each unmet expectation
func (m *BttMock) MinimockDisableCleanViewInspect() {
	for _, e := range m.DisableCleanViewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.DisableCleanView at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDisableCleanViewCounter := mm_atomic.LoadUint64(&m.afterDisableCleanViewCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DisableCleanViewMock.defaultExpectation != nil && afterDisableCleanViewCounter < 1 {
		if m.DisableCleanViewMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.DisableCleanView at\n%s", m.DisableCleanViewMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.DisableCleanView at\n%s with params: %#v", m.DisableCleanViewMock.defaultExpectation.expectationOrigins.origin, *m.DisableCleanViewMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDisableCleanView != nil && afterDisableCleanViewCounter < 1 {
		m.t.Errorf("Expected call to BttMock.DisableCleanView at\n%s", m.funcDisableCleanViewOrigin)
	}

	if !m.DisableCleanViewMock.invocationsDone() && afterDisableCleanViewCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.DisableCleanView at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DisableCleanViewMock.expectedInvocations), m.DisableCleanViewMock.expectedInvocationsOrigin, afterDisableCleanViewCounter)
	}
}

type mBttMockEnableCleanMode struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockEnableCleanModeExpectation
	expectations       []*BttMockEnableCleanModeExpectation

	callArgs []*BttMockEnableCleanModeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockEnableCleanModeExpectation specifies expectation struct of the Btt.EnableCleanMode
type BttMockEnableCleanModeExpectation struct {
	mock               *BttMock
	params             *BttMockEnableCleanModeParams
	paramPtrs          *BttMockEnableCleanModeParamPtrs
	expectationOrigins BttMockEnableCleanModeExpectationOrigins
	results            *BttMockEnableCleanModeResults
	returnOrigin       string
	Counter            uint64
}

// BttMockEnableCleanModeParams contains parameters of the Btt.EnableCleanMode
type BttMockEnableCleanModeParams struct {
	ctx context.Context
}

// BttMockEnableCleanModeParamPtrs contains pointers to parameters of the Btt.EnableCleanMode
type BttMockEnableCleanModeParamPtrs struct {
	ctx *context.Context
}

// BttMockEnableCleanModeResults contains results of the Btt.EnableCleanMode
type BttMockEnableCleanModeResults struct {
	err error
}

// BttMockEnableCleanModeOrigins contains origins of expectations of the Btt.EnableCleanMode
type BttMockEnableCleanModeExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEnableCleanMode *mBttMockEnableCleanMode) Optional() *mBttMockEnableCleanMode {
	mmEnableCleanMode.optional = true
	return mmEnableCleanMode
}

// Expect sets up expected params for Btt.EnableCleanMode
func (mmEnableCleanMode *mBttMockEnableCleanMode) Expect(ctx context.Context) *mBttMockEnableCleanMode {
	if mmEnableCleanMode.mock.funcEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("BttMock.EnableCleanMode mock is already set by Set")
	}

	if mmEnableCleanMode.defaultExpectation == nil {
		mmEnableCleanMode.defaultExpectation = &BttMockEnableCleanModeExpectation{}
	}

	if mmEnableCleanMode.defaultExpectation.paramPtrs != nil {
		mmEnableCleanMode.mock.t.Fatalf("BttMock.EnableCleanMode mock is already set by ExpectParams functions")
	}

	mmEnableCleanMode.defaultExpectation.params = &BttMockEnableCleanModeParams{ctx}
	mmEnableCleanMode.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEnableCleanMode.expectations {
		if minimock.Equal(e.params, mmEnableCleanMode.defaultExpectation.params) {
			mmEnableCleanMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEnableCleanMode.defaultExpectation.params)
		}
	}

	return mmEnableCleanMode
}

// ExpectCtxParam1 sets up expected param ctx for Btt.EnableCleanMode
func (mmEnableCleanMode *mBttMockEnableCleanMode) ExpectCtxParam1(ctx context.Context) *mBttMockEnableCleanMode {
	if mmEnableCleanMode.mock.funcEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("BttMock.EnableCleanMode mock is already set by Set")
	}

	if mmEnableCleanMode.defaultExpectation == nil {
		mmEnableCleanMode.defaultExpectation = &BttMockEnableCleanModeExpectation{}
	}

	if mmEnableCleanMode.defaultExpectation.params != nil {
		mmEnableCleanMode.mock.t.Fatalf("BttMock.EnableCleanMode mock is already set by Expect")
	}

	if mmEnableCleanMode.defaultExpectation.paramPtrs == nil {
		mmEnableCleanMode.defaultExpectation.paramPtrs = &BttMockEnableCleanModeParamPtrs{}
	}
	mmEnableCleanMode.defaultExpectation.paramPtrs.ctx = &ctx
	mmEnableCleanMode.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEnableCleanMode
}

// Inspect accepts an inspector function that has same arguments as the Btt.EnableCleanMode
func (mmEnableCleanMode *mBttMockEnableCleanMode) Inspect(f func(ctx context.Context)) *mBttMockEnableCleanMode {
	if mmEnableCleanMode.mock.inspectFuncEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("Inspect function is already set for BttMock.EnableCleanMode")
	}

	mmEnableCleanMode.mock.inspectFuncEnableCleanMode = f

	return mmEnableCleanMode
}

// Return sets up results that will be returned by Btt.EnableCleanMode
func (mmEnableCleanMode *mBttMockEnableCleanMode) Return(err error) *BttMock {
	if mmEnableCleanMode.mock.funcEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("BttMock.EnableCleanMode mock is already set by Set")
	}

	if mmEnableCleanMode.defaultExpectation == nil {
		mmEnableCleanMode.defaultExpectation = &BttMockEnableCleanModeExpectation{mock: mmEnableCleanMode.mock}
	}
	mmEnableCleanMode.defaultExpectation.results = &BttMockEnableCleanModeResults{err}
	mmEnableCleanMode.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEnableCleanMode.mock
}

// Set uses given function f to mock the Btt.EnableCleanMode method
func (mmEnableCleanMode *mBttMockEnableCleanMode) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmEnableCleanMode.defaultExpectation != nil {
		mmEnableCleanMode.mock.t.Fatalf("Default expectation is already set for the Btt.EnableCleanMode method")
	}

	if len(mmEnableCleanMode.expectations) > 0 {
		mmEnableCleanMode.mock.t.Fatalf("Some expectations are already set for the Btt.EnableCleanMode method")
	}

	mmEnableCleanMode.mock.funcEnableCleanMode = f
	mmEnableCleanMode.mock.funcEnableCleanModeOrigin = minimock.CallerInfo(1)
	return mmEnableCleanMode.mock
}

// When sets expectation for the Btt.EnableCleanMode which will trigger the result defined by the following
// Then helper
func (mmEnableCleanMode *mBttMockEnableCleanMode) When(ctx context.Context) *BttMockEnableCleanModeExpectation {
	if mmEnableCleanMode.mock.funcEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("BttMock.EnableCleanMode mock is already set by Set")
	}

	expectation := &BttMockEnableCleanModeExpectation{
		mock:               mmEnableCleanMode.mock,
		params:             &BttMockEnableCleanModeParams{ctx},
		expectationOrigins: BttMockEnableCleanModeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEnableCleanMode.expectations = append(mmEnableCleanMode.expectations, expectation)
	return expectation
}

// Then sets up Btt.EnableCleanMode return parameters for the expectation previously defined by the When method
func (e *BttMockEnableCleanModeExpectation) Then(err error) *BttMock {
	e.results = &BttMockEnableCleanModeResults{err}
	return e.mock
}

// Times sets number of times Btt.EnableCleanMode should be invoked
func (mmEnableCleanMode *mBttMockEnableCleanMode) Times(n uint64) *mBttMockEnableCleanMode {
	if n == 0 {
		mmEnableCleanMode.mock.t.Fatalf("Times of BttMock.EnableCleanMode mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEnableCleanMode.expectedInvocations, n)
	mmEnableCleanMode.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEnableCleanMode
}

func (mmEnableCleanMode *mBttMockEnableCleanMode) invocationsDone() bool {
	if len(mmEnableCleanMode.expectations) == 0 && mmEnableCleanMode.defaultExpectation == nil && mmEnableCleanMode.mock.funcEnableCleanMode == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEnableCleanMode.mock.afterEnableCleanModeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEnableCleanMode.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EnableCleanMode implements Btt
func (mmEnableCleanMode *BttMock) EnableCleanMode(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmEnableCleanMode.beforeEnableCleanModeCounter, 1)
	defer mm_atomic.AddUint64(&mmEnableCleanMode.afterEnableCleanModeCounter, 1)

	mmEnableCleanMode.t.Helper()

	if mmEnableCleanMode.inspectFuncEnableCleanMode != nil {
		mmEnableCleanMode.inspectFuncEnableCleanMode(ctx)
	}

	mm_params := BttMockEnableCleanModeParams{ctx}

	// Record call args
	mmEnableCleanMode.EnableCleanModeMock.mutex.Lock()
	mmEnableCleanMode.EnableCleanModeMock.callArgs = append(mmEnableCleanMode.EnableCleanModeMock.callArgs, &mm_params)
	mmEnableCleanMode.EnableCleanModeMock.mutex.Unlock()

	for _, e := range mmEnableCleanMode.EnableCleanModeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEnableCleanMode.EnableCleanModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.Counter, 1)
		mm_want := mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.params
		mm_want_ptrs := mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.paramPtrs

		mm_got := BttMockEnableCleanModeParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEnableCleanMode.t.Errorf("BttMock.EnableCleanMode got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEnableCleanMode.t.Errorf("BttMock.EnableCleanMode got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.results
		if mm_results == nil {
			mmEnableCleanMode.t.Fatal("No results are set for the BttMock.EnableCleanMode")
		}
		return (*mm_results).err
	}
	if mmEnableCleanMode.funcEnableCleanMode != nil {
		return mmEnableCleanMode.funcEnableCleanMode(ctx)
	}
	mmEnableCleanMode.t.Fatalf("Unexpected call to BttMock.EnableCleanMode. %v", ctx)
	return
}

// EnableCleanModeAfterCounter returns a count of finished BttMock.EnableCleanMode invocations
func (mmEnableCleanMode *BttMock) EnableCleanModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnableCleanMode.afterEnableCleanModeCounter)
}

// EnableCleanModeBeforeCounter returns a count of BttMock.EnableCleanMode invocations
func (mmEnableCleanMode *BttMock) EnableCleanModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnableCleanMode.beforeEnableCleanModeCounter)
}

// Calls returns a list of arguments used in each call to BttMock.EnableCleanMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEnableCleanMode *mBttMockEnableCleanMode) Calls() []*BttMockEnableCleanModeParams {
	mmEnableCleanMode.mutex.RLock()

	argCopy := make([]*BttMockEnableCleanModeParams, len(mmEnableCleanMode.callArgs))
	copy(argCopy, mmEnableCleanMode.callArgs)

	mmEnableCleanMode.mutex.RUnlock()

	return argCopy
}

// MinimockEnableCleanModeDone returns true if the count of the EnableCleanMode invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockEnableCleanModeDone() bool {
	if m.EnableCleanModeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EnableCleanModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EnableCleanModeMock.invocationsDone()
}

// MinimockEnableCleanModeInspect logs each unmet expectation
func (m *BttMock) MinimockEnableCleanModeInspect() {
	for _, e := range m.EnableCleanModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.EnableCleanMode at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEnableCleanModeCounter := mm_atomic.LoadUint64(&m.afterEnableCleanModeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EnableCleanModeMock.defaultExpectation != nil && afterEnableCleanModeCounter < 1 {
		if m.EnableCleanModeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.EnableCleanMode at\n%s", m.EnableCleanModeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.EnableCleanMode at\n%s with params: %#v", m.EnableCleanModeMock.defaultExpectation.expectationOrigins.origin, *m.EnableCleanModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnableCleanMode != nil && afterEnableCleanModeCounter < 1 {
		m.t.Errorf("Expected call to BttMock.EnableCleanMode at\n%s", m.funcEnableCleanModeOrigin)
	}

	if !m.EnableCleanModeMock.invocationsDone() && afterEnableCleanModeCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.EnableCleanMode at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EnableCleanModeMock.expectedInvocations), m.EnableCleanModeMock.expectedInvocationsOrigin, afterEnableCleanModeCounter)
	}
}

type mBttMockFloatingPage struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockFloatingPageExpectation
	expectations       []*BttMockFloatingPageExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockFloatingPageExpectation specifies expectation struct of the Btt.FloatingPage
type BttMockFloatingPageExpectation struct {
	mock *BttMock

	results      *BttMockFloatingPageResults
	returnOrigin string
	Counter      uint64
}

// BttMockFloatingPageResults contains results of the Btt.FloatingPage
type BttMockFloatingPageResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFloatingPage *mBttMockFloatingPage) Optional() *mBttMockFloatingPage {
	mmFloatingPage.optional = true
	return mmFloatingPage
}

// Expect sets up expected params for Btt.FloatingPage
func (mmFloatingPage *mBttMockFloatingPage) Expect() *mBttMockFloatingPage {
	if mmFloatingPage.mock.funcFloatingPage != nil {
		mmFloatingPage.mock.t.Fatalf("BttMock.FloatingPage mock is already set by Set")
	}

	if mmFloatingPage.defaultExpectation == nil {
		mmFloatingPage.defaultExpectation = &BttMockFloatingPageExpectation{}
	}

	return mmFloatingPage
}

// Inspect accepts an inspector function that has same arguments as the Btt.FloatingPage
func (mmFloatingPage *mBttMockFloatingPage) Inspect(f func()) *mBttMockFloatingPage {
	if mmFloatingPage.mock.inspectFuncFloatingPage != nil {
		mmFloatingPage.mock.t.Fatalf("Inspect function is already set for BttMock.FloatingPage")
	}

	mmFloatingPage.mock.inspectFuncFloatingPage = f

	return mmFloatingPage
}

// Return sets up results that will be returned by Btt.FloatingPage
func (mmFloatingPage *mBttMockFloatingPage) Return(s1 string) *BttMock {
	if mmFloatingPage.mock.funcFloatingPage != nil {
		mmFloatingPage.mock.t.Fatalf("BttMock.FloatingPage mock is already set by Set")
	}

	if mmFloatingPage.defaultExpectation == nil {
		mmFloatingPage.defaultExpectation = &BttMockFloatingPageExpectation{mock: mmFloatingPage.mock}
	}
	mmFloatingPage.defaultExpectation.results = &BttMockFloatingPageResults{s1}
	mmFloatingPage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFloatingPage.mock
}

// Set uses given function f to mock the Btt.FloatingPage method
func (mmFloatingPage *mBttMockFloatingPage) Set(f func() (s1 string)) *BttMock {
	if mmFloatingPage.defaultExpectation != nil {
		mmFloatingPage.mock.t.Fatalf("Default expectation is already set for the Btt.FloatingPage method")
	}

	if len(mmFloatingPage.expectations) > 0 {
		mmFloatingPage.mock.t.Fatalf("Some expectations are already set for the Btt.FloatingPage method")
	}

	mmFloatingPage.mock.funcFloatingPage = f
	mmFloatingPage.mock.funcFloatingPageOrigin = minimock.CallerInfo(1)
	return mmFloatingPage.mock
}

// Times sets number of times Btt.FloatingPage should be invoked
func (mmFloatingPage *mBttMockFloatingPage) Times(n uint64) *mBttMockFloatingPage {
	if n == 0 {
		mmFloatingPage.mock.t.Fatalf("Times of BttMock.FloatingPage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFloatingPage.expectedInvocations, n)
	mmFloatingPage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFloatingPage
}

func (mmFloatingPage *mBttMockFloatingPage) invocationsDone() bool {
	if len(mmFloatingPage.expectations) == 0 && mmFloatingPage.defaultExpectation == nil && mmFloatingPage.mock.funcFloatingPage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFloatingPage.mock.afterFloatingPageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFloatingPage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FloatingPage implements Btt
func (mmFloatingPage *BttMock) FloatingPage() (s1 string) {
	mm_atomic.AddUint64(&mmFloatingPage.beforeFloatingPageCounter, 1)
	defer mm_atomic.AddUint64(&mmFloatingPage.afterFloatingPageCounter, 1)

	mmFloatingPage.t.Helper()

	if mmFloatingPage.inspectFuncFloatingPage != nil {
		mmFloatingPage.inspectFuncFloatingPage()
	}

	if mmFloatingPage.FloatingPageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFloatingPage.FloatingPageMock.defaultExpectation.Counter, 1)

		mm_results := mmFloatingPage.FloatingPageMock.defaultExpectation.results
		if mm_results == nil {
			mmFloatingPage.t.Fatal("No results are set for the BttMock.FloatingPage")
		}
		return (*mm_results).s1
	}
	if mmFloatingPage.funcFloatingPage != nil {
		return mmFloatingPage.funcFloatingPage()
	}
	mmFloatingPage.t.Fatalf("Unexpected call to BttMock.FloatingPage.")
	return
}

// FloatingPageAfterCounter returns a count of finished BttMock.FloatingPage invocations
func (mmFloatingPage *BttMock) FloatingPageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFloatingPage.afterFloatingPageCounter)
}

// FloatingPageBeforeCounter returns a count of BttMock.FloatingPage invocations
func (mmFloatingPage *BttMock) FloatingPageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFloatingPage.beforeFloatingPageCounter)
}

// MinimockFloatingPageDone returns true if the count of the FloatingPage invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockFloatingPageDone() bool {
	if m.FloatingPageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FloatingPageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FloatingPageMock.invocationsDone()
}

// MinimockFloatingPageInspect logs each unmet expectation
func (m *BttMock) MinimockFloatingPageInspect() {
	for _, e := range m.FloatingPageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to BttMock.FloatingPage")
		}
	}

	afterFloatingPageCounter := mm_atomic.LoadUint64(&m.afterFloatingPageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FloatingPageMock.defaultExpectation != nil && afterFloatingPageCounter < 1 {
		m.t.Errorf("Expected call to BttMock.FloatingPage at\n%s", m.FloatingPageMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFloatingPage != nil && afterFloatingPageCounter < 1 {
		m.t.Errorf("Expected call to BttMock.FloatingPage at\n%s", m.funcFloatingPageOrigin)
	}

	if !m.FloatingPageMock.invocationsDone() && afterFloatingPageCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.FloatingPage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FloatingPageMock.expectedInvocations), m.FloatingPageMock.expectedInvocationsOrigin, afterFloatingPageCounter)
	}
}

type mBttMockHealth struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockHealthExpectation
	expectations       []*BttMockHealthExpectation

	callArgs []*BttMockHealthParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockHealthExpectation specifies expectation struct of the Btt.Health
type BttMockHealthExpectation struct {
	mock               *BttMock
	params             *BttMockHealthParams
	paramPtrs          *BttMockHealthParamPtrs
	expectationOrigins BttMockHealthExpectationOrigins
	results            *BttMockHealthResults
	returnOrigin       string
	Counter            uint64
}

// BttMockHealthParams contains parameters of the Btt.Health
type BttMockHealthParams struct {
	ctx context.Context
}

// BttMockHealthParamPtrs contains pointers to parameters of the Btt.Health
type BttMockHealthParamPtrs struct {
	ctx *context.Context
}

// BttMockHealthResults contains results of the Btt.Health
type BttMockHealthResults struct {
	b1 bool
}

// BttMockHealthOrigins contains origins of expectations of the Btt.Health
type BttMockHealthExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHealth *mBttMockHealth) Optional() *mBttMockHealth {
	mmHealth.optional = true
	return mmHealth
}

// Expect sets up expected params for Btt.Health
func (mmHealth *mBttMockHealth) Expect(ctx context.Context) *mBttMockHealth {
	if mmHealth.mock.funcHealth != nil {
		mmHealth.mock.t.Fatalf("BttMock.Health mock is already set by Set")
	}

	if mmHealth.defaultExpectation == nil {
		mmHealth.defaultExpectation = &BttMockHealthExpectation{}
	}

	if mmHealth.defaultExpectation.paramPtrs != nil {
		mmHealth.mock.t.Fatalf("BttMock.Health mock is already set by ExpectParams functions")
	}

	mmHealth.defaultExpectation.params = &BttMockHealthParams{ctx}
	mmHealth.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHealth.expectations {
		if minimock.Equal(e.params, mmHealth.defaultExpectation.params) {
			mmHealth.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHealth.defaultExpectation.params)
		}
	}

	return mmHealth
}

// ExpectCtxParam1 sets up expected param ctx for Btt.Health
func (mmHealth *mBttMockHealth) ExpectCtxParam1(ctx context.Context) *mBttMockHealth {
	if mmHealth.mock.funcHealth != nil {
		mmHealth.mock.t.Fatalf("BttMock.Health mock is already set by Set")
	}

	if mmHealth.defaultExpectation == nil {
		mmHealth.defaultExpectation = &BttMockHealthExpectation{}
	}

	if mmHealth.defaultExpectation.params != nil {
		mmHealth.mock.t.Fatalf("BttMock.Health mock is already set by Expect")
	}

	if mmHealth.defaultExpectation.paramPtrs == nil {
		mmHealth.defaultExpectation.paramPtrs = &BttMockHealthParamPtrs{}
	}
	mmHealth.defaultExpectation.paramPtrs.ctx = &ctx
	mmHealth.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHealth
}

// Inspect accepts an inspector function that has same arguments as the Btt.Health
func (mmHealth *mBttMockHealth) Inspect(f func(ctx context.Context)) *mBttMockHealth {
	if mmHealth.mock.inspectFuncHealth != nil {
		mmHealth.mock.t.Fatalf("Inspect function is already set for BttMock.Health")
	}

	mmHealth.mock.inspectFuncHealth = f

	return mmHealth
}

// Return sets up results that will be returned by Btt.Health
func (mmHealth *mBttMockHealth) Return(b1 bool) *BttMock {
	if mmHealth.mock.funcHealth != nil {
		mmHealth.mock.t.Fatalf("BttMock.Health mock is already set by Set")
	}

	if mmHealth.defaultExpectation == nil {
		mmHealth.defaultExpectation = &BttMockHealthExpectation{mock: mmHealth.mock}
	}
	mmHealth.defaultExpectation.results = &BttMockHealthResults{b1}
	mmHealth.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHealth.mock
}

// Set uses given function f to mock the Btt.Health method
func (mmHealth *mBttMockHealth) Set(f func(ctx context.Context) (b1 bool)) *BttMock {
	if mmHealth.defaultExpectation != nil {
		mmHealth.mock.t.Fatalf("Default expectation is already set for the Btt.Health method")
	}

	if len(mmHealth.expectations) > 0 {
		mmHealth.mock.t.Fatalf("Some expectations are already set for the Btt.Health method")
	}

	mmHealth.mock.funcHealth = f
	mmHealth.mock.funcHealthOrigin = minimock.CallerInfo(1)
	return mmHealth.mock
}

// When sets expectation for the Btt.Health which will trigger the result defined by the following
// Then helper
func (mmHealth *mBttMockHealth) When(ctx context.Context) *BttMockHealthExpectation {
	if mmHealth.mock.funcHealth != nil {
		mmHealth.mock.t.Fatalf("BttMock.Health mock is already set by Set")
	}

	expectation := &BttMockHealthExpectation{
		mock:               mmHealth.mock,
		params:             &BttMockHealthParams{ctx},
		expectationOrigins: BttMockHealthExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHealth.expectations = append(mmHealth.expectations, expectation)
	return expectation
}

// Then sets up Btt.Health return parameters for the expectation previously defined by the When method
func (e *BttMockHealthExpectation) Then(b1 bool) *BttMock {
	e.results = &BttMockHealthResults{b1}
	return e.mock
}

// Times sets number of times Btt.Health should be invoked
func (mmHealth *mBttMockHealth) Times(n uint64) *mBttMockHealth {
	if n == 0 {
		mmHealth.mock.t.Fatalf("Times of BttMock.Health mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHealth.expectedInvocations, n)
	mmHealth.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHealth
}

func (mmHealth *mBttMockHealth) invocationsDone() bool {
	if len(mmHealth.expectations) == 0 && mmHealth.defaultExpectation == nil && mmHealth.mock.funcHealth == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHealth.mock.afterHealthCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHealth.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Health implements Btt
func (mmHealth *BttMock) Health(ctx context.Context) (b1 bool) {
	mm_atomic.AddUint64(&mmHealth.beforeHealthCounter, 1)
	defer mm_atomic.AddUint64(&mmHealth.afterHealthCounter, 1)

	mmHealth.t.Helper()

	if mmHealth.inspectFuncHealth != nil {
		mmHealth.inspectFuncHealth(ctx)
	}

	mm_params := BttMockHealthParams{ctx}

	// Record call args
	mmHealth.HealthMock.mutex.Lock()
	mmHealth.HealthMock.callArgs = append(mmHealth.HealthMock.callArgs, &mm_params)
	mmHealth.HealthMock.mutex.Unlock()

	for _, e := range mmHealth.HealthMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmHealth.HealthMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHealth.HealthMock.defaultExpectation.Counter, 1)
		mm_want := mmHealth.HealthMock.defaultExpectation.params
		mm_want_ptrs := mmHealth.HealthMock.defaultExpectation.paramPtrs

		mm_got := BttMockHealthParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHealth.t.Errorf("BttMock.Health got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHealth.HealthMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHealth.t.Errorf("BttMock.Health got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHealth.HealthMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHealth.HealthMock.defaultExpectation.results
		if mm_results == nil {
			mmHealth.t.Fatal("No results are set for the BttMock.Health")
		}
		return (*mm_results).b1
	}
	if mmHealth.funcHealth != nil {
		return mmHealth.funcHealth(ctx)
	}
	mmHealth.t.Fatalf("Unexpected call to BttMock.Health. %v", ctx)
	return
}

// HealthAfterCounter returns a count of finished BttMock.Health invocations
func (mmHealth *BttMock) HealthAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHealth.afterHealthCounter)
}

// HealthBeforeCounter returns a count of BttMock.Health invocations
func (mmHealth *BttMock) HealthBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHealth.beforeHealthCounter)
}

// Calls returns a list of arguments used in each call to BttMock.Health.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHealth *mBttMockHealth) Calls() []*BttMockHealthParams {
	mmHealth.mutex.RLock()

	argCopy := make([]*BttMockHealthParams, len(mmHealth.callArgs))
	copy(argCopy, mmHealth.callArgs)

	mmHealth.mutex.RUnlock()

	return argCopy
}

// MinimockHealthDone returns true if the count of the Health invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockHealthDone() bool {
	if m.HealthMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HealthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HealthMock.invocationsDone()
}

// MinimockHealthInspect logs each unmet expectation
func (m *BttMock) MinimockHealthInspect() {
	for _, e := range m.HealthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.Health at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHealthCounter := mm_atomic.LoadUint64(&m.afterHealthCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HealthMock.defaultExpectation != nil && afterHealthCounter < 1 {
		if m.HealthMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.Health at\n%s", m.HealthMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.Health at\n%s with params: %#v", m.HealthMock.defaultExpectation.expectationOrigins.origin, *m.HealthMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHealth != nil && afterHealthCounter < 1 {
		m.t.Errorf("Expected call to BttMock.Health at\n%s", m.funcHealthOrigin)
	}

	if !m.HealthMock.invocationsDone() && afterHealthCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.Health at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HealthMock.expectedInvocations), m.HealthMock.expectedInvocationsOrigin, afterHealthCounter)
	}
}

type mBttMockHideClipboard struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockHideClipboardExpectation
	expectations       []*BttMockHideClipboardExpectation

	callArgs []*BttMockHideClipboardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockHideClipboardExpectation specifies expectation struct of the Btt.HideClipboard
type BttMockHideClipboardExpectation struct {
	mock               *BttMock
	params             *BttMockHideClipboardParams
	paramPtrs          *BttMockHideClipboardParamPtrs
	expectationOrigins BttMockHideClipboardExpectationOrigins
	results            *BttMockHideClipboardResults
	returnOrigin       string
	Counter            uint64
}

// BttMockHideClipboardParams contains parameters of the Btt.HideClipboard
type BttMockHideClipboardParams struct {
	ctx context.Context
}

// BttMockHideClipboardParamPtrs contains pointers to parameters of the Btt.HideClipboard
type BttMockHideClipboardParamPtrs struct {
	ctx *context.Context
}

// BttMockHideClipboardResults contains results of the Btt.HideClipboard
type BttMockHideClipboardResults struct {
	err error
}

// BttMockHideClipboardOrigins contains origins of expectations of the Btt.HideClipboard
type BttMockHideClipboardExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHideClipboard *mBttMockHideClipboard) Optional() *mBttMockHideClipboard {
	mmHideClipboard.optional = true
	return mmHideClipboard
}

// Expect sets up expected params for Btt.HideClipboard
func (mmHideClipboard *mBttMockHideClipboard) Expect(ctx context.Context) *mBttMockHideClipboard {
	if mmHideClipboard.mock.funcHideClipboard != nil {
		mmHideClipboard.mock.t.Fatalf("BttMock.HideClipboard mock is already set by Set")
	}

	if mmHideClipboard.defaultExpectation == nil {
		mmHideClipboard.defaultExpectation = &BttMockHideClipboardExpectation{}
	}

	if mmHideClipboard.defaultExpectation.paramPtrs != nil {
		mmHideClipboard.mock.t.Fatalf("BttMock.HideClipboard mock is already set by ExpectParams functions")
	}

	mmHideClipboard.defaultExpectation.params = &BttMockHideClipboardParams{ctx}
	mmHideClipboard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHideClipboard.expectations {
		if minimock.Equal(e.params, mmHideClipboard.defaultExpectation.params) {
			mmHideClipboard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHideClipboard.defaultExpectation.params)
		}
	}

	return mmHideClipboard
}

// ExpectCtxParam1 sets up expected param ctx for Btt.HideClipboard
func (mmHideClipboard *mBttMockHideClipboard) ExpectCtxParam1(ctx context.Context) *mBttMockHideClipboard {
	if mmHideClipboard.mock.funcHideClipboard != nil {
		mmHideClipboard.mock.t.Fatalf("BttMock.HideClipboard mock is already set by Set")
	}

	if mmHideClipboard.defaultExpectation == nil {
		mmHideClipboard.defaultExpectation = &BttMockHideClipboardExpectation{}
	}

	if mmHideClipboard.defaultExpectation.params != nil {
		mmHideClipboard.mock.t.Fatalf("BttMock.HideClipboard mock is already set by Expect")
	}

	if mmHideClipboard.defaultExpectation.paramPtrs == nil {
		mmHideClipboard.defaultExpectation.paramPtrs = &BttMockHideClipboardParamPtrs{}
	}
	mmHideClipboard.defaultExpectation.paramPtrs.ctx = &ctx
	mmHideClipboard.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHideClipboard
}

// Inspect accepts an inspector function that has same arguments as the Btt.HideClipboard
func (mmHideClipboard *mBttMockHideClipboard) Inspect(f func(ctx context.Context)) *mBttMockHideClipboard {
	if mmHideClipboard.mock.inspectFuncHideClipboard != nil {
		mmHideClipboard.mock.t.Fatalf("Inspect function is already set for BttMock.HideClipboard")
	}

	mmHideClipboard.mock.inspectFuncHideClipboard = f

	return mmHideClipboard
}

// Return sets up results that will be returned by Btt.HideClipboard
func (mmHideClipboard *mBttMockHideClipboard) Return(err error) *BttMock {
	if mmHideClipboard.mock.funcHideClipboard != nil {
		mmHideClipboard.mock.t.Fatalf("BttMock.HideClipboard mock is already set by Set")
	}

	if mmHideClipboard.defaultExpectation == nil {
		mmHideClipboard.defaultExpectation = &BttMockHideClipboardExpectation{mock: mmHideClipboard.mock}
	}
	mmHideClipboard.defaultExpectation.results = &BttMockHideClipboardResults{err}
	mmHideClipboard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHideClipboard.mock
}

// Set uses given function f to mock the Btt.HideClipboard method
func (mmHideClipboard *mBttMockHideClipboard) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmHideClipboard.defaultExpectation != nil {
		mmHideClipboard.mock.t.Fatalf("Default expectation is already set for the Btt.HideClipboard method")
	}

	if len(mmHideClipboard.expectations) > 0 {
		mmHideClipboard.mock.t.Fatalf("Some expectations are already set for the Btt.HideClipboard method")
	}

	mmHideClipboard.mock.funcHideClipboard = f
	mmHideClipboard.mock.funcHideClipboardOrigin = minimock.CallerInfo(1)
	return mmHideClipboard.mock
}

// When sets expectation for the Btt.HideClipboard which will trigger the result defined by the following
// Then helper
func (mmHideClipboard *mBttMockHideClipboard) When(ctx context.Context) *BttMockHideClipboardExpectation {
	if mmHideClipboard.mock.funcHideClipboard != nil {
		mmHideClipboard.mock.t.Fatalf("BttMock.HideClipboard mock is already set by Set")
	}

	expectation := &BttMockHideClipboardExpectation{
		mock:               mmHideClipboard.mock,
		params:             &BttMockHideClipboardParams{ctx},
		expectationOrigins: BttMockHideClipboardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHideClipboard.expectations = append(mmHideClipboard.expectations, expectation)
	return expectation
}

// Then sets up Btt.HideClipboard return parameters for the expectation previously defined by the When method
func (e *BttMockHideClipboardExpectation) Then(err error) *BttMock {
	e.results = &BttMockHideClipboardResults{err}
	return e.mock
}

// Times sets number of times Btt.HideClipboard should be invoked
func (mmHideClipboard *mBttMockHideClipboard) Times(n uint64) *mBttMockHideClipboard {
	if n == 0 {
		mmHideClipboard.mock.t.Fatalf("Times of BttMock.HideClipboard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHideClipboard.expectedInvocations, n)
	mmHideClipboard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHideClipboard
}

func (mmHideClipboard *mBttMockHideClipboard) invocationsDone() bool {
	if len(mmHideClipboard.expectations) == 0 && mmHideClipboard.defaultExpectation == nil && mmHideClipboard.mock.funcHideClipboard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHideClipboard.mock.afterHideClipboardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHideClipboard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HideClipboard implements Btt
func (mmHideClipboard *BttMock) HideClipboard(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmHideClipboard.beforeHideClipboardCounter, 1)
	defer mm_atomic.AddUint64(&mmHideClipboard.afterHideClipboardCounter, 1)

	mmHideClipboard.t.Helper()

	if mmHideClipboard.inspectFuncHideClipboard != nil {
		mmHideClipboard.inspectFuncHideClipboard(ctx)
	}

	mm_params := BttMockHideClipboardParams{ctx}

	// Record call args
	mmHideClipboard.HideClipboardMock.mutex.Lock()
	mmHideClipboard.HideClipboardMock.callArgs = append(mmHideClipboard.HideClipboardMock.callArgs, &mm_params)
	mmHideClipboard.HideClipboardMock.mutex.Unlock()

	for _, e := range mmHideClipboard.HideClipboardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHideClipboard.HideClipboardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHideClipboard.HideClipboardMock.defaultExpectation.Counter, 1)
		mm_want := mmHideClipboard.HideClipboardMock.defaultExpectation.params
		mm_want_ptrs := mmHideClipboard.HideClipboardMock.defaultExpectation.paramPtrs

		mm_got := BttMockHideClipboardParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHideClipboard.t.Errorf("BttMock.HideClipboard got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHideClipboard.HideClipboardMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHideClipboard.t.Errorf("BttMock.HideClipboard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHideClipboard.HideClipboardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHideClipboard.HideClipboardMock.defaultExpectation.results
		if mm_results == nil {
			mmHideClipboard.t.Fatal("No results are set for the BttMock.HideClipboard")
		}
		return (*mm_results).err
	}
	if mmHideClipboard.funcHideClipboard != nil {
		return mmHideClipboard.funcHideClipboard(ctx)
	}
	mmHideClipboard.t.Fatalf("Unexpected call to BttMock.HideClipboard. %v", ctx)
	return
}

// HideClipboardAfterCounter returns a count of finished BttMock.HideClipboard invocations
func (mmHideClipboard *BttMock) HideClipboardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHideClipboard.afterHideClipboardCounter)
}

// HideClipboardBeforeCounter returns a count of BttMock.HideClipboard invocations
func (mmHideClipboard *BttMock) HideClipboardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHideClipboard.beforeHideClipboardCounter)
}

// Calls returns a list of arguments used in each call to BttMock.HideClipboard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHideClipboard *mBttMockHideClipboard) Calls() []*BttMockHideClipboardParams {
	mmHideClipboard.mutex.RLock()

	argCopy := make([]*BttMockHideClipboardParams, len(mmHideClipboard.callArgs))
	copy(argCopy, mmHideClipboard.callArgs)

	mmHideClipboard.mutex.RUnlock()

	return argCopy
}

// MinimockHideClipboardDone returns true if the count of the HideClipboard invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockHideClipboardDone() bool {
	if m.HideClipboardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HideClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HideClipboardMock.invocationsDone()
}

// MinimockHideClipboardInspect logs each unmet expectation
func (m *BttMock) MinimockHideClipboardInspect() {
	for _, e := range m.HideClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.HideClipboard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHideClipboardCounter := mm_atomic.LoadUint64(&m.afterHideClipboardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HideClipboardMock.defaultExpectation != nil && afterHideClipboardCounter < 1 {
		if m.HideClipboardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.HideClipboard at\n%s", m.HideClipboardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.HideClipboard at\n%s with params: %#v", m.HideClipboardMock.defaultExpectation.expectationOrigins.origin, *m.HideClipboardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHideClipboard != nil && afterHideClipboardCounter < 1 {
		m.t.Errorf("Expected call to BttMock.HideClipboard at\n%s", m.funcHideClipboardOrigin)
	}

	if !m.HideClipboardMock.invocationsDone() && afterHideClipboardCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.HideClipboard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HideClipboardMock.expectedInvocations), m.HideClipboardMock.expectedInvocationsOrigin, afterHideClipboardCounter)
	}
}

type mBttMockHideFloating struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockHideFloatingExpectation
	expectations       []*BttMockHideFloatingExpectation

	callArgs []*BttMockHideFloatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockHideFloatingExpectation specifies expectation struct of the Btt.HideFloating
type BttMockHideFloatingExpectation struct {
	mock               *BttMock
	params             *BttMockHideFloatingParams
	paramPtrs          *BttMockHideFloatingParamPtrs
	expectationOrigins BttMockHideFloatingExpectationOrigins
	results            *BttMockHideFloatingResults
	returnOrigin       string
	Counter            uint64
}

// BttMockHideFloatingParams contains parameters of the Btt.HideFloating
type BttMockHideFloatingParams struct {
	ctx context.Context
}

// BttMockHideFloatingParamPtrs contains pointers to parameters of the Btt.HideFloating
type BttMockHideFloatingParamPtrs struct {
	ctx *context.Context
}

// BttMockHideFloatingResults contains results of the Btt.HideFloating
type BttMockHideFloatingResults struct {
	err error
}

// BttMockHideFloatingOrigins contains origins of expectations of the Btt.HideFloating
type BttMockHideFloatingExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHideFloating *mBttMockHideFloating) Optional() *mBttMockHideFloating {
	mmHideFloating.optional = true
	return mmHideFloating
}

// Expect sets up expected params for Btt.HideFloating
func (mmHideFloating *mBttMockHideFloating) Expect(ctx context.Context) *mBttMockHideFloating {
	if mmHideFloating.mock.funcHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("BttMock.HideFloating mock is already set by Set")
	}

	if mmHideFloating.defaultExpectation == nil {
		mmHideFloating.defaultExpectation = &BttMockHideFloatingExpectation{}
	}

	if mmHideFloating.defaultExpectation.paramPtrs != nil {
		mmHideFloating.mock.t.Fatalf("BttMock.HideFloating mock is already set by ExpectParams functions")
	}

	mmHideFloating.defaultExpectation.params = &BttMockHideFloatingParams{ctx}
	mmHideFloating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHideFloating.expectations {
		if minimock.Equal(e.params, mmHideFloating.defaultExpectation.params) {
			mmHideFloating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHideFloating.defaultExpectation.params)
		}
	}

	return mmHideFloating
}

// ExpectCtxParam1 sets up expected param ctx for Btt.HideFloating
func (mmHideFloating *mBttMockHideFloating) ExpectCtxParam1(ctx context.Context) *mBttMockHideFloating {
	if mmHideFloating.mock.funcHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("BttMock.HideFloating mock is already set by Set")
	}

	if mmHideFloating.defaultExpectation == nil {
		mmHideFloating.defaultExpectation = &BttMockHideFloatingExpectation{}
	}

	if mmHideFloating.defaultExpectation.params != nil {
		mmHideFloating.mock.t.Fatalf("BttMock.HideFloating mock is already set by Expect")
	}

	if mmHideFloating.defaultExpectation.paramPtrs == nil {
		mmHideFloating.defaultExpectation.paramPtrs = &BttMockHideFloatingParamPtrs{}
	}
	mmHideFloating.defaultExpectation.paramPtrs.ctx = &ctx
	mmHideFloating.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHideFloating
}

// Inspect accepts an inspector function that has same arguments as the Btt.HideFloating
func (mmHideFloating *mBttMockHideFloating) Inspect(f func(ctx context.Context)) *mBttMockHideFloating {
	if mmHideFloating.mock.inspectFuncHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("Inspect function is already set for BttMock.HideFloating")
	}

	mmHideFloating.mock.inspectFuncHideFloating = f

	return mmHideFloating
}

// Return sets up results that will be returned by Btt.HideFloating
func (mmHideFloating *mBttMockHideFloating) Return(err error) *BttMock {
	if mmHideFloating.mock.funcHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("BttMock.HideFloating mock is already set by Set")
	}

	if mmHideFloating.defaultExpectation == nil {
		mmHideFloating.defaultExpectation = &BttMockHideFloatingExpectation{mock: mmHideFloating.mock}
	}
	mmHideFloating.defaultExpectation.results = &BttMockHideFloatingResults{err}
	mmHideFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHideFloating.mock
}

// Set uses given function f to mock the Btt.HideFloating method
func (mmHideFloating *mBttMockHideFloating) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmHideFloating.defaultExpectation != nil {
		mmHideFloating.mock.t.Fatalf("Default expectation is already set for the Btt.HideFloating method")
	}

	if len(mmHideFloating.expectations) > 0 {
		mmHideFloating.mock.t.Fatalf("Some expectations are already set for the Btt.HideFloating method")
	}

	mmHideFloating.mock.funcHideFloating = f
	mmHideFloating.mock.funcHideFloatingOrigin = minimock.CallerInfo(1)
	return mmHideFloating.mock
}

// When sets expectation for the Btt.HideFloating which will trigger the result defined by the following
// Then helper
func (mmHideFloating *mBttMockHideFloating) When(ctx context.Context) *BttMockHideFloatingExpectation {
	if mmHideFloating.mock.funcHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("BttMock.HideFloating mock is already set by Set")
	}

	expectation := &BttMockHideFloatingExpectation{
		mock:               mmHideFloating.mock,
		params:             &BttMockHideFloatingParams{ctx},
		expectationOrigins: BttMockHideFloatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHideFloating.expectations = append(mmHideFloating.expectations, expectation)
	return expectation
}

// Then sets up Btt.HideFloating return parameters for the expectation previously defined by the When method
func (e *BttMockHideFloatingExpectation) Then(err error) *BttMock {
	e.results = &BttMockHideFloatingResults{err}
	return e.mock
}

// Times sets number of times Btt.HideFloating should be invoked
func (mmHideFloating *mBttMockHideFloating) Times(n uint64) *mBttMockHideFloating {
	if n == 0 {
		mmHideFloating.mock.t.Fatalf("Times of BttMock.HideFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHideFloating.expectedInvocations, n)
	mmHideFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHideFloating
}

func (mmHideFloating *mBttMockHideFloating) invocationsDone() bool {
	if len(mmHideFloating.expectations) == 0 && mmHideFloating.defaultExpectation == nil && mmHideFloating.mock.funcHideFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHideFloating.mock.afterHideFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHideFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HideFloating implements Btt
func (mmHideFloating *BttMock) HideFloating(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmHideFloating.beforeHideFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmHideFloating.afterHideFloatingCounter, 1)

	mmHideFloating.t.Helper()

	if mmHideFloating.inspectFuncHideFloating != nil {
		mmHideFloating.inspectFuncHideFloating(ctx)
	}

	mm_params := BttMockHideFloatingParams{ctx}

	// Record call args
	mmHideFloating.HideFloatingMock.mutex.Lock()
	mmHideFloating.HideFloatingMock.callArgs = append(mmHideFloating.HideFloatingMock.callArgs, &mm_params)
	mmHideFloating.HideFloatingMock.mutex.Unlock()

	for _, e := range mmHideFloating.HideFloatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHideFloating.HideFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHideFloating.HideFloatingMock.defaultExpectation.Counter, 1)
		mm_want := mmHideFloating.HideFloatingMock.defaultExpectation.params
		mm_want_ptrs := mmHideFloating.HideFloatingMock.defaultExpectation.paramPtrs

		mm_got := BttMockHideFloatingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHideFloating.t.Errorf("BttMock.HideFloating got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHideFloating.HideFloatingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHideFloating.t.Errorf("BttMock.HideFloating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHideFloating.HideFloatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHideFloating.HideFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmHideFloating.t.Fatal("No results are set for the BttMock.HideFloating")
		}
		return (*mm_results).err
	}
	if mmHideFloating.funcHideFloating != nil {
		return mmHideFloating.funcHideFloating(ctx)
	}
	mmHideFloating.t.Fatalf("Unexpected call to BttMock.HideFloating. %v", ctx)
	return
}

// HideFloatingAfterCounter returns a count of finished BttMock.HideFloating invocations
func (mmHideFloating *BttMock) HideFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHideFloating.afterHideFloatingCounter)
}

// HideFloatingBeforeCounter returns a count of BttMock.HideFloating invocations
func (mmHideFloating *BttMock) HideFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHideFloating.beforeHideFloatingCounter)
}

// Calls returns a list of arguments used in each call to BttMock.HideFloating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHideFloating *mBttMockHideFloating) Calls() []*BttMockHideFloatingParams {
	mmHideFloating.mutex.RLock()

	argCopy := make([]*BttMockHideFloatingParams, len(mmHideFloating.callArgs))
	copy(argCopy, mmHideFloating.callArgs)

	mmHideFloating.mutex.RUnlock()

	return argCopy
}

// MinimockHideFloatingDone returns true if the count of the HideFloating invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockHideFloatingDone() bool {
	if m.HideFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HideFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HideFloatingMock.invocationsDone()
}

// MinimockHideFloatingInspect logs each unmet expectation
func (m *BttMock) MinimockHideFloatingInspect() {
	for _, e := range m.HideFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.HideFloating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHideFloatingCounter := mm_atomic.LoadUint64(&m.afterHideFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HideFloatingMock.defaultExpectation != nil && afterHideFloatingCounter < 1 {
		if m.HideFloatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.HideFloating at\n%s", m.HideFloatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.HideFloating at\n%s with params: %#v", m.HideFloatingMock.defaultExpectation.expectationOrigins.origin, *m.HideFloatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHideFloating != nil && afterHideFloatingCounter < 1 {
		m.t.Errorf("Expected call to BttMock.HideFloating at\n%s", m.funcHideFloatingOrigin)
	}

	if !m.HideFloatingMock.invocationsDone() && afterHideFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.HideFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HideFloatingMock.expectedInvocations), m.HideFloatingMock.expectedInvocationsOrigin, afterHideFloatingCounter)
	}
}

type mBttMockInstall struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockInstallExpectation
	expectations       []*BttMockInstallExpectation

	callArgs []*BttMockInstallParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockInstallExpectation specifies expectation struct of the Btt.Install
type BttMockInstallExpectation struct {
	mock               *BttMock
	params             *BttMockInstallParams
	paramPtrs          *BttMockInstallParamPtrs
	expectationOrigins BttMockInstallExpectationOrigins
	results            *BttMockInstallResults
	returnOrigin       string
	Counter            uint64
}

// BttMockInstallParams contains parameters of the Btt.Install
type BttMockInstallParams struct {
	ctx context.Context
}

// BttMockInstallParamPtrs contains pointers to parameters of the Btt.Install
type BttMockInstallParamPtrs struct {
	ctx *context.Context
}

// BttMockInstallResults contains results of the Btt.Install
type BttMockInstallResults struct {
	err error
}

// BttMockInstallOrigins contains origins of expectations of the Btt.Install
type BttMockInstallExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInstall *mBttMockInstall) Optional() *mBttMockInstall {
	mmInstall.optional = true
	return mmInstall
}

// Expect sets up expected params for Btt.Install
func (mmInstall *mBttMockInstall) Expect(ctx context.Context) *mBttMockInstall {
	if mmInstall.mock.funcInstall != nil {
		mmInstall.mock.t.Fatalf("BttMock.Install mock is already set by Set")
	}

	if mmInstall.defaultExpectation == nil {
		mmInstall.defaultExpectation = &BttMockInstallExpectation{}
	}

	if mmInstall.defaultExpectation.paramPtrs != nil {
		mmInstall.mock.t.Fatalf("BttMock.Install mock is already set by ExpectParams functions")
	}

	mmInstall.defaultExpectation.params = &BttMockInstallParams{ctx}
	mmInstall.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInstall.expectations {
		if minimock.Equal(e.params, mmInstall.defaultExpectation.params) {
			mmInstall.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInstall.defaultExpectation.params)
		}
	}

	return mmInstall
}

// ExpectCtxParam1 sets up expected param ctx for Btt.Install
func (mmInstall *mBttMockInstall) ExpectCtxParam1(ctx context.Context) *mBttMockInstall {
	if mmInstall.mock.funcInstall != nil {
		mmInstall.mock.t.Fatalf("BttMock.Install mock is already set by Set")
	}

	if mmInstall.defaultExpectation == nil {
		mmInstall.defaultExpectation = &BttMockInstallExpectation{}
	}

	if mmInstall.defaultExpectation.params != nil {
		mmInstall.mock.t.Fatalf("BttMock.Install mock is already set by Expect")
	}

	if mmInstall.defaultExpectation.paramPtrs == nil {
		mmInstall.defaultExpectation.paramPtrs = &BttMockInstallParamPtrs{}
	}
	mmInstall.defaultExpectation.paramPtrs.ctx = &ctx
	mmInstall.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInstall
}

// Inspect accepts an inspector function that has same arguments as the Btt.Install
func (mmInstall *mBttMockInstall) Inspect(f func(ctx context.Context)) *mBttMockInstall {
	if mmInstall.mock.inspectFuncInstall != nil {
		mmInstall.mock.t.Fatalf("Inspect function is already set for BttMock.Install")
	}

	mmInstall.mock.inspectFuncInstall = f

	return mmInstall
}

// Return sets up results that will be returned by Btt.Install
func (mmInstall *mBttMockInstall) Return(err error) *BttMock {
	if mmInstall.mock.funcInstall != nil {
		mmInstall.mock.t.Fatalf("BttMock.Install mock is already set by Set")
	}

	if mmInstall.defaultExpectation == nil {
		mmInstall.defaultExpectation = &BttMockInstallExpectation{mock: mmInstall.mock}
	}
	mmInstall.defaultExpectation.results = &BttMockInstallResults{err}
	mmInstall.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInstall.mock
}

// Set uses given function f to mock the Btt.Install method
func (mmInstall *mBttMockInstall) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmInstall.defaultExpectation != nil {
		mmInstall.mock.t.Fatalf("Default expectation is already set for the Btt.Install method")
	}

	if len(mmInstall.expectations) > 0 {
		mmInstall.mock.t.Fatalf("Some expectations are already set for the Btt.Install method")
	}

	mmInstall.mock.funcInstall = f
	mmInstall.mock.funcInstallOrigin = minimock.CallerInfo(1)
	return mmInstall.mock
}

// When sets expectation for the Btt.Install which will trigger the result defined by the following
// Then helper
func (mmInstall *mBttMockInstall) When(ctx context.Context) *BttMockInstallExpectation {
	if mmInstall.mock.funcInstall != nil {
		mmInstall.mock.t.Fatalf("BttMock.Install mock is already set by Set")
	}

	expectation := &BttMockInstallExpectation{
		mock:               mmInstall.mock,
		params:             &BttMockInstallParams{ctx},
		expectationOrigins: BttMockInstallExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInstall.expectations = append(mmInstall.expectations, expectation)
	return expectation
}

// Then sets up Btt.Install return parameters for the expectation previously defined by the When method
func (e *BttMockInstallExpectation) Then(err error) *BttMock {
	e.results = &BttMockInstallResults{err}
	return e.mock
}

// Times sets number of times Btt.Install should be invoked
func (mmInstall *mBttMockInstall) Times(n uint64) *mBttMockInstall {
	if n == 0 {
		mmInstall.mock.t.Fatalf("Times of BttMock.Install mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInstall.expectedInvocations, n)
	mmInstall.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInstall
}

func (mmInstall *mBttMockInstall) invocationsDone() bool {
	if len(mmInstall.expectations) == 0 && mmInstall.defaultExpectation == nil && mmInstall.mock.funcInstall == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInstall.mock.afterInstallCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInstall.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Install implements Btt
func (mmInstall *BttMock) Install(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmInstall.beforeInstallCounter, 1)
	defer mm_atomic.AddUint64(&mmInstall.afterInstallCounter, 1)

	mmInstall.t.Helper()

	if mmInstall.inspectFuncInstall != nil {
		mmInstall.inspectFuncInstall(ctx)
	}

	mm_params := BttMockInstallParams{ctx}

	// Record call args
	mmInstall.InstallMock.mutex.Lock()
	mmInstall.InstallMock.callArgs = append(mmInstall.InstallMock.callArgs, &mm_params)
	mmInstall.InstallMock.mutex.Unlock()

	for _, e := range mmInstall.InstallMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInstall.InstallMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInstall.InstallMock.defaultExpectation.Counter, 1)
		mm_want := mmInstall.InstallMock.defaultExpectation.params
		mm_want_ptrs := mmInstall.InstallMock.defaultExpectation.paramPtrs

		mm_got := BttMockInstallParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInstall.t.Errorf("BttMock.Install got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInstall.InstallMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInstall.t.Errorf("BttMock.Install got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInstall.InstallMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInstall.InstallMock.defaultExpectation.results
		if mm_results == nil {
			mmInstall.t.Fatal("No results are set for the BttMock.Install")
		}
		return (*mm_results).err
	}
	if mmInstall.funcInstall != nil {
		return mmInstall.funcInstall(ctx)
	}
	mmInstall.t.Fatalf("Unexpected call to BttMock.Install. %v", ctx)
	return
}

// InstallAfterCounter returns a count of finished BttMock.Install invocations
func (mmInstall *BttMock) InstallAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInstall.afterInstallCounter)
}

// InstallBeforeCounter returns a count of BttMock.Install invocations
func (mmInstall *BttMock) InstallBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInstall.beforeInstallCounter)
}

// Calls returns a list of arguments used in each call to BttMock.Install.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInstall *mBttMockInstall) Calls() []*BttMockInstallParams {
	mmInstall.mutex.RLock()

	argCopy := make([]*BttMockInstallParams, len(mmInstall.callArgs))
	copy(argCopy, mmInstall.callArgs)

	mmInstall.mutex.RUnlock()

	return argCopy
}

// MinimockInstallDone returns true if the count of the Install invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockInstallDone() bool {
	if m.InstallMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InstallMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InstallMock.invocationsDone()
}

// MinimockInstallInspect logs each unmet expectation
func (m *BttMock) MinimockInstallInspect() {
	for _, e := range m.InstallMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.Install at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInstallCounter := mm_atomic.LoadUint64(&m.afterInstallCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InstallMock.defaultExpectation != nil && afterInstallCounter < 1 {
		if m.InstallMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.Install at\n%s", m.InstallMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.Install at\n%s with params: %#v", m.InstallMock.defaultExpectation.expectationOrigins.origin, *m.InstallMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInstall != nil && afterInstallCounter < 1 {
		m.t.Errorf("Expected call to BttMock.Install at\n%s", m.funcInstallOrigin)
	}

	if !m.InstallMock.invocationsDone() && afterInstallCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.Install at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InstallMock.expectedInvocations), m.InstallMock.expectedInvocationsOrigin, afterInstallCounter)
	}
}

type mBttMockIsAvailable struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockIsAvailableExpectation
	expectations       []*BttMockIsAvailableExpectation

	callArgs []*BttMockIsAvailableParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockIsAvailableExpectation specifies expectation struct of the Btt.IsAvailable
type BttMockIsAvailableExpectation struct {
	mock               *BttMock
	params             *BttMockIsAvailableParams
	paramPtrs          *BttMockIsAvailableParamPtrs
	expectationOrigins BttMockIsAvailableExpectationOrigins
	results            *BttMockIsAvailableResults
	returnOrigin       string
	Counter            uint64
}

// BttMockIsAvailableParams contains parameters of the Btt.IsAvailable
type BttMockIsAvailableParams struct {
	ctx    context.Context
	device string
}

// BttMockIsAvailableParamPtrs contains pointers to parameters of the Btt.IsAvailable
type BttMockIsAvailableParamPtrs struct {
	ctx    *context.Context
	device *string
}

// BttMockIsAvailableResults contains results of the Btt.IsAvailable
type BttMockIsAvailableResults struct {
	b1  bool
	err error
}

// BttMockIsAvailableOrigins contains origins of expectations of the Btt.IsAvailable
type BttMockIsAvailableExpectationOrigins struct {
	origin       string
	originCtx    string
	originDevice string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsAvailable *mBttMockIsAvailable) Optional() *mBttMockIsAvailable {
	mmIsAvailable.optional = true
	return mmIsAvailable
}

// Expect sets up expected params for Btt.IsAvailable
func (mmIsAvailable *mBttMockIsAvailable) Expect(ctx context.Context, device string) *mBttMockIsAvailable {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("BttMock.IsAvailable mock is already set by Set")
	}

	if mmIsAvailable.defaultExpectation == nil {
		mmIsAvailable.defaultExpectation = &BttMockIsAvailableExpectation{}
	}

	if mmIsAvailable.defaultExpectation.paramPtrs != nil {
		mmIsAvailable.mock.t.Fatalf("BttMock.IsAvailable mock is already set by ExpectParams functions")
	}

	mmIsAvailable.defaultExpectation.params = &BttMockIsAvailableParams{ctx, device}
	mmIsAvailable.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsAvailable.expectations {
		if minimock.Equal(e.params, mmIsAvailable.defaultExpectation.params) {
			mmIsAvailable.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsAvailable.defaultExpectation.params)
		}
	}

	return mmIsAvailable
}

// ExpectCtxParam1 sets up expected param ctx for Btt.IsAvailable
func (mmIsAvailable *mBttMockIsAvailable) ExpectCtxParam1(ctx context.Context) *mBttMockIsAvailable {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("BttMock.IsAvailable mock is already set by Set")
	}

	if mmIsAvailable.defaultExpectation == nil {
		mmIsAvailable.defaultExpectation = &BttMockIsAvailableExpectation{}
	}

	if mmIsAvailable.defaultExpectation.params != nil {
		mmIsAvailable.mock.t.Fatalf("BttMock.IsAvailable mock is already set by Expect")
	}

	if mmIsAvailable.defaultExpectation.paramPtrs == nil {
		mmIsAvailable.defaultExpectation.paramPtrs = &BttMockIsAvailableParamPtrs{}
	}
	mmIsAvailable.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsAvailable.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsAvailable
}

// ExpectDeviceParam2 sets up expected param device for Btt.IsAvailable
func (mmIsAvailable *mBttMockIsAvailable) ExpectDeviceParam2(device string) *mBttMockIsAvailable {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("BttMock.IsAvailable mock is already set by Set")
	}

	if mmIsAvailable.defaultExpectation == nil {
		mmIsAvailable.defaultExpectation = &BttMockIsAvailableExpectation{}
	}

	if mmIsAvailable.defaultExpectation.params != nil {
		mmIsAvailable.mock.t.Fatalf("BttMock.IsAvailable mock is already set by Expect")
	}

	if mmIsAvailable.defaultExpectation.paramPtrs == nil {
		mmIsAvailable.defaultExpectation.paramPtrs = &BttMockIsAvailableParamPtrs{}
	}
	mmIsAvailable.defaultExpectation.paramPtrs.device = &device
	mmIsAvailable.defaultExpectation.expectationOrigins.originDevice = minimock.CallerInfo(1)

	return mmIsAvailable
}

// Inspect accepts an inspector function that has same arguments as the Btt.IsAvailable
func (mmIsAvailable *mBttMockIsAvailable) Inspect(f func(ctx context.Context, device string)) *mBttMockIsAvailable {
	if mmIsAvailable.mock.inspectFuncIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("Inspect function is already set for BttMock.IsAvailable")
	}

	mmIsAvailable.mock.inspectFuncIsAvailable = f

	return mmIsAvailable
}

// Return sets up results that will be returned by Btt.IsAvailable
func (mmIsAvailable *mBttMockIsAvailable) Return(b1 bool, err error) *BttMock {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("BttMock.IsAvailable mock is already set by Set")
	}

	if mmIsAvailable.defaultExpectation == nil {
		mmIsAvailable.defaultExpectation = &BttMockIsAvailableExpectation{mock: mmIsAvailable.mock}
	}
	mmIsAvailable.defaultExpectation.results = &BttMockIsAvailableResults{b1, err}
	mmIsAvailable.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsAvailable.mock
}

// Set uses given function f to mock the Btt.IsAvailable method
func (mmIsAvailable *mBttMockIsAvailable) Set(f func(ctx context.Context, device string) (b1 bool, err error)) *BttMock {
	if mmIsAvailable.defaultExpectation != nil {
		mmIsAvailable.mock.t.Fatalf("Default expectation is already set for the Btt.IsAvailable method")
	}

	if len(mmIsAvailable.expectations) > 0 {
		mmIsAvailable.mock.t.Fatalf("Some expectations are already set for the Btt.IsAvailable method")
	}

	mmIsAvailable.mock.funcIsAvailable = f
	mmIsAvailable.mock.funcIsAvailableOrigin = minimock.CallerInfo(1)
	return mmIsAvailable.mock
}

// When sets expectation for the Btt.IsAvailable which will trigger the result defined by the following
// Then helper
func (mmIsAvailable *mBttMockIsAvailable) When(ctx context.Context, device string) *BttMockIsAvailableExpectation {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("BttMock.IsAvailable mock is already set by Set")
	}

	expectation := &BttMockIsAvailableExpectation{
		mock:               mmIsAvailable.mock,
		params:             &BttMockIsAvailableParams{ctx, device},
		expectationOrigins: BttMockIsAvailableExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsAvailable.expectations = append(mmIsAvailable.expectations, expectation)
	return expectation
}

// Then sets up Btt.IsAvailable return parameters for the expectation previously defined by the When method
func (e *BttMockIsAvailableExpectation) Then(b1 bool, err error) *BttMock {
	e.results = &BttMockIsAvailableResults{b1, err}
	return e.mock
}

// Times sets number of times Btt.IsAvailable should be invoked
func (mmIsAvailable *mBttMockIsAvailable) Times(n uint64) *mBttMockIsAvailable {
	if n == 0 {
		mmIsAvailable.mock.t.Fatalf("Times of BttMock.IsAvailable mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsAvailable.expectedInvocations, n)
	mmIsAvailable.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsAvailable
}

func (mmIsAvailable *mBttMockIsAvailable) invocationsDone() bool {
	if len(mmIsAvailable.expectations) == 0 && mmIsAvailable.defaultExpectation == nil && mmIsAvailable.mock.funcIsAvailable == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsAvailable.mock.afterIsAvailableCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsAvailable.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsAvailable implements Btt
func (mmIsAvailable *BttMock) IsAvailable(ctx context.Context, device string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsAvailable.beforeIsAvailableCounter, 1)
	defer mm_atomic.AddUint64(&mmIsAvailable.afterIsAvailableCounter, 1)

	mmIsAvailable.t.Helper()

	if mmIsAvailable.inspectFuncIsAvailable != nil {
		mmIsAvailable.inspectFuncIsAvailable(ctx, device)
	}

	mm_params := BttMockIsAvailableParams{ctx, device}

	// Record call args
	mmIsAvailable.IsAvailableMock.mutex.Lock()
	mmIsAvailable.IsAvailableMock.callArgs = append(mmIsAvailable.IsAvailableMock.callArgs, &mm_params)
	mmIsAvailable.IsAvailableMock.mutex.Unlock()

	for _, e := range mmIsAvailable.IsAvailableMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsAvailable.IsAvailableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsAvailable.IsAvailableMock.defaultExpectation.Counter, 1)
		mm_want := mmIsAvailable.IsAvailableMock.defaultExpectation.params
		mm_want_ptrs := mmIsAvailable.IsAvailableMock.defaultExpectation.paramPtrs

		mm_got := BttMockIsAvailableParams{ctx, device}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsAvailable.t.Errorf("BttMock.IsAvailable got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsAvailable.IsAvailableMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.device != nil && !minimock.Equal(*mm_want_ptrs.device, mm_got.device) {
				mmIsAvailable.t.Errorf("BttMock.IsAvailable got unexpected parameter device, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsAvailable.IsAvailableMock.defaultExpectation.expectationOrigins.originDevice, *mm_want_ptrs.device, mm_got.device, minimock.Diff(*mm_want_ptrs.device, mm_got.device))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsAvailable.t.Errorf("BttMock.IsAvailable got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsAvailable.IsAvailableMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsAvailable.IsAvailableMock.defaultExpectation.results
		if mm_results == nil {
			mmIsAvailable.t.Fatal("No results are set for the BttMock.IsAvailable")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsAvailable.funcIsAvailable != nil {
		return mmIsAvailable.funcIsAvailable(ctx, device)
	}
	mmIsAvailable.t.Fatalf("Unexpected call to BttMock.IsAvailable. %v %v", ctx, device)
	return
}

// IsAvailableAfterCounter returns a count of finished BttMock.IsAvailable invocations
func (mmIsAvailable *BttMock) IsAvailableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAvailable.afterIsAvailableCounter)
}

// IsAvailableBeforeCounter returns a count of BttMock.IsAvailable invocations
func (mmIsAvailable *BttMock) IsAvailableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAvailable.beforeIsAvailableCounter)
}

// Calls returns a list of arguments used in each call to BttMock.IsAvailable.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsAvailable *mBttMockIsAvailable) Calls() []*BttMockIsAvailableParams {
	mmIsAvailable.mutex.RLock()

	argCopy := make([]*BttMockIsAvailableParams, len(mmIsAvailable.callArgs))
	copy(argCopy, mmIsAvailable.callArgs)

	mmIsAvailable.mutex.RUnlock()

	return argCopy
}

// MinimockIsAvailableDone returns true if the count of the IsAvailable invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockIsAvailableDone() bool {
	if m.IsAvailableMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsAvailableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsAvailableMock.invocationsDone()
}

// MinimockIsAvailableInspect logs each unmet expectation
func (m *BttMock) MinimockIsAvailableInspect() {
	for _, e := range m.IsAvailableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.IsAvailable at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsAvailableCounter := mm_atomic.LoadUint64(&m.afterIsAvailableCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsAvailableMock.defaultExpectation != nil && afterIsAvailableCounter < 1 {
		if m.IsAvailableMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.IsAvailable at\n%s", m.IsAvailableMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.IsAvailable at\n%s with params: %#v", m.IsAvailableMock.defaultExpectation.expectationOrigins.origin, *m.IsAvailableMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsAvailable != nil && afterIsAvailableCounter < 1 {
		m.t.Errorf("Expected call to BttMock.IsAvailable at\n%s", m.funcIsAvailableOrigin)
	}

	if !m.IsAvailableMock.invocationsDone() && afterIsAvailableCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.IsAvailable at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsAvailableMock.expectedInvocations), m.IsAvailableMock.expectedInvocationsOrigin, afterIsAvailableCounter)
	}
}

type mBttMockIsRunning struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockIsRunningExpectation
	expectations       []*BttMockIsRunningExpectation

	callArgs []*BttMockIsRunningParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockIsRunningExpectation specifies expectation struct of the Btt.IsRunning
type BttMockIsRunningExpectation struct {
	mock               *BttMock
	params             *BttMockIsRunningParams
	paramPtrs          *BttMockIsRunningParamPtrs
	expectationOrigins BttMockIsRunningExpectationOrigins
	results            *BttMockIsRunningResults
	returnOrigin       string
	Counter            uint64
}

// BttMockIsRunningParams contains parameters of the Btt.IsRunning
type BttMockIsRunningParams struct {
	ctx context.Context
}

// BttMockIsRunningParamPtrs contains pointers to parameters of the Btt.IsRunning
type BttMockIsRunningParamPtrs struct {
	ctx *context.Context
}

// BttMockIsRunningResults contains results of the Btt.IsRunning
type BttMockIsRunningResults struct {
	b1  bool
	err error
}

// BttMockIsRunningOrigins contains origins of expectations of the Btt.IsRunning
type BttMockIsRunningExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsRunning *mBttMockIsRunning) Optional() *mBttMockIsRunning {
	mmIsRunning.optional = true
	return mmIsRunning
}

// Expect sets up expected params for Btt.IsRunning
func (mmIsRunning *mBttMockIsRunning) Expect(ctx context.Context) *mBttMockIsRunning {
	if mmIsRunning.mock.funcIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("BttMock.IsRunning mock is already set by Set")
	}

	if mmIsRunning.defaultExpectation == nil {
		mmIsRunning.defaultExpectation = &BttMockIsRunningExpectation{}
	}

	if mmIsRunning.defaultExpectation.paramPtrs != nil {
		mmIsRunning.mock.t.Fatalf("BttMock.IsRunning mock is already set by ExpectParams functions")
	}

	mmIsRunning.defaultExpectation.params = &BttMockIsRunningParams{ctx}
	mmIsRunning.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsRunning.expectations {
		if minimock.Equal(e.params, mmIsRunning.defaultExpectation.params) {
			mmIsRunning.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsRunning.defaultExpectation.params)
		}
	}

	return mmIsRunning
}

// ExpectCtxParam1 sets up expected param ctx for Btt.IsRunning
func (mmIsRunning *mBttMockIsRunning) ExpectCtxParam1(ctx context.Context) *mBttMockIsRunning {
	if mmIsRunning.mock.funcIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("BttMock.IsRunning mock is already set by Set")
	}

	if mmIsRunning.defaultExpectation == nil {
		mmIsRunning.defaultExpectation = &BttMockIsRunningExpectation{}
	}

	if mmIsRunning.defaultExpectation.params != nil {
		mmIsRunning.mock.t.Fatalf("BttMock.IsRunning mock is already set by Expect")
	}

	if mmIsRunning.defaultExpectation.paramPtrs == nil {
		mmIsRunning.defaultExpectation.paramPtrs = &BttMockIsRunningParamPtrs{}
	}
	mmIsRunning.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsRunning.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsRunning
}

// Inspect accepts an inspector function that has same arguments as the Btt.IsRunning
func (mmIsRunning *mBttMockIsRunning) Inspect(f func(ctx context.Context)) *mBttMockIsRunning {
	if mmIsRunning.mock.inspectFuncIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("Inspect function is already set for BttMock.IsRunning")
	}

	mmIsRunning.mock.inspectFuncIsRunning = f

	return mmIsRunning
}

// Return sets up results that will be returned by Btt.IsRunning
func (mmIsRunning *mBttMockIsRunning) Return(b1 bool, err error) *BttMock {
	if mmIsRunning.mock.funcIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("BttMock.IsRunning mock is already set by Set")
	}

	if mmIsRunning.defaultExpectation == nil {
		mmIsRunning.defaultExpectation = &BttMockIsRunningExpectation{mock: mmIsRunning.mock}
	}
	mmIsRunning.defaultExpectation.results = &BttMockIsRunningResults{b1, err}
	mmIsRunning.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsRunning.mock
}

// Set uses given function f to mock the Btt.IsRunning method
func (mmIsRunning *mBttMockIsRunning) Set(f func(ctx context.Context) (b1 bool, err error)) *BttMock {
	if mmIsRunning.defaultExpectation != nil {
		mmIsRunning.mock.t.Fatalf("Default expectation is already set for the Btt.IsRunning method")
	}

	if len(mmIsRunning.expectations) > 0 {
		mmIsRunning.mock.t.Fatalf("Some expectations are already set for the Btt.IsRunning method")
	}

	mmIsRunning.mock.funcIsRunning = f
	mmIsRunning.mock.funcIsRunningOrigin = minimock.CallerInfo(1)
	return mmIsRunning.mock
}

// When sets expectation for the Btt.IsRunning which will trigger the result defined by the following
// Then helper
func (mmIsRunning *mBttMockIsRunning) When(ctx context.Context) *BttMockIsRunningExpectation {
	if mmIsRunning.mock.funcIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("BttMock.IsRunning mock is already set by Set")
	}

	expectation := &BttMockIsRunningExpectation{
		mock:               mmIsRunning.mock,
		params:             &BttMockIsRunningParams{ctx},
		expectationOrigins: BttMockIsRunningExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsRunning.expectations = append(mmIsRunning.expectations, expectation)
	return expectation
}

// Then sets up Btt.IsRunning return parameters for the expectation previously defined by the When method
func (e *BttMockIsRunningExpectation) Then(b1 bool, err error) *BttMock {
	e.results = &BttMockIsRunningResults{b1, err}
	return e.mock
}

// Times sets number of times Btt.IsRunning should be invoked
func (mmIsRunning *mBttMockIsRunning) Times(n uint64) *mBttMockIsRunning {
	if n == 0 {
		mmIsRunning.mock.t.Fatalf("Times of BttMock.IsRunning mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsRunning.expectedInvocations, n)
	mmIsRunning.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsRunning
}

func (mmIsRunning *mBttMockIsRunning) invocationsDone() bool {
	if len(mmIsRunning.expectations) == 0 && mmIsRunning.defaultExpectation == nil && mmIsRunning.mock.funcIsRunning == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsRunning.mock.afterIsRunningCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsRunning.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsRunning implements Btt
func (mmIsRunning *BttMock) IsRunning(ctx context.Context) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsRunning.beforeIsRunningCounter, 1)
	defer mm_atomic.AddUint64(&mmIsRunning.afterIsRunningCounter, 1)

	mmIsRunning.t.Helper()

	if mmIsRunning.inspectFuncIsRunning != nil {
		mmIsRunning.inspectFuncIsRunning(ctx)
	}

	mm_params := BttMockIsRunningParams{ctx}

	// Record call args
	mmIsRunning.IsRunningMock.mutex.Lock()
	mmIsRunning.IsRunningMock.callArgs = append(mmIsRunning.IsRunningMock.callArgs, &mm_params)
	mmIsRunning.IsRunningMock.mutex.Unlock()

	for _, e := range mmIsRunning.IsRunningMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsRunning.IsRunningMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsRunning.IsRunningMock.defaultExpectation.Counter, 1)
		mm_want := mmIsRunning.IsRunningMock.defaultExpectation.params
		mm_want_ptrs := mmIsRunning.IsRunningMock.defaultExpectation.paramPtrs

		mm_got := BttMockIsRunningParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsRunning.t.Errorf("BttMock.IsRunning got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsRunning.IsRunningMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsRunning.t.Errorf("BttMock.IsRunning got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsRunning.IsRunningMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsRunning.IsRunningMock.defaultExpectation.results
		if mm_results == nil {
			mmIsRunning.t.Fatal("No results are set for the BttMock.IsRunning")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsRunning.funcIsRunning != nil {
		return mmIsRunning.funcIsRunning(ctx)
	}
	mmIsRunning.t.Fatalf("Unexpected call to BttMock.IsRunning. %v", ctx)
	return
}

// IsRunningAfterCounter returns a count of finished BttMock.IsRunning invocations
func (mmIsRunning *BttMock) IsRunningAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRunning.afterIsRunningCounter)
}

// IsRunningBeforeCounter returns a count of BttMock.IsRunning invocations
func (mmIsRunning *BttMock) IsRunningBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRunning.beforeIsRunningCounter)
}

// Calls returns a list of arguments used in each call to BttMock.IsRunning.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsRunning *mBttMockIsRunning) Calls() []*BttMockIsRunningParams {
	mmIsRunning.mutex.RLock()

	argCopy := make([]*BttMockIsRunningParams, len(mmIsRunning.callArgs))
	copy(argCopy, mmIsRunning.callArgs)

	mmIsRunning.mutex.RUnlock()

	return argCopy
}

// MinimockIsRunningDone returns true if the count of the IsRunning invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockIsRunningDone() bool {
	if m.IsRunningMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsRunningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsRunningMock.invocationsDone()
}

// MinimockIsRunningInspect logs each unmet expectation
func (m *BttMock) MinimockIsRunningInspect() {
	for _, e := range m.IsRunningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.IsRunning at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsRunningCounter := mm_atomic.LoadUint64(&m.afterIsRunningCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsRunningMock.defaultExpectation != nil && afterIsRunningCounter < 1 {
		if m.IsRunningMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.IsRunning at\n%s", m.IsRunningMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.IsRunning at\n%s with params: %#v", m.IsRunningMock.defaultExpectation.expectationOrigins.origin, *m.IsRunningMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsRunning != nil && afterIsRunningCounter < 1 {
		m.t.Errorf("Expected call to BttMock.IsRunning at\n%s", m.funcIsRunningOrigin)
	}

	if !m.IsRunningMock.invocationsDone() && afterIsRunningCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.IsRunning at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsRunningMock.expectedInvocations), m.IsRunningMock.expectedInvocationsOrigin, afterIsRunningCounter)
	}
}

type mBttMockLoadDevices struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockLoadDevicesExpectation
	expectations       []*BttMockLoadDevicesExpectation

	callArgs []*BttMockLoadDevicesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockLoadDevicesExpectation specifies expectation struct of the Btt.LoadDevices
type BttMockLoadDevicesExpectation struct {
	mock               *BttMock
	params             *BttMockLoadDevicesParams
	paramPtrs          *BttMockLoadDevicesParamPtrs
	expectationOrigins BttMockLoadDevicesExpectationOrigins
	results            *BttMockLoadDevicesResults
	returnOrigin       string
	Counter            uint64
}

// BttMockLoadDevicesParams contains parameters of the Btt.LoadDevices
type BttMockLoadDevicesParams struct {
	ctx context.Context
}

// BttMockLoadDevicesParamPtrs contains pointers to parameters of the Btt.LoadDevices
type BttMockLoadDevicesParamPtrs struct {
	ctx *context.Context
}

// BttMockLoadDevicesResults contains results of the Btt.LoadDevices
type BttMockLoadDevicesResults struct {
	err error
}

// BttMockLoadDevicesOrigins contains origins of expectations of the Btt.LoadDevices
type BttMockLoadDevicesExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLoadDevices *mBttMockLoadDevices) Optional() *mBttMockLoadDevices {
	mmLoadDevices.optional = true
	return mmLoadDevices
}

// Expect sets up expected params for Btt.LoadDevices
func (mmLoadDevices *mBttMockLoadDevices) Expect(ctx context.Context) *mBttMockLoadDevices {
	if mmLoadDevices.mock.funcLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("BttMock.LoadDevices mock is already set by Set")
	}

	if mmLoadDevices.defaultExpectation == nil {
		mmLoadDevices.defaultExpectation = &BttMockLoadDevicesExpectation{}
	}

	if mmLoadDevices.defaultExpectation.paramPtrs != nil {
		mmLoadDevices.mock.t.Fatalf("BttMock.LoadDevices mock is already set by ExpectParams functions")
	}

	mmLoadDevices.defaultExpectation.params = &BttMockLoadDevicesParams{ctx}
	mmLoadDevices.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLoadDevices.expectations {
		if minimock.Equal(e.params, mmLoadDevices.defaultExpectation.params) {
			mmLoadDevices.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLoadDevices.defaultExpectation.params)
		}
	}

	return mmLoadDevices
}

// ExpectCtxParam1 sets up expected param ctx for Btt.LoadDevices
func (mmLoadDevices *mBttMockLoadDevices) ExpectCtxParam1(ctx context.Context) *mBttMockLoadDevices {
	if mmLoadDevices.mock.funcLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("BttMock.LoadDevices mock is already set by Set")
	}

	if mmLoadDevices.defaultExpectation == nil {
		mmLoadDevices.defaultExpectation = &BttMockLoadDevicesExpectation{}
	}

	if mmLoadDevices.defaultExpectation.params != nil {
		mmLoadDevices.mock.t.Fatalf("BttMock.LoadDevices mock is already set by Expect")
	}

	if mmLoadDevices.defaultExpectation.paramPtrs == nil {
		mmLoadDevices.defaultExpectation.paramPtrs = &BttMockLoadDevicesParamPtrs{}
	}
	mmLoadDevices.defaultExpectation.paramPtrs.ctx = &ctx
	mmLoadDevices.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLoadDevices
}

// Inspect accepts an inspector function that has same arguments as the Btt.LoadDevices
func (mmLoadDevices *mBttMockLoadDevices) Inspect(f func(ctx context.Context)) *mBttMockLoadDevices {
	if mmLoadDevices.mock.inspectFuncLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("Inspect function is already set for BttMock.LoadDevices")
	}

	mmLoadDevices.mock.inspectFuncLoadDevices = f

	return mmLoadDevices
}

// Return sets up results that will be returned by Btt.LoadDevices
func (mmLoadDevices *mBttMockLoadDevices) Return(err error) *BttMock {
	if mmLoadDevices.mock.funcLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("BttMock.LoadDevices mock is already set by Set")
	}

	if mmLoadDevices.defaultExpectation == nil {
		mmLoadDevices.defaultExpectation = &BttMockLoadDevicesExpectation{mock: mmLoadDevices.mock}
	}
	mmLoadDevices.defaultExpectation.results = &BttMockLoadDevicesResults{err}
	mmLoadDevices.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLoadDevices.mock
}

// Set uses given function f to mock the Btt.LoadDevices method
func (mmLoadDevices *mBttMockLoadDevices) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmLoadDevices.defaultExpectation != nil {
		mmLoadDevices.mock.t.Fatalf("Default expectation is already set for the Btt.LoadDevices method")
	}

	if len(mmLoadDevices.expectations) > 0 {
		mmLoadDevices.mock.t.Fatalf("Some expectations are already set for the Btt.LoadDevices method")
	}

	mmLoadDevices.mock.funcLoadDevices = f
	mmLoadDevices.mock.funcLoadDevicesOrigin = minimock.CallerInfo(1)
	return mmLoadDevices.mock
}

// When sets expectation for the Btt.LoadDevices which will trigger the result defined by the following
// Then helper
func (mmLoadDevices *mBttMockLoadDevices) When(ctx context.Context) *BttMockLoadDevicesExpectation {
	if mmLoadDevices.mock.funcLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("BttMock.LoadDevices mock is already set by Set")
	}

	expectation := &BttMockLoadDevicesExpectation{
		mock:               mmLoadDevices.mock,
		params:             &BttMockLoadDevicesParams{ctx},
		expectationOrigins: BttMockLoadDevicesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLoadDevices.expectations = append(mmLoadDevices.expectations, expectation)
	return expectation
}

// Then sets up Btt.LoadDevices return parameters for the expectation previously defined by the When method
func (e *BttMockLoadDevicesExpectation) Then(err error) *BttMock {
	e.results = &BttMockLoadDevicesResults{err}
	return e.mock
}

// Times sets number of times Btt.LoadDevices should be invoked
func (mmLoadDevices *mBttMockLoadDevices) Times(n uint64) *mBttMockLoadDevices {
	if n == 0 {
		mmLoadDevices.mock.t.Fatalf("Times of BttMock.LoadDevices mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLoadDevices.expectedInvocations, n)
	mmLoadDevices.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLoadDevices
}

func (mmLoadDevices *mBttMockLoadDevices) invocationsDone() bool {
	if len(mmLoadDevices.expectations) == 0 && mmLoadDevices.defaultExpectation == nil && mmLoadDevices.mock.funcLoadDevices == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLoadDevices.mock.afterLoadDevicesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLoadDevices.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LoadDevices implements Btt
func (mmLoadDevices *BttMock) LoadDevices(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmLoadDevices.beforeLoadDevicesCounter, 1)
	defer mm_atomic.AddUint64(&mmLoadDevices.afterLoadDevicesCounter, 1)

	mmLoadDevices.t.Helper()

	if mmLoadDevices.inspectFuncLoadDevices != nil {
		mmLoadDevices.inspectFuncLoadDevices(ctx)
	}

	mm_params := BttMockLoadDevicesParams{ctx}

	// Record call args
	mmLoadDevices.LoadDevicesMock.mutex.Lock()
	mmLoadDevices.LoadDevicesMock.callArgs = append(mmLoadDevices.LoadDevicesMock.callArgs, &mm_params)
	mmLoadDevices.LoadDevicesMock.mutex.Unlock()

	for _, e := range mmLoadDevices.LoadDevicesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLoadDevices.LoadDevicesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLoadDevices.LoadDevicesMock.defaultExpectation.Counter, 1)
		mm_want := mmLoadDevices.LoadDevicesMock.defaultExpectation.params
		mm_want_ptrs := mmLoadDevices.LoadDevicesMock.defaultExpectation.paramPtrs

		mm_got := BttMockLoadDevicesParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLoadDevices.t.Errorf("BttMock.LoadDevices got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLoadDevices.LoadDevicesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLoadDevices.t.Errorf("BttMock.LoadDevices got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLoadDevices.LoadDevicesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLoadDevices.LoadDevicesMock.defaultExpectation.results
		if mm_results == nil {
			mmLoadDevices.t.Fatal("No results are set for the BttMock.LoadDevices")
		}
		return (*mm_results).err
	}
	if mmLoadDevices.funcLoadDevices != nil {
		return mmLoadDevices.funcLoadDevices(ctx)
	}
	mmLoadDevices.t.Fatalf("Unexpected call to BttMock.LoadDevices. %v", ctx)
	return
}

// LoadDevicesAfterCounter returns a count of finished BttMock.LoadDevices invocations
func (mmLoadDevices *BttMock) LoadDevicesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadDevices.afterLoadDevicesCounter)
}

// LoadDevicesBeforeCounter returns a count of BttMock.LoadDevices invocations
func (mmLoadDevices *BttMock) LoadDevicesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadDevices.beforeLoadDevicesCounter)
}

// Calls returns a list of arguments used in each call to BttMock.LoadDevices.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLoadDevices *mBttMockLoadDevices) Calls() []*BttMockLoadDevicesParams {
	mmLoadDevices.mutex.RLock()

	argCopy := make([]*BttMockLoadDevicesParams, len(mmLoadDevices.callArgs))
	copy(argCopy, mmLoadDevices.callArgs)

	mmLoadDevices.mutex.RUnlock()

	return argCopy
}

// MinimockLoadDevicesDone returns true if the count of the LoadDevices invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockLoadDevicesDone() bool {
	if m.LoadDevicesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoadDevicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoadDevicesMock.invocationsDone()
}

// MinimockLoadDevicesInspect logs each unmet expectation
func (m *BttMock) MinimockLoadDevicesInspect() {
	for _, e := range m.LoadDevicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.LoadDevices at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoadDevicesCounter := mm_atomic.LoadUint64(&m.afterLoadDevicesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoadDevicesMock.defaultExpectation != nil && afterLoadDevicesCounter < 1 {
		if m.LoadDevicesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.LoadDevices at\n%s", m.LoadDevicesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.LoadDevices at\n%s with params: %#v", m.LoadDevicesMock.defaultExpectation.expectationOrigins.origin, *m.LoadDevicesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoadDevices != nil && afterLoadDevicesCounter < 1 {
		m.t.Errorf("Expected call to BttMock.LoadDevices at\n%s", m.funcLoadDevicesOrigin)
	}

	if !m.LoadDevicesMock.invocationsDone() && afterLoadDevicesCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.LoadDevices at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoadDevicesMock.expectedInvocations), m.LoadDevicesMock.expectedInvocationsOrigin, afterLoadDevicesCounter)
	}
}

type mBttMockSelectClipboard struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectClipboardExpectation
	expectations       []*BttMockSelectClipboardExpectation

	callArgs []*BttMockSelectClipboardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectClipboardExpectation specifies expectation struct of the Btt.SelectClipboard
type BttMockSelectClipboardExpectation struct {
	mock               *BttMock
	params             *BttMockSelectClipboardParams
	paramPtrs          *BttMockSelectClipboardParamPtrs
	expectationOrigins BttMockSelectClipboardExpectationOrigins
	results            *BttMockSelectClipboardResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectClipboardParams contains parameters of the Btt.SelectClipboard
type BttMockSelectClipboardParams struct {
	ctx       context.Context
	clipboard Clipboard
}

// BttMockSelectClipboardParamPtrs contains pointers to parameters of the Btt.SelectClipboard
type BttMockSelectClipboardParamPtrs struct {
	ctx       *context.Context
	clipboard *Clipboard
}

// BttMockSelectClipboardResults contains results of the Btt.SelectClipboard
type BttMockSelectClipboardResults struct {
	err error
}

// BttMockSelectClipboardOrigins contains origins of expectations of the Btt.SelectClipboard
type BttMockSelectClipboardExpectationOrigins struct {
	origin          string
	originCtx       string
	originClipboard string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectClipboard *mBttMockSelectClipboard) Optional() *mBttMockSelectClipboard {
	mmSelectClipboard.optional = true
	return mmSelectClipboard
}

// Expect sets up expected params for Btt.SelectClipboard
func (mmSelectClipboard *mBttMockSelectClipboard) Expect(ctx context.Context, clipboard Clipboard) *mBttMockSelectClipboard {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("BttMock.SelectClipboard mock is already set by Set")
	}

	if mmSelectClipboard.defaultExpectation == nil {
		mmSelectClipboard.defaultExpectation = &BttMockSelectClipboardExpectation{}
	}

	if mmSelectClipboard.defaultExpectation.paramPtrs != nil {
		mmSelectClipboard.mock.t.Fatalf("BttMock.SelectClipboard mock is already set by ExpectParams functions")
	}

	mmSelectClipboard.defaultExpectation.params = &BttMockSelectClipboardParams{ctx, clipboard}
	mmSelectClipboard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectClipboard.expectations {
		if minimock.Equal(e.params, mmSelectClipboard.defaultExpectation.params) {
			mmSelectClipboard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectClipboard.defaultExpectation.params)
		}
	}

	return mmSelectClipboard
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectClipboard
func (mmSelectClipboard *mBttMockSelectClipboard) ExpectCtxParam1(ctx context.Context) *mBttMockSelectClipboard {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("BttMock.SelectClipboard mock is already set by Set")
	}

	if mmSelectClipboard.defaultExpectation == nil {
		mmSelectClipboard.defaultExpectation = &BttMockSelectClipboardExpectation{}
	}

	if mmSelectClipboard.defaultExpectation.params != nil {
		mmSelectClipboard.mock.t.Fatalf("BttMock.SelectClipboard mock is already set by Expect")
	}

	if mmSelectClipboard.defaultExpectation.paramPtrs == nil {
		mmSelectClipboard.defaultExpectation.paramPtrs = &BttMockSelectClipboardParamPtrs{}
	}
	mmSelectClipboard.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectClipboard.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectClipboard
}

// ExpectClipboardParam2 sets up expected param clipboard for Btt.SelectClipboard
func (mmSelectClipboard *mBttMockSelectClipboard) ExpectClipboardParam2(clipboard Clipboard) *mBttMockSelectClipboard {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("BttMock.SelectClipboard mock is already set by Set")
	}

	if mmSelectClipboard.defaultExpectation == nil {
		mmSelectClipboard.defaultExpectation = &BttMockSelectClipboardExpectation{}
	}

	if mmSelectClipboard.defaultExpectation.params != nil {
		mmSelectClipboard.mock.t.Fatalf("BttMock.SelectClipboard mock is already set by Expect")
	}

	if mmSelectClipboard.defaultExpectation.paramPtrs == nil {
		mmSelectClipboard.defaultExpectation.paramPtrs = &BttMockSelectClipboardParamPtrs{}
	}
	mmSelectClipboard.defaultExpectation.paramPtrs.clipboard = &clipboard
	mmSelectClipboard.defaultExpectation.expectationOrigins.originClipboard = minimock.CallerInfo(1)

	return mmSelectClipboard
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectClipboard
func (mmSelectClipboard *mBttMockSelectClipboard) Inspect(f func(ctx context.Context, clipboard Clipboard)) *mBttMockSelectClipboard {
	if mmSelectClipboard.mock.inspectFuncSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("Inspect function is already set for BttMock.SelectClipboard")
	}

	mmSelectClipboard.mock.inspectFuncSelectClipboard = f

	return mmSelectClipboard
}

// Return sets up results that will be returned by Btt.SelectClipboard
func (mmSelectClipboard *mBttMockSelectClipboard) Return(err error) *BttMock {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("BttMock.SelectClipboard mock is already set by Set")
	}

	if mmSelectClipboard.defaultExpectation == nil {
		mmSelectClipboard.defaultExpectation = &BttMockSelectClipboardExpectation{mock: mmSelectClipboard.mock}
	}
	mmSelectClipboard.defaultExpectation.results = &BttMockSelectClipboardResults{err}
	mmSelectClipboard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectClipboard.mock
}

// Set uses given function f to mock the Btt.SelectClipboard method
func (mmSelectClipboard *mBttMockSelectClipboard) Set(f func(ctx context.Context, clipboard Clipboard) (err error)) *BttMock {
	if mmSelectClipboard.defaultExpectation != nil {
		mmSelectClipboard.mock.t.Fatalf("Default expectation is already set for the Btt.SelectClipboard method")
	}

	if len(mmSelectClipboard.expectations) > 0 {
		mmSelectClipboard.mock.t.Fatalf("Some expectations are already set for the Btt.SelectClipboard method")
	}

	mmSelectClipboard.mock.funcSelectClipboard = f
	mmSelectClipboard.mock.funcSelectClipboardOrigin = minimock.CallerInfo(1)
	return mmSelectClipboard.mock
}

// When sets expectation for the Btt.SelectClipboard which will trigger the result defined by the following
// Then helper
func (mmSelectClipboard *mBttMockSelectClipboard) When(ctx context.Context, clipboard Clipboard) *BttMockSelectClipboardExpectation {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("BttMock.SelectClipboard mock is already set by Set")
	}

	expectation := &BttMockSelectClipboardExpectation{
		mock:               mmSelectClipboard.mock,
		params:             &BttMockSelectClipboardParams{ctx, clipboard},
		expectationOrigins: BttMockSelectClipboardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectClipboard.expectations = append(mmSelectClipboard.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectClipboard return parameters for the expectation previously defined by the When method
func (e *BttMockSelectClipboardExpectation) Then(err error) *BttMock {
	e.results = &BttMockSelectClipboardResults{err}
	return e.mock
}

// Times sets number of times Btt.SelectClipboard should be invoked
func (mmSelectClipboard *mBttMockSelectClipboard) Times(n uint64) *mBttMockSelectClipboard {
	if n == 0 {
		mmSelectClipboard.mock.t.Fatalf("Times of BttMock.SelectClipboard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectClipboard.expectedInvocations, n)
	mmSelectClipboard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectClipboard
}

func (mmSelectClipboard *mBttMockSelectClipboard) invocationsDone() bool {
	if len(mmSelectClipboard.expectations) == 0 && mmSelectClipboard.defaultExpectation == nil && mmSelectClipboard.mock.funcSelectClipboard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectClipboard.mock.afterSelectClipboardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectClipboard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectClipboard implements Btt
func (mmSelectClipboard *BttMock) SelectClipboard(ctx context.Context, clipboard Clipboard) (err error) {
	mm_atomic.AddUint64(&mmSelectClipboard.beforeSelectClipboardCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectClipboard.afterSelectClipboardCounter, 1)

	mmSelectClipboard.t.Helper()

	if mmSelectClipboard.inspectFuncSelectClipboard != nil {
		mmSelectClipboard.inspectFuncSelectClipboard(ctx, clipboard)
	}

	mm_params := BttMockSelectClipboardParams{ctx, clipboard}

	// Record call args
	mmSelectClipboard.SelectClipboardMock.mutex.Lock()
	mmSelectClipboard.SelectClipboardMock.callArgs = append(mmSelectClipboard.SelectClipboardMock.callArgs, &mm_params)
	mmSelectClipboard.SelectClipboardMock.mutex.Unlock()

	for _, e := range mmSelectClipboard.SelectClipboardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectClipboard.SelectClipboardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectClipboard.SelectClipboardMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectClipboard.SelectClipboardMock.defaultExpectation.params
		mm_want_ptrs := mmSelectClipboard.SelectClipboardMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectClipboardParams{ctx, clipboard}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectClipboard.t.Errorf("BttMock.SelectClipboard got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectClipboard.SelectClipboardMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.clipboard != nil && !minimock.Equal(*mm_want_ptrs.clipboard, mm_got.clipboard) {
				mmSelectClipboard.t.Errorf("BttMock.SelectClipboard got unexpected parameter clipboard, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectClipboard.SelectClipboardMock.defaultExpectation.expectationOrigins.originClipboard, *mm_want_ptrs.clipboard, mm_got.clipboard, minimock.Diff(*mm_want_ptrs.clipboard, mm_got.clipboard))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectClipboard.t.Errorf("BttMock.SelectClipboard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectClipboard.SelectClipboardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectClipboard.SelectClipboardMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectClipboard.t.Fatal("No results are set for the BttMock.SelectClipboard")
		}
		return (*mm_results).err
	}
	if mmSelectClipboard.funcSelectClipboard != nil {
		return mmSelectClipboard.funcSelectClipboard(ctx, clipboard)
	}
	mmSelectClipboard.t.Fatalf("Unexpected call to BttMock.SelectClipboard. %v %v", ctx, clipboard)
	return
}

// SelectClipboardAfterCounter returns a count of finished BttMock.SelectClipboard invocations
func (mmSelectClipboard *BttMock) SelectClipboardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectClipboard.afterSelectClipboardCounter)
}

// SelectClipboardBeforeCounter returns a count of BttMock.SelectClipboard invocations
func (mmSelectClipboard *BttMock) SelectClipboardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectClipboard.beforeSelectClipboardCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectClipboard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectClipboard *mBttMockSelectClipboard) Calls() []*BttMockSelectClipboardParams {
	mmSelectClipboard.mutex.RLock()

	argCopy := make([]*BttMockSelectClipboardParams, len(mmSelectClipboard.callArgs))
	copy(argCopy, mmSelectClipboard.callArgs)

	mmSelectClipboard.mutex.RUnlock()

	return argCopy
}

// MinimockSelectClipboardDone returns true if the count of the SelectClipboard invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectClipboardDone() bool {
	if m.SelectClipboardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectClipboardMock.invocationsDone()
}

// MinimockSelectClipboardInspect logs each unmet expectation
func (m *BttMock) MinimockSelectClipboardInspect() {
	for _, e := range m.SelectClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectClipboard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectClipboardCounter := mm_atomic.LoadUint64(&m.afterSelectClipboardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectClipboardMock.defaultExpectation != nil && afterSelectClipboardCounter < 1 {
		if m.SelectClipboardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectClipboard at\n%s", m.SelectClipboardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectClipboard at\n%s with params: %#v", m.SelectClipboardMock.defaultExpectation.expectationOrigins.origin, *m.SelectClipboardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectClipboard != nil && afterSelectClipboardCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectClipboard at\n%s", m.funcSelectClipboardOrigin)
	}

	if !m.SelectClipboardMock.invocationsDone() && afterSelectClipboardCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectClipboard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectClipboardMock.expectedInvocations), m.SelectClipboardMock.expectedInvocationsOrigin, afterSelectClipboardCounter)
	}
}

type mBttMockSelectDevice struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectDeviceExpectation
	expectations       []*BttMockSelectDeviceExpectation

	callArgs []*BttMockSelectDeviceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectDeviceExpectation specifies expectation struct of the Btt.SelectDevice
type BttMockSelectDeviceExpectation struct {
	mock               *BttMock
	params             *BttMockSelectDeviceParams
	paramPtrs          *BttMockSelectDeviceParamPtrs
	expectationOrigins BttMockSelectDeviceExpectationOrigins
	results            *BttMockSelectDeviceResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectDeviceParams contains parameters of the Btt.SelectDevice
type BttMockSelectDeviceParams struct {
	ctx    context.Context
	device string
}

// BttMockSelectDeviceParamPtrs contains pointers to parameters of the Btt.SelectDevice
type BttMockSelectDeviceParamPtrs struct {
	ctx    *context.Context
	device *string
}

// BttMockSelectDeviceResults contains results of the Btt.SelectDevice
type BttMockSelectDeviceResults struct {
	err error
}

// BttMockSelectDeviceOrigins contains origins of expectations of the Btt.SelectDevice
type BttMockSelectDeviceExpectationOrigins struct {
	origin       string
	originCtx    string
	originDevice string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectDevice *mBttMockSelectDevice) Optional() *mBttMockSelectDevice {
	mmSelectDevice.optional = true
	return mmSelectDevice
}

// Expect sets up expected params for Btt.SelectDevice
func (mmSelectDevice *mBttMockSelectDevice) Expect(ctx context.Context, device string) *mBttMockSelectDevice {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &BttMockSelectDeviceExpectation{}
	}

	if mmSelectDevice.defaultExpectation.paramPtrs != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by ExpectParams functions")
	}

	mmSelectDevice.defaultExpectation.params = &BttMockSelectDeviceParams{ctx, device}
	mmSelectDevice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectDevice.expectations {
		if minimock.Equal(e.params, mmSelectDevice.defaultExpectation.params) {
			mmSelectDevice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectDevice.defaultExpectation.params)
		}
	}

	return mmSelectDevice
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectDevice
func (mmSelectDevice *mBttMockSelectDevice) ExpectCtxParam1(ctx context.Context) *mBttMockSelectDevice {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &BttMockSelectDeviceExpectation{}
	}

	if mmSelectDevice.defaultExpectation.params != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Expect")
	}

	if mmSelectDevice.defaultExpectation.paramPtrs == nil {
		mmSelectDevice.defaultExpectation.paramPtrs = &BttMockSelectDeviceParamPtrs{}
	}
	mmSelectDevice.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectDevice.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectDevice
}

// ExpectDeviceParam2 sets up expected param device for Btt.SelectDevice
func (mmSelectDevice *mBttMockSelectDevice) ExpectDeviceParam2(device string) *mBttMockSelectDevice {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &BttMockSelectDeviceExpectation{}
	}

	if mmSelectDevice.defaultExpectation.params != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Expect")
	}

	if mmSelectDevice.defaultExpectation.paramPtrs == nil {
		mmSelectDevice.defaultExpectation.paramPtrs = &BttMockSelectDeviceParamPtrs{}
	}
	mmSelectDevice.defaultExpectation.paramPtrs.device = &device
	mmSelectDevice.defaultExpectation.expectationOrigins.originDevice = minimock.CallerInfo(1)

	return mmSelectDevice
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectDevice
func (mmSelectDevice *mBttMockSelectDevice) Inspect(f func(ctx context.Context, device string)) *mBttMockSelectDevice {
	if mmSelectDevice.mock.inspectFuncSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("Inspect function is already set for BttMock.SelectDevice")
	}

	mmSelectDevice.mock.inspectFuncSelectDevice = f

	return mmSelectDevice
}

// Return sets up results that will be returned by Btt.SelectDevice
func (mmSelectDevice *mBttMockSelectDevice) Return(err error) *BttMock {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &BttMockSelectDeviceExpectation{mock: mmSelectDevice.mock}
	}
	mmSelectDevice.defaultExpectation.results = &BttMockSelectDeviceResults{err}
	mmSelectDevice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectDevice.mock
}

// Set uses given function f to mock the Btt.SelectDevice method
func (mmSelectDevice *mBttMockSelectDevice) Set(f func(ctx context.Context, device string) (err error)) *BttMock {
	if mmSelectDevice.defaultExpectation != nil {
		mmSelectDevice.mock.t.Fatalf("Default expectation is already set for the Btt.SelectDevice method")
	}

	if len(mmSelectDevice.expectations) > 0 {
		mmSelectDevice.mock.t.Fatalf("Some expectations are already set for the Btt.SelectDevice method")
	}

	mmSelectDevice.mock.funcSelectDevice = f
	mmSelectDevice.mock.funcSelectDeviceOrigin = minimock.CallerInfo(1)
	return mmSelectDevice.mock
}

// When sets expectation for the Btt.SelectDevice which will trigger the result defined by the following
// Then helper
func (mmSelectDevice *mBttMockSelectDevice) When(ctx context.Context, device string) *BttMockSelectDeviceExpectation {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Set")
	}

	expectation := &BttMockSelectDeviceExpectation{
		mock:               mmSelectDevice.mock,
		params:             &BttMockSelectDeviceParams{ctx, device},
		expectationOrigins: BttMockSelectDeviceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectDevice.expectations = append(mmSelectDevice.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectDevice return parameters for the expectation previously defined by the When method
func (e *BttMockSelectDeviceExpectation) Then(err error) *BttMock {
	e.results = &BttMockSelectDeviceResults{err}
	return e.mock
}

// Times sets number of times Btt.SelectDevice should be invoked
func (mmSelectDevice *mBttMockSelectDevice) Times(n uint64) *mBttMockSelectDevice {
	if n == 0 {
		mmSelectDevice.mock.t.Fatalf("Times of BttMock.SelectDevice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectDevice.expectedInvocations, n)
	mmSelectDevice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectDevice
}

func (mmSelectDevice *mBttMockSelectDevice) invocationsDone() bool {
	if len(mmSelectDevice.expectations) == 0 && mmSelectDevice.defaultExpectation == nil && mmSelectDevice.mock.funcSelectDevice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectDevice.mock.afterSelectDeviceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectDevice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectDevice implements Btt
func (mmSelectDevice *BttMock) SelectDevice(ctx context.Context, device string) (err error) {
	mm_atomic.AddUint64(&mmSelectDevice.beforeSelectDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectDevice.afterSelectDeviceCounter, 1)

	mmSelectDevice.t.Helper()

	if mmSelectDevice.inspectFuncSelectDevice != nil {
		mmSelectDevice.inspectFuncSelectDevice(ctx, device)
	}

	mm_params := BttMockSelectDeviceParams{ctx, device}

	// Record call args
	mmSelectDevice.SelectDeviceMock.mutex.Lock()
	mmSelectDevice.SelectDeviceMock.callArgs = append(mmSelectDevice.SelectDeviceMock.callArgs, &mm_params)
	mmSelectDevice.SelectDeviceMock.mutex.Unlock()

	for _, e := range mmSelectDevice.SelectDeviceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectDevice.SelectDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectDevice.SelectDeviceMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectDevice.SelectDeviceMock.defaultExpectation.params
		mm_want_ptrs := mmSelectDevice.SelectDeviceMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectDeviceParams{ctx, device}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectDevice.t.Errorf("BttMock.SelectDevice got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectDevice.SelectDeviceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.device != nil && !minimock.Equal(*mm_want_ptrs.device, mm_got.device) {
				mmSelectDevice.t.Errorf("BttMock.SelectDevice got unexpected parameter device, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectDevice.SelectDeviceMock.defaultExpectation.expectationOrigins.originDevice, *mm_want_ptrs.device, mm_got.device, minimock.Diff(*mm_want_ptrs.device, mm_got.device))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectDevice.t.Errorf("BttMock.SelectDevice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectDevice.SelectDeviceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectDevice.SelectDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectDevice.t.Fatal("No results are set for the BttMock.SelectDevice")
		}
		return (*mm_results).err
	}
	if mmSelectDevice.funcSelectDevice != nil {
		return mmSelectDevice.funcSelectDevice(ctx, device)
	}
	mmSelectDevice.t.Fatalf("Unexpected call to BttMock.SelectDevice. %v %v", ctx, device)
	return
}

// SelectDeviceAfterCounter returns a count of finished BttMock.SelectDevice invocations
func (mmSelectDevice *BttMock) SelectDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectDevice.afterSelectDeviceCounter)
}

// SelectDeviceBeforeCounter returns a count of BttMock.SelectDevice invocations
func (mmSelectDevice *BttMock) SelectDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectDevice.beforeSelectDeviceCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectDevice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectDevice *mBttMockSelectDevice) Calls() []*BttMockSelectDeviceParams {
	mmSelectDevice.mutex.RLock()

	argCopy := make([]*BttMockSelectDeviceParams, len(mmSelectDevice.callArgs))
	copy(argCopy, mmSelectDevice.callArgs)

	mmSelectDevice.mutex.RUnlock()

	return argCopy
}

// MinimockSelectDeviceDone returns true if the count of the SelectDevice invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectDeviceDone() bool {
	if m.SelectDeviceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectDeviceMock.invocationsDone()
}

// MinimockSelectDeviceInspect logs each unmet expectation
func (m *BttMock) MinimockSelectDeviceInspect() {
	for _, e := range m.SelectDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectDevice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectDeviceCounter := mm_atomic.LoadUint64(&m.afterSelectDeviceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectDeviceMock.defaultExpectation != nil && afterSelectDeviceCounter < 1 {
		if m.SelectDeviceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectDevice at\n%s", m.SelectDeviceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectDevice at\n%s with params: %#v", m.SelectDeviceMock.defaultExpectation.expectationOrigins.origin, *m.SelectDeviceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectDevice != nil && afterSelectDeviceCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectDevice at\n%s", m.funcSelectDeviceOrigin)
	}

	if !m.SelectDeviceMock.invocationsDone() && afterSelectDeviceCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectDevice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectDeviceMock.expectedInvocations), m.SelectDeviceMock.expectedInvocationsOrigin, afterSelectDeviceCounter)
	}
}

type mBttMockSelectFloating struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectFloatingExpectation
	expectations       []*BttMockSelectFloatingExpectation

	callArgs []*BttMockSelectFloatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectFloatingExpectation specifies expectation struct of the Btt.SelectFloating
type BttMockSelectFloatingExpectation struct {
	mock               *BttMock
	params             *BttMockSelectFloatingParams
	paramPtrs          *BttMockSelectFloatingParamPtrs
	expectationOrigins BttMockSelectFloatingExpectationOrigins
	results            *BttMockSelectFloatingResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectFloatingParams contains parameters of the Btt.SelectFloating
type BttMockSelectFloatingParams struct {
	ctx      context.Context
	floating Floating
}

// BttMockSelectFloatingParamPtrs contains pointers to parameters of the Btt.SelectFloating
type BttMockSelectFloatingParamPtrs struct {
	ctx      *context.Context
	floating *Floating
}

// BttMockSelectFloatingResults contains results of the Btt.SelectFloating
type BttMockSelectFloatingResults struct {
	err error
}

// BttMockSelectFloatingOrigins contains origins of expectations of the Btt.SelectFloating
type BttMockSelectFloatingExpectationOrigins struct {
	origin         string
	originCtx      string
	originFloating string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectFloating *mBttMockSelectFloating) Optional() *mBttMockSelectFloating {
	mmSelectFloating.optional = true
	return mmSelectFloating
}

// Expect sets up expected params for Btt.SelectFloating
func (mmSelectFloating *mBttMockSelectFloating) Expect(ctx context.Context, floating Floating) *mBttMockSelectFloating {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &BttMockSelectFloatingExpectation{}
	}

	if mmSelectFloating.defaultExpectation.paramPtrs != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by ExpectParams functions")
	}

	mmSelectFloating.defaultExpectation.params = &BttMockSelectFloatingParams{ctx, floating}
	mmSelectFloating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectFloating.expectations {
		if minimock.Equal(e.params, mmSelectFloating.defaultExpectation.params) {
			mmSelectFloating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectFloating.defaultExpectation.params)
		}
	}

	return mmSelectFloating
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectFloating
func (mmSelectFloating *mBttMockSelectFloating) ExpectCtxParam1(ctx context.Context) *mBttMockSelectFloating {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &BttMockSelectFloatingExpectation{}
	}

	if mmSelectFloating.defaultExpectation.params != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Expect")
	}

	if mmSelectFloating.defaultExpectation.paramPtrs == nil {
		mmSelectFloating.defaultExpectation.paramPtrs = &BttMockSelectFloatingParamPtrs{}
	}
	mmSelectFloating.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectFloating.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectFloating
}

// ExpectFloatingParam2 sets up expected param floating for Btt.SelectFloating
func (mmSelectFloating *mBttMockSelectFloating) ExpectFloatingParam2(floating Floating) *mBttMockSelectFloating {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &BttMockSelectFloatingExpectation{}
	}

	if mmSelectFloating.defaultExpectation.params != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Expect")
	}

	if mmSelectFloating.defaultExpectation.paramPtrs == nil {
		mmSelectFloating.defaultExpectation.paramPtrs = &BttMockSelectFloatingParamPtrs{}
	}
	mmSelectFloating.defaultExpectation.paramPtrs.floating = &floating
	mmSelectFloating.defaultExpectation.expectationOrigins.originFloating = minimock.CallerInfo(1)

	return mmSelectFloating
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectFloating
func (mmSelectFloating *mBttMockSelectFloating) Inspect(f func(ctx context.Context, floating Floating)) *mBttMockSelectFloating {
	if mmSelectFloating.mock.inspectFuncSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("Inspect function is already set for BttMock.SelectFloating")
	}

	mmSelectFloating.mock.inspectFuncSelectFloating = f

	return mmSelectFloating
}

// Return sets up results that will be returned by Btt.SelectFloating
func (mmSelectFloating *mBttMockSelectFloating) Return(err error) *BttMock {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &BttMockSelectFloatingExpectation{mock: mmSelectFloating.mock}
	}
	mmSelectFloating.defaultExpectation.results = &BttMockSelectFloatingResults{err}
	mmSelectFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectFloating.mock
}

// Set uses given function f to mock the Btt.SelectFloating method
func (mmSelectFloating *mBttMockSelectFloating) Set(f func(ctx context.Context, floating Floating) (err error)) *BttMock {
	if mmSelectFloating.defaultExpectation != nil {
		mmSelectFloating.mock.t.Fatalf("Default expectation is already set for the Btt.SelectFloating method")
	}

	if len(mmSelectFloating.expectations) > 0 {
		mmSelectFloating.mock.t.Fatalf("Some expectations are already set for the Btt.SelectFloating method")
	}

	mmSelectFloating.mock.funcSelectFloating = f
	mmSelectFloating.mock.funcSelectFloatingOrigin = minimock.CallerInfo(1)
	return mmSelectFloating.mock
}

// When sets expectation for the Btt.SelectFloating which will trigger the result defined by the following
// Then helper
func (mmSelectFloating *mBttMockSelectFloating) When(ctx context.Context, floating Floating) *BttMockSelectFloatingExpectation {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Set")
	}

	expectation := &BttMockSelectFloatingExpectation{
		mock:               mmSelectFloating.mock,
		params:             &BttMockSelectFloatingParams{ctx, floating},
		expectationOrigins: BttMockSelectFloatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectFloating.expectations = append(mmSelectFloating.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectFloating return parameters for the expectation previously defined by the When method
func (e *BttMockSelectFloatingExpectation) Then(err error) *BttMock {
	e.results = &BttMockSelectFloatingResults{err}
	return e.mock
}

// Times sets number of times Btt.SelectFloating should be invoked
func (mmSelectFloating *mBttMockSelectFloating) Times(n uint64) *mBttMockSelectFloating {
	if n == 0 {
		mmSelectFloating.mock.t.Fatalf("Times of BttMock.SelectFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectFloating.expectedInvocations, n)
	mmSelectFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectFloating
}

func (mmSelectFloating *mBttMockSelectFloating) invocationsDone() bool {
	if len(mmSelectFloating.expectations) == 0 && mmSelectFloating.defaultExpectation == nil && mmSelectFloating.mock.funcSelectFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectFloating.mock.afterSelectFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectFloating implements Btt
func (mmSelectFloating *BttMock) SelectFloating(ctx context.Context, floating Floating) (err error) {
	mm_atomic.AddUint64(&mmSelectFloating.beforeSelectFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectFloating.afterSelectFloatingCounter, 1)

	mmSelectFloating.t.Helper()

	if mmSelectFloating.inspectFuncSelectFloating != nil {
		mmSelectFloating.inspectFuncSelectFloating(ctx, floating)
	}

	mm_params := BttMockSelectFloatingParams{ctx, floating}

	// Record call args
	mmSelectFloating.SelectFloatingMock.mutex.Lock()
	mmSelectFloating.SelectFloatingMock.callArgs = append(mmSelectFloating.SelectFloatingMock.callArgs, &mm_params)
	mmSelectFloating.SelectFloatingMock.mutex.Unlock()

	for _, e := range mmSelectFloating.SelectFloatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectFloating.SelectFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectFloating.SelectFloatingMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectFloating.SelectFloatingMock.defaultExpectation.params
		mm_want_ptrs := mmSelectFloating.SelectFloatingMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectFloatingParams{ctx, floating}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectFloating.t.Errorf("BttMock.SelectFloating got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectFloating.SelectFloatingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.floating != nil && !minimock.Equal(*mm_want_ptrs.floating, mm_got.floating) {
				mmSelectFloating.t.Errorf("BttMock.SelectFloating got unexpected parameter floating, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectFloating.SelectFloatingMock.defaultExpectation.expectationOrigins.originFloating, *mm_want_ptrs.floating, mm_got.floating, minimock.Diff(*mm_want_ptrs.floating, mm_got.floating))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectFloating.t.Errorf("BttMock.SelectFloating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectFloating.SelectFloatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectFloating.SelectFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectFloating.t.Fatal("No results are set for the BttMock.SelectFloating")
		}
		return (*mm_results).err
	}
	if mmSelectFloating.funcSelectFloating != nil {
		return mmSelectFloating.funcSelectFloating(ctx, floating)
	}
	mmSelectFloating.t.Fatalf("Unexpected call to BttMock.SelectFloating. %v %v", ctx, floating)
	return
}

// SelectFloatingAfterCounter returns a count of finished BttMock.SelectFloating invocations
func (mmSelectFloating *BttMock) SelectFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectFloating.afterSelectFloatingCounter)
}

// SelectFloatingBeforeCounter returns a count of BttMock.SelectFloating invocations
func (mmSelectFloating *BttMock) SelectFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectFloating.beforeSelectFloatingCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectFloating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectFloating *mBttMockSelectFloating) Calls() []*BttMockSelectFloatingParams {
	mmSelectFloating.mutex.RLock()

	argCopy := make([]*BttMockSelectFloatingParams, len(mmSelectFloating.callArgs))
	copy(argCopy, mmSelectFloating.callArgs)

	mmSelectFloating.mutex.RUnlock()

	return argCopy
}

// MinimockSelectFloatingDone returns true if the count of the SelectFloating invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectFloatingDone() bool {
	if m.SelectFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectFloatingMock.invocationsDone()
}

// MinimockSelectFloatingInspect logs each unmet expectation
func (m *BttMock) MinimockSelectFloatingInspect() {
	for _, e := range m.SelectFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectFloating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectFloatingCounter := mm_atomic.LoadUint64(&m.afterSelectFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectFloatingMock.defaultExpectation != nil && afterSelectFloatingCounter < 1 {
		if m.SelectFloatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectFloating at\n%s", m.SelectFloatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectFloating at\n%s with params: %#v", m.SelectFloatingMock.defaultExpectation.expectationOrigins.origin, *m.SelectFloatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectFloating != nil && afterSelectFloatingCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectFloating at\n%s", m.funcSelectFloatingOrigin)
	}

	if !m.SelectFloatingMock.invocationsDone() && afterSelectFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectFloatingMock.expectedInvocations), m.SelectFloatingMock.expectedInvocationsOrigin, afterSelectFloatingCounter)
	}
}

type mBttMockSelectLanguage struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectLanguageExpectation
	expectations       []*BttMockSelectLanguageExpectation

	callArgs []*BttMockSelectLanguageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectLanguageExpectation specifies expectation struct of the Btt.SelectLanguage
type BttMockSelectLanguageExpectation struct {
	mock               *BttMock
	params             *BttMockSelectLanguageParams
	paramPtrs          *BttMockSelectLanguageParamPtrs
	expectationOrigins BttMockSelectLanguageExpectationOrigins
	results            *BttMockSelectLanguageResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectLanguageParams contains parameters of the Btt.SelectLanguage
type BttMockSelectLanguageParams struct {
	ctx      context.Context
	language string
}

// BttMockSelectLanguageParamPtrs contains pointers to parameters of the Btt.SelectLanguage
type BttMockSelectLanguageParamPtrs struct {
	ctx      *context.Context
	language *string
}

// BttMockSelectLanguageResults contains results of the Btt.SelectLanguage
type BttMockSelectLanguageResults struct {
	err error
}

// BttMockSelectLanguageOrigins contains origins of expectations of the Btt.SelectLanguage
type BttMockSelectLanguageExpectationOrigins struct {
	origin         string
	originCtx      string
	originLanguage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectLanguage *mBttMockSelectLanguage) Optional() *mBttMockSelectLanguage {
	mmSelectLanguage.optional = true
	return mmSelectLanguage
}

// Expect sets up expected params for Btt.SelectLanguage
func (mmSelectLanguage *mBttMockSelectLanguage) Expect(ctx context.Context, language string) *mBttMockSelectLanguage {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &BttMockSelectLanguageExpectation{}
	}

	if mmSelectLanguage.defaultExpectation.paramPtrs != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by ExpectParams functions")
	}

	mmSelectLanguage.defaultExpectation.params = &BttMockSelectLanguageParams{ctx, language}
	mmSelectLanguage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectLanguage.expectations {
		if minimock.Equal(e.params, mmSelectLanguage.defaultExpectation.params) {
			mmSelectLanguage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectLanguage.defaultExpectation.params)
		}
	}

	return mmSelectLanguage
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectLanguage
func (mmSelectLanguage *mBttMockSelectLanguage) ExpectCtxParam1(ctx context.Context) *mBttMockSelectLanguage {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &BttMockSelectLanguageExpectation{}
	}

	if mmSelectLanguage.defaultExpectation.params != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Expect")
	}

	if mmSelectLanguage.defaultExpectation.paramPtrs == nil {
		mmSelectLanguage.defaultExpectation.paramPtrs = &BttMockSelectLanguageParamPtrs{}
	}
	mmSelectLanguage.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectLanguage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectLanguage
}

// ExpectLanguageParam2 sets up expected param language for Btt.SelectLanguage
func (mmSelectLanguage *mBttMockSelectLanguage) ExpectLanguageParam2(language string) *mBttMockSelectLanguage {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &BttMockSelectLanguageExpectation{}
	}

	if mmSelectLanguage.defaultExpectation.params != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Expect")
	}

	if mmSelectLanguage.defaultExpectation.paramPtrs == nil {
		mmSelectLanguage.defaultExpectation.paramPtrs = &BttMockSelectLanguageParamPtrs{}
	}
	mmSelectLanguage.defaultExpectation.paramPtrs.language = &language
	mmSelectLanguage.defaultExpectation.expectationOrigins.originLanguage = minimock.CallerInfo(1)

	return mmSelectLanguage
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectLanguage
func (mmSelectLanguage *mBttMockSelectLanguage) Inspect(f func(ctx context.Context, language string)) *mBttMockSelectLanguage {
	if mmSelectLanguage.mock.inspectFuncSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("Inspect function is already set for BttMock.SelectLanguage")
	}

	mmSelectLanguage.mock.inspectFuncSelectLanguage = f

	return mmSelectLanguage
}

// Return sets up results that will be returned by Btt.SelectLanguage
func (mmSelectLanguage *mBttMockSelectLanguage) Return(err error) *BttMock {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &BttMockSelectLanguageExpectation{mock: mmSelectLanguage.mock}
	}
	mmSelectLanguage.defaultExpectation.results = &BttMockSelectLanguageResults{err}
	mmSelectLanguage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectLanguage.mock
}

// Set uses given function f to mock the Btt.SelectLanguage method
func (mmSelectLanguage *mBttMockSelectLanguage) Set(f func(ctx context.Context, language string) (err error)) *BttMock {
	if mmSelectLanguage.defaultExpectation != nil {
		mmSelectLanguage.mock.t.Fatalf("Default expectation is already set for the Btt.SelectLanguage method")
	}

	if len(mmSelectLanguage.expectations) > 0 {
		mmSelectLanguage.mock.t.Fatalf("Some expectations are already set for the Btt.SelectLanguage method")
	}

	mmSelectLanguage.mock.funcSelectLanguage = f
	mmSelectLanguage.mock.funcSelectLanguageOrigin = minimock.CallerInfo(1)
	return mmSelectLanguage.mock
}

// When sets expectation for the Btt.SelectLanguage which will trigger the result defined by the following
// Then helper
func (mmSelectLanguage *mBttMockSelectLanguage) When(ctx context.Context, language string) *BttMockSelectLanguageExpectation {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Set")
	}

	expectation := &BttMockSelectLanguageExpectation{
		mock:               mmSelectLanguage.mock,
		params:             &BttMockSelectLanguageParams{ctx, language},
		expectationOrigins: BttMockSelectLanguageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectLanguage.expectations = append(mmSelectLanguage.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectLanguage return parameters for the expectation previously defined by the When method
func (e *BttMockSelectLanguageExpectation) Then(err error) *BttMock {
	e.results = &BttMockSelectLanguageResults{err}
	return e.mock
}

// Times sets number of times Btt.SelectLanguage should be invoked
func (mmSelectLanguage *mBttMockSelectLanguage) Times(n uint64) *mBttMockSelectLanguage {
	if n == 0 {
		mmSelectLanguage.mock.t.Fatalf("Times of BttMock.SelectLanguage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectLanguage.expectedInvocations, n)
	mmSelectLanguage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectLanguage
}

func (mmSelectLanguage *mBttMockSelectLanguage) invocationsDone() bool {
	if len(mmSelectLanguage.expectations) == 0 && mmSelectLanguage.defaultExpectation == nil && mmSelectLanguage.mock.funcSelectLanguage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectLanguage.mock.afterSelectLanguageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectLanguage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectLanguage implements Btt
func (mmSelectLanguage *BttMock) SelectLanguage(ctx context.Context, language string) (err error) {
	mm_atomic.AddUint64(&mmSelectLanguage.beforeSelectLanguageCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectLanguage.afterSelectLanguageCounter, 1)

	mmSelectLanguage.t.Helper()

	if mmSelectLanguage.inspectFuncSelectLanguage != nil {
		mmSelectLanguage.inspectFuncSelectLanguage(ctx, language)
	}

	mm_params := BttMockSelectLanguageParams{ctx, language}

	// Record call args
	mmSelectLanguage.SelectLanguageMock.mutex.Lock()
	mmSelectLanguage.SelectLanguageMock.callArgs = append(mmSelectLanguage.SelectLanguageMock.callArgs, &mm_params)
	mmSelectLanguage.SelectLanguageMock.mutex.Unlock()

	for _, e := range mmSelectLanguage.SelectLanguageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectLanguage.SelectLanguageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectLanguage.SelectLanguageMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectLanguage.SelectLanguageMock.defaultExpectation.params
		mm_want_ptrs := mmSelectLanguage.SelectLanguageMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectLanguageParams{ctx, language}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectLanguage.t.Errorf("BttMock.SelectLanguage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectLanguage.SelectLanguageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.language != nil && !minimock.Equal(*mm_want_ptrs.language, mm_got.language) {
				mmSelectLanguage.t.Errorf("BttMock.SelectLanguage got unexpected parameter language, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectLanguage.SelectLanguageMock.defaultExpectation.expectationOrigins.originLanguage, *mm_want_ptrs.language, mm_got.language, minimock.Diff(*mm_want_ptrs.language, mm_got.language))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectLanguage.t.Errorf("BttMock.SelectLanguage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectLanguage.SelectLanguageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectLanguage.SelectLanguageMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectLanguage.t.Fatal("No results are set for the BttMock.SelectLanguage")
		}
		return (*mm_results).err
	}
	if mmSelectLanguage.funcSelectLanguage != nil {
		return mmSelectLanguage.funcSelectLanguage(ctx, language)
	}
	mmSelectLanguage.t.Fatalf("Unexpected call to BttMock.SelectLanguage. %v %v", ctx, language)
	return
}

// SelectLanguageAfterCounter returns a count of finished BttMock.SelectLanguage invocations
func (mmSelectLanguage *BttMock) SelectLanguageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectLanguage.afterSelectLanguageCounter)
}

// SelectLanguageBeforeCounter returns a count of BttMock.SelectLanguage invocations
func (mmSelectLanguage *BttMock) SelectLanguageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectLanguage.beforeSelectLanguageCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectLanguage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectLanguage *mBttMockSelectLanguage) Calls() []*BttMockSelectLanguageParams {
	mmSelectLanguage.mutex.RLock()

	argCopy := make([]*BttMockSelectLanguageParams, len(mmSelectLanguage.callArgs))
	copy(argCopy, mmSelectLanguage.callArgs)

	mmSelectLanguage.mutex.RUnlock()

	return argCopy
}

// MinimockSelectLanguageDone returns true if the count of the SelectLanguage invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectLanguageDone() bool {
	if m.SelectLanguageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectLanguageMock.invocationsDone()
}

// MinimockSelectLanguageInspect logs each unmet expectation
func (m *BttMock) MinimockSelectLanguageInspect() {
	for _, e := range m.SelectLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectLanguage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectLanguageCounter := mm_atomic.LoadUint64(&m.afterSelectLanguageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectLanguageMock.defaultExpectation != nil && afterSelectLanguageCounter < 1 {
		if m.SelectLanguageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectLanguage at\n%s", m.SelectLanguageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectLanguage at\n%s with params: %#v", m.SelectLanguageMock.defaultExpectation.expectationOrigins.origin, *m.SelectLanguageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectLanguage != nil && afterSelectLanguageCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectLanguage at\n%s", m.funcSelectLanguageOrigin)
	}

	if !m.SelectLanguageMock.invocationsDone() && afterSelectLanguageCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectLanguage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectLanguageMock.expectedInvocations), m.SelectLanguageMock.expectedInvocationsOrigin, afterSelectLanguageCounter)
	}
}

type mBttMockSelectViewMode struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectViewModeExpectation
	expectations       []*BttMockSelectViewModeExpectation

	callArgs []*BttMockSelectViewModeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectViewModeExpectation specifies expectation struct of the Btt.SelectViewMode
type BttMockSelectViewModeExpectation struct {
	mock               *BttMock
	params             *BttMockSelectViewModeParams
	paramPtrs          *BttMockSelectViewModeParamPtrs
	expectationOrigins BttMockSelectViewModeExpectationOrigins
	results            *BttMockSelectViewModeResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectViewModeParams contains parameters of the Btt.SelectViewMode
type BttMockSelectViewModeParams struct {
	ctx      context.Context
	viewMode ViewMode
}

// BttMockSelectViewModeParamPtrs contains pointers to parameters of the Btt.SelectViewMode
type BttMockSelectViewModeParamPtrs struct {
	ctx      *context.Context
	viewMode *ViewMode
}

// BttMockSelectViewModeResults contains results of the Btt.SelectViewMode
type BttMockSelectViewModeResults struct {
	err error
}

// BttMockSelectViewModeOrigins contains origins of expectations of the Btt.SelectViewMode
type BttMockSelectViewModeExpectationOrigins struct {
	origin         string
	originCtx      string
	originViewMode string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectViewMode *mBttMockSelectViewMode) Optional() *mBttMockSelectViewMode {
	mmSelectViewMode.optional = true
	return mmSelectViewMode
}

// Expect sets up expected params for Btt.SelectViewMode
func (mmSelectViewMode *mBttMockSelectViewMode) Expect(ctx context.Context, viewMode ViewMode) *mBttMockSelectViewMode {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &BttMockSelectViewModeExpectation{}
	}

	if mmSelectViewMode.defaultExpectation.paramPtrs != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by ExpectParams functions")
	}

	mmSelectViewMode.defaultExpectation.params = &BttMockSelectViewModeParams{ctx, viewMode}
	mmSelectViewMode.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectViewMode.expectations {
		if minimock.Equal(e.params, mmSelectViewMode.defaultExpectation.params) {
			mmSelectViewMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectViewMode.defaultExpectation.params)
		}
	}

	return mmSelectViewMode
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectViewMode
func (mmSelectViewMode *mBttMockSelectViewMode) ExpectCtxParam1(ctx context.Context) *mBttMockSelectViewMode {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &BttMockSelectViewModeExpectation{}
	}

	if mmSelectViewMode.defaultExpectation.params != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Expect")
	}

	if mmSelectViewMode.defaultExpectation.paramPtrs == nil {
		mmSelectViewMode.defaultExpectation.paramPtrs = &BttMockSelectViewModeParamPtrs{}
	}
	mmSelectViewMode.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectViewMode.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectViewMode
}

// ExpectViewModeParam2 sets up expected param viewMode for Btt.SelectViewMode
func (mmSelectViewMode *mBttMockSelectViewMode) ExpectViewModeParam2(viewMode ViewMode) *mBttMockSelectViewMode {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &BttMockSelectViewModeExpectation{}
	}

	if mmSelectViewMode.defaultExpectation.params != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Expect")
	}

	if mmSelectViewMode.defaultExpectation.paramPtrs == nil {
		mmSelectViewMode.defaultExpectation.paramPtrs = &BttMockSelectViewModeParamPtrs{}
	}
	mmSelectViewMode.defaultExpectation.paramPtrs.viewMode = &viewMode
	mmSelectViewMode.defaultExpectation.expectationOrigins.originViewMode = minimock.CallerInfo(1)

	return mmSelectViewMode
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectViewMode
func (mmSelectViewMode *mBttMockSelectViewMode) Inspect(f func(ctx context.Context, viewMode ViewMode)) *mBttMockSelectViewMode {
	if mmSelectViewMode.mock.inspectFuncSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("Inspect function is already set for BttMock.SelectViewMode")
	}

	mmSelectViewMode.mock.inspectFuncSelectViewMode = f

	return mmSelectViewMode
}

// Return sets up results that will be returned by Btt.SelectViewMode
func (mmSelectViewMode *mBttMockSelectViewMode) Return(err error) *BttMock {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &BttMockSelectViewModeExpectation{mock: mmSelectViewMode.mock}
	}
	mmSelectViewMode.defaultExpectation.results = &BttMockSelectViewModeResults{err}
	mmSelectViewMode.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectViewMode.mock
}

// Set uses given function f to mock the Btt.SelectViewMode method
func (mmSelectViewMode *mBttMockSelectViewMode) Set(f func(ctx context.Context, viewMode ViewMode) (err error)) *BttMock {
	if mmSelectViewMode.defaultExpectation != nil {
		mmSelectViewMode.mock.t.Fatalf("Default expectation is already set for the Btt.SelectViewMode method")
	}

	if len(mmSelectViewMode.expectations) > 0 {
		mmSelectViewMode.mock.t.Fatalf("Some expectations are already set for the Btt.SelectViewMode method")
	}

	mmSelectViewMode.mock.funcSelectViewMode = f
	mmSelectViewMode.mock.funcSelectViewModeOrigin = minimock.CallerInfo(1)
	return mmSelectViewMode.mock
}

// When sets expectation for the Btt.SelectViewMode which will trigger the result defined by the following
// Then helper
func (mmSelectViewMode *mBttMockSelectViewMode) When(ctx context.Context, viewMode ViewMode) *BttMockSelectViewModeExpectation {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Set")
	}

	expectation := &BttMockSelectViewModeExpectation{
		mock:               mmSelectViewMode.mock,
		params:             &BttMockSelectViewModeParams{ctx, viewMode},
		expectationOrigins: BttMockSelectViewModeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectViewMode.expectations = append(mmSelectViewMode.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectViewMode return parameters for the expectation previously defined by the When method
func (e *BttMockSelectViewModeExpectation) Then(err error) *BttMock {
	e.results = &BttMockSelectViewModeResults{err}
	return e.mock
}

// Times sets number of times Btt.SelectViewMode should be invoked
func (mmSelectViewMode *mBttMockSelectViewMode) Times(n uint64) *mBttMockSelectViewMode {
	if n == 0 {
		mmSelectViewMode.mock.t.Fatalf("Times of BttMock.SelectViewMode mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectViewMode.expectedInvocations, n)
	mmSelectViewMode.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectViewMode
}

func (mmSelectViewMode *mBttMockSelectViewMode) invocationsDone() bool {
	if len(mmSelectViewMode.expectations) == 0 && mmSelectViewMode.defaultExpectation == nil && mmSelectViewMode.mock.funcSelectViewMode == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectViewMode.mock.afterSelectViewModeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectViewMode.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectViewMode implements Btt
func (mmSelectViewMode *BttMock) SelectViewMode(ctx context.Context, viewMode ViewMode) (err error) {
	mm_atomic.AddUint64(&mmSelectViewMode.beforeSelectViewModeCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectViewMode.afterSelectViewModeCounter, 1)

	mmSelectViewMode.t.Helper()

	if mmSelectViewMode.inspectFuncSelectViewMode != nil {
		mmSelectViewMode.inspectFuncSelectViewMode(ctx, viewMode)
	}

	mm_params := BttMockSelectViewModeParams{ctx, viewMode}

	// Record call args
	mmSelectViewMode.SelectViewModeMock.mutex.Lock()
	mmSelectViewMode.SelectViewModeMock.callArgs = append(mmSelectViewMode.SelectViewModeMock.callArgs, &mm_params)
	mmSelectViewMode.SelectViewModeMock.mutex.Unlock()

	for _, e := range mmSelectViewMode.SelectViewModeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectViewMode.SelectViewModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectViewMode.SelectViewModeMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectViewMode.SelectViewModeMock.defaultExpectation.params
		mm_want_ptrs := mmSelectViewMode.SelectViewModeMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectViewModeParams{ctx, viewMode}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectViewMode.t.Errorf("BttMock.SelectViewMode got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectViewMode.SelectViewModeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.viewMode != nil && !minimock.Equal(*mm_want_ptrs.viewMode, mm_got.viewMode) {
				mmSelectViewMode.t.Errorf("BttMock.SelectViewMode got unexpected parameter viewMode, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectViewMode.SelectViewModeMock.defaultExpectation.expectationOrigins.originViewMode, *mm_want_ptrs.viewMode, mm_got.viewMode, minimock.Diff(*mm_want_ptrs.viewMode, mm_got.viewMode))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectViewMode.t.Errorf("BttMock.SelectViewMode got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectViewMode.SelectViewModeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectViewMode.SelectViewModeMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectViewMode.t.Fatal("No results are set for the BttMock.SelectViewMode")
		}
		return (*mm_results).err
	}
	if mmSelectViewMode.funcSelectViewMode != nil {
		return mmSelectViewMode.funcSelectViewMode(ctx, viewMode)
	}
	mmSelectViewMode.t.Fatalf("Unexpected call to BttMock.SelectViewMode. %v %v", ctx, viewMode)
	return
}

// SelectViewModeAfterCounter returns a count of finished BttMock.SelectViewMode invocations
func (mmSelectViewMode *BttMock) SelectViewModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectViewMode.afterSelectViewModeCounter)
}

// SelectViewModeBeforeCounter returns a count of BttMock.SelectViewMode invocations
func (mmSelectViewMode *BttMock) SelectViewModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectViewMode.beforeSelectViewModeCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectViewMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectViewMode *mBttMockSelectViewMode) Calls() []*BttMockSelectViewModeParams {
	mmSelectViewMode.mutex.RLock()

	argCopy := make([]*BttMockSelectViewModeParams, len(mmSelectViewMode.callArgs))
	copy(argCopy, mmSelectViewMode.callArgs)

	mmSelectViewMode.mutex.RUnlock()

	return argCopy
}

// MinimockSelectViewModeDone returns true if the count of the SelectViewMode invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectViewModeDone() bool {
	if m.SelectViewModeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectViewModeMock.invocationsDone()
}

// MinimockSelectViewModeInspect logs each unmet expectation
func (m *BttMock) MinimockSelectViewModeInspect() {
	for _, e := range m.SelectViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectViewMode at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectViewModeCounter := mm_atomic.LoadUint64(&m.afterSelectViewModeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectViewModeMock.defaultExpectation != nil && afterSelectViewModeCounter < 1 {
		if m.SelectViewModeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectViewMode at\n%s", m.SelectViewModeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectViewMode at\n%s with params: %#v", m.SelectViewModeMock.defaultExpectation.expectationOrigins.origin, *m.SelectViewModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectViewMode != nil && afterSelectViewModeCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectViewMode at\n%s", m.funcSelectViewModeOrigin)
	}

	if !m.SelectViewModeMock.invocationsDone() && afterSelectViewModeCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectViewMode at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectViewModeMock.expectedInvocations), m.SelectViewModeMock.expectedInvocationsOrigin, afterSelectViewModeCounter)
	}
}

type mBttMockSelectedClipboard struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectedClipboardExpectation
	expectations       []*BttMockSelectedClipboardExpectation

	callArgs []*BttMockSelectedClipboardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectedClipboardExpectation specifies expectation struct of the Btt.SelectedClipboard
type BttMockSelectedClipboardExpectation struct {
	mock               *BttMock
	params             *BttMockSelectedClipboardParams
	paramPtrs          *BttMockSelectedClipboardParamPtrs
	expectationOrigins BttMockSelectedClipboardExpectationOrigins
	results            *BttMockSelectedClipboardResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectedClipboardParams contains parameters of the Btt.SelectedClipboard
type BttMockSelectedClipboardParams struct {
	ctx context.Context
}

// BttMockSelectedClipboardParamPtrs contains pointers to parameters of the Btt.SelectedClipboard
type BttMockSelectedClipboardParamPtrs struct {
	ctx *context.Context
}

// BttMockSelectedClipboardResults contains results of the Btt.SelectedClipboard
type BttMockSelectedClipboardResults struct {
	c2  Clipboard
	err error
}

// BttMockSelectedClipboardOrigins contains origins of expectations of the Btt.SelectedClipboard
type BttMockSelectedClipboardExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedClipboard *mBttMockSelectedClipboard) Optional() *mBttMockSelectedClipboard {
	mmSelectedClipboard.optional = true
	return mmSelectedClipboard
}

// Expect sets up expected params for Btt.SelectedClipboard
func (mmSelectedClipboard *mBttMockSelectedClipboard) Expect(ctx context.Context) *mBttMockSelectedClipboard {
	if mmSelectedClipboard.mock.funcSelectedClipboard != nil {
		mmSelectedClipboard.mock.t.Fatalf("BttMock.SelectedClipboard mock is already set by Set")
	}

	if mmSelectedClipboard.defaultExpectation == nil {
		mmSelectedClipboard.defaultExpectation = &BttMockSelectedClipboardExpectation{}
	}

	if mmSelectedClipboard.defaultExpectation.paramPtrs != nil {
		mmSelectedClipboard.mock.t.Fatalf("BttMock.SelectedClipboard mock is already set by ExpectParams functions")
	}

	mmSelectedClipboard.defaultExpectation.params = &BttMockSelectedClipboardParams{ctx}
	mmSelectedClipboard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedClipboard.expectations {
		if minimock.Equal(e.params, mmSelectedClipboard.defaultExpectation.params) {
			mmSelectedClipboard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedClipboard.defaultExpectation.params)
		}
	}

	return mmSelectedClipboard
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectedClipboard
func (mmSelectedClipboard *mBttMockSelectedClipboard) ExpectCtxParam1(ctx context.Context) *mBttMockSelectedClipboard {
	if mmSelectedClipboard.mock.funcSelectedClipboard != nil {
		mmSelectedClipboard.mock.t.Fatalf("BttMock.SelectedClipboard mock is already set by Set")
	}

	if mmSelectedClipboard.defaultExpectation == nil {
		mmSelectedClipboard.defaultExpectation = &BttMockSelectedClipboardExpectation{}
	}

	if mmSelectedClipboard.defaultExpectation.params != nil {
		mmSelectedClipboard.mock.t.Fatalf("BttMock.SelectedClipboard mock is already set by Expect")
	}

	if mmSelectedClipboard.defaultExpectation.paramPtrs == nil {
		mmSelectedClipboard.defaultExpectation.paramPtrs = &BttMockSelectedClipboardParamPtrs{}
	}
	mmSelectedClipboard.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedClipboard.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedClipboard
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectedClipboard
func (mmSelectedClipboard *mBttMockSelectedClipboard) Inspect(f func(ctx context.Context)) *mBttMockSelectedClipboard {
	if mmSelectedClipboard.mock.inspectFuncSelectedClipboard != nil {
		mmSelectedClipboard.mock.t.Fatalf("Inspect function is already set for BttMock.SelectedClipboard")
	}

	mmSelectedClipboard.mock.inspectFuncSelectedClipboard = f

	return mmSelectedClipboard
}

// Return sets up results that will be returned by Btt.SelectedClipboard
func (mmSelectedClipboard *mBttMockSelectedClipboard) Return(c2 Clipboard, err error) *BttMock {
	if mmSelectedClipboard.mock.funcSelectedClipboard != nil {
		mmSelectedClipboard.mock.t.Fatalf("BttMock.SelectedClipboard mock is already set by Set")
	}

	if mmSelectedClipboard.defaultExpectation == nil {
		mmSelectedClipboard.defaultExpectation = &BttMockSelectedClipboardExpectation{mock: mmSelectedClipboard.mock}
	}
	mmSelectedClipboard.defaultExpectation.results = &BttMockSelectedClipboardResults{c2, err}
	mmSelectedClipboard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedClipboard.mock
}

// Set uses given function f to mock the Btt.SelectedClipboard method
func (mmSelectedClipboard *mBttMockSelectedClipboard) Set(f func(ctx context.Context) (c2 Clipboard, err error)) *BttMock {
	if mmSelectedClipboard.defaultExpectation != nil {
		mmSelectedClipboard.mock.t.Fatalf("Default expectation is already set for the Btt.SelectedClipboard method")
	}

	if len(mmSelectedClipboard.expectations) > 0 {
		mmSelectedClipboard.mock.t.Fatalf("Some expectations are already set for the Btt.SelectedClipboard method")
	}

	mmSelectedClipboard.mock.funcSelectedClipboard = f
	mmSelectedClipboard.mock.funcSelectedClipboardOrigin = minimock.CallerInfo(1)
	return mmSelectedClipboard.mock
}

// When sets expectation for the Btt.SelectedClipboard which will trigger the result defined by the following
// Then helper
func (mmSelectedClipboard *mBttMockSelectedClipboard) When(ctx context.Context) *BttMockSelectedClipboardExpectation {
	if mmSelectedClipboard.mock.funcSelectedClipboard != nil {
		mmSelectedClipboard.mock.t.Fatalf("BttMock.SelectedClipboard mock is already set by Set")
	}

	expectation := &BttMockSelectedClipboardExpectation{
		mock:               mmSelectedClipboard.mock,
		params:             &BttMockSelectedClipboardParams{ctx},
		expectationOrigins: BttMockSelectedClipboardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedClipboard.expectations = append(mmSelectedClipboard.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectedClipboard return parameters for the expectation previously defined by the When method
func (e *BttMockSelectedClipboardExpectation) Then(c2 Clipboard, err error) *BttMock {
	e.results = &BttMockSelectedClipboardResults{c2, err}
	return e.mock
}

// Times sets number of times Btt.SelectedClipboard should be invoked
func (mmSelectedClipboard *mBttMockSelectedClipboard) Times(n uint64) *mBttMockSelectedClipboard {
	if n == 0 {
		mmSelectedClipboard.mock.t.Fatalf("Times of BttMock.SelectedClipboard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedClipboard.expectedInvocations, n)
	mmSelectedClipboard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedClipboard
}

func (mmSelectedClipboard *mBttMockSelectedClipboard) invocationsDone() bool {
	if len(mmSelectedClipboard.expectations) == 0 && mmSelectedClipboard.defaultExpectation == nil && mmSelectedClipboard.mock.funcSelectedClipboard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedClipboard.mock.afterSelectedClipboardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedClipboard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedClipboard implements Btt
func (mmSelectedClipboard *BttMock) SelectedClipboard(ctx context.Context) (c2 Clipboard, err error) {
	mm_atomic.AddUint64(&mmSelectedClipboard.beforeSelectedClipboardCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedClipboard.afterSelectedClipboardCounter, 1)

	mmSelectedClipboard.t.Helper()

	if mmSelectedClipboard.inspectFuncSelectedClipboard != nil {
		mmSelectedClipboard.inspectFuncSelectedClipboard(ctx)
	}

	mm_params := BttMockSelectedClipboardParams{ctx}

	// Record call args
	mmSelectedClipboard.SelectedClipboardMock.mutex.Lock()
	mmSelectedClipboard.SelectedClipboardMock.callArgs = append(mmSelectedClipboard.SelectedClipboardMock.callArgs, &mm_params)
	mmSelectedClipboard.SelectedClipboardMock.mutex.Unlock()

	for _, e := range mmSelectedClipboard.SelectedClipboardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmSelectedClipboard.SelectedClipboardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedClipboard.SelectedClipboardMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedClipboard.SelectedClipboardMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedClipboard.SelectedClipboardMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectedClipboardParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedClipboard.t.Errorf("BttMock.SelectedClipboard got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedClipboard.SelectedClipboardMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedClipboard.t.Errorf("BttMock.SelectedClipboard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedClipboard.SelectedClipboardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedClipboard.SelectedClipboardMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedClipboard.t.Fatal("No results are set for the BttMock.SelectedClipboard")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmSelectedClipboard.funcSelectedClipboard != nil {
		return mmSelectedClipboard.funcSelectedClipboard(ctx)
	}
	mmSelectedClipboard.t.Fatalf("Unexpected call to BttMock.SelectedClipboard. %v", ctx)
	return
}

// SelectedClipboardAfterCounter returns a count of finished BttMock.SelectedClipboard invocations
func (mmSelectedClipboard *BttMock) SelectedClipboardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedClipboard.afterSelectedClipboardCounter)
}

// SelectedClipboardBeforeCounter returns a count of BttMock.SelectedClipboard invocations
func (mmSelectedClipboard *BttMock) SelectedClipboardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedClipboard.beforeSelectedClipboardCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectedClipboard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedClipboard *mBttMockSelectedClipboard) Calls() []*BttMockSelectedClipboardParams {
	mmSelectedClipboard.mutex.RLock()

	argCopy := make([]*BttMockSelectedClipboardParams, len(mmSelectedClipboard.callArgs))
	copy(argCopy, mmSelectedClipboard.callArgs)

	mmSelectedClipboard.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedClipboardDone returns true if the count of the SelectedClipboard invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectedClipboardDone() bool {
	if m.SelectedClipboardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedClipboardMock.invocationsDone()
}

// MinimockSelectedClipboardInspect logs each unmet expectation
func (m *BttMock) MinimockSelectedClipboardInspect() {
	for _, e := range m.SelectedClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectedClipboard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedClipboardCounter := mm_atomic.LoadUint64(&m.afterSelectedClipboardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedClipboardMock.defaultExpectation != nil && afterSelectedClipboardCounter < 1 {
		if m.SelectedClipboardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectedClipboard at\n%s", m.SelectedClipboardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectedClipboard at\n%s with params: %#v", m.SelectedClipboardMock.defaultExpectation.expectationOrigins.origin, *m.SelectedClipboardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedClipboard != nil && afterSelectedClipboardCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectedClipboard at\n%s", m.funcSelectedClipboardOrigin)
	}

	if !m.SelectedClipboardMock.invocationsDone() && afterSelectedClipboardCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectedClipboard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedClipboardMock.expectedInvocations), m.SelectedClipboardMock.expectedInvocationsOrigin, afterSelectedClipboardCounter)
	}
}

type mBttMockSelectedDevice struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectedDeviceExpectation
	expectations       []*BttMockSelectedDeviceExpectation

	callArgs []*BttMockSelectedDeviceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectedDeviceExpectation specifies expectation struct of the Btt.SelectedDevice
type BttMockSelectedDeviceExpectation struct {
	mock               *BttMock
	params             *BttMockSelectedDeviceParams
	paramPtrs          *BttMockSelectedDeviceParamPtrs
	expectationOrigins BttMockSelectedDeviceExpectationOrigins
	results            *BttMockSelectedDeviceResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectedDeviceParams contains parameters of the Btt.SelectedDevice
type BttMockSelectedDeviceParams struct {
	ctx context.Context
}

// BttMockSelectedDeviceParamPtrs contains pointers to parameters of the Btt.SelectedDevice
type BttMockSelectedDeviceParamPtrs struct {
	ctx *context.Context
}

// BttMockSelectedDeviceResults contains results of the Btt.SelectedDevice
type BttMockSelectedDeviceResults struct {
	s1  string
	err error
}

// BttMockSelectedDeviceOrigins contains origins of expectations of the Btt.SelectedDevice
type BttMockSelectedDeviceExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedDevice *mBttMockSelectedDevice) Optional() *mBttMockSelectedDevice {
	mmSelectedDevice.optional = true
	return mmSelectedDevice
}

// Expect sets up expected params for Btt.SelectedDevice
func (mmSelectedDevice *mBttMockSelectedDevice) Expect(ctx context.Context) *mBttMockSelectedDevice {
	if mmSelectedDevice.mock.funcSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("BttMock.SelectedDevice mock is already set by Set")
	}

	if mmSelectedDevice.defaultExpectation == nil {
		mmSelectedDevice.defaultExpectation = &BttMockSelectedDeviceExpectation{}
	}

	if mmSelectedDevice.defaultExpectation.paramPtrs != nil {
		mmSelectedDevice.mock.t.Fatalf("BttMock.SelectedDevice mock is already set by ExpectParams functions")
	}

	mmSelectedDevice.defaultExpectation.params = &BttMockSelectedDeviceParams{ctx}
	mmSelectedDevice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedDevice.expectations {
		if minimock.Equal(e.params, mmSelectedDevice.defaultExpectation.params) {
			mmSelectedDevice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedDevice.defaultExpectation.params)
		}
	}

	return mmSelectedDevice
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectedDevice
func (mmSelectedDevice *mBttMockSelectedDevice) ExpectCtxParam1(ctx context.Context) *mBttMockSelectedDevice {
	if mmSelectedDevice.mock.funcSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("BttMock.SelectedDevice mock is already set by Set")
	}

	if mmSelectedDevice.defaultExpectation == nil {
		mmSelectedDevice.defaultExpectation = &BttMockSelectedDeviceExpectation{}
	}

	if mmSelectedDevice.defaultExpectation.params != nil {
		mmSelectedDevice.mock.t.Fatalf("BttMock.SelectedDevice mock is already set by Expect")
	}

	if mmSelectedDevice.defaultExpectation.paramPtrs == nil {
		mmSelectedDevice.defaultExpectation.paramPtrs = &BttMockSelectedDeviceParamPtrs{}
	}
	mmSelectedDevice.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedDevice.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedDevice
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectedDevice
func (mmSelectedDevice *mBttMockSelectedDevice) Inspect(f func(ctx context.Context)) *mBttMockSelectedDevice {
	if mmSelectedDevice.mock.inspectFuncSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("Inspect function is already set for BttMock.SelectedDevice")
	}

	mmSelectedDevice.mock.inspectFuncSelectedDevice = f

	return mmSelectedDevice
}

// Return sets up results that will be returned by Btt.SelectedDevice
func (mmSelectedDevice *mBttMockSelectedDevice) Return(s1 string, err error) *BttMock {
	if mmSelectedDevice.mock.funcSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("BttMock.SelectedDevice mock is already set by Set")
	}

	if mmSelectedDevice.defaultExpectation == nil {
		mmSelectedDevice.defaultExpectation = &BttMockSelectedDeviceExpectation{mock: mmSelectedDevice.mock}
	}
	mmSelectedDevice.defaultExpectation.results = &BttMockSelectedDeviceResults{s1, err}
	mmSelectedDevice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedDevice.mock
}

// Set uses given function f to mock the Btt.SelectedDevice method
func (mmSelectedDevice *mBttMockSelectedDevice) Set(f func(ctx context.Context) (s1 string, err error)) *BttMock {
	if mmSelectedDevice.defaultExpectation != nil {
		mmSelectedDevice.mock.t.Fatalf("Default expectation is already set for the Btt.SelectedDevice method")
	}

	if len(mmSelectedDevice.expectations) > 0 {
		mmSelectedDevice.mock.t.Fatalf("Some expectations are already set for the Btt.SelectedDevice method")
	}

	mmSelectedDevice.mock.funcSelectedDevice = f
	mmSelectedDevice.mock.funcSelectedDeviceOrigin = minimock.CallerInfo(1)
	return mmSelectedDevice.mock
}

// When sets expectation for the Btt.SelectedDevice which will trigger the result defined by the following
// Then helper
func (mmSelectedDevice *mBttMockSelectedDevice) When(ctx context.Context) *BttMockSelectedDeviceExpectation {
	if mmSelectedDevice.mock.funcSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("BttMock.SelectedDevice mock is already set by Set")
	}

	expectation := &BttMockSelectedDeviceExpectation{
		mock:               mmSelectedDevice.mock,
		params:             &BttMockSelectedDeviceParams{ctx},
		expectationOrigins: BttMockSelectedDeviceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedDevice.expectations = append(mmSelectedDevice.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectedDevice return parameters for the expectation previously defined by the When method
func (e *BttMockSelectedDeviceExpectation) Then(s1 string, err error) *BttMock {
	e.results = &BttMockSelectedDeviceResults{s1, err}
	return e.mock
}

// Times sets number of times Btt.SelectedDevice should be invoked
func (mmSelectedDevice *mBttMockSelectedDevice) Times(n uint64) *mBttMockSelectedDevice {
	if n == 0 {
		mmSelectedDevice.mock.t.Fatalf("Times of BttMock.SelectedDevice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedDevice.expectedInvocations, n)
	mmSelectedDevice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedDevice
}

func (mmSelectedDevice *mBttMockSelectedDevice) invocationsDone() bool {
	if len(mmSelectedDevice.expectations) == 0 && mmSelectedDevice.defaultExpectation == nil && mmSelectedDevice.mock.funcSelectedDevice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedDevice.mock.afterSelectedDeviceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedDevice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedDevice implements Btt
func (mmSelectedDevice *BttMock) SelectedDevice(ctx context.Context) (s1 string, err error) {
	mm_atomic.AddUint64(&mmSelectedDevice.beforeSelectedDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedDevice.afterSelectedDeviceCounter, 1)

	mmSelectedDevice.t.Helper()

	if mmSelectedDevice.inspectFuncSelectedDevice != nil {
		mmSelectedDevice.inspectFuncSelectedDevice(ctx)
	}

	mm_params := BttMockSelectedDeviceParams{ctx}

	// Record call args
	mmSelectedDevice.SelectedDeviceMock.mutex.Lock()
	mmSelectedDevice.SelectedDeviceMock.callArgs = append(mmSelectedDevice.SelectedDeviceMock.callArgs, &mm_params)
	mmSelectedDevice.SelectedDeviceMock.mutex.Unlock()

	for _, e := range mmSelectedDevice.SelectedDeviceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmSelectedDevice.SelectedDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedDevice.SelectedDeviceMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedDevice.SelectedDeviceMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedDevice.SelectedDeviceMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectedDeviceParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedDevice.t.Errorf("BttMock.SelectedDevice got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedDevice.SelectedDeviceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedDevice.t.Errorf("BttMock.SelectedDevice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedDevice.SelectedDeviceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedDevice.SelectedDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedDevice.t.Fatal("No results are set for the BttMock.SelectedDevice")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmSelectedDevice.funcSelectedDevice != nil {
		return mmSelectedDevice.funcSelectedDevice(ctx)
	}
	mmSelectedDevice.t.Fatalf("Unexpected call to BttMock.SelectedDevice. %v", ctx)
	return
}

// SelectedDeviceAfterCounter returns a count of finished BttMock.SelectedDevice invocations
func (mmSelectedDevice *BttMock) SelectedDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedDevice.afterSelectedDeviceCounter)
}

// SelectedDeviceBeforeCounter returns a count of BttMock.SelectedDevice invocations
func (mmSelectedDevice *BttMock) SelectedDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedDevice.beforeSelectedDeviceCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectedDevice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedDevice *mBttMockSelectedDevice) Calls() []*BttMockSelectedDeviceParams {
	mmSelectedDevice.mutex.RLock()

	argCopy := make([]*BttMockSelectedDeviceParams, len(mmSelectedDevice.callArgs))
	copy(argCopy, mmSelectedDevice.callArgs)

	mmSelectedDevice.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedDeviceDone returns true if the count of the SelectedDevice invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectedDeviceDone() bool {
	if m.SelectedDeviceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedDeviceMock.invocationsDone()
}

// MinimockSelectedDeviceInspect logs each unmet expectation
func (m *BttMock) MinimockSelectedDeviceInspect() {
	for _, e := range m.SelectedDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectedDevice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedDeviceCounter := mm_atomic.LoadUint64(&m.afterSelectedDeviceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedDeviceMock.defaultExpectation != nil && afterSelectedDeviceCounter < 1 {
		if m.SelectedDeviceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectedDevice at\n%s", m.SelectedDeviceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectedDevice at\n%s with params: %#v", m.SelectedDeviceMock.defaultExpectation.expectationOrigins.origin, *m.SelectedDeviceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedDevice != nil && afterSelectedDeviceCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectedDevice at\n%s", m.funcSelectedDeviceOrigin)
	}

	if !m.SelectedDeviceMock.invocationsDone() && afterSelectedDeviceCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectedDevice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedDeviceMock.expectedInvocations), m.SelectedDeviceMock.expectedInvocationsOrigin, afterSelectedDeviceCounter)
	}
}

type mBttMockSelectedFloating struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectedFloatingExpectation
	expectations       []*BttMockSelectedFloatingExpectation

	callArgs []*BttMockSelectedFloatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectedFloatingExpectation specifies expectation struct of the Btt.SelectedFloating
type BttMockSelectedFloatingExpectation struct {
	mock               *BttMock
	params             *BttMockSelectedFloatingParams
	paramPtrs          *BttMockSelectedFloatingParamPtrs
	expectationOrigins BttMockSelectedFloatingExpectationOrigins
	results            *BttMockSelectedFloatingResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectedFloatingParams contains parameters of the Btt.SelectedFloating
type BttMockSelectedFloatingParams struct {
	ctx context.Context
}

// BttMockSelectedFloatingParamPtrs contains pointers to parameters of the Btt.SelectedFloating
type BttMockSelectedFloatingParamPtrs struct {
	ctx *context.Context
}

// BttMockSelectedFloatingResults contains results of the Btt.SelectedFloating
type BttMockSelectedFloatingResults struct {
	f1  Floating
	err error
}

// BttMockSelectedFloatingOrigins contains origins of expectations of the Btt.SelectedFloating
type BttMockSelectedFloatingExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedFloating *mBttMockSelectedFloating) Optional() *mBttMockSelectedFloating {
	mmSelectedFloating.optional = true
	return mmSelectedFloating
}

// Expect sets up expected params for Btt.SelectedFloating
func (mmSelectedFloating *mBttMockSelectedFloating) Expect(ctx context.Context) *mBttMockSelectedFloating {
	if mmSelectedFloating.mock.funcSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("BttMock.SelectedFloating mock is already set by Set")
	}

	if mmSelectedFloating.defaultExpectation == nil {
		mmSelectedFloating.defaultExpectation = &BttMockSelectedFloatingExpectation{}
	}

	if mmSelectedFloating.defaultExpectation.paramPtrs != nil {
		mmSelectedFloating.mock.t.Fatalf("BttMock.SelectedFloating mock is already set by ExpectParams functions")
	}

	mmSelectedFloating.defaultExpectation.params = &BttMockSelectedFloatingParams{ctx}
	mmSelectedFloating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedFloating.expectations {
		if minimock.Equal(e.params, mmSelectedFloating.defaultExpectation.params) {
			mmSelectedFloating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedFloating.defaultExpectation.params)
		}
	}

	return mmSelectedFloating
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectedFloating
func (mmSelectedFloating *mBttMockSelectedFloating) ExpectCtxParam1(ctx context.Context) *mBttMockSelectedFloating {
	if mmSelectedFloating.mock.funcSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("BttMock.SelectedFloating mock is already set by Set")
	}

	if mmSelectedFloating.defaultExpectation == nil {
		mmSelectedFloating.defaultExpectation = &BttMockSelectedFloatingExpectation{}
	}

	if mmSelectedFloating.defaultExpectation.params != nil {
		mmSelectedFloating.mock.t.Fatalf("BttMock.SelectedFloating mock is already set by Expect")
	}

	if mmSelectedFloating.defaultExpectation.paramPtrs == nil {
		mmSelectedFloating.defaultExpectation.paramPtrs = &BttMockSelectedFloatingParamPtrs{}
	}
	mmSelectedFloating.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedFloating.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedFloating
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectedFloating
func (mmSelectedFloating *mBttMockSelectedFloating) Inspect(f func(ctx context.Context)) *mBttMockSelectedFloating {
	if mmSelectedFloating.mock.inspectFuncSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("Inspect function is already set for BttMock.SelectedFloating")
	}

	mmSelectedFloating.mock.inspectFuncSelectedFloating = f

	return mmSelectedFloating
}

// Return sets up results that will be returned by Btt.SelectedFloating
func (mmSelectedFloating *mBttMockSelectedFloating) Return(f1 Floating, err error) *BttMock {
	if mmSelectedFloating.mock.funcSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("BttMock.SelectedFloating mock is already set by Set")
	}

	if mmSelectedFloating.defaultExpectation == nil {
		mmSelectedFloating.defaultExpectation = &BttMockSelectedFloatingExpectation{mock: mmSelectedFloating.mock}
	}
	mmSelectedFloating.defaultExpectation.results = &BttMockSelectedFloatingResults{f1, err}
	mmSelectedFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedFloating.mock
}

// Set uses given function f to mock the Btt.SelectedFloating method
func (mmSelectedFloating *mBttMockSelectedFloating) Set(f func(ctx context.Context) (f1 Floating, err error)) *BttMock {
	if mmSelectedFloating.defaultExpectation != nil {
		mmSelectedFloating.mock.t.Fatalf("Default expectation is already set for the Btt.SelectedFloating method")
	}

	if len(mmSelectedFloating.expectations) > 0 {
		mmSelectedFloating.mock.t.Fatalf("Some expectations are already set for the Btt.SelectedFloating method")
	}

	mmSelectedFloating.mock.funcSelectedFloating = f
	mmSelectedFloating.mock.funcSelectedFloatingOrigin = minimock.CallerInfo(1)
	return mmSelectedFloating.mock
}

// When sets expectation for the Btt.SelectedFloating which will trigger the result defined by the following
// Then helper
func (mmSelectedFloating *mBttMockSelectedFloating) When(ctx context.Context) *BttMockSelectedFloatingExpectation {
	if mmSelectedFloating.mock.funcSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("BttMock.SelectedFloating mock is already set by Set")
	}

	expectation := &BttMockSelectedFloatingExpectation{
		mock:               mmSelectedFloating.mock,
		params:             &BttMockSelectedFloatingParams{ctx},
		expectationOrigins: BttMockSelectedFloatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedFloating.expectations = append(mmSelectedFloating.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectedFloating return parameters for the expectation previously defined by the When method
func (e *BttMockSelectedFloatingExpectation) Then(f1 Floating, err error) *BttMock {
	e.results = &BttMockSelectedFloatingResults{f1, err}
	return e.mock
}

// Times sets number of times Btt.SelectedFloating should be invoked
func (mmSelectedFloating *mBttMockSelectedFloating) Times(n uint64) *mBttMockSelectedFloating {
	if n == 0 {
		mmSelectedFloating.mock.t.Fatalf("Times of BttMock.SelectedFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedFloating.expectedInvocations, n)
	mmSelectedFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedFloating
}

func (mmSelectedFloating *mBttMockSelectedFloating) invocationsDone() bool {
	if len(mmSelectedFloating.expectations) == 0 && mmSelectedFloating.defaultExpectation == nil && mmSelectedFloating.mock.funcSelectedFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedFloating.mock.afterSelectedFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedFloating implements Btt
func (mmSelectedFloating *BttMock) SelectedFloating(ctx context.Context) (f1 Floating, err error) {
	mm_atomic.AddUint64(&mmSelectedFloating.beforeSelectedFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedFloating.afterSelectedFloatingCounter, 1)

	mmSelectedFloating.t.Helper()

	if mmSelectedFloating.inspectFuncSelectedFloating != nil {
		mmSelectedFloating.inspectFuncSelectedFloating(ctx)
	}

	mm_params := BttMockSelectedFloatingParams{ctx}

	// Record call args
	mmSelectedFloating.SelectedFloatingMock.mutex.Lock()
	mmSelectedFloating.SelectedFloatingMock.callArgs = append(mmSelectedFloating.SelectedFloatingMock.callArgs, &mm_params)
	mmSelectedFloating.SelectedFloatingMock.mutex.Unlock()

	for _, e := range mmSelectedFloating.SelectedFloatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmSelectedFloating.SelectedFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedFloating.SelectedFloatingMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedFloating.SelectedFloatingMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedFloating.SelectedFloatingMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectedFloatingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedFloating.t.Errorf("BttMock.SelectedFloating got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedFloating.SelectedFloatingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedFloating.t.Errorf("BttMock.SelectedFloating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedFloating.SelectedFloatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedFloating.SelectedFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedFloating.t.Fatal("No results are set for the BttMock.SelectedFloating")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmSelectedFloating.funcSelectedFloating != nil {
		return mmSelectedFloating.funcSelectedFloating(ctx)
	}
	mmSelectedFloating.t.Fatalf("Unexpected call to BttMock.SelectedFloating. %v", ctx)
	return
}

// SelectedFloatingAfterCounter returns a count of finished BttMock.SelectedFloating invocations
func (mmSelectedFloating *BttMock) SelectedFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedFloating.afterSelectedFloatingCounter)
}

// SelectedFloatingBeforeCounter returns a count of BttMock.SelectedFloating invocations
func (mmSelectedFloating *BttMock) SelectedFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedFloating.beforeSelectedFloatingCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectedFloating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedFloating *mBttMockSelectedFloating) Calls() []*BttMockSelectedFloatingParams {
	mmSelectedFloating.mutex.RLock()

	argCopy := make([]*BttMockSelectedFloatingParams, len(mmSelectedFloating.callArgs))
	copy(argCopy, mmSelectedFloating.callArgs)

	mmSelectedFloating.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedFloatingDone returns true if the count of the SelectedFloating invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectedFloatingDone() bool {
	if m.SelectedFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedFloatingMock.invocationsDone()
}

// MinimockSelectedFloatingInspect logs each unmet expectation
func (m *BttMock) MinimockSelectedFloatingInspect() {
	for _, e := range m.SelectedFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectedFloating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedFloatingCounter := mm_atomic.LoadUint64(&m.afterSelectedFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedFloatingMock.defaultExpectation != nil && afterSelectedFloatingCounter < 1 {
		if m.SelectedFloatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectedFloating at\n%s", m.SelectedFloatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectedFloating at\n%s with params: %#v", m.SelectedFloatingMock.defaultExpectation.expectationOrigins.origin, *m.SelectedFloatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedFloating != nil && afterSelectedFloatingCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectedFloating at\n%s", m.funcSelectedFloatingOrigin)
	}

	if !m.SelectedFloatingMock.invocationsDone() && afterSelectedFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectedFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedFloatingMock.expectedInvocations), m.SelectedFloatingMock.expectedInvocationsOrigin, afterSelectedFloatingCounter)
	}
}

type mBttMockSelectedLanguage struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectedLanguageExpectation
	expectations       []*BttMockSelectedLanguageExpectation

	callArgs []*BttMockSelectedLanguageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectedLanguageExpectation specifies expectation struct of the Btt.SelectedLanguage
type BttMockSelectedLanguageExpectation struct {
	mock               *BttMock
	params             *BttMockSelectedLanguageParams
	paramPtrs          *BttMockSelectedLanguageParamPtrs
	expectationOrigins BttMockSelectedLanguageExpectationOrigins
	results            *BttMockSelectedLanguageResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectedLanguageParams contains parameters of the Btt.SelectedLanguage
type BttMockSelectedLanguageParams struct {
	ctx context.Context
}

// BttMockSelectedLanguageParamPtrs contains pointers to parameters of the Btt.SelectedLanguage
type BttMockSelectedLanguageParamPtrs struct {
	ctx *context.Context
}

// BttMockSelectedLanguageResults contains results of the Btt.SelectedLanguage
type BttMockSelectedLanguageResults struct {
	s1  string
	err error
}

// BttMockSelectedLanguageOrigins contains origins of expectations of the Btt.SelectedLanguage
type BttMockSelectedLanguageExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedLanguage *mBttMockSelectedLanguage) Optional() *mBttMockSelectedLanguage {
	mmSelectedLanguage.optional = true
	return mmSelectedLanguage
}

// Expect sets up expected params for Btt.SelectedLanguage
func (mmSelectedLanguage *mBttMockSelectedLanguage) Expect(ctx context.Context) *mBttMockSelectedLanguage {
	if mmSelectedLanguage.mock.funcSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("BttMock.SelectedLanguage mock is already set by Set")
	}

	if mmSelectedLanguage.defaultExpectation == nil {
		mmSelectedLanguage.defaultExpectation = &BttMockSelectedLanguageExpectation{}
	}

	if mmSelectedLanguage.defaultExpectation.paramPtrs != nil {
		mmSelectedLanguage.mock.t.Fatalf("BttMock.SelectedLanguage mock is already set by ExpectParams functions")
	}

	mmSelectedLanguage.defaultExpectation.params = &BttMockSelectedLanguageParams{ctx}
	mmSelectedLanguage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedLanguage.expectations {
		if minimock.Equal(e.params, mmSelectedLanguage.defaultExpectation.params) {
			mmSelectedLanguage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedLanguage.defaultExpectation.params)
		}
	}

	return mmSelectedLanguage
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectedLanguage
func (mmSelectedLanguage *mBttMockSelectedLanguage) ExpectCtxParam1(ctx context.Context) *mBttMockSelectedLanguage {
	if mmSelectedLanguage.mock.funcSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("BttMock.SelectedLanguage mock is already set by Set")
	}

	if mmSelectedLanguage.defaultExpectation == nil {
		mmSelectedLanguage.defaultExpectation = &BttMockSelectedLanguageExpectation{}
	}

	if mmSelectedLanguage.defaultExpectation.params != nil {
		mmSelectedLanguage.mock.t.Fatalf("BttMock.SelectedLanguage mock is already set by Expect")
	}

	if mmSelectedLanguage.defaultExpectation.paramPtrs == nil {
		mmSelectedLanguage.defaultExpectation.paramPtrs = &BttMockSelectedLanguageParamPtrs{}
	}
	mmSelectedLanguage.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedLanguage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedLanguage
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectedLanguage
func (mmSelectedLanguage *mBttMockSelectedLanguage) Inspect(f func(ctx context.Context)) *mBttMockSelectedLanguage {
	if mmSelectedLanguage.mock.inspectFuncSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("Inspect function is already set for BttMock.SelectedLanguage")
	}

	mmSelectedLanguage.mock.inspectFuncSelectedLanguage = f

	return mmSelectedLanguage
}

// Return sets up results that will be returned by Btt.SelectedLanguage
func (mmSelectedLanguage *mBttMockSelectedLanguage) Return(s1 string, err error) *BttMock {
	if mmSelectedLanguage.mock.funcSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("BttMock.SelectedLanguage mock is already set by Set")
	}

	if mmSelectedLanguage.defaultExpectation == nil {
		mmSelectedLanguage.defaultExpectation = &BttMockSelectedLanguageExpectation{mock: mmSelectedLanguage.mock}
	}
	mmSelectedLanguage.defaultExpectation.results = &BttMockSelectedLanguageResults{s1, err}
	mmSelectedLanguage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedLanguage.mock
}

// Set uses given function f to mock the Btt.SelectedLanguage method
func (mmSelectedLanguage *mBttMockSelectedLanguage) Set(f func(ctx context.Context) (s1 string, err error)) *BttMock {
	if mmSelectedLanguage.defaultExpectation != nil {
		mmSelectedLanguage.mock.t.Fatalf("Default expectation is already set for the Btt.SelectedLanguage method")
	}

	if len(mmSelectedLanguage.expectations) > 0 {
		mmSelectedLanguage.mock.t.Fatalf("Some expectations are already set for the Btt.SelectedLanguage method")
	}

	mmSelectedLanguage.mock.funcSelectedLanguage = f
	mmSelectedLanguage.mock.funcSelectedLanguageOrigin = minimock.CallerInfo(1)
	return mmSelectedLanguage.mock
}

// When sets expectation for the Btt.SelectedLanguage which will trigger the result defined by the following
// Then helper
func (mmSelectedLanguage *mBttMockSelectedLanguage) When(ctx context.Context) *BttMockSelectedLanguageExpectation {
	if mmSelectedLanguage.mock.funcSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("BttMock.SelectedLanguage mock is already set by Set")
	}

	expectation := &BttMockSelectedLanguageExpectation{
		mock:               mmSelectedLanguage.mock,
		params:             &BttMockSelectedLanguageParams{ctx},
		expectationOrigins: BttMockSelectedLanguageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedLanguage.expectations = append(mmSelectedLanguage.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectedLanguage return parameters for the expectation previously defined by the When method
func (e *BttMockSelectedLanguageExpectation) Then(s1 string, err error) *BttMock {
	e.results = &BttMockSelectedLanguageResults{s1, err}
	return e.mock
}

// Times sets number of times Btt.SelectedLanguage should be invoked
func (mmSelectedLanguage *mBttMockSelectedLanguage) Times(n uint64) *mBttMockSelectedLanguage {
	if n == 0 {
		mmSelectedLanguage.mock.t.Fatalf("Times of BttMock.SelectedLanguage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedLanguage.expectedInvocations, n)
	mmSelectedLanguage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedLanguage
}

func (mmSelectedLanguage *mBttMockSelectedLanguage) invocationsDone() bool {
	if len(mmSelectedLanguage.expectations) == 0 && mmSelectedLanguage.defaultExpectation == nil && mmSelectedLanguage.mock.funcSelectedLanguage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedLanguage.mock.afterSelectedLanguageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedLanguage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedLanguage implements Btt
func (mmSelectedLanguage *BttMock) SelectedLanguage(ctx context.Context) (s1 string, err error) {
	mm_atomic.AddUint64(&mmSelectedLanguage.beforeSelectedLanguageCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedLanguage.afterSelectedLanguageCounter, 1)

	mmSelectedLanguage.t.Helper()

	if mmSelectedLanguage.inspectFuncSelectedLanguage != nil {
		mmSelectedLanguage.inspectFuncSelectedLanguage(ctx)
	}

	mm_params := BttMockSelectedLanguageParams{ctx}

	// Record call args
	mmSelectedLanguage.SelectedLanguageMock.mutex.Lock()
	mmSelectedLanguage.SelectedLanguageMock.callArgs = append(mmSelectedLanguage.SelectedLanguageMock.callArgs, &mm_params)
	mmSelectedLanguage.SelectedLanguageMock.mutex.Unlock()

	for _, e := range mmSelectedLanguage.SelectedLanguageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmSelectedLanguage.SelectedLanguageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectedLanguageParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedLanguage.t.Errorf("BttMock.SelectedLanguage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedLanguage.t.Errorf("BttMock.SelectedLanguage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedLanguage.t.Fatal("No results are set for the BttMock.SelectedLanguage")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmSelectedLanguage.funcSelectedLanguage != nil {
		return mmSelectedLanguage.funcSelectedLanguage(ctx)
	}
	mmSelectedLanguage.t.Fatalf("Unexpected call to BttMock.SelectedLanguage. %v", ctx)
	return
}

// SelectedLanguageAfterCounter returns a count of finished BttMock.SelectedLanguage invocations
func (mmSelectedLanguage *BttMock) SelectedLanguageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedLanguage.afterSelectedLanguageCounter)
}

// SelectedLanguageBeforeCounter returns a count of BttMock.SelectedLanguage invocations
func (mmSelectedLanguage *BttMock) SelectedLanguageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedLanguage.beforeSelectedLanguageCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectedLanguage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedLanguage *mBttMockSelectedLanguage) Calls() []*BttMockSelectedLanguageParams {
	mmSelectedLanguage.mutex.RLock()

	argCopy := make([]*BttMockSelectedLanguageParams, len(mmSelectedLanguage.callArgs))
	copy(argCopy, mmSelectedLanguage.callArgs)

	mmSelectedLanguage.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedLanguageDone returns true if the count of the SelectedLanguage invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectedLanguageDone() bool {
	if m.SelectedLanguageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedLanguageMock.invocationsDone()
}

// MinimockSelectedLanguageInspect logs each unmet expectation
func (m *BttMock) MinimockSelectedLanguageInspect() {
	for _, e := range m.SelectedLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectedLanguage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedLanguageCounter := mm_atomic.LoadUint64(&m.afterSelectedLanguageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedLanguageMock.defaultExpectation != nil && afterSelectedLanguageCounter < 1 {
		if m.SelectedLanguageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectedLanguage at\n%s", m.SelectedLanguageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectedLanguage at\n%s with params: %#v", m.SelectedLanguageMock.defaultExpectation.expectationOrigins.origin, *m.SelectedLanguageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedLanguage != nil && afterSelectedLanguageCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectedLanguage at\n%s", m.funcSelectedLanguageOrigin)
	}

	if !m.SelectedLanguageMock.invocationsDone() && afterSelectedLanguageCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectedLanguage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedLanguageMock.expectedInvocations), m.SelectedLanguageMock.expectedInvocationsOrigin, afterSelectedLanguageCounter)
	}
}

type mBttMockSelectedViewMode struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectedViewModeExpectation
	expectations       []*BttMockSelectedViewModeExpectation

	callArgs []*BttMockSelectedViewModeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectedViewModeExpectation specifies expectation struct of the Btt.SelectedViewMode
type BttMockSelectedViewModeExpectation struct {
	mock               *BttMock
	params             *BttMockSelectedViewModeParams
	paramPtrs          *BttMockSelectedViewModeParamPtrs
	expectationOrigins BttMockSelectedViewModeExpectationOrigins
	results            *BttMockSelectedViewModeResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectedViewModeParams contains parameters of the Btt.SelectedViewMode
type BttMockSelectedViewModeParams struct {
	ctx context.Context
}

// BttMockSelectedViewModeParamPtrs contains pointers to parameters of the Btt.SelectedViewMode
type BttMockSelectedViewModeParamPtrs struct {
	ctx *context.Context
}

// BttMockSelectedViewModeResults contains results of the Btt.SelectedViewMode
type BttMockSelectedViewModeResults struct {
	v1  ViewMode
	err error
}

// BttMockSelectedViewModeOrigins contains origins of expectations of the Btt.SelectedViewMode
type BttMockSelectedViewModeExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedViewMode *mBttMockSelectedViewMode) Optional() *mBttMockSelectedViewMode {
	mmSelectedViewMode.optional = true
	return mmSelectedViewMode
}

// Expect sets up expected params for Btt.SelectedViewMode
func (mmSelectedViewMode *mBttMockSelectedViewMode) Expect(ctx context.Context) *mBttMockSelectedViewMode {
	if mmSelectedViewMode.mock.funcSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("BttMock.SelectedViewMode mock is already set by Set")
	}

	if mmSelectedViewMode.defaultExpectation == nil {
		mmSelectedViewMode.defaultExpectation = &BttMockSelectedViewModeExpectation{}
	}

	if mmSelectedViewMode.defaultExpectation.paramPtrs != nil {
		mmSelectedViewMode.mock.t.Fatalf("BttMock.SelectedViewMode mock is already set by ExpectParams functions")
	}

	mmSelectedViewMode.defaultExpectation.params = &BttMockSelectedViewModeParams{ctx}
	mmSelectedViewMode.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedViewMode.expectations {
		if minimock.Equal(e.params, mmSelectedViewMode.defaultExpectation.params) {
			mmSelectedViewMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedViewMode.defaultExpectation.params)
		}
	}

	return mmSelectedViewMode
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectedViewMode
func (mmSelectedViewMode *mBttMockSelectedViewMode) ExpectCtxParam1(ctx context.Context) *mBttMockSelectedViewMode {
	if mmSelectedViewMode.mock.funcSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("BttMock.SelectedViewMode mock is already set by Set")
	}

	if mmSelectedViewMode.defaultExpectation == nil {
		mmSelectedViewMode.defaultExpectation = &BttMockSelectedViewModeExpectation{}
	}

	if mmSelectedViewMode.defaultExpectation.params != nil {
		mmSelectedViewMode.mock.t.Fatalf("BttMock.SelectedViewMode mock is already set by Expect")
	}

	if mmSelectedViewMode.defaultExpectation.paramPtrs == nil {
		mmSelectedViewMode.defaultExpectation.paramPtrs = &BttMockSelectedViewModeParamPtrs{}
	}
	mmSelectedViewMode.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedViewMode.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedViewMode
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectedViewMode
func (mmSelectedViewMode *mBttMockSelectedViewMode) Inspect(f func(ctx context.Context)) *mBttMockSelectedViewMode {
	if mmSelectedViewMode.mock.inspectFuncSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("Inspect function is already set for BttMock.SelectedViewMode")
	}

	mmSelectedViewMode.mock.inspectFuncSelectedViewMode = f

	return mmSelectedViewMode
}

// Return sets up results that will be returned by Btt.SelectedViewMode
func (mmSelectedViewMode *mBttMockSelectedViewMode) Return(v1 ViewMode, err error) *BttMock {
	if mmSelectedViewMode.mock.funcSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("BttMock.SelectedViewMode mock is already set by Set")
	}

	if mmSelectedViewMode.defaultExpectation == nil {
		mmSelectedViewMode.defaultExpectation = &BttMockSelectedViewModeExpectation{mock: mmSelectedViewMode.mock}
	}
	mmSelectedViewMode.defaultExpectation.results = &BttMockSelectedViewModeResults{v1, err}
	mmSelectedViewMode.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedViewMode.mock
}

// Set uses given function f to mock the Btt.SelectedViewMode method
func (mmSelectedViewMode *mBttMockSelectedViewMode) Set(f func(ctx context.Context) (v1 ViewMode, err error)) *BttMock {
	if mmSelectedViewMode.defaultExpectation != nil {
		mmSelectedViewMode.mock.t.Fatalf("Default expectation is already set for the Btt.SelectedViewMode method")
	}

	if len(mmSelectedViewMode.expectations) > 0 {
		mmSelectedViewMode.mock.t.Fatalf("Some expectations are already set for the Btt.SelectedViewMode method")
	}

	mmSelectedViewMode.mock.funcSelectedViewMode = f
	mmSelectedViewMode.mock.funcSelectedViewModeOrigin = minimock.CallerInfo(1)
	return mmSelectedViewMode.mock
}

// When sets expectation for the Btt.SelectedViewMode which will trigger the result defined by the following
// Then helper
func (mmSelectedViewMode *mBttMockSelectedViewMode) When(ctx context.Context) *BttMockSelectedViewModeExpectation {
	if mmSelectedViewMode.mock.funcSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("BttMock.SelectedViewMode mock is already set by Set")
	}

	expectation := &BttMockSelectedViewModeExpectation{
		mock:               mmSelectedViewMode.mock,
		params:             &BttMockSelectedViewModeParams{ctx},
		expectationOrigins: BttMockSelectedViewModeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedViewMode.expectations = append(mmSelectedViewMode.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectedViewMode return parameters for the expectation previously defined by the When method
func (e *BttMockSelectedViewModeExpectation) Then(v1 ViewMode, err error) *BttMock {
	e.results = &BttMockSelectedViewModeResults{v1, err}
	return e.mock
}

// Times sets number of times Btt.SelectedViewMode should be invoked
func (mmSelectedViewMode *mBttMockSelectedViewMode) Times(n uint64) *mBttMockSelectedViewMode {
	if n == 0 {
		mmSelectedViewMode.mock.t.Fatalf("Times of BttMock.SelectedViewMode mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedViewMode.expectedInvocations, n)
	mmSelectedViewMode.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedViewMode
}

func (mmSelectedViewMode *mBttMockSelectedViewMode) invocationsDone() bool {
	if len(mmSelectedViewMode.expectations) == 0 && mmSelectedViewMode.defaultExpectation == nil && mmSelectedViewMode.mock.funcSelectedViewMode == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedViewMode.mock.afterSelectedViewModeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedViewMode.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedViewMode implements Btt
func (mmSelectedViewMode *BttMock) SelectedViewMode(ctx context.Context) (v1 ViewMode, err error) {
	mm_atomic.AddUint64(&mmSelectedViewMode.beforeSelectedViewModeCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedViewMode.afterSelectedViewModeCounter, 1)

	mmSelectedViewMode.t.Helper()

	if mmSelectedViewMode.inspectFuncSelectedViewMode != nil {
		mmSelectedViewMode.inspectFuncSelectedViewMode(ctx)
	}

	mm_params := BttMockSelectedViewModeParams{ctx}

	// Record call args
	mmSelectedViewMode.SelectedViewModeMock.mutex.Lock()
	mmSelectedViewMode.SelectedViewModeMock.callArgs = append(mmSelectedViewMode.SelectedViewModeMock.callArgs, &mm_params)
	mmSelectedViewMode.SelectedViewModeMock.mutex.Unlock()

	for _, e := range mmSelectedViewMode.SelectedViewModeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.v1, e.results.err
		}
	}

	if mmSelectedViewMode.SelectedViewModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectedViewModeParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedViewMode.t.Errorf("BttMock.SelectedViewMode got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedViewMode.t.Errorf("BttMock.SelectedViewMode got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedViewMode.t.Fatal("No results are set for the BttMock.SelectedViewMode")
		}
		return (*mm_results).v1, (*mm_results).err
	}
	if mmSelectedViewMode.funcSelectedViewMode != nil {
		return mmSelectedViewMode.funcSelectedViewMode(ctx)
	}
	mmSelectedViewMode.t.Fatalf("Unexpected call to BttMock.SelectedViewMode. %v", ctx)
	return
}

// SelectedViewModeAfterCounter returns a count of finished BttMock.SelectedViewMode invocations
func (mmSelectedViewMode *BttMock) SelectedViewModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedViewMode.afterSelectedViewModeCounter)
}

// SelectedViewModeBeforeCounter returns a count of BttMock.SelectedViewMode invocations
func (mmSelectedViewMode *BttMock) SelectedViewModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedViewMode.beforeSelectedViewModeCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectedViewMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedViewMode *mBttMockSelectedViewMode) Calls() []*BttMockSelectedViewModeParams {
	mmSelectedViewMode.mutex.RLock()

	argCopy := make([]*BttMockSelectedViewModeParams, len(mmSelectedViewMode.callArgs))
	copy(argCopy, mmSelectedViewMode.callArgs)

	mmSelectedViewMode.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedViewModeDone returns true if the count of the SelectedViewMode invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectedViewModeDone() bool {
	if m.SelectedViewModeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedViewModeMock.invocationsDone()
}

// MinimockSelectedViewModeInspect logs each unmet expectation
func (m *BttMock) MinimockSelectedViewModeInspect() {
	for _, e := range m.SelectedViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectedViewMode at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedViewModeCounter := mm_atomic.LoadUint64(&m.afterSelectedViewModeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedViewModeMock.defaultExpectation != nil && afterSelectedViewModeCounter < 1 {
		if m.SelectedViewModeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectedViewMode at\n%s", m.SelectedViewModeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectedViewMode at\n%s with params: %#v", m.SelectedViewModeMock.defaultExpectation.expectationOrigins.origin, *m.SelectedViewModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedViewMode != nil && afterSelectedViewModeCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectedViewMode at\n%s", m.funcSelectedViewModeOrigin)
	}

	if !m.SelectedViewModeMock.invocationsDone() && afterSelectedViewModeCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectedViewMode at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedViewModeMock.expectedInvocations), m.SelectedViewModeMock.expectedInvocationsOrigin, afterSelectedViewModeCounter)
	}
}

type mBttMockShowClipboard struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockShowClipboardExpectation
	expectations       []*BttMockShowClipboardExpectation

	callArgs []*BttMockShowClipboardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockShowClipboardExpectation specifies expectation struct of the Btt.ShowClipboard
type BttMockShowClipboardExpectation struct {
	mock               *BttMock
	params             *BttMockShowClipboardParams
	paramPtrs          *BttMockShowClipboardParamPtrs
	expectationOrigins BttMockShowClipboardExpectationOrigins
	results            *BttMockShowClipboardResults
	returnOrigin       string
	Counter            uint64
}

// BttMockShowClipboardParams contains parameters of the Btt.ShowClipboard
type BttMockShowClipboardParams struct {
	ctx context.Context
}

// BttMockShowClipboardParamPtrs contains pointers to parameters of the Btt.ShowClipboard
type BttMockShowClipboardParamPtrs struct {
	ctx *context.Context
}

// BttMockShowClipboardResults contains results of the Btt.ShowClipboard
type BttMockShowClipboardResults struct {
	err error
}

// BttMockShowClipboardOrigins contains origins of expectations of the Btt.ShowClipboard
type BttMockShowClipboardExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmShowClipboard *mBttMockShowClipboard) Optional() *mBttMockShowClipboard {
	mmShowClipboard.optional = true
	return mmShowClipboard
}

// Expect sets up expected params for Btt.ShowClipboard
func (mmShowClipboard *mBttMockShowClipboard) Expect(ctx context.Context) *mBttMockShowClipboard {
	if mmShowClipboard.mock.funcShowClipboard != nil {
		mmShowClipboard.mock.t.Fatalf("BttMock.ShowClipboard mock is already set by Set")
	}

	if mmShowClipboard.defaultExpectation == nil {
		mmShowClipboard.defaultExpectation = &BttMockShowClipboardExpectation{}
	}

	if mmShowClipboard.defaultExpectation.paramPtrs != nil {
		mmShowClipboard.mock.t.Fatalf("BttMock.ShowClipboard mock is already set by ExpectParams functions")
	}

	mmShowClipboard.defaultExpectation.params = &BttMockShowClipboardParams{ctx}
	mmShowClipboard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmShowClipboard.expectations {
		if minimock.Equal(e.params, mmShowClipboard.defaultExpectation.params) {
			mmShowClipboard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmShowClipboard.defaultExpectation.params)
		}
	}

	return mmShowClipboard
}

// ExpectCtxParam1 sets up expected param ctx for Btt.ShowClipboard
func (mmShowClipboard *mBttMockShowClipboard) ExpectCtxParam1(ctx context.Context) *mBttMockShowClipboard {
	if mmShowClipboard.mock.funcShowClipboard != nil {
		mmShowClipboard.mock.t.Fatalf("BttMock.ShowClipboard mock is already set by Set")
	}

	if mmShowClipboard.defaultExpectation == nil {
		mmShowClipboard.defaultExpectation = &BttMockShowClipboardExpectation{}
	}

	if mmShowClipboard.defaultExpectation.params != nil {
		mmShowClipboard.mock.t.Fatalf("BttMock.ShowClipboard mock is already set by Expect")
	}

	if mmShowClipboard.defaultExpectation.paramPtrs == nil {
		mmShowClipboard.defaultExpectation.paramPtrs = &BttMockShowClipboardParamPtrs{}
	}
	mmShowClipboard.defaultExpectation.paramPtrs.ctx = &ctx
	mmShowClipboard.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmShowClipboard
}

// Inspect accepts an inspector function that has same arguments as the Btt.ShowClipboard
func (mmShowClipboard *mBttMockShowClipboard) Inspect(f func(ctx context.Context)) *mBttMockShowClipboard {
	if mmShowClipboard.mock.inspectFuncShowClipboard != nil {
		mmShowClipboard.mock.t.Fatalf("Inspect function is already set for BttMock.ShowClipboard")
	}

	mmShowClipboard.mock.inspectFuncShowClipboard = f

	return mmShowClipboard
}

// Return sets up results that will be returned by Btt.ShowClipboard
func (mmShowClipboard *mBttMockShowClipboard) Return(err error) *BttMock {
	if mmShowClipboard.mock.funcShowClipboard != nil {
		mmShowClipboard.mock.t.Fatalf("BttMock.ShowClipboard mock is already set by Set")
	}

	if mmShowClipboard.defaultExpectation == nil {
		mmShowClipboard.defaultExpectation = &BttMockShowClipboardExpectation{mock: mmShowClipboard.mock}
	}
	mmShowClipboard.defaultExpectation.results = &BttMockShowClipboardResults{err}
	mmShowClipboard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmShowClipboard.mock
}

// Set uses given function f to mock the Btt.ShowClipboard method
func (mmShowClipboard *mBttMockShowClipboard) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmShowClipboard.defaultExpectation != nil {
		mmShowClipboard.mock.t.Fatalf("Default expectation is already set for the Btt.ShowClipboard method")
	}

	if len(mmShowClipboard.expectations) > 0 {
		mmShowClipboard.mock.t.Fatalf("Some expectations are already set for the Btt.ShowClipboard method")
	}

	mmShowClipboard.mock.funcShowClipboard = f
	mmShowClipboard.mock.funcShowClipboardOrigin = minimock.CallerInfo(1)
	return mmShowClipboard.mock
}

// When sets expectation for the Btt.ShowClipboard which will trigger the result defined by the following
// Then helper
func (mmShowClipboard *mBttMockShowClipboard) When(ctx context.Context) *BttMockShowClipboardExpectation {
	if mmShowClipboard.mock.funcShowClipboard != nil {
		mmShowClipboard.mock.t.Fatalf("BttMock.ShowClipboard mock is already set by Set")
	}

	expectation := &BttMockShowClipboardExpectation{
		mock:               mmShowClipboard.mock,
		params:             &BttMockShowClipboardParams{ctx},
		expectationOrigins: BttMockShowClipboardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmShowClipboard.expectations = append(mmShowClipboard.expectations, expectation)
	return expectation
}

// Then sets up Btt.ShowClipboard return parameters for the expectation previously defined by the When method
func (e *BttMockShowClipboardExpectation) Then(err error) *BttMock {
	e.results = &BttMockShowClipboardResults{err}
	return e.mock
}

// Times sets number of times Btt.ShowClipboard should be invoked
func (mmShowClipboard *mBttMockShowClipboard) Times(n uint64) *mBttMockShowClipboard {
	if n == 0 {
		mmShowClipboard.mock.t.Fatalf("Times of BttMock.ShowClipboard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmShowClipboard.expectedInvocations, n)
	mmShowClipboard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmShowClipboard
}

func (mmShowClipboard *mBttMockShowClipboard) invocationsDone() bool {
	if len(mmShowClipboard.expectations) == 0 && mmShowClipboard.defaultExpectation == nil && mmShowClipboard.mock.funcShowClipboard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmShowClipboard.mock.afterShowClipboardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmShowClipboard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ShowClipboard implements Btt
func (mmShowClipboard *BttMock) ShowClipboard(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmShowClipboard.beforeShowClipboardCounter, 1)
	defer mm_atomic.AddUint64(&mmShowClipboard.afterShowClipboardCounter, 1)

	mmShowClipboard.t.Helper()

	if mmShowClipboard.inspectFuncShowClipboard != nil {
		mmShowClipboard.inspectFuncShowClipboard(ctx)
	}

	mm_params := BttMockShowClipboardParams{ctx}

	// Record call args
	mmShowClipboard.ShowClipboardMock.mutex.Lock()
	mmShowClipboard.ShowClipboardMock.callArgs = append(mmShowClipboard.ShowClipboardMock.callArgs, &mm_params)
	mmShowClipboard.ShowClipboardMock.mutex.Unlock()

	for _, e := range mmShowClipboard.ShowClipboardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmShowClipboard.ShowClipboardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShowClipboard.ShowClipboardMock.defaultExpectation.Counter, 1)
		mm_want := mmShowClipboard.ShowClipboardMock.defaultExpectation.params
		mm_want_ptrs := mmShowClipboard.ShowClipboardMock.defaultExpectation.paramPtrs

		mm_got := BttMockShowClipboardParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmShowClipboard.t.Errorf("BttMock.ShowClipboard got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmShowClipboard.ShowClipboardMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmShowClipboard.t.Errorf("BttMock.ShowClipboard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmShowClipboard.ShowClipboardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmShowClipboard.ShowClipboardMock.defaultExpectation.results
		if mm_results == nil {
			mmShowClipboard.t.Fatal("No results are set for the BttMock.ShowClipboard")
		}
		return (*mm_results).err
	}
	if mmShowClipboard.funcShowClipboard != nil {
		return mmShowClipboard.funcShowClipboard(ctx)
	}
	mmShowClipboard.t.Fatalf("Unexpected call to BttMock.ShowClipboard. %v", ctx)
	return
}

// ShowClipboardAfterCounter returns a count of finished BttMock.ShowClipboard invocations
func (mmShowClipboard *BttMock) ShowClipboardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShowClipboard.afterShowClipboardCounter)
}

// ShowClipboardBeforeCounter returns a count of BttMock.ShowClipboard invocations
func (mmShowClipboard *BttMock) ShowClipboardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShowClipboard.beforeShowClipboardCounter)
}

// Calls returns a list of arguments used in each call to BttMock.ShowClipboard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmShowClipboard *mBttMockShowClipboard) Calls() []*BttMockShowClipboardParams {
	mmShowClipboard.mutex.RLock()

	argCopy := make([]*BttMockShowClipboardParams, len(mmShowClipboard.callArgs))
	copy(argCopy, mmShowClipboard.callArgs)

	mmShowClipboard.mutex.RUnlock()

	return argCopy
}

// MinimockShowClipboardDone returns true if the count of the ShowClipboard invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockShowClipboardDone() bool {
	if m.ShowClipboardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ShowClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ShowClipboardMock.invocationsDone()
}

// MinimockShowClipboardInspect logs each unmet expectation
func (m *BttMock) MinimockShowClipboardInspect() {
	for _, e := range m.ShowClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.ShowClipboard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterShowClipboardCounter := mm_atomic.LoadUint64(&m.afterShowClipboardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ShowClipboardMock.defaultExpectation != nil && afterShowClipboardCounter < 1 {
		if m.ShowClipboardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.ShowClipboard at\n%s", m.ShowClipboardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.ShowClipboard at\n%s with params: %#v", m.ShowClipboardMock.defaultExpectation.expectationOrigins.origin, *m.ShowClipboardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShowClipboard != nil && afterShowClipboardCounter < 1 {
		m.t.Errorf("Expected call to BttMock.ShowClipboard at\n%s", m.funcShowClipboardOrigin)
	}

	if !m.ShowClipboardMock.invocationsDone() && afterShowClipboardCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.ShowClipboard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ShowClipboardMock.expectedInvocations), m.ShowClipboardMock.expectedInvocationsOrigin, afterShowClipboardCounter)
	}
}

type mBttMockShowFloating struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockShowFloatingExpectation
	expectations       []*BttMockShowFloatingExpectation

	callArgs []*BttMockShowFloatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockShowFloatingExpectation specifies expectation struct of the Btt.ShowFloating
type BttMockShowFloatingExpectation struct {
	mock               *BttMock
	params             *BttMockShowFloatingParams
	paramPtrs          *BttMockShowFloatingParamPtrs
	expectationOrigins BttMockShowFloatingExpectationOrigins
	results            *BttMockShowFloatingResults
	returnOrigin       string
	Counter            uint64
}

// BttMockShowFloatingParams contains parameters of the Btt.ShowFloating
type BttMockShowFloatingParams struct {
	ctx context.Context
}

// BttMockShowFloatingParamPtrs contains pointers to parameters of the Btt.ShowFloating
type BttMockShowFloatingParamPtrs struct {
	ctx *context.Context
}

// BttMockShowFloatingResults contains results of the Btt.ShowFloating
type BttMockShowFloatingResults struct {
	err error
}

// BttMockShowFloatingOrigins contains origins of expectations of the Btt.ShowFloating
type BttMockShowFloatingExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmShowFloating *mBttMockShowFloating) Optional() *mBttMockShowFloating {
	mmShowFloating.optional = true
	return mmShowFloating
}

// Expect sets up expected params for Btt.ShowFloating
func (mmShowFloating *mBttMockShowFloating) Expect(ctx context.Context) *mBttMockShowFloating {
	if mmShowFloating.mock.funcShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("BttMock.ShowFloating mock is already set by Set")
	}

	if mmShowFloating.defaultExpectation == nil {
		mmShowFloating.defaultExpectation = &BttMockShowFloatingExpectation{}
	}

	if mmShowFloating.defaultExpectation.paramPtrs != nil {
		mmShowFloating.mock.t.Fatalf("BttMock.ShowFloating mock is already set by ExpectParams functions")
	}

	mmShowFloating.defaultExpectation.params = &BttMockShowFloatingParams{ctx}
	mmShowFloating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmShowFloating.expectations {
		if minimock.Equal(e.params, mmShowFloating.defaultExpectation.params) {
			mmShowFloating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmShowFloating.defaultExpectation.params)
		}
	}

	return mmShowFloating
}

// ExpectCtxParam1 sets up expected param ctx for Btt.ShowFloating
func (mmShowFloating *mBttMockShowFloating) ExpectCtxParam1(ctx context.Context) *mBttMockShowFloating {
	if mmShowFloating.mock.funcShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("BttMock.ShowFloating mock is already set by Set")
	}

	if mmShowFloating.defaultExpectation == nil {
		mmShowFloating.defaultExpectation = &BttMockShowFloatingExpectation{}
	}

	if mmShowFloating.defaultExpectation.params != nil {
		mmShowFloating.mock.t.Fatalf("BttMock.ShowFloating mock is already set by Expect")
	}

	if mmShowFloating.defaultExpectation.paramPtrs == nil {
		mmShowFloating.defaultExpectation.paramPtrs = &BttMockShowFloatingParamPtrs{}
	}
	mmShowFloating.defaultExpectation.paramPtrs.ctx = &ctx
	mmShowFloating.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmShowFloating
}

// Inspect accepts an inspector function that has same arguments as the Btt.ShowFloating
func (mmShowFloating *mBttMockShowFloating) Inspect(f func(ctx context.Context)) *mBttMockShowFloating {
	if mmShowFloating.mock.inspectFuncShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("Inspect function is already set for BttMock.ShowFloating")
	}

	mmShowFloating.mock.inspectFuncShowFloating = f

	return mmShowFloating
}

// Return sets up results that will be returned by Btt.ShowFloating
func (mmShowFloating *mBttMockShowFloating) Return(err error) *BttMock {
	if mmShowFloating.mock.funcShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("BttMock.ShowFloating mock is already set by Set")
	}

	if mmShowFloating.defaultExpectation == nil {
		mmShowFloating.defaultExpectation = &BttMockShowFloatingExpectation{mock: mmShowFloating.mock}
	}
	mmShowFloating.defaultExpectation.results = &BttMockShowFloatingResults{err}
	mmShowFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmShowFloating.mock
}

// Set uses given function f to mock the Btt.ShowFloating method
func (mmShowFloating *mBttMockShowFloating) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmShowFloating.defaultExpectation != nil {
		mmShowFloating.mock.t.Fatalf("Default expectation is already set for the Btt.ShowFloating method")
	}

	if len(mmShowFloating.expectations) > 0 {
		mmShowFloating.mock.t.Fatalf("Some expectations are already set for the Btt.ShowFloating method")
	}

	mmShowFloating.mock.funcShowFloating = f
	mmShowFloating.mock.funcShowFloatingOrigin = minimock.CallerInfo(1)
	return mmShowFloating.mock
}

// When sets expectation for the Btt.ShowFloating which will trigger the result defined by the following
// Then helper
func (mmShowFloating *mBttMockShowFloating) When(ctx context.Context) *BttMockShowFloatingExpectation {
	if mmShowFloating.mock.funcShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("BttMock.ShowFloating mock is already set by Set")
	}

	expectation := &BttMockShowFloatingExpectation{
		mock:               mmShowFloating.mock,
		params:             &BttMockShowFloatingParams{ctx},
		expectationOrigins: BttMockShowFloatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmShowFloating.expectations = append(mmShowFloating.expectations, expectation)
	return expectation
}

// Then sets up Btt.ShowFloating return parameters for the expectation previously defined by the When method
func (e *BttMockShowFloatingExpectation) Then(err error) *BttMock {
	e.results = &BttMockShowFloatingResults{err}
	return e.mock
}

// Times sets number of times Btt.ShowFloating should be invoked
func (mmShowFloating *mBttMockShowFloating) Times(n uint64) *mBttMockShowFloating {
	if n == 0 {
		mmShowFloating.mock.t.Fatalf("Times of BttMock.ShowFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmShowFloating.expectedInvocations, n)
	mmShowFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmShowFloating
}

func (mmShowFloating *mBttMockShowFloating) invocationsDone() bool {
	if len(mmShowFloating.expectations) == 0 && mmShowFloating.defaultExpectation == nil && mmShowFloating.mock.funcShowFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmShowFloating.mock.afterShowFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmShowFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ShowFloating implements Btt
func (mmShowFloating *BttMock) ShowFloating(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmShowFloating.beforeShowFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmShowFloating.afterShowFloatingCounter, 1)

	mmShowFloating.t.Helper()

	if mmShowFloating.inspectFuncShowFloating != nil {
		mmShowFloating.inspectFuncShowFloating(ctx)
	}

	mm_params := BttMockShowFloatingParams{ctx}

	// Record call args
	mmShowFloating.ShowFloatingMock.mutex.Lock()
	mmShowFloating.ShowFloatingMock.callArgs = append(mmShowFloating.ShowFloatingMock.callArgs, &mm_params)
	mmShowFloating.ShowFloatingMock.mutex.Unlock()

	for _, e := range mmShowFloating.ShowFloatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmShowFloating.ShowFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShowFloating.ShowFloatingMock.defaultExpectation.Counter, 1)
		mm_want := mmShowFloating.ShowFloatingMock.defaultExpectation.params
		mm_want_ptrs := mmShowFloating.ShowFloatingMock.defaultExpectation.paramPtrs

		mm_got := BttMockShowFloatingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmShowFloating.t.Errorf("BttMock.ShowFloating got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmShowFloating.ShowFloatingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmShowFloating.t.Errorf("BttMock.ShowFloating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmShowFloating.ShowFloatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmShowFloating.ShowFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmShowFloating.t.Fatal("No results are set for the BttMock.ShowFloating")
		}
		return (*mm_results).err
	}
	if mmShowFloating.funcShowFloating != nil {
		return mmShowFloating.funcShowFloating(ctx)
	}
	mmShowFloating.t.Fatalf("Unexpected call to BttMock.ShowFloating. %v", ctx)
	return
}

// ShowFloatingAfterCounter returns a count of finished BttMock.ShowFloating invocations
func (mmShowFloating *BttMock) ShowFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShowFloating.afterShowFloatingCounter)
}

// ShowFloatingBeforeCounter returns a count of BttMock.ShowFloating invocations
func (mmShowFloating *BttMock) ShowFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShowFloating.beforeShowFloatingCounter)
}

// Calls returns a list of arguments used in each call to BttMock.ShowFloating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmShowFloating *mBttMockShowFloating) Calls() []*BttMockShowFloatingParams {
	mmShowFloating.mutex.RLock()

	argCopy := make([]*BttMockShowFloatingParams, len(mmShowFloating.callArgs))
	copy(argCopy, mmShowFloating.callArgs)

	mmShowFloating.mutex.RUnlock()

	return argCopy
}

// MinimockShowFloatingDone returns true if the count of the ShowFloating invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockShowFloatingDone() bool {
	if m.ShowFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ShowFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ShowFloatingMock.invocationsDone()
}

// MinimockShowFloatingInspect logs each unmet expectation
func (m *BttMock) MinimockShowFloatingInspect() {
	for _, e := range m.ShowFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.ShowFloating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterShowFloatingCounter := mm_atomic.LoadUint64(&m.afterShowFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ShowFloatingMock.defaultExpectation != nil && afterShowFloatingCounter < 1 {
		if m.ShowFloatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.ShowFloating at\n%s", m.ShowFloatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.ShowFloating at\n%s with params: %#v", m.ShowFloatingMock.defaultExpectation.expectationOrigins.origin, *m.ShowFloatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShowFloating != nil && afterShowFloatingCounter < 1 {
		m.t.Errorf("Expected call to BttMock.ShowFloating at\n%s", m.funcShowFloatingOrigin)
	}

	if !m.ShowFloatingMock.invocationsDone() && afterShowFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.ShowFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ShowFloatingMock.expectedInvocations), m.ShowFloatingMock.expectedInvocationsOrigin, afterShowFloatingCounter)
	}
}

type mBttMockStartListening struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockStartListeningExpectation
	expectations       []*BttMockStartListeningExpectation

	callArgs []*BttMockStartListeningParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockStartListeningExpectation specifies expectation struct of the Btt.StartListening
type BttMockStartListeningExpectation struct {
	mock               *BttMock
	params             *BttMockStartListeningParams
	paramPtrs          *BttMockStartListeningParamPtrs
	expectationOrigins BttMockStartListeningExpectationOrigins
	results            *BttMockStartListeningResults
	returnOrigin       string
	Counter            uint64
}

// BttMockStartListeningParams contains parameters of the Btt.StartListening
type BttMockStartListeningParams struct {
	ctx context.Context
}

// BttMockStartListeningParamPtrs contains pointers to parameters of the Btt.StartListening
type BttMockStartListeningParamPtrs struct {
	ctx *context.Context
}

// BttMockStartListeningResults contains results of the Btt.StartListening
type BttMockStartListeningResults struct {
	err error
}

// BttMockStartListeningOrigins contains origins of expectations of the Btt.StartListening
type BttMockStartListeningExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStartListening *mBttMockStartListening) Optional() *mBttMockStartListening {
	mmStartListening.optional = true
	return mmStartListening
}

// Expect sets up expected params for Btt.StartListening
func (mmStartListening *mBttMockStartListening) Expect(ctx context.Context) *mBttMockStartListening {
	if mmStartListening.mock.funcStartListening != nil {
		mmStartListening.mock.t.Fatalf("BttMock.StartListening mock is already set by Set")
	}

	if mmStartListening.defaultExpectation == nil {
		mmStartListening.defaultExpectation = &BttMockStartListeningExpectation{}
	}

	if mmStartListening.defaultExpectation.paramPtrs != nil {
		mmStartListening.mock.t.Fatalf("BttMock.StartListening mock is already set by ExpectParams functions")
	}

	mmStartListening.defaultExpectation.params = &BttMockStartListeningParams{ctx}
	mmStartListening.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStartListening.expectations {
		if minimock.Equal(e.params, mmStartListening.defaultExpectation.params) {
			mmStartListening.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStartListening.defaultExpectation.params)
		}
	}

	return mmStartListening
}

// ExpectCtxParam1 sets up expected param ctx for Btt.StartListening
func (mmStartListening *mBttMockStartListening) ExpectCtxParam1(ctx context.Context) *mBttMockStartListening {
	if mmStartListening.mock.funcStartListening != nil {
		mmStartListening.mock.t.Fatalf("BttMock.StartListening mock is already set by Set")
	}

	if mmStartListening.defaultExpectation == nil {
		mmStartListening.defaultExpectation = &BttMockStartListeningExpectation{}
	}

	if mmStartListening.defaultExpectation.params != nil {
		mmStartListening.mock.t.Fatalf("BttMock.StartListening mock is already set by Expect")
	}

	if mmStartListening.defaultExpectation.paramPtrs == nil {
		mmStartListening.defaultExpectation.paramPtrs = &BttMockStartListeningParamPtrs{}
	}
	mmStartListening.defaultExpectation.paramPtrs.ctx = &ctx
	mmStartListening.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStartListening
}

// Inspect accepts an inspector function that has same arguments as the Btt.StartListening
func (mmStartListening *mBttMockStartListening) Inspect(f func(ctx context.Context)) *mBttMockStartListening {
	if mmStartListening.mock.inspectFuncStartListening != nil {
		mmStartListening.mock.t.Fatalf("Inspect function is already set for BttMock.StartListening")
	}

	mmStartListening.mock.inspectFuncStartListening = f

	return mmStartListening
}

// Return sets up results that will be returned by Btt.StartListening
func (mmStartListening *mBttMockStartListening) Return(err error) *BttMock {
	if mmStartListening.mock.funcStartListening != nil {
		mmStartListening.mock.t.Fatalf("BttMock.StartListening mock is already set by Set")
	}

	if mmStartListening.defaultExpectation == nil {
		mmStartListening.defaultExpectation = &BttMockStartListeningExpectation{mock: mmStartListening.mock}
	}
	mmStartListening.defaultExpectation.results = &BttMockStartListeningResults{err}
	mmStartListening.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStartListening.mock
}

// Set uses given function f to mock the Btt.StartListening method
func (mmStartListening *mBttMockStartListening) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmStartListening.defaultExpectation != nil {
		mmStartListening.mock.t.Fatalf("Default expectation is already set for the Btt.StartListening method")
	}

	if len(mmStartListening.expectations) > 0 {
		mmStartListening.mock.t.Fatalf("Some expectations are already set for the Btt.StartListening method")
	}

	mmStartListening.mock.funcStartListening = f
	mmStartListening.mock.funcStartListeningOrigin = minimock.CallerInfo(1)
	return mmStartListening.mock
}

// When sets expectation for the Btt.StartListening which will trigger the result defined by the following
// Then helper
func (mmStartListening *mBttMockStartListening) When(ctx context.Context) *BttMockStartListeningExpectation {
	if mmStartListening.mock.funcStartListening != nil {
		mmStartListening.mock.t.Fatalf("BttMock.StartListening mock is already set by Set")
	}

	expectation := &BttMockStartListeningExpectation{
		mock:               mmStartListening.mock,
		params:             &BttMockStartListeningParams{ctx},
		expectationOrigins: BttMockStartListeningExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStartListening.expectations = append(mmStartListening.expectations, expectation)
	return expectation
}

// Then sets up Btt.StartListening return parameters for the expectation previously defined by the When method
func (e *BttMockStartListeningExpectation) Then(err error) *BttMock {
	e.results = &BttMockStartListeningResults{err}
	return e.mock
}

// Times sets number of times Btt.StartListening should be invoked
func (mmStartListening *mBttMockStartListening) Times(n uint64) *mBttMockStartListening {
	if n == 0 {
		mmStartListening.mock.t.Fatalf("Times of BttMock.StartListening mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStartListening.expectedInvocations, n)
	mmStartListening.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStartListening
}

func (mmStartListening *mBttMockStartListening) invocationsDone() bool {
	if len(mmStartListening.expectations) == 0 && mmStartListening.defaultExpectation == nil && mmStartListening.mock.funcStartListening == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStartListening.mock.afterStartListeningCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStartListening.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StartListening implements Btt
func (mmStartListening *BttMock) StartListening(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStartListening.beforeStartListeningCounter, 1)
	defer mm_atomic.AddUint64(&mmStartListening.afterStartListeningCounter, 1)

	mmStartListening.t.Helper()

	if mmStartListening.inspectFuncStartListening != nil {
		mmStartListening.inspectFuncStartListening(ctx)
	}

	mm_params := BttMockStartListeningParams{ctx}

	// Record call args
	mmStartListening.StartListeningMock.mutex.Lock()
	mmStartListening.StartListeningMock.callArgs = append(mmStartListening.StartListeningMock.callArgs, &mm_params)
	mmStartListening.StartListeningMock.mutex.Unlock()

	for _, e := range mmStartListening.StartListeningMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStartListening.StartListeningMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStartListening.StartListeningMock.defaultExpectation.Counter, 1)
		mm_want := mmStartListening.StartListeningMock.defaultExpectation.params
		mm_want_ptrs := mmStartListening.StartListeningMock.defaultExpectation.paramPtrs

		mm_got := BttMockStartListeningParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStartListening.t.Errorf("BttMock.StartListening got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStartListening.StartListeningMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStartListening.t.Errorf("BttMock.StartListening got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStartListening.StartListeningMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStartListening.StartListeningMock.defaultExpectation.results
		if mm_results == nil {
			mmStartListening.t.Fatal("No results are set for the BttMock.StartListening")
		}
		return (*mm_results).err
	}
	if mmStartListening.funcStartListening != nil {
		return mmStartListening.funcStartListening(ctx)
	}
	mmStartListening.t.Fatalf("Unexpected call to BttMock.StartListening. %v", ctx)
	return
}

// StartListeningAfterCounter returns a count of finished BttMock.StartListening invocations
func (mmStartListening *BttMock) StartListeningAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartListening.afterStartListeningCounter)
}

// StartListeningBeforeCounter returns a count of BttMock.StartListening invocations
func (mmStartListening *BttMock) StartListeningBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartListening.beforeStartListeningCounter)
}

// Calls returns a list of arguments used in each call to BttMock.StartListening.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStartListening *mBttMockStartListening) Calls() []*BttMockStartListeningParams {
	mmStartListening.mutex.RLock()

	argCopy := make([]*BttMockStartListeningParams, len(mmStartListening.callArgs))
	copy(argCopy, mmStartListening.callArgs)

	mmStartListening.mutex.RUnlock()

	return argCopy
}

// MinimockStartListeningDone returns true if the count of the StartListening invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockStartListeningDone() bool {
	if m.StartListeningMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StartListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StartListeningMock.invocationsDone()
}

// MinimockStartListeningInspect logs each unmet expectation
func (m *BttMock) MinimockStartListeningInspect() {
	for _, e := range m.StartListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.StartListening at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStartListeningCounter := mm_atomic.LoadUint64(&m.afterStartListeningCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StartListeningMock.defaultExpectation != nil && afterStartListeningCounter < 1 {
		if m.StartListeningMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.StartListening at\n%s", m.StartListeningMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.StartListening at\n%s with params: %#v", m.StartListeningMock.defaultExpectation.expectationOrigins.origin, *m.StartListeningMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartListening != nil && afterStartListeningCounter < 1 {
		m.t.Errorf("Expected call to BttMock.StartListening at\n%s", m.funcStartListeningOrigin)
	}

	if !m.StartListeningMock.invocationsDone() && afterStartListeningCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.StartListening at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StartListeningMock.expectedInvocations), m.StartListeningMock.expectedInvocationsOrigin, afterStartListeningCounter)
	}
}

type mBttMockStopListening struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockStopListeningExpectation
	expectations       []*BttMockStopListeningExpectation

	callArgs []*BttMockStopListeningParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockStopListeningExpectation specifies expectation struct of the Btt.StopListening
type BttMockStopListeningExpectation struct {
	mock               *BttMock
	params             *BttMockStopListeningParams
	paramPtrs          *BttMockStopListeningParamPtrs
	expectationOrigins BttMockStopListeningExpectationOrigins
	results            *BttMockStopListeningResults
	returnOrigin       string
	Counter            uint64
}

// BttMockStopListeningParams contains parameters of the Btt.StopListening
type BttMockStopListeningParams struct {
	ctx context.Context
}

// BttMockStopListeningParamPtrs contains pointers to parameters of the Btt.StopListening
type BttMockStopListeningParamPtrs struct {
	ctx *context.Context
}

// BttMockStopListeningResults contains results of the Btt.StopListening
type BttMockStopListeningResults struct {
	err error
}

// BttMockStopListeningOrigins contains origins of expectations of the Btt.StopListening
type BttMockStopListeningExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStopListening *mBttMockStopListening) Optional() *mBttMockStopListening {
	mmStopListening.optional = true
	return mmStopListening
}

// Expect sets up expected params for Btt.StopListening
func (mmStopListening *mBttMockStopListening) Expect(ctx context.Context) *mBttMockStopListening {
	if mmStopListening.mock.funcStopListening != nil {
		mmStopListening.mock.t.Fatalf("BttMock.StopListening mock is already set by Set")
	}

	if mmStopListening.defaultExpectation == nil {
		mmStopListening.defaultExpectation = &BttMockStopListeningExpectation{}
	}

	if mmStopListening.defaultExpectation.paramPtrs != nil {
		mmStopListening.mock.t.Fatalf("BttMock.StopListening mock is already set by ExpectParams functions")
	}

	mmStopListening.defaultExpectation.params = &BttMockStopListeningParams{ctx}
	mmStopListening.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStopListening.expectations {
		if minimock.Equal(e.params, mmStopListening.defaultExpectation.params) {
			mmStopListening.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStopListening.defaultExpectation.params)
		}
	}

	return mmStopListening
}

// ExpectCtxParam1 sets up expected param ctx for Btt.StopListening
func (mmStopListening *mBttMockStopListening) ExpectCtxParam1(ctx context.Context) *mBttMockStopListening {
	if mmStopListening.mock.funcStopListening != nil {
		mmStopListening.mock.t.Fatalf("BttMock.StopListening mock is already set by Set")
	}

	if mmStopListening.defaultExpectation == nil {
		mmStopListening.defaultExpectation = &BttMockStopListeningExpectation{}
	}

	if mmStopListening.defaultExpectation.params != nil {
		mmStopListening.mock.t.Fatalf("BttMock.StopListening mock is already set by Expect")
	}

	if mmStopListening.defaultExpectation.paramPtrs == nil {
		mmStopListening.defaultExpectation.paramPtrs = &BttMockStopListeningParamPtrs{}
	}
	mmStopListening.defaultExpectation.paramPtrs.ctx = &ctx
	mmStopListening.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStopListening
}

// Inspect accepts an inspector function that has same arguments as the Btt.StopListening
func (mmStopListening *mBttMockStopListening) Inspect(f func(ctx context.Context)) *mBttMockStopListening {
	if mmStopListening.mock.inspectFuncStopListening != nil {
		mmStopListening.mock.t.Fatalf("Inspect function is already set for BttMock.StopListening")
	}

	mmStopListening.mock.inspectFuncStopListening = f

	return mmStopListening
}

// Return sets up results that will be returned by Btt.StopListening
func (mmStopListening *mBttMockStopListening) Return(err error) *BttMock {
	if mmStopListening.mock.funcStopListening != nil {
		mmStopListening.mock.t.Fatalf("BttMock.StopListening mock is already set by Set")
	}

	if mmStopListening.defaultExpectation == nil {
		mmStopListening.defaultExpectation = &BttMockStopListeningExpectation{mock: mmStopListening.mock}
	}
	mmStopListening.defaultExpectation.results = &BttMockStopListeningResults{err}
	mmStopListening.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStopListening.mock
}

// Set uses given function f to mock the Btt.StopListening method
func (mmStopListening *mBttMockStopListening) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmStopListening.defaultExpectation != nil {
		mmStopListening.mock.t.Fatalf("Default expectation is already set for the Btt.StopListening method")
	}

	if len(mmStopListening.expectations) > 0 {
		mmStopListening.mock.t.Fatalf("Some expectations are already set for the Btt.StopListening method")
	}

	mmStopListening.mock.funcStopListening = f
	mmStopListening.mock.funcStopListeningOrigin = minimock.CallerInfo(1)
	return mmStopListening.mock
}

// When sets expectation for the Btt.StopListening which will trigger the result defined by the following
// Then helper
func (mmStopListening *mBttMockStopListening) When(ctx context.Context) *BttMockStopListeningExpectation {
	if mmStopListening.mock.funcStopListening != nil {
		mmStopListening.mock.t.Fatalf("BttMock.StopListening mock is already set by Set")
	}

	expectation := &BttMockStopListeningExpectation{
		mock:               mmStopListening.mock,
		params:             &BttMockStopListeningParams{ctx},
		expectationOrigins: BttMockStopListeningExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStopListening.expectations = append(mmStopListening.expectations, expectation)
	return expectation
}

// Then sets up Btt.StopListening return parameters for the expectation previously defined by the When method
func (e *BttMockStopListeningExpectation) Then(err error) *BttMock {
	e.results = &BttMockStopListeningResults{err}
	return e.mock
}

// Times sets number of times Btt.StopListening should be invoked
func (mmStopListening *mBttMockStopListening) Times(n uint64) *mBttMockStopListening {
	if n == 0 {
		mmStopListening.mock.t.Fatalf("Times of BttMock.StopListening mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStopListening.expectedInvocations, n)
	mmStopListening.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStopListening
}

func (mmStopListening *mBttMockStopListening) invocationsDone() bool {
	if len(mmStopListening.expectations) == 0 && mmStopListening.defaultExpectation == nil && mmStopListening.mock.funcStopListening == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStopListening.mock.afterStopListeningCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStopListening.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StopListening implements Btt
func (mmStopListening *BttMock) StopListening(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStopListening.beforeStopListeningCounter, 1)
	defer mm_atomic.AddUint64(&mmStopListening.afterStopListeningCounter, 1)

	mmStopListening.t.Helper()

	if mmStopListening.inspectFuncStopListening != nil {
		mmStopListening.inspectFuncStopListening(ctx)
	}

	mm_params := BttMockStopListeningParams{ctx}

	// Record call args
	mmStopListening.StopListeningMock.mutex.Lock()
	mmStopListening.StopListeningMock.callArgs = append(mmStopListening.StopListeningMock.callArgs, &mm_params)
	mmStopListening.StopListeningMock.mutex.Unlock()

	for _, e := range mmStopListening.StopListeningMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStopListening.StopListeningMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStopListening.StopListeningMock.defaultExpectation.Counter, 1)
		mm_want := mmStopListening.StopListeningMock.defaultExpectation.params
		mm_want_ptrs := mmStopListening.StopListeningMock.defaultExpectation.paramPtrs

		mm_got := BttMockStopListeningParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStopListening.t.Errorf("BttMock.StopListening got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStopListening.StopListeningMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStopListening.t.Errorf("BttMock.StopListening got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStopListening.StopListeningMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStopListening.StopListeningMock.defaultExpectation.results
		if mm_results == nil {
			mmStopListening.t.Fatal("No results are set for the BttMock.StopListening")
		}
		return (*mm_results).err
	}
	if mmStopListening.funcStopListening != nil {
		return mmStopListening.funcStopListening(ctx)
	}
	mmStopListening.t.Fatalf("Unexpected call to BttMock.StopListening. %v", ctx)
	return
}

// StopListeningAfterCounter returns a count of finished BttMock.StopListening invocations
func (mmStopListening *BttMock) StopListeningAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStopListening.afterStopListeningCounter)
}

// StopListeningBeforeCounter returns a count of BttMock.StopListening invocations
func (mmStopListening *BttMock) StopListeningBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStopListening.beforeStopListeningCounter)
}

// Calls returns a list of arguments used in each call to BttMock.StopListening.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStopListening *mBttMockStopListening) Calls() []*BttMockStopListeningParams {
	mmStopListening.mutex.RLock()

	argCopy := make([]*BttMockStopListeningParams, len(mmStopListening.callArgs))
	copy(argCopy, mmStopListening.callArgs)

	mmStopListening.mutex.RUnlock()

	return argCopy
}

// MinimockStopListeningDone returns true if the count of the StopListening invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockStopListeningDone() bool {
	if m.StopListeningMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StopListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StopListeningMock.invocationsDone()
}

// MinimockStopListeningInspect logs each unmet expectation
func (m *BttMock) MinimockStopListeningInspect() {
	for _, e := range m.StopListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.StopListening at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStopListeningCounter := mm_atomic.LoadUint64(&m.afterStopListeningCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StopListeningMock.defaultExpectation != nil && afterStopListeningCounter < 1 {
		if m.StopListeningMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.StopListening at\n%s", m.StopListeningMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.StopListening at\n%s with params: %#v", m.StopListeningMock.defaultExpectation.expectationOrigins.origin, *m.StopListeningMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStopListening != nil && afterStopListeningCounter < 1 {
		m.t.Errorf("Expected call to BttMock.StopListening at\n%s", m.funcStopListeningOrigin)
	}

	if !m.StopListeningMock.invocationsDone() && afterStopListeningCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.StopListening at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StopListeningMock.expectedInvocations), m.StopListeningMock.expectedInvocationsOrigin, afterStopListeningCounter)
	}
}

type mBttMockStreamText struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockStreamTextExpectation
	expectations       []*BttMockStreamTextExpectation

	callArgs []*BttMockStreamTextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockStreamTextExpectation specifies expectation struct of the Btt.StreamText
type BttMockStreamTextExpectation struct {
	mock               *BttMock
	params             *BttMockStreamTextParams
	paramPtrs          *BttMockStreamTextParamPtrs
	expectationOrigins BttMockStreamTextExpectationOrigins
	results            *BttMockStreamTextResults
	returnOrigin       string
	Counter            uint64
}

// BttMockStreamTextParams contains parameters of the Btt.StreamText
type BttMockStreamTextParams struct {
	ctx context.Context
}

// BttMockStreamTextParamPtrs contains pointers to parameters of the Btt.StreamText
type BttMockStreamTextParamPtrs struct {
	ctx *context.Context
}

// BttMockStreamTextResults contains results of the Btt.StreamText
type BttMockStreamTextResults struct {
	ch1 <-chan string
	ch2 <-chan error
	err error
}

// BttMockStreamTextOrigins contains origins of expectations of the Btt.StreamText
type BttMockStreamTextExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStreamText *mBttMockStreamText) Optional() *mBttMockStreamText {
	mmStreamText.optional = true
	return mmStreamText
}

// Expect sets up expected params for Btt.StreamText
func (mmStreamText *mBttMockStreamText) Expect(ctx context.Context) *mBttMockStreamText {
	if mmStreamText.mock.funcStreamText != nil {
		mmStreamText.mock.t.Fatalf("BttMock.StreamText mock is already set by Set")
	}

	if mmStreamText.defaultExpectation == nil {
		mmStreamText.defaultExpectation = &BttMockStreamTextExpectation{}
	}

	if mmStreamText.defaultExpectation.paramPtrs != nil {
		mmStreamText.mock.t.Fatalf("BttMock.StreamText mock is already set by ExpectParams functions")
	}

	mmStreamText.defaultExpectation.params = &BttMockStreamTextParams{ctx}
	mmStreamText.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStreamText.expectations {
		if minimock.Equal(e.params, mmStreamText.defaultExpectation.params) {
			mmStreamText.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStreamText.defaultExpectation.params)
		}
	}

	return mmStreamText
}

// ExpectCtxParam1 sets up expected param ctx for Btt.StreamText
func (mmStreamText *mBttMockStreamText) ExpectCtxParam1(ctx context.Context) *mBttMockStreamText {
	if mmStreamText.mock.funcStreamText != nil {
		mmStreamText.mock.t.Fatalf("BttMock.StreamText mock is already set by Set")
	}

	if mmStreamText.defaultExpectation == nil {
		mmStreamText.defaultExpectation = &BttMockStreamTextExpectation{}
	}

	if mmStreamText.defaultExpectation.params != nil {
		mmStreamText.mock.t.Fatalf("BttMock.StreamText mock is already set by Expect")
	}

	if mmStreamText.defaultExpectation.paramPtrs == nil {
		mmStreamText.defaultExpectation.paramPtrs = &BttMockStreamTextParamPtrs{}
	}
	mmStreamText.defaultExpectation.paramPtrs.ctx = &ctx
	mmStreamText.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStreamText
}

// Inspect accepts an inspector function that has same arguments as the Btt.StreamText
func (mmStreamText *mBttMockStreamText) Inspect(f func(ctx context.Context)) *mBttMockStreamText {
	if mmStreamText.mock.inspectFuncStreamText != nil {
		mmStreamText.mock.t.Fatalf("Inspect function is already set for BttMock.StreamText")
	}

	mmStreamText.mock.inspectFuncStreamText = f

	return mmStreamText
}

// Return sets up results that will be returned by Btt.StreamText
func (mmStreamText *mBttMockStreamText) Return(ch1 <-chan string, ch2 <-chan error, err error) *BttMock {
	if mmStreamText.mock.funcStreamText != nil {
		mmStreamText.mock.t.Fatalf("BttMock.StreamText mock is already set by Set")
	}

	if mmStreamText.defaultExpectation == nil {
		mmStreamText.defaultExpectation = &BttMockStreamTextExpectation{mock: mmStreamText.mock}
	}
	mmStreamText.defaultExpectation.results = &BttMockStreamTextResults{ch1, ch2, err}
	mmStreamText.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStreamText.mock
}

// Set uses given function f to mock the Btt.StreamText method
func (mmStreamText *mBttMockStreamText) Set(f func(ctx context.Context) (ch1 <-chan string, ch2 <-chan error, err error)) *BttMock {
	if mmStreamText.defaultExpectation != nil {
		mmStreamText.mock.t.Fatalf("Default expectation is already set for the Btt.StreamText method")
	}

	if len(mmStreamText.expectations) > 0 {
		mmStreamText.mock.t.Fatalf("Some expectations are already set for the Btt.StreamText method")
	}

	mmStreamText.mock.funcStreamText = f
	mmStreamText.mock.funcStreamTextOrigin = minimock.CallerInfo(1)
	return mmStreamText.mock
}

// When sets expectation for the Btt.StreamText which will trigger the result defined by the following
// Then helper
func (mmStreamText *mBttMockStreamText) When(ctx context.Context) *BttMockStreamTextExpectation {
	if mmStreamText.mock.funcStreamText != nil {
		mmStreamText.mock.t.Fatalf("BttMock.StreamText mock is already set by Set")
	}

	expectation := &BttMockStreamTextExpectation{
		mock:               mmStreamText.mock,
		params:             &BttMockStreamTextParams{ctx},
		expectationOrigins: BttMockStreamTextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStreamText.expectations = append(mmStreamText.expectations, expectation)
	return expectation
}

// Then sets up Btt.StreamText return parameters for the expectation previously defined by the When method
func (e *BttMockStreamTextExpectation) Then(ch1 <-chan string, ch2 <-chan error, err error) *BttMock {
	e.results = &BttMockStreamTextResults{ch1, ch2, err}
	return e.mock
}

// Times sets number of times Btt.StreamText should be invoked
func (mmStreamText *mBttMockStreamText) Times(n uint64) *mBttMockStreamText {
	if n == 0 {
		mmStreamText.mock.t.Fatalf("Times of BttMock.StreamText mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStreamText.expectedInvocations, n)
	mmStreamText.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStreamText
}

func (mmStreamText *mBttMockStreamText) invocationsDone() bool {
	if len(mmStreamText.expectations) == 0 && mmStreamText.defaultExpectation == nil && mmStreamText.mock.funcStreamText == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStreamText.mock.afterStreamTextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStreamText.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StreamText implements Btt
func (mmStreamText *BttMock) StreamText(ctx context.Context) (ch1 <-chan string, ch2 <-chan error, err error) {
	mm_atomic.AddUint64(&mmStreamText.beforeStreamTextCounter, 1)
	defer mm_atomic.AddUint64(&mmStreamText.afterStreamTextCounter, 1)

	mmStreamText.t.Helper()

	if mmStreamText.inspectFuncStreamText != nil {
		mmStreamText.inspectFuncStreamText(ctx)
	}

	mm_params := BttMockStreamTextParams{ctx}

	// Record call args
	mmStreamText.StreamTextMock.mutex.Lock()
	mmStreamText.StreamTextMock.callArgs = append(mmStreamText.StreamTextMock.callArgs, &mm_params)
	mmStreamText.StreamTextMock.mutex.Unlock()

	for _, e := range mmStreamText.StreamTextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ch1, e.results.ch2, e.results.err
		}
	}

	if mmStreamText.StreamTextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStreamText.StreamTextMock.defaultExpectation.Counter, 1)
		mm_want := mmStreamText.StreamTextMock.defaultExpectation.params
		mm_want_ptrs := mmStreamText.StreamTextMock.defaultExpectation.paramPtrs

		mm_got := BttMockStreamTextParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStreamText.t.Errorf("BttMock.StreamText got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStreamText.StreamTextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStreamText.t.Errorf("BttMock.StreamText got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStreamText.StreamTextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStreamText.StreamTextMock.defaultExpectation.results
		if mm_results == nil {
			mmStreamText.t.Fatal("No results are set for the BttMock.StreamText")
		}
		return (*mm_results).ch1, (*mm_results).ch2, (*mm_results).err
	}
	if mmStreamText.funcStreamText != nil {
		return mmStreamText.funcStreamText(ctx)
	}
	mmStreamText.t.Fatalf("Unexpected call to BttMock.StreamText. %v", ctx)
	return
}

// StreamTextAfterCounter returns a count of finished BttMock.StreamText invocations
func (mmStreamText *BttMock) StreamTextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStreamText.afterStreamTextCounter)
}

// StreamTextBeforeCounter returns a count of BttMock.StreamText invocations
func (mmStreamText *BttMock) StreamTextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStreamText.beforeStreamTextCounter)
}

// Calls returns a list of arguments used in each call to BttMock.StreamText.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStreamText *mBttMockStreamText) Calls() []*BttMockStreamTextParams {
	mmStreamText.mutex.RLock()

	argCopy := make([]*BttMockStreamTextParams, len(mmStreamText.callArgs))
	copy(argCopy, mmStreamText.callArgs)

	mmStreamText.mutex.RUnlock()

	return argCopy
}

// MinimockStreamTextDone returns true if the count of the StreamText invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockStreamTextDone() bool {
	if m.StreamTextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StreamTextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StreamTextMock.invocationsDone()
}

// MinimockStreamTextInspect logs each unmet expectation
func (m *BttMock) MinimockStreamTextInspect() {
	for _, e := range m.StreamTextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.StreamText at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStreamTextCounter := mm_atomic.LoadUint64(&m.afterStreamTextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StreamTextMock.defaultExpectation != nil && afterStreamTextCounter < 1 {
		if m.StreamTextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.StreamText at\n%s", m.StreamTextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.StreamText at\n%s with params: %#v", m.StreamTextMock.defaultExpectation.expectationOrigins.origin, *m.StreamTextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStreamText != nil && afterStreamTextCounter < 1 {
		m.t.Errorf("Expected call to BttMock.StreamText at\n%s", m.funcStreamTextOrigin)
	}

	if !m.StreamTextMock.invocationsDone() && afterStreamTextCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.StreamText at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StreamTextMock.expectedInvocations), m.StreamTextMock.expectedInvocationsOrigin, afterStreamTextCounter)
	}
}

type mBttMockText struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockTextExpectation
	expectations       []*BttMockTextExpectation

	callArgs []*BttMockTextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockTextExpectation specifies expectation struct of the Btt.Text
type BttMockTextExpectation struct {
	mock               *BttMock
	params             *BttMockTextParams
	paramPtrs          *BttMockTextParamPtrs
	expectationOrigins BttMockTextExpectationOrigins
	results            *BttMockTextResults
	returnOrigin       string
	Counter            uint64
}

// BttMockTextParams contains parameters of the Btt.Text
type BttMockTextParams struct {
	ctx context.Context
}

// BttMockTextParamPtrs contains pointers to parameters of the Btt.Text
type BttMockTextParamPtrs struct {
	ctx *context.Context
}

// BttMockTextResults contains results of the Btt.Text
type BttMockTextResults struct {
	s1  string
	err error
}

// BttMockTextOrigins contains origins of expectations of the Btt.Text
type BttMockTextExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmText *mBttMockText) Optional() *mBttMockText {
	mmText.optional = true
	return mmText
}

// Expect sets up expected params for Btt.Text
func (mmText *mBttMockText) Expect(ctx context.Context) *mBttMockText {
	if mmText.mock.funcText != nil {
		mmText.mock.t.Fatalf("BttMock.Text mock is already set by Set")
	}

	if mmText.defaultExpectation == nil {
		mmText.defaultExpectation = &BttMockTextExpectation{}
	}

	if mmText.defaultExpectation.paramPtrs != nil {
		mmText.mock.t.Fatalf("BttMock.Text mock is already set by ExpectParams functions")
	}

	mmText.defaultExpectation.params = &BttMockTextParams{ctx}
	mmText.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmText.expectations {
		if minimock.Equal(e.params, mmText.defaultExpectation.params) {
			mmText.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmText.defaultExpectation.params)
		}
	}

	return mmText
}

// ExpectCtxParam1 sets up expected param ctx for Btt.Text
func (mmText *mBttMockText) ExpectCtxParam1(ctx context.Context) *mBttMockText {
	if mmText.mock.funcText != nil {
		mmText.mock.t.Fatalf("BttMock.Text mock is already set by Set")
	}

	if mmText.defaultExpectation == nil {
		mmText.defaultExpectation = &BttMockTextExpectation{}
	}

	if mmText.defaultExpectation.params != nil {
		mmText.mock.t.Fatalf("BttMock.Text mock is already set by Expect")
	}

	if mmText.defaultExpectation.paramPtrs == nil {
		mmText.defaultExpectation.paramPtrs = &BttMockTextParamPtrs{}
	}
	mmText.defaultExpectation.paramPtrs.ctx = &ctx
	mmText.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmText
}

// Inspect accepts an inspector function that has same arguments as the Btt.Text
func (mmText *mBttMockText) Inspect(f func(ctx context.Context)) *mBttMockText {
	if mmText.mock.inspectFuncText != nil {
		mmText.mock.t.Fatalf("Inspect function is already set for BttMock.Text")
	}

	mmText.mock.inspectFuncText = f

	return mmText
}

// Return sets up results that will be returned by Btt.Text
func (mmText *mBttMockText) Return(s1 string, err error) *BttMock {
	if mmText.mock.funcText != nil {
		mmText.mock.t.Fatalf("BttMock.Text mock is already set by Set")
	}

	if mmText.defaultExpectation == nil {
		mmText.defaultExpectation = &BttMockTextExpectation{mock: mmText.mock}
	}
	mmText.defaultExpectation.results = &BttMockTextResults{s1, err}
	mmText.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmText.mock
}

// Set uses given function f to mock the Btt.Text method
func (mmText *mBttMockText) Set(f func(ctx context.Context) (s1 string, err error)) *BttMock {
	if mmText.defaultExpectation != nil {
		mmText.mock.t.Fatalf("Default expectation is already set for the Btt.Text method")
	}

	if len(mmText.expectations) > 0 {
		mmText.mock.t.Fatalf("Some expectations are already set for the Btt.Text method")
	}

	mmText.mock.funcText = f
	mmText.mock.funcTextOrigin = minimock.CallerInfo(1)
	return mmText.mock
}

// When sets expectation for the Btt.Text which will trigger the result defined by the following
// Then helper
func (mmText *mBttMockText) When(ctx context.Context) *BttMockTextExpectation {
	if mmText.mock.funcText != nil {
		mmText.mock.t.Fatalf("BttMock.Text mock is already set by Set")
	}

	expectation := &BttMockTextExpectation{
		mock:               mmText.mock,
		params:             &BttMockTextParams{ctx},
		expectationOrigins: BttMockTextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmText.expectations = append(mmText.expectations, expectation)
	return expectation
}

// Then sets up Btt.Text return parameters for the expectation previously defined by the When method
func (e *BttMockTextExpectation) Then(s1 string, err error) *BttMock {
	e.results = &BttMockTextResults{s1, err}
	return e.mock
}

// Times sets number of times Btt.Text should be invoked
func (mmText *mBttMockText) Times(n uint64) *mBttMockText {
	if n == 0 {
		mmText.mock.t.Fatalf("Times of BttMock.Text mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmText.expectedInvocations, n)
	mmText.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmText
}

func (mmText *mBttMockText) invocationsDone() bool {
	if len(mmText.expectations) == 0 && mmText.defaultExpectation == nil && mmText.mock.funcText == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmText.mock.afterTextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmText.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Text implements Btt
func (mmText *BttMock) Text(ctx context.Context) (s1 string, err error) {
	mm_atomic.AddUint64(&mmText.beforeTextCounter, 1)
	defer mm_atomic.AddUint64(&mmText.afterTextCounter, 1)

	mmText.t.Helper()

	if mmText.inspectFuncText != nil {
		mmText.inspectFuncText(ctx)
	}

	mm_params := BttMockTextParams{ctx}

	// Record call args
	mmText.TextMock.mutex.Lock()
	mmText.TextMock.callArgs = append(mmText.TextMock.callArgs, &mm_params)
	mmText.TextMock.mutex.Unlock()

	for _, e := range mmText.TextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmText.TextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmText.TextMock.defaultExpectation.Counter, 1)
		mm_want := mmText.TextMock.defaultExpectation.params
		mm_want_ptrs := mmText.TextMock.defaultExpectation.paramPtrs

		mm_got := BttMockTextParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmText.t.Errorf("BttMock.Text got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmText.TextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmText.t.Errorf("BttMock.Text got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmText.TextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmText.TextMock.defaultExpectation.results
		if mm_results == nil {
			mmText.t.Fatal("No results are set for the BttMock.Text")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmText.funcText != nil {
		return mmText.funcText(ctx)
	}
	mmText.t.Fatalf("Unexpected call to BttMock.Text. %v", ctx)
	return
}

// TextAfterCounter returns a count of finished BttMock.Text invocations
func (mmText *BttMock) TextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmText.afterTextCounter)
}

// TextBeforeCounter returns a count of BttMock.Text invocations
func (mmText *BttMock) TextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmText.beforeTextCounter)
}

// Calls returns a list of arguments used in each call to BttMock.Text.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmText *mBttMockText) Calls() []*BttMockTextParams {
	mmText.mutex.RLock()

	argCopy := make([]*BttMockTextParams, len(mmText.callArgs))
	copy(argCopy, mmText.callArgs)

	mmText.mutex.RUnlock()

	return argCopy
}

// MinimockTextDone returns true if the count of the Text invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockTextDone() bool {
	if m.TextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TextMock.invocationsDone()
}

// MinimockTextInspect logs each unmet expectation
func (m *BttMock) MinimockTextInspect() {
	for _, e := range m.TextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.Text at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTextCounter := mm_atomic.LoadUint64(&m.afterTextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TextMock.defaultExpectation != nil && afterTextCounter < 1 {
		if m.TextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.Text at\n%s", m.TextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.Text at\n%s with params: %#v", m.TextMock.defaultExpectation.expectationOrigins.origin, *m.TextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcText != nil && afterTextCounter < 1 {
		m.t.Errorf("Expected call to BttMock.Text at\n%s", m.funcTextOrigin)
	}

	if !m.TextMock.invocationsDone() && afterTextCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.Text at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TextMock.expectedInvocations), m.TextMock.expectedInvocationsOrigin, afterTextCounter)
	}
}

type mBttMockToggleListening struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockToggleListeningExpectation
	expectations       []*BttMockToggleListeningExpectation

	callArgs []*BttMockToggleListeningParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockToggleListeningExpectation specifies expectation struct of the Btt.ToggleListening
type BttMockToggleListeningExpectation struct {
	mock               *BttMock
	params             *BttMockToggleListeningParams
	paramPtrs          *BttMockToggleListeningParamPtrs
	expectationOrigins BttMockToggleListeningExpectationOrigins
	results            *BttMockToggleListeningResults
	returnOrigin       string
	Counter            uint64
}

// BttMockToggleListeningParams contains parameters of the Btt.ToggleListening
type BttMockToggleListeningParams struct {
	ctx context.Context
}

// BttMockToggleListeningParamPtrs contains pointers to parameters of the Btt.ToggleListening
type BttMockToggleListeningParamPtrs struct {
	ctx *context.Context
}

// BttMockToggleListeningResults contains results of the Btt.ToggleListening
type BttMockToggleListeningResults struct {
	err error
}

// BttMockToggleListeningOrigins contains origins of expectations of the Btt.ToggleListening
type BttMockToggleListeningExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToggleListening *mBttMockToggleListening) Optional() *mBttMockToggleListening {
	mmToggleListening.optional = true
	return mmToggleListening
}

// Expect sets up expected params for Btt.ToggleListening
func (mmToggleListening *mBttMockToggleListening) Expect(ctx context.Context) *mBttMockToggleListening {
	if mmToggleListening.mock.funcToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("BttMock.ToggleListening mock is already set by Set")
	}

	if mmToggleListening.defaultExpectation == nil {
		mmToggleListening.defaultExpectation = &BttMockToggleListeningExpectation{}
	}

	if mmToggleListening.defaultExpectation.paramPtrs != nil {
		mmToggleListening.mock.t.Fatalf("BttMock.ToggleListening mock is already set by ExpectParams functions")
	}

	mmToggleListening.defaultExpectation.params = &BttMockToggleListeningParams{ctx}
	mmToggleListening.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToggleListening.expectations {
		if minimock.Equal(e.params, mmToggleListening.defaultExpectation.params) {
			mmToggleListening.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToggleListening.defaultExpectation.params)
		}
	}

	return mmToggleListening
}

// ExpectCtxParam1 sets up expected param ctx for Btt.ToggleListening
func (mmToggleListening *mBttMockToggleListening) ExpectCtxParam1(ctx context.Context) *mBttMockToggleListening {
	if mmToggleListening.mock.funcToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("BttMock.ToggleListening mock is already set by Set")
	}

	if mmToggleListening.defaultExpectation == nil {
		mmToggleListening.defaultExpectation = &BttMockToggleListeningExpectation{}
	}

	if mmToggleListening.defaultExpectation.params != nil {
		mmToggleListening.mock.t.Fatalf("BttMock.ToggleListening mock is already set by Expect")
	}

	if mmToggleListening.defaultExpectation.paramPtrs == nil {
		mmToggleListening.defaultExpectation.paramPtrs = &BttMockToggleListeningParamPtrs{}
	}
	mmToggleListening.defaultExpectation.paramPtrs.ctx = &ctx
	mmToggleListening.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmToggleListening
}

// Inspect accepts an inspector function that has same arguments as the Btt.ToggleListening
func (mmToggleListening *mBttMockToggleListening) Inspect(f func(ctx context.Context)) *mBttMockToggleListening {
	if mmToggleListening.mock.inspectFuncToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("Inspect function is already set for BttMock.ToggleListening")
	}

	mmToggleListening.mock.inspectFuncToggleListening = f

	return mmToggleListening
}

// Return sets up results that will be returned by Btt.ToggleListening
func (mmToggleListening *mBttMockToggleListening) Return(err error) *BttMock {
	if mmToggleListening.mock.funcToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("BttMock.ToggleListening mock is already set by Set")
	}

	if mmToggleListening.defaultExpectation == nil {
		mmToggleListening.defaultExpectation = &BttMockToggleListeningExpectation{mock: mmToggleListening.mock}
	}
	mmToggleListening.defaultExpectation.results = &BttMockToggleListeningResults{err}
	mmToggleListening.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToggleListening.mock
}

// Set uses given function f to mock the Btt.ToggleListening method
func (mmToggleListening *mBttMockToggleListening) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmToggleListening.defaultExpectation != nil {
		mmToggleListening.mock.t.Fatalf("Default expectation is already set for the Btt.ToggleListening method")
	}

	if len(mmToggleListening.expectations) > 0 {
		mmToggleListening.mock.t.Fatalf("Some expectations are already set for the Btt.ToggleListening method")
	}

	mmToggleListening.mock.funcToggleListening = f
	mmToggleListening.mock.funcToggleListeningOrigin = minimock.CallerInfo(1)
	return mmToggleListening.mock
}

// When sets expectation for the Btt.ToggleListening which will trigger the result defined by the following
// Then helper
func (mmToggleListening *mBttMockToggleListening) When(ctx context.Context) *BttMockToggleListeningExpectation {
	if mmToggleListening.mock.funcToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("BttMock.ToggleListening mock is already set by Set")
	}

	expectation := &BttMockToggleListeningExpectation{
		mock:               mmToggleListening.mock,
		params:             &BttMockToggleListeningParams{ctx},
		expectationOrigins: BttMockToggleListeningExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToggleListening.expectations = append(mmToggleListening.expectations, expectation)
	return expectation
}

// Then sets up Btt.ToggleListening return parameters for the expectation previously defined by the When method
func (e *BttMockToggleListeningExpectation) Then(err error) *BttMock {
	e.results = &BttMockToggleListeningResults{err}
	return e.mock
}

// Times sets number of times Btt.ToggleListening should be invoked
func (mmToggleListening *mBttMockToggleListening) Times(n uint64) *mBttMockToggleListening {
	if n == 0 {
		mmToggleListening.mock.t.Fatalf("Times of BttMock.ToggleListening mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToggleListening.expectedInvocations, n)
	mmToggleListening.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToggleListening
}

func (mmToggleListening *mBttMockToggleListening) invocationsDone() bool {
	if len(mmToggleListening.expectations) == 0 && mmToggleListening.defaultExpectation == nil && mmToggleListening.mock.funcToggleListening == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToggleListening.mock.afterToggleListeningCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToggleListening.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToggleListening implements Btt
func (mmToggleListening *BttMock) ToggleListening(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmToggleListening.beforeToggleListeningCounter, 1)
	defer mm_atomic.AddUint64(&mmToggleListening.afterToggleListeningCounter, 1)

	mmToggleListening.t.Helper()

	if mmToggleListening.inspectFuncToggleListening != nil {
		mmToggleListening.inspectFuncToggleListening(ctx)
	}

	mm_params := BttMockToggleListeningParams{ctx}

	// Record call args
	mmToggleListening.ToggleListeningMock.mutex.Lock()
	mmToggleListening.ToggleListeningMock.callArgs = append(mmToggleListening.ToggleListeningMock.callArgs, &mm_params)
	mmToggleListening.ToggleListeningMock.mutex.Unlock()

	for _, e := range mmToggleListening.ToggleListeningMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmToggleListening.ToggleListeningMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToggleListening.ToggleListeningMock.defaultExpectation.Counter, 1)
		mm_want := mmToggleListening.ToggleListeningMock.defaultExpectation.params
		mm_want_ptrs := mmToggleListening.ToggleListeningMock.defaultExpectation.paramPtrs

		mm_got := BttMockToggleListeningParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmToggleListening.t.Errorf("BttMock.ToggleListening got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToggleListening.ToggleListeningMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToggleListening.t.Errorf("BttMock.ToggleListening got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToggleListening.ToggleListeningMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToggleListening.ToggleListeningMock.defaultExpectation.results
		if mm_results == nil {
			mmToggleListening.t.Fatal("No results are set for the BttMock.ToggleListening")
		}
		return (*mm_results).err
	}
	if mmToggleListening.funcToggleListening != nil {
		return mmToggleListening.funcToggleListening(ctx)
	}
	mmToggleListening.t.Fatalf("Unexpected call to BttMock.ToggleListening. %v", ctx)
	return
}

// ToggleListeningAfterCounter returns a count of finished BttMock.ToggleListening invocations
func (mmToggleListening *BttMock) ToggleListeningAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToggleListening.afterToggleListeningCounter)
}

// ToggleListeningBeforeCounter returns a count of BttMock.ToggleListening invocations
func (mmToggleListening *BttMock) ToggleListeningBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToggleListening.beforeToggleListeningCounter)
}

// Calls returns a list of arguments used in each call to BttMock.ToggleListening.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToggleListening *mBttMockToggleListening) Calls() []*BttMockToggleListeningParams {
	mmToggleListening.mutex.RLock()

	argCopy := make([]*BttMockToggleListeningParams, len(mmToggleListening.callArgs))
	copy(argCopy, mmToggleListening.callArgs)

	mmToggleListening.mutex.RUnlock()

	return argCopy
}

// MinimockToggleListeningDone returns true if the count of the ToggleListening invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockToggleListeningDone() bool {
	if m.ToggleListeningMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToggleListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToggleListeningMock.invocationsDone()
}

// MinimockToggleListeningInspect logs each unmet expectation
func (m *BttMock) MinimockToggleListeningInspect() {
	for _, e := range m.ToggleListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.ToggleListening at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToggleListeningCounter := mm_atomic.LoadUint64(&m.afterToggleListeningCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToggleListeningMock.defaultExpectation != nil && afterToggleListeningCounter < 1 {
		if m.ToggleListeningMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.ToggleListening at\n%s", m.ToggleListeningMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.ToggleListening at\n%s with params: %#v", m.ToggleListeningMock.defaultExpectation.expectationOrigins.origin, *m.ToggleListeningMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToggleListening != nil && afterToggleListeningCounter < 1 {
		m.t.Errorf("Expected call to BttMock.ToggleListening at\n%s", m.funcToggleListeningOrigin)
	}

	if !m.ToggleListeningMock.invocationsDone() && afterToggleListeningCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.ToggleListening at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToggleListeningMock.expectedInvocations), m.ToggleListeningMock.expectedInvocationsOrigin, afterToggleListeningCounter)
	}
}

type mBttMockUninstall struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockUninstallExpectation
	expectations       []*BttMockUninstallExpectation

	callArgs []*BttMockUninstallParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockUninstallExpectation specifies expectation struct of the Btt.Uninstall
type BttMockUninstallExpectation struct {
	mock               *BttMock
	params             *BttMockUninstallParams
	paramPtrs          *BttMockUninstallParamPtrs
	expectationOrigins BttMockUninstallExpectationOrigins
	results            *BttMockUninstallResults
	returnOrigin       string
	Counter            uint64
}

// BttMockUninstallParams contains parameters of the Btt.Uninstall
type BttMockUninstallParams struct {
	ctx context.Context
}

// BttMockUninstallParamPtrs contains pointers to parameters of the Btt.Uninstall
type BttMockUninstallParamPtrs struct {
	ctx *context.Context
}

// BttMockUninstallResults contains results of the Btt.Uninstall
type BttMockUninstallResults struct {
	err error
}

// BttMockUninstallOrigins contains origins of expectations of the Btt.Uninstall
type BttMockUninstallExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUninstall *mBttMockUninstall) Optional() *mBttMockUninstall {
	mmUninstall.optional = true
	return mmUninstall
}

// Expect sets up expected params for Btt.Uninstall
func (mmUninstall *mBttMockUninstall) Expect(ctx context.Context) *mBttMockUninstall {
	if mmUninstall.mock.funcUninstall != nil {
		mmUninstall.mock.t.Fatalf("BttMock.Uninstall mock is already set by Set")
	}

	if mmUninstall.defaultExpectation == nil {
		mmUninstall.defaultExpectation = &BttMockUninstallExpectation{}
	}

	if mmUninstall.defaultExpectation.paramPtrs != nil {
		mmUninstall.mock.t.Fatalf("BttMock.Uninstall mock is already set by ExpectParams functions")
	}

	mmUninstall.defaultExpectation.params = &BttMockUninstallParams{ctx}
	mmUninstall.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUninstall.expectations {
		if minimock.Equal(e.params, mmUninstall.defaultExpectation.params) {
			mmUninstall.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUninstall.defaultExpectation.params)
		}
	}

	return mmUninstall
}

// ExpectCtxParam1 sets up expected param ctx for Btt.Uninstall
func (mmUninstall *mBttMockUninstall) ExpectCtxParam1(ctx context.Context) *mBttMockUninstall {
	if mmUninstall.mock.funcUninstall != nil {
		mmUninstall.mock.t.Fatalf("BttMock.Uninstall mock is already set by Set")
	}

	if mmUninstall.defaultExpectation == nil {
		mmUninstall.defaultExpectation = &BttMockUninstallExpectation{}
	}

	if mmUninstall.defaultExpectation.params != nil {
		mmUninstall.mock.t.Fatalf("BttMock.Uninstall mock is already set by Expect")
	}

	if mmUninstall.defaultExpectation.paramPtrs == nil {
		mmUninstall.defaultExpectation.paramPtrs = &BttMockUninstallParamPtrs{}
	}
	mmUninstall.defaultExpectation.paramPtrs.ctx = &ctx
	mmUninstall.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUninstall
}

// Inspect accepts an inspector function that has same arguments as the Btt.Uninstall
func (mmUninstall *mBttMockUninstall) Inspect(f func(ctx context.Context)) *mBttMockUninstall {
	if mmUninstall.mock.inspectFuncUninstall != nil {
		mmUninstall.mock.t.Fatalf("Inspect function is already set for BttMock.Uninstall")
	}

	mmUninstall.mock.inspectFuncUninstall = f

	return mmUninstall
}

// Return sets up results that will be returned by Btt.Uninstall
func (mmUninstall *mBttMockUninstall) Return(err error) *BttMock {
	if mmUninstall.mock.funcUninstall != nil {
		mmUninstall.mock.t.Fatalf("BttMock.Uninstall mock is already set by Set")
	}

	if mmUninstall.defaultExpectation == nil {
		mmUninstall.defaultExpectation = &BttMockUninstallExpectation{mock: mmUninstall.mock}
	}
	mmUninstall.defaultExpectation.results = &BttMockUninstallResults{err}
	mmUninstall.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUninstall.mock
}

// Set uses given function f to mock the Btt.Uninstall method
func (mmUninstall *mBttMockUninstall) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmUninstall.defaultExpectation != nil {
		mmUninstall.mock.t.Fatalf("Default expectation is already set for the Btt.Uninstall method")
	}

	if len(mmUninstall.expectations) > 0 {
		mmUninstall.mock.t.Fatalf("Some expectations are already set for the Btt.Uninstall method")
	}

	mmUninstall.mock.funcUninstall = f
	mmUninstall.mock.funcUninstallOrigin = minimock.CallerInfo(1)
	return mmUninstall.mock
}

// When sets expectation for the Btt.Uninstall which will trigger the result defined by the following
// Then helper
func (mmUninstall *mBttMockUninstall) When(ctx context.Context) *BttMockUninstallExpectation {
	if mmUninstall.mock.funcUninstall != nil {
		mmUninstall.mock.t.Fatalf("BttMock.Uninstall mock is already set by Set")
	}

	expectation := &BttMockUninstallExpectation{
		mock:               mmUninstall.mock,
		params:             &BttMockUninstallParams{ctx},
		expectationOrigins: BttMockUninstallExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUninstall.expectations = append(mmUninstall.expectations, expectation)
	return expectation
}

// Then sets up Btt.Uninstall return parameters for the expectation previously defined by the When method
func (e *BttMockUninstallExpectation) Then(err error) *BttMock {
	e.results = &BttMockUninstallResults{err}
	return e.mock
}

// Times sets number of times Btt.Uninstall should be invoked
func (mmUninstall *mBttMockUninstall) Times(n uint64) *mBttMockUninstall {
	if n == 0 {
		mmUninstall.mock.t.Fatalf("Times of BttMock.Uninstall mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUninstall.expectedInvocations, n)
	mmUninstall.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUninstall
}

func (mmUninstall *mBttMockUninstall) invocationsDone() bool {
	if len(mmUninstall.expectations) == 0 && mmUninstall.defaultExpectation == nil && mmUninstall.mock.funcUninstall == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUninstall.mock.afterUninstallCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUninstall.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Uninstall implements Btt
func (mmUninstall *BttMock) Uninstall(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmUninstall.beforeUninstallCounter, 1)
	defer mm_atomic.AddUint64(&mmUninstall.afterUninstallCounter, 1)

	mmUninstall.t.Helper()

	if mmUninstall.inspectFuncUninstall != nil {
		mmUninstall.inspectFuncUninstall(ctx)
	}

	mm_params := BttMockUninstallParams{ctx}

	// Record call args
	mmUninstall.UninstallMock.mutex.Lock()
	mmUninstall.UninstallMock.callArgs = append(mmUninstall.UninstallMock.callArgs, &mm_params)
	mmUninstall.UninstallMock.mutex.Unlock()

	for _, e := range mmUninstall.UninstallMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUninstall.UninstallMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUninstall.UninstallMock.defaultExpectation.Counter, 1)
		mm_want := mmUninstall.UninstallMock.defaultExpectation.params
		mm_want_ptrs := mmUninstall.UninstallMock.defaultExpectation.paramPtrs

		mm_got := BttMockUninstallParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUninstall.t.Errorf("BttMock.Uninstall got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUninstall.UninstallMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUninstall.t.Errorf("BttMock.Uninstall got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUninstall.UninstallMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUninstall.UninstallMock.defaultExpectation.results
		if mm_results == nil {
			mmUninstall.t.Fatal("No results are set for the BttMock.Uninstall")
		}
		return (*mm_results).err
	}
	if mmUninstall.funcUninstall != nil {
		return mmUninstall.funcUninstall(ctx)
	}
	mmUninstall.t.Fatalf("Unexpected call to BttMock.Uninstall. %v", ctx)
	return
}

// UninstallAfterCounter returns a count of finished BttMock.Uninstall invocations
func (mmUninstall *BttMock) UninstallAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUninstall.afterUninstallCounter)
}

// UninstallBeforeCounter returns a count of BttMock.Uninstall invocations
func (mmUninstall *BttMock) UninstallBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUninstall.beforeUninstallCounter)
}

// Calls returns a list of arguments used in each call to BttMock.Uninstall.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUninstall *mBttMockUninstall) Calls() []*BttMockUninstallParams {
	mmUninstall.mutex.RLock()

	argCopy := make([]*BttMockUninstallParams, len(mmUninstall.callArgs))
	copy(argCopy, mmUninstall.callArgs)

	mmUninstall.mutex.RUnlock()

	return argCopy
}

// MinimockUninstallDone returns true if the count of the Uninstall invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockUninstallDone() bool {
	if m.UninstallMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UninstallMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UninstallMock.invocationsDone()
}

// MinimockUninstallInspect logs each unmet expectation
func (m *BttMock) MinimockUninstallInspect() {
	for _, e := range m.UninstallMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.Uninstall at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUninstallCounter := mm_atomic.LoadUint64(&m.afterUninstallCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UninstallMock.defaultExpectation != nil && afterUninstallCounter < 1 {
		if m.UninstallMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.Uninstall at\n%s", m.UninstallMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.Uninstall at\n%s with params: %#v", m.UninstallMock.defaultExpectation.expectationOrigins.origin, *m.UninstallMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUninstall != nil && afterUninstallCounter < 1 {
		m.t.Errorf("Expected call to BttMock.Uninstall at\n%s", m.funcUninstallOrigin)
	}

	if !m.UninstallMock.invocationsDone() && afterUninstallCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.Uninstall at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UninstallMock.expectedInvocations), m.UninstallMock.expectedInvocationsOrigin, afterUninstallCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BttMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDisableCleanViewInspect()

			m.MinimockEnableCleanModeInspect()

			m.MinimockFloatingPageInspect()

			m.MinimockHealthInspect()

			m.MinimockHideClipboardInspect()

			m.MinimockHideFloatingInspect()

			m.MinimockInstallInspect()

			m.MinimockIsAvailableInspect()

			m.MinimockIsRunningInspect()

			m.MinimockLoadDevicesInspect()

			m.MinimockSelectClipboardInspect()

			m.MinimockSelectDeviceInspect()

			m.MinimockSelectFloatingInspect()

			m.MinimockSelectLanguageInspect()

			m.MinimockSelectViewModeInspect()

			m.MinimockSelectedClipboardInspect()

			m.MinimockSelectedDeviceInspect()

			m.MinimockSelectedFloatingInspect()

			m.MinimockSelectedLanguageInspect()

			m.MinimockSelectedViewModeInspect()

			m.MinimockShowClipboardInspect()

			m.MinimockShowFloatingInspect()

			m.MinimockStartListeningInspect()

			m.MinimockStopListeningInspect()

			m.MinimockStreamTextInspect()

			m.MinimockTextInspect()

			m.MinimockToggleListeningInspect()

			m.MinimockUninstallInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BttMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BttMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDisableCleanViewDone() &&
		m.MinimockEnableCleanModeDone() &&
		m.MinimockFloatingPageDone() &&
		m.MinimockHealthDone() &&
		m.MinimockHideClipboardDone() &&
		m.MinimockHideFloatingDone() &&
		m.MinimockInstallDone() &&
		m.MinimockIsAvailableDone() &&
		m.MinimockIsRunningDone() &&
		m.MinimockLoadDevicesDone() &&
		m.MinimockSelectClipboardDone() &&
		m.MinimockSelectDeviceDone() &&
		m.MinimockSelectFloatingDone() &&
		m.MinimockSelectLanguageDone() &&
		m.MinimockSelectViewModeDone() &&
		m.MinimockSelectedClipboardDone() &&
		m.MinimockSelectedDeviceDone() &&
		m.MinimockSelectedFloatingDone() &&
		m.MinimockSelectedLanguageDone() &&
		m.MinimockSelectedViewModeDone() &&
		m.MinimockShowClipboardDone() &&
		m.MinimockShowFloatingDone() &&
		m.MinimockStartListeningDone() &&
		m.MinimockStopListeningDone() &&
		m.MinimockStreamTextDone() &&
		m.MinimockTextDone() &&
		m.MinimockToggleListeningDone() &&
		m.MinimockUninstallDone()
}
