// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package btt

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// BttMock implements Btt
type BttMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClear          func(ctx context.Context) (err error)
	funcClearOrigin    string
	inspectFuncClear   func(ctx context.Context)
	afterClearCounter  uint64
	beforeClearCounter uint64
	ClearMock          mBttMockClear

	funcDisableCleanView          func(ctx context.Context) (err error)
	funcDisableCleanViewOrigin    string
	inspectFuncDisableCleanView   func(ctx context.Context)
	afterDisableCleanViewCounter  uint64
	beforeDisableCleanViewCounter uint64
	DisableCleanViewMock          mBttMockDisableCleanView

	funcEnableCleanMode          func(ctx context.Context) (err error)
	funcEnableCleanModeOrigin    string
	inspectFuncEnableCleanMode   func(ctx context.Context)
	afterEnableCleanModeCounter  uint64
	beforeEnableCleanModeCounter uint64
	EnableCleanModeMock          mBttMockEnableCleanMode

	funcFloatingPage          func() (s1 string)
	funcFloatingPageOrigin    string
	inspectFuncFloatingPage   func()
	afterFloatingPageCounter  uint64
	beforeFloatingPageCounter uint64
	FloatingPageMock          mBttMockFloatingPage

	funcHideFloating          func(ctx context.Context) (err error)
	funcHideFloatingOrigin    string
	inspectFuncHideFloating   func(ctx context.Context)
	afterHideFloatingCounter  uint64
	beforeHideFloatingCounter uint64
	HideFloatingMock          mBttMockHideFloating

	funcInitialize          func(ctx context.Context) (err error)
	funcInitializeOrigin    string
	inspectFuncInitialize   func(ctx context.Context)
	afterInitializeCounter  uint64
	beforeInitializeCounter uint64
	InitializeMock          mBttMockInitialize

	funcIsRunning          func(ctx context.Context) (b1 bool, err error)
	funcIsRunningOrigin    string
	inspectFuncIsRunning   func(ctx context.Context)
	afterIsRunningCounter  uint64
	beforeIsRunningCounter uint64
	IsRunningMock          mBttMockIsRunning

	funcLoadDevices          func(ctx context.Context) (err error)
	funcLoadDevicesOrigin    string
	inspectFuncLoadDevices   func(ctx context.Context)
	afterLoadDevicesCounter  uint64
	beforeLoadDevicesCounter uint64
	LoadDevicesMock          mBttMockLoadDevices

	funcSelectDevice          func(ctx context.Context, device string) (err error)
	funcSelectDeviceOrigin    string
	inspectFuncSelectDevice   func(ctx context.Context, device string)
	afterSelectDeviceCounter  uint64
	beforeSelectDeviceCounter uint64
	SelectDeviceMock          mBttMockSelectDevice

	funcSelectFloating          func(ctx context.Context, floating Floating) (err error)
	funcSelectFloatingOrigin    string
	inspectFuncSelectFloating   func(ctx context.Context, floating Floating)
	afterSelectFloatingCounter  uint64
	beforeSelectFloatingCounter uint64
	SelectFloatingMock          mBttMockSelectFloating

	funcSelectLanguage          func(ctx context.Context, language string) (err error)
	funcSelectLanguageOrigin    string
	inspectFuncSelectLanguage   func(ctx context.Context, language string)
	afterSelectLanguageCounter  uint64
	beforeSelectLanguageCounter uint64
	SelectLanguageMock          mBttMockSelectLanguage

	funcSelectViewMode          func(ctx context.Context, viewMode ViewMode) (err error)
	funcSelectViewModeOrigin    string
	inspectFuncSelectViewMode   func(ctx context.Context, viewMode ViewMode)
	afterSelectViewModeCounter  uint64
	beforeSelectViewModeCounter uint64
	SelectViewModeMock          mBttMockSelectViewMode

	funcSelectedDevice          func(ctx context.Context) (s1 string, err error)
	funcSelectedDeviceOrigin    string
	inspectFuncSelectedDevice   func(ctx context.Context)
	afterSelectedDeviceCounter  uint64
	beforeSelectedDeviceCounter uint64
	SelectedDeviceMock          mBttMockSelectedDevice

	funcSelectedFloating          func(ctx context.Context) (f1 Floating, err error)
	funcSelectedFloatingOrigin    string
	inspectFuncSelectedFloating   func(ctx context.Context)
	afterSelectedFloatingCounter  uint64
	beforeSelectedFloatingCounter uint64
	SelectedFloatingMock          mBttMockSelectedFloating

	funcSelectedLanguage          func(ctx context.Context) (s1 string, err error)
	funcSelectedLanguageOrigin    string
	inspectFuncSelectedLanguage   func(ctx context.Context)
	afterSelectedLanguageCounter  uint64
	beforeSelectedLanguageCounter uint64
	SelectedLanguageMock          mBttMockSelectedLanguage

	funcSelectedViewMode          func(ctx context.Context) (v1 ViewMode, err error)
	funcSelectedViewModeOrigin    string
	inspectFuncSelectedViewMode   func(ctx context.Context)
	afterSelectedViewModeCounter  uint64
	beforeSelectedViewModeCounter uint64
	SelectedViewModeMock          mBttMockSelectedViewMode

	funcShowFloating          func(ctx context.Context) (err error)
	funcShowFloatingOrigin    string
	inspectFuncShowFloating   func(ctx context.Context)
	afterShowFloatingCounter  uint64
	beforeShowFloatingCounter uint64
	ShowFloatingMock          mBttMockShowFloating

	funcStartListening          func(ctx context.Context) (err error)
	funcStartListeningOrigin    string
	inspectFuncStartListening   func(ctx context.Context)
	afterStartListeningCounter  uint64
	beforeStartListeningCounter uint64
	StartListeningMock          mBttMockStartListening

	funcStopListening          func(ctx context.Context) (err error)
	funcStopListeningOrigin    string
	inspectFuncStopListening   func(ctx context.Context)
	afterStopListeningCounter  uint64
	beforeStopListeningCounter uint64
	StopListeningMock          mBttMockStopListening

	funcStreamText          func(ctx context.Context) (ch1 <-chan string, ch2 <-chan error, err error)
	funcStreamTextOrigin    string
	inspectFuncStreamText   func(ctx context.Context)
	afterStreamTextCounter  uint64
	beforeStreamTextCounter uint64
	StreamTextMock          mBttMockStreamText

	funcToggleListening          func(ctx context.Context) (err error)
	funcToggleListeningOrigin    string
	inspectFuncToggleListening   func(ctx context.Context)
	afterToggleListeningCounter  uint64
	beforeToggleListeningCounter uint64
	ToggleListeningMock          mBttMockToggleListening
}

// NewBttMock returns a mock for Btt
func NewBttMock(t minimock.Tester) *BttMock {
	m := &BttMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ClearMock = mBttMockClear{mock: m}
	m.ClearMock.callArgs = []*BttMockClearParams{}

	m.DisableCleanViewMock = mBttMockDisableCleanView{mock: m}
	m.DisableCleanViewMock.callArgs = []*BttMockDisableCleanViewParams{}

	m.EnableCleanModeMock = mBttMockEnableCleanMode{mock: m}
	m.EnableCleanModeMock.callArgs = []*BttMockEnableCleanModeParams{}

	m.FloatingPageMock = mBttMockFloatingPage{mock: m}

	m.HideFloatingMock = mBttMockHideFloating{mock: m}
	m.HideFloatingMock.callArgs = []*BttMockHideFloatingParams{}

	m.InitializeMock = mBttMockInitialize{mock: m}
	m.InitializeMock.callArgs = []*BttMockInitializeParams{}

	m.IsRunningMock = mBttMockIsRunning{mock: m}
	m.IsRunningMock.callArgs = []*BttMockIsRunningParams{}

	m.LoadDevicesMock = mBttMockLoadDevices{mock: m}
	m.LoadDevicesMock.callArgs = []*BttMockLoadDevicesParams{}

	m.SelectDeviceMock = mBttMockSelectDevice{mock: m}
	m.SelectDeviceMock.callArgs = []*BttMockSelectDeviceParams{}

	m.SelectFloatingMock = mBttMockSelectFloating{mock: m}
	m.SelectFloatingMock.callArgs = []*BttMockSelectFloatingParams{}

	m.SelectLanguageMock = mBttMockSelectLanguage{mock: m}
	m.SelectLanguageMock.callArgs = []*BttMockSelectLanguageParams{}

	m.SelectViewModeMock = mBttMockSelectViewMode{mock: m}
	m.SelectViewModeMock.callArgs = []*BttMockSelectViewModeParams{}

	m.SelectedDeviceMock = mBttMockSelectedDevice{mock: m}
	m.SelectedDeviceMock.callArgs = []*BttMockSelectedDeviceParams{}

	m.SelectedFloatingMock = mBttMockSelectedFloating{mock: m}
	m.SelectedFloatingMock.callArgs = []*BttMockSelectedFloatingParams{}

	m.SelectedLanguageMock = mBttMockSelectedLanguage{mock: m}
	m.SelectedLanguageMock.callArgs = []*BttMockSelectedLanguageParams{}

	m.SelectedViewModeMock = mBttMockSelectedViewMode{mock: m}
	m.SelectedViewModeMock.callArgs = []*BttMockSelectedViewModeParams{}

	m.ShowFloatingMock = mBttMockShowFloating{mock: m}
	m.ShowFloatingMock.callArgs = []*BttMockShowFloatingParams{}

	m.StartListeningMock = mBttMockStartListening{mock: m}
	m.StartListeningMock.callArgs = []*BttMockStartListeningParams{}

	m.StopListeningMock = mBttMockStopListening{mock: m}
	m.StopListeningMock.callArgs = []*BttMockStopListeningParams{}

	m.StreamTextMock = mBttMockStreamText{mock: m}
	m.StreamTextMock.callArgs = []*BttMockStreamTextParams{}

	m.ToggleListeningMock = mBttMockToggleListening{mock: m}
	m.ToggleListeningMock.callArgs = []*BttMockToggleListeningParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mBttMockClear struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockClearExpectation
	expectations       []*BttMockClearExpectation

	callArgs []*BttMockClearParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockClearExpectation specifies expectation struct of the Btt.Clear
type BttMockClearExpectation struct {
	mock               *BttMock
	params             *BttMockClearParams
	paramPtrs          *BttMockClearParamPtrs
	expectationOrigins BttMockClearExpectationOrigins
	results            *BttMockClearResults
	returnOrigin       string
	Counter            uint64
}

// BttMockClearParams contains parameters of the Btt.Clear
type BttMockClearParams struct {
	ctx context.Context
}

// BttMockClearParamPtrs contains pointers to parameters of the Btt.Clear
type BttMockClearParamPtrs struct {
	ctx *context.Context
}

// BttMockClearResults contains results of the Btt.Clear
type BttMockClearResults struct {
	err error
}

// BttMockClearOrigins contains origins of expectations of the Btt.Clear
type BttMockClearExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClear *mBttMockClear) Optional() *mBttMockClear {
	mmClear.optional = true
	return mmClear
}

// Expect sets up expected params for Btt.Clear
func (mmClear *mBttMockClear) Expect(ctx context.Context) *mBttMockClear {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("BttMock.Clear mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &BttMockClearExpectation{}
	}

	if mmClear.defaultExpectation.paramPtrs != nil {
		mmClear.mock.t.Fatalf("BttMock.Clear mock is already set by ExpectParams functions")
	}

	mmClear.defaultExpectation.params = &BttMockClearParams{ctx}
	mmClear.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClear.expectations {
		if minimock.Equal(e.params, mmClear.defaultExpectation.params) {
			mmClear.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClear.defaultExpectation.params)
		}
	}

	return mmClear
}

// ExpectCtxParam1 sets up expected param ctx for Btt.Clear
func (mmClear *mBttMockClear) ExpectCtxParam1(ctx context.Context) *mBttMockClear {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("BttMock.Clear mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &BttMockClearExpectation{}
	}

	if mmClear.defaultExpectation.params != nil {
		mmClear.mock.t.Fatalf("BttMock.Clear mock is already set by Expect")
	}

	if mmClear.defaultExpectation.paramPtrs == nil {
		mmClear.defaultExpectation.paramPtrs = &BttMockClearParamPtrs{}
	}
	mmClear.defaultExpectation.paramPtrs.ctx = &ctx
	mmClear.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmClear
}

// Inspect accepts an inspector function that has same arguments as the Btt.Clear
func (mmClear *mBttMockClear) Inspect(f func(ctx context.Context)) *mBttMockClear {
	if mmClear.mock.inspectFuncClear != nil {
		mmClear.mock.t.Fatalf("Inspect function is already set for BttMock.Clear")
	}

	mmClear.mock.inspectFuncClear = f

	return mmClear
}

// Return sets up results that will be returned by Btt.Clear
func (mmClear *mBttMockClear) Return(err error) *BttMock {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("BttMock.Clear mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &BttMockClearExpectation{mock: mmClear.mock}
	}
	mmClear.defaultExpectation.results = &BttMockClearResults{err}
	mmClear.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClear.mock
}

// Set uses given function f to mock the Btt.Clear method
func (mmClear *mBttMockClear) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmClear.defaultExpectation != nil {
		mmClear.mock.t.Fatalf("Default expectation is already set for the Btt.Clear method")
	}

	if len(mmClear.expectations) > 0 {
		mmClear.mock.t.Fatalf("Some expectations are already set for the Btt.Clear method")
	}

	mmClear.mock.funcClear = f
	mmClear.mock.funcClearOrigin = minimock.CallerInfo(1)
	return mmClear.mock
}

// When sets expectation for the Btt.Clear which will trigger the result defined by the following
// Then helper
func (mmClear *mBttMockClear) When(ctx context.Context) *BttMockClearExpectation {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("BttMock.Clear mock is already set by Set")
	}

	expectation := &BttMockClearExpectation{
		mock:               mmClear.mock,
		params:             &BttMockClearParams{ctx},
		expectationOrigins: BttMockClearExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClear.expectations = append(mmClear.expectations, expectation)
	return expectation
}

// Then sets up Btt.Clear return parameters for the expectation previously defined by the When method
func (e *BttMockClearExpectation) Then(err error) *BttMock {
	e.results = &BttMockClearResults{err}
	return e.mock
}

// Times sets number of times Btt.Clear should be invoked
func (mmClear *mBttMockClear) Times(n uint64) *mBttMockClear {
	if n == 0 {
		mmClear.mock.t.Fatalf("Times of BttMock.Clear mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClear.expectedInvocations, n)
	mmClear.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClear
}

func (mmClear *mBttMockClear) invocationsDone() bool {
	if len(mmClear.expectations) == 0 && mmClear.defaultExpectation == nil && mmClear.mock.funcClear == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClear.mock.afterClearCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClear.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Clear implements Btt
func (mmClear *BttMock) Clear(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmClear.beforeClearCounter, 1)
	defer mm_atomic.AddUint64(&mmClear.afterClearCounter, 1)

	mmClear.t.Helper()

	if mmClear.inspectFuncClear != nil {
		mmClear.inspectFuncClear(ctx)
	}

	mm_params := BttMockClearParams{ctx}

	// Record call args
	mmClear.ClearMock.mutex.Lock()
	mmClear.ClearMock.callArgs = append(mmClear.ClearMock.callArgs, &mm_params)
	mmClear.ClearMock.mutex.Unlock()

	for _, e := range mmClear.ClearMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClear.ClearMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClear.ClearMock.defaultExpectation.Counter, 1)
		mm_want := mmClear.ClearMock.defaultExpectation.params
		mm_want_ptrs := mmClear.ClearMock.defaultExpectation.paramPtrs

		mm_got := BttMockClearParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClear.t.Errorf("BttMock.Clear got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClear.ClearMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClear.t.Errorf("BttMock.Clear got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClear.ClearMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClear.ClearMock.defaultExpectation.results
		if mm_results == nil {
			mmClear.t.Fatal("No results are set for the BttMock.Clear")
		}
		return (*mm_results).err
	}
	if mmClear.funcClear != nil {
		return mmClear.funcClear(ctx)
	}
	mmClear.t.Fatalf("Unexpected call to BttMock.Clear. %v", ctx)
	return
}

// ClearAfterCounter returns a count of finished BttMock.Clear invocations
func (mmClear *BttMock) ClearAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClear.afterClearCounter)
}

// ClearBeforeCounter returns a count of BttMock.Clear invocations
func (mmClear *BttMock) ClearBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClear.beforeClearCounter)
}

// Calls returns a list of arguments used in each call to BttMock.Clear.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClear *mBttMockClear) Calls() []*BttMockClearParams {
	mmClear.mutex.RLock()

	argCopy := make([]*BttMockClearParams, len(mmClear.callArgs))
	copy(argCopy, mmClear.callArgs)

	mmClear.mutex.RUnlock()

	return argCopy
}

// MinimockClearDone returns true if the count of the Clear invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockClearDone() bool {
	if m.ClearMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearMock.invocationsDone()
}

// MinimockClearInspect logs each unmet expectation
func (m *BttMock) MinimockClearInspect() {
	for _, e := range m.ClearMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.Clear at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClearCounter := mm_atomic.LoadUint64(&m.afterClearCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearMock.defaultExpectation != nil && afterClearCounter < 1 {
		if m.ClearMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.Clear at\n%s", m.ClearMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.Clear at\n%s with params: %#v", m.ClearMock.defaultExpectation.expectationOrigins.origin, *m.ClearMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClear != nil && afterClearCounter < 1 {
		m.t.Errorf("Expected call to BttMock.Clear at\n%s", m.funcClearOrigin)
	}

	if !m.ClearMock.invocationsDone() && afterClearCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.Clear at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearMock.expectedInvocations), m.ClearMock.expectedInvocationsOrigin, afterClearCounter)
	}
}

type mBttMockDisableCleanView struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockDisableCleanViewExpectation
	expectations       []*BttMockDisableCleanViewExpectation

	callArgs []*BttMockDisableCleanViewParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockDisableCleanViewExpectation specifies expectation struct of the Btt.DisableCleanView
type BttMockDisableCleanViewExpectation struct {
	mock               *BttMock
	params             *BttMockDisableCleanViewParams
	paramPtrs          *BttMockDisableCleanViewParamPtrs
	expectationOrigins BttMockDisableCleanViewExpectationOrigins
	results            *BttMockDisableCleanViewResults
	returnOrigin       string
	Counter            uint64
}

// BttMockDisableCleanViewParams contains parameters of the Btt.DisableCleanView
type BttMockDisableCleanViewParams struct {
	ctx context.Context
}

// BttMockDisableCleanViewParamPtrs contains pointers to parameters of the Btt.DisableCleanView
type BttMockDisableCleanViewParamPtrs struct {
	ctx *context.Context
}

// BttMockDisableCleanViewResults contains results of the Btt.DisableCleanView
type BttMockDisableCleanViewResults struct {
	err error
}

// BttMockDisableCleanViewOrigins contains origins of expectations of the Btt.DisableCleanView
type BttMockDisableCleanViewExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDisableCleanView *mBttMockDisableCleanView) Optional() *mBttMockDisableCleanView {
	mmDisableCleanView.optional = true
	return mmDisableCleanView
}

// Expect sets up expected params for Btt.DisableCleanView
func (mmDisableCleanView *mBttMockDisableCleanView) Expect(ctx context.Context) *mBttMockDisableCleanView {
	if mmDisableCleanView.mock.funcDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("BttMock.DisableCleanView mock is already set by Set")
	}

	if mmDisableCleanView.defaultExpectation == nil {
		mmDisableCleanView.defaultExpectation = &BttMockDisableCleanViewExpectation{}
	}

	if mmDisableCleanView.defaultExpectation.paramPtrs != nil {
		mmDisableCleanView.mock.t.Fatalf("BttMock.DisableCleanView mock is already set by ExpectParams functions")
	}

	mmDisableCleanView.defaultExpectation.params = &BttMockDisableCleanViewParams{ctx}
	mmDisableCleanView.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDisableCleanView.expectations {
		if minimock.Equal(e.params, mmDisableCleanView.defaultExpectation.params) {
			mmDisableCleanView.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDisableCleanView.defaultExpectation.params)
		}
	}

	return mmDisableCleanView
}

// ExpectCtxParam1 sets up expected param ctx for Btt.DisableCleanView
func (mmDisableCleanView *mBttMockDisableCleanView) ExpectCtxParam1(ctx context.Context) *mBttMockDisableCleanView {
	if mmDisableCleanView.mock.funcDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("BttMock.DisableCleanView mock is already set by Set")
	}

	if mmDisableCleanView.defaultExpectation == nil {
		mmDisableCleanView.defaultExpectation = &BttMockDisableCleanViewExpectation{}
	}

	if mmDisableCleanView.defaultExpectation.params != nil {
		mmDisableCleanView.mock.t.Fatalf("BttMock.DisableCleanView mock is already set by Expect")
	}

	if mmDisableCleanView.defaultExpectation.paramPtrs == nil {
		mmDisableCleanView.defaultExpectation.paramPtrs = &BttMockDisableCleanViewParamPtrs{}
	}
	mmDisableCleanView.defaultExpectation.paramPtrs.ctx = &ctx
	mmDisableCleanView.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDisableCleanView
}

// Inspect accepts an inspector function that has same arguments as the Btt.DisableCleanView
func (mmDisableCleanView *mBttMockDisableCleanView) Inspect(f func(ctx context.Context)) *mBttMockDisableCleanView {
	if mmDisableCleanView.mock.inspectFuncDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("Inspect function is already set for BttMock.DisableCleanView")
	}

	mmDisableCleanView.mock.inspectFuncDisableCleanView = f

	return mmDisableCleanView
}

// Return sets up results that will be returned by Btt.DisableCleanView
func (mmDisableCleanView *mBttMockDisableCleanView) Return(err error) *BttMock {
	if mmDisableCleanView.mock.funcDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("BttMock.DisableCleanView mock is already set by Set")
	}

	if mmDisableCleanView.defaultExpectation == nil {
		mmDisableCleanView.defaultExpectation = &BttMockDisableCleanViewExpectation{mock: mmDisableCleanView.mock}
	}
	mmDisableCleanView.defaultExpectation.results = &BttMockDisableCleanViewResults{err}
	mmDisableCleanView.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDisableCleanView.mock
}

// Set uses given function f to mock the Btt.DisableCleanView method
func (mmDisableCleanView *mBttMockDisableCleanView) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmDisableCleanView.defaultExpectation != nil {
		mmDisableCleanView.mock.t.Fatalf("Default expectation is already set for the Btt.DisableCleanView method")
	}

	if len(mmDisableCleanView.expectations) > 0 {
		mmDisableCleanView.mock.t.Fatalf("Some expectations are already set for the Btt.DisableCleanView method")
	}

	mmDisableCleanView.mock.funcDisableCleanView = f
	mmDisableCleanView.mock.funcDisableCleanViewOrigin = minimock.CallerInfo(1)
	return mmDisableCleanView.mock
}

// When sets expectation for the Btt.DisableCleanView which will trigger the result defined by the following
// Then helper
func (mmDisableCleanView *mBttMockDisableCleanView) When(ctx context.Context) *BttMockDisableCleanViewExpectation {
	if mmDisableCleanView.mock.funcDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("BttMock.DisableCleanView mock is already set by Set")
	}

	expectation := &BttMockDisableCleanViewExpectation{
		mock:               mmDisableCleanView.mock,
		params:             &BttMockDisableCleanViewParams{ctx},
		expectationOrigins: BttMockDisableCleanViewExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDisableCleanView.expectations = append(mmDisableCleanView.expectations, expectation)
	return expectation
}

// Then sets up Btt.DisableCleanView return parameters for the expectation previously defined by the When method
func (e *BttMockDisableCleanViewExpectation) Then(err error) *BttMock {
	e.results = &BttMockDisableCleanViewResults{err}
	return e.mock
}

// Times sets number of times Btt.DisableCleanView should be invoked
func (mmDisableCleanView *mBttMockDisableCleanView) Times(n uint64) *mBttMockDisableCleanView {
	if n == 0 {
		mmDisableCleanView.mock.t.Fatalf("Times of BttMock.DisableCleanView mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDisableCleanView.expectedInvocations, n)
	mmDisableCleanView.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDisableCleanView
}

func (mmDisableCleanView *mBttMockDisableCleanView) invocationsDone() bool {
	if len(mmDisableCleanView.expectations) == 0 && mmDisableCleanView.defaultExpectation == nil && mmDisableCleanView.mock.funcDisableCleanView == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDisableCleanView.mock.afterDisableCleanViewCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDisableCleanView.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DisableCleanView implements Btt
func (mmDisableCleanView *BttMock) DisableCleanView(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmDisableCleanView.beforeDisableCleanViewCounter, 1)
	defer mm_atomic.AddUint64(&mmDisableCleanView.afterDisableCleanViewCounter, 1)

	mmDisableCleanView.t.Helper()

	if mmDisableCleanView.inspectFuncDisableCleanView != nil {
		mmDisableCleanView.inspectFuncDisableCleanView(ctx)
	}

	mm_params := BttMockDisableCleanViewParams{ctx}

	// Record call args
	mmDisableCleanView.DisableCleanViewMock.mutex.Lock()
	mmDisableCleanView.DisableCleanViewMock.callArgs = append(mmDisableCleanView.DisableCleanViewMock.callArgs, &mm_params)
	mmDisableCleanView.DisableCleanViewMock.mutex.Unlock()

	for _, e := range mmDisableCleanView.DisableCleanViewMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDisableCleanView.DisableCleanViewMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDisableCleanView.DisableCleanViewMock.defaultExpectation.Counter, 1)
		mm_want := mmDisableCleanView.DisableCleanViewMock.defaultExpectation.params
		mm_want_ptrs := mmDisableCleanView.DisableCleanViewMock.defaultExpectation.paramPtrs

		mm_got := BttMockDisableCleanViewParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDisableCleanView.t.Errorf("BttMock.DisableCleanView got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDisableCleanView.DisableCleanViewMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDisableCleanView.t.Errorf("BttMock.DisableCleanView got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDisableCleanView.DisableCleanViewMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDisableCleanView.DisableCleanViewMock.defaultExpectation.results
		if mm_results == nil {
			mmDisableCleanView.t.Fatal("No results are set for the BttMock.DisableCleanView")
		}
		return (*mm_results).err
	}
	if mmDisableCleanView.funcDisableCleanView != nil {
		return mmDisableCleanView.funcDisableCleanView(ctx)
	}
	mmDisableCleanView.t.Fatalf("Unexpected call to BttMock.DisableCleanView. %v", ctx)
	return
}

// DisableCleanViewAfterCounter returns a count of finished BttMock.DisableCleanView invocations
func (mmDisableCleanView *BttMock) DisableCleanViewAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDisableCleanView.afterDisableCleanViewCounter)
}

// DisableCleanViewBeforeCounter returns a count of BttMock.DisableCleanView invocations
func (mmDisableCleanView *BttMock) DisableCleanViewBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDisableCleanView.beforeDisableCleanViewCounter)
}

// Calls returns a list of arguments used in each call to BttMock.DisableCleanView.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDisableCleanView *mBttMockDisableCleanView) Calls() []*BttMockDisableCleanViewParams {
	mmDisableCleanView.mutex.RLock()

	argCopy := make([]*BttMockDisableCleanViewParams, len(mmDisableCleanView.callArgs))
	copy(argCopy, mmDisableCleanView.callArgs)

	mmDisableCleanView.mutex.RUnlock()

	return argCopy
}

// MinimockDisableCleanViewDone returns true if the count of the DisableCleanView invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockDisableCleanViewDone() bool {
	if m.DisableCleanViewMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DisableCleanViewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DisableCleanViewMock.invocationsDone()
}

// MinimockDisableCleanViewInspect logs each unmet expectation
func (m *BttMock) MinimockDisableCleanViewInspect() {
	for _, e := range m.DisableCleanViewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.DisableCleanView at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDisableCleanViewCounter := mm_atomic.LoadUint64(&m.afterDisableCleanViewCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DisableCleanViewMock.defaultExpectation != nil && afterDisableCleanViewCounter < 1 {
		if m.DisableCleanViewMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.DisableCleanView at\n%s", m.DisableCleanViewMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.DisableCleanView at\n%s with params: %#v", m.DisableCleanViewMock.defaultExpectation.expectationOrigins.origin, *m.DisableCleanViewMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDisableCleanView != nil && afterDisableCleanViewCounter < 1 {
		m.t.Errorf("Expected call to BttMock.DisableCleanView at\n%s", m.funcDisableCleanViewOrigin)
	}

	if !m.DisableCleanViewMock.invocationsDone() && afterDisableCleanViewCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.DisableCleanView at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DisableCleanViewMock.expectedInvocations), m.DisableCleanViewMock.expectedInvocationsOrigin, afterDisableCleanViewCounter)
	}
}

type mBttMockEnableCleanMode struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockEnableCleanModeExpectation
	expectations       []*BttMockEnableCleanModeExpectation

	callArgs []*BttMockEnableCleanModeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockEnableCleanModeExpectation specifies expectation struct of the Btt.EnableCleanMode
type BttMockEnableCleanModeExpectation struct {
	mock               *BttMock
	params             *BttMockEnableCleanModeParams
	paramPtrs          *BttMockEnableCleanModeParamPtrs
	expectationOrigins BttMockEnableCleanModeExpectationOrigins
	results            *BttMockEnableCleanModeResults
	returnOrigin       string
	Counter            uint64
}

// BttMockEnableCleanModeParams contains parameters of the Btt.EnableCleanMode
type BttMockEnableCleanModeParams struct {
	ctx context.Context
}

// BttMockEnableCleanModeParamPtrs contains pointers to parameters of the Btt.EnableCleanMode
type BttMockEnableCleanModeParamPtrs struct {
	ctx *context.Context
}

// BttMockEnableCleanModeResults contains results of the Btt.EnableCleanMode
type BttMockEnableCleanModeResults struct {
	err error
}

// BttMockEnableCleanModeOrigins contains origins of expectations of the Btt.EnableCleanMode
type BttMockEnableCleanModeExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEnableCleanMode *mBttMockEnableCleanMode) Optional() *mBttMockEnableCleanMode {
	mmEnableCleanMode.optional = true
	return mmEnableCleanMode
}

// Expect sets up expected params for Btt.EnableCleanMode
func (mmEnableCleanMode *mBttMockEnableCleanMode) Expect(ctx context.Context) *mBttMockEnableCleanMode {
	if mmEnableCleanMode.mock.funcEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("BttMock.EnableCleanMode mock is already set by Set")
	}

	if mmEnableCleanMode.defaultExpectation == nil {
		mmEnableCleanMode.defaultExpectation = &BttMockEnableCleanModeExpectation{}
	}

	if mmEnableCleanMode.defaultExpectation.paramPtrs != nil {
		mmEnableCleanMode.mock.t.Fatalf("BttMock.EnableCleanMode mock is already set by ExpectParams functions")
	}

	mmEnableCleanMode.defaultExpectation.params = &BttMockEnableCleanModeParams{ctx}
	mmEnableCleanMode.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEnableCleanMode.expectations {
		if minimock.Equal(e.params, mmEnableCleanMode.defaultExpectation.params) {
			mmEnableCleanMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEnableCleanMode.defaultExpectation.params)
		}
	}

	return mmEnableCleanMode
}

// ExpectCtxParam1 sets up expected param ctx for Btt.EnableCleanMode
func (mmEnableCleanMode *mBttMockEnableCleanMode) ExpectCtxParam1(ctx context.Context) *mBttMockEnableCleanMode {
	if mmEnableCleanMode.mock.funcEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("BttMock.EnableCleanMode mock is already set by Set")
	}

	if mmEnableCleanMode.defaultExpectation == nil {
		mmEnableCleanMode.defaultExpectation = &BttMockEnableCleanModeExpectation{}
	}

	if mmEnableCleanMode.defaultExpectation.params != nil {
		mmEnableCleanMode.mock.t.Fatalf("BttMock.EnableCleanMode mock is already set by Expect")
	}

	if mmEnableCleanMode.defaultExpectation.paramPtrs == nil {
		mmEnableCleanMode.defaultExpectation.paramPtrs = &BttMockEnableCleanModeParamPtrs{}
	}
	mmEnableCleanMode.defaultExpectation.paramPtrs.ctx = &ctx
	mmEnableCleanMode.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEnableCleanMode
}

// Inspect accepts an inspector function that has same arguments as the Btt.EnableCleanMode
func (mmEnableCleanMode *mBttMockEnableCleanMode) Inspect(f func(ctx context.Context)) *mBttMockEnableCleanMode {
	if mmEnableCleanMode.mock.inspectFuncEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("Inspect function is already set for BttMock.EnableCleanMode")
	}

	mmEnableCleanMode.mock.inspectFuncEnableCleanMode = f

	return mmEnableCleanMode
}

// Return sets up results that will be returned by Btt.EnableCleanMode
func (mmEnableCleanMode *mBttMockEnableCleanMode) Return(err error) *BttMock {
	if mmEnableCleanMode.mock.funcEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("BttMock.EnableCleanMode mock is already set by Set")
	}

	if mmEnableCleanMode.defaultExpectation == nil {
		mmEnableCleanMode.defaultExpectation = &BttMockEnableCleanModeExpectation{mock: mmEnableCleanMode.mock}
	}
	mmEnableCleanMode.defaultExpectation.results = &BttMockEnableCleanModeResults{err}
	mmEnableCleanMode.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEnableCleanMode.mock
}

// Set uses given function f to mock the Btt.EnableCleanMode method
func (mmEnableCleanMode *mBttMockEnableCleanMode) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmEnableCleanMode.defaultExpectation != nil {
		mmEnableCleanMode.mock.t.Fatalf("Default expectation is already set for the Btt.EnableCleanMode method")
	}

	if len(mmEnableCleanMode.expectations) > 0 {
		mmEnableCleanMode.mock.t.Fatalf("Some expectations are already set for the Btt.EnableCleanMode method")
	}

	mmEnableCleanMode.mock.funcEnableCleanMode = f
	mmEnableCleanMode.mock.funcEnableCleanModeOrigin = minimock.CallerInfo(1)
	return mmEnableCleanMode.mock
}

// When sets expectation for the Btt.EnableCleanMode which will trigger the result defined by the following
// Then helper
func (mmEnableCleanMode *mBttMockEnableCleanMode) When(ctx context.Context) *BttMockEnableCleanModeExpectation {
	if mmEnableCleanMode.mock.funcEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("BttMock.EnableCleanMode mock is already set by Set")
	}

	expectation := &BttMockEnableCleanModeExpectation{
		mock:               mmEnableCleanMode.mock,
		params:             &BttMockEnableCleanModeParams{ctx},
		expectationOrigins: BttMockEnableCleanModeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEnableCleanMode.expectations = append(mmEnableCleanMode.expectations, expectation)
	return expectation
}

// Then sets up Btt.EnableCleanMode return parameters for the expectation previously defined by the When method
func (e *BttMockEnableCleanModeExpectation) Then(err error) *BttMock {
	e.results = &BttMockEnableCleanModeResults{err}
	return e.mock
}

// Times sets number of times Btt.EnableCleanMode should be invoked
func (mmEnableCleanMode *mBttMockEnableCleanMode) Times(n uint64) *mBttMockEnableCleanMode {
	if n == 0 {
		mmEnableCleanMode.mock.t.Fatalf("Times of BttMock.EnableCleanMode mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEnableCleanMode.expectedInvocations, n)
	mmEnableCleanMode.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEnableCleanMode
}

func (mmEnableCleanMode *mBttMockEnableCleanMode) invocationsDone() bool {
	if len(mmEnableCleanMode.expectations) == 0 && mmEnableCleanMode.defaultExpectation == nil && mmEnableCleanMode.mock.funcEnableCleanMode == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEnableCleanMode.mock.afterEnableCleanModeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEnableCleanMode.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EnableCleanMode implements Btt
func (mmEnableCleanMode *BttMock) EnableCleanMode(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmEnableCleanMode.beforeEnableCleanModeCounter, 1)
	defer mm_atomic.AddUint64(&mmEnableCleanMode.afterEnableCleanModeCounter, 1)

	mmEnableCleanMode.t.Helper()

	if mmEnableCleanMode.inspectFuncEnableCleanMode != nil {
		mmEnableCleanMode.inspectFuncEnableCleanMode(ctx)
	}

	mm_params := BttMockEnableCleanModeParams{ctx}

	// Record call args
	mmEnableCleanMode.EnableCleanModeMock.mutex.Lock()
	mmEnableCleanMode.EnableCleanModeMock.callArgs = append(mmEnableCleanMode.EnableCleanModeMock.callArgs, &mm_params)
	mmEnableCleanMode.EnableCleanModeMock.mutex.Unlock()

	for _, e := range mmEnableCleanMode.EnableCleanModeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEnableCleanMode.EnableCleanModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.Counter, 1)
		mm_want := mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.params
		mm_want_ptrs := mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.paramPtrs

		mm_got := BttMockEnableCleanModeParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEnableCleanMode.t.Errorf("BttMock.EnableCleanMode got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEnableCleanMode.t.Errorf("BttMock.EnableCleanMode got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.results
		if mm_results == nil {
			mmEnableCleanMode.t.Fatal("No results are set for the BttMock.EnableCleanMode")
		}
		return (*mm_results).err
	}
	if mmEnableCleanMode.funcEnableCleanMode != nil {
		return mmEnableCleanMode.funcEnableCleanMode(ctx)
	}
	mmEnableCleanMode.t.Fatalf("Unexpected call to BttMock.EnableCleanMode. %v", ctx)
	return
}

// EnableCleanModeAfterCounter returns a count of finished BttMock.EnableCleanMode invocations
func (mmEnableCleanMode *BttMock) EnableCleanModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnableCleanMode.afterEnableCleanModeCounter)
}

// EnableCleanModeBeforeCounter returns a count of BttMock.EnableCleanMode invocations
func (mmEnableCleanMode *BttMock) EnableCleanModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnableCleanMode.beforeEnableCleanModeCounter)
}

// Calls returns a list of arguments used in each call to BttMock.EnableCleanMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEnableCleanMode *mBttMockEnableCleanMode) Calls() []*BttMockEnableCleanModeParams {
	mmEnableCleanMode.mutex.RLock()

	argCopy := make([]*BttMockEnableCleanModeParams, len(mmEnableCleanMode.callArgs))
	copy(argCopy, mmEnableCleanMode.callArgs)

	mmEnableCleanMode.mutex.RUnlock()

	return argCopy
}

// MinimockEnableCleanModeDone returns true if the count of the EnableCleanMode invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockEnableCleanModeDone() bool {
	if m.EnableCleanModeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EnableCleanModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EnableCleanModeMock.invocationsDone()
}

// MinimockEnableCleanModeInspect logs each unmet expectation
func (m *BttMock) MinimockEnableCleanModeInspect() {
	for _, e := range m.EnableCleanModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.EnableCleanMode at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEnableCleanModeCounter := mm_atomic.LoadUint64(&m.afterEnableCleanModeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EnableCleanModeMock.defaultExpectation != nil && afterEnableCleanModeCounter < 1 {
		if m.EnableCleanModeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.EnableCleanMode at\n%s", m.EnableCleanModeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.EnableCleanMode at\n%s with params: %#v", m.EnableCleanModeMock.defaultExpectation.expectationOrigins.origin, *m.EnableCleanModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnableCleanMode != nil && afterEnableCleanModeCounter < 1 {
		m.t.Errorf("Expected call to BttMock.EnableCleanMode at\n%s", m.funcEnableCleanModeOrigin)
	}

	if !m.EnableCleanModeMock.invocationsDone() && afterEnableCleanModeCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.EnableCleanMode at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EnableCleanModeMock.expectedInvocations), m.EnableCleanModeMock.expectedInvocationsOrigin, afterEnableCleanModeCounter)
	}
}

type mBttMockFloatingPage struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockFloatingPageExpectation
	expectations       []*BttMockFloatingPageExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockFloatingPageExpectation specifies expectation struct of the Btt.FloatingPage
type BttMockFloatingPageExpectation struct {
	mock *BttMock

	results      *BttMockFloatingPageResults
	returnOrigin string
	Counter      uint64
}

// BttMockFloatingPageResults contains results of the Btt.FloatingPage
type BttMockFloatingPageResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFloatingPage *mBttMockFloatingPage) Optional() *mBttMockFloatingPage {
	mmFloatingPage.optional = true
	return mmFloatingPage
}

// Expect sets up expected params for Btt.FloatingPage
func (mmFloatingPage *mBttMockFloatingPage) Expect() *mBttMockFloatingPage {
	if mmFloatingPage.mock.funcFloatingPage != nil {
		mmFloatingPage.mock.t.Fatalf("BttMock.FloatingPage mock is already set by Set")
	}

	if mmFloatingPage.defaultExpectation == nil {
		mmFloatingPage.defaultExpectation = &BttMockFloatingPageExpectation{}
	}

	return mmFloatingPage
}

// Inspect accepts an inspector function that has same arguments as the Btt.FloatingPage
func (mmFloatingPage *mBttMockFloatingPage) Inspect(f func()) *mBttMockFloatingPage {
	if mmFloatingPage.mock.inspectFuncFloatingPage != nil {
		mmFloatingPage.mock.t.Fatalf("Inspect function is already set for BttMock.FloatingPage")
	}

	mmFloatingPage.mock.inspectFuncFloatingPage = f

	return mmFloatingPage
}

// Return sets up results that will be returned by Btt.FloatingPage
func (mmFloatingPage *mBttMockFloatingPage) Return(s1 string) *BttMock {
	if mmFloatingPage.mock.funcFloatingPage != nil {
		mmFloatingPage.mock.t.Fatalf("BttMock.FloatingPage mock is already set by Set")
	}

	if mmFloatingPage.defaultExpectation == nil {
		mmFloatingPage.defaultExpectation = &BttMockFloatingPageExpectation{mock: mmFloatingPage.mock}
	}
	mmFloatingPage.defaultExpectation.results = &BttMockFloatingPageResults{s1}
	mmFloatingPage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFloatingPage.mock
}

// Set uses given function f to mock the Btt.FloatingPage method
func (mmFloatingPage *mBttMockFloatingPage) Set(f func() (s1 string)) *BttMock {
	if mmFloatingPage.defaultExpectation != nil {
		mmFloatingPage.mock.t.Fatalf("Default expectation is already set for the Btt.FloatingPage method")
	}

	if len(mmFloatingPage.expectations) > 0 {
		mmFloatingPage.mock.t.Fatalf("Some expectations are already set for the Btt.FloatingPage method")
	}

	mmFloatingPage.mock.funcFloatingPage = f
	mmFloatingPage.mock.funcFloatingPageOrigin = minimock.CallerInfo(1)
	return mmFloatingPage.mock
}

// Times sets number of times Btt.FloatingPage should be invoked
func (mmFloatingPage *mBttMockFloatingPage) Times(n uint64) *mBttMockFloatingPage {
	if n == 0 {
		mmFloatingPage.mock.t.Fatalf("Times of BttMock.FloatingPage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFloatingPage.expectedInvocations, n)
	mmFloatingPage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFloatingPage
}

func (mmFloatingPage *mBttMockFloatingPage) invocationsDone() bool {
	if len(mmFloatingPage.expectations) == 0 && mmFloatingPage.defaultExpectation == nil && mmFloatingPage.mock.funcFloatingPage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFloatingPage.mock.afterFloatingPageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFloatingPage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FloatingPage implements Btt
func (mmFloatingPage *BttMock) FloatingPage() (s1 string) {
	mm_atomic.AddUint64(&mmFloatingPage.beforeFloatingPageCounter, 1)
	defer mm_atomic.AddUint64(&mmFloatingPage.afterFloatingPageCounter, 1)

	mmFloatingPage.t.Helper()

	if mmFloatingPage.inspectFuncFloatingPage != nil {
		mmFloatingPage.inspectFuncFloatingPage()
	}

	if mmFloatingPage.FloatingPageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFloatingPage.FloatingPageMock.defaultExpectation.Counter, 1)

		mm_results := mmFloatingPage.FloatingPageMock.defaultExpectation.results
		if mm_results == nil {
			mmFloatingPage.t.Fatal("No results are set for the BttMock.FloatingPage")
		}
		return (*mm_results).s1
	}
	if mmFloatingPage.funcFloatingPage != nil {
		return mmFloatingPage.funcFloatingPage()
	}
	mmFloatingPage.t.Fatalf("Unexpected call to BttMock.FloatingPage.")
	return
}

// FloatingPageAfterCounter returns a count of finished BttMock.FloatingPage invocations
func (mmFloatingPage *BttMock) FloatingPageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFloatingPage.afterFloatingPageCounter)
}

// FloatingPageBeforeCounter returns a count of BttMock.FloatingPage invocations
func (mmFloatingPage *BttMock) FloatingPageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFloatingPage.beforeFloatingPageCounter)
}

// MinimockFloatingPageDone returns true if the count of the FloatingPage invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockFloatingPageDone() bool {
	if m.FloatingPageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FloatingPageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FloatingPageMock.invocationsDone()
}

// MinimockFloatingPageInspect logs each unmet expectation
func (m *BttMock) MinimockFloatingPageInspect() {
	for _, e := range m.FloatingPageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to BttMock.FloatingPage")
		}
	}

	afterFloatingPageCounter := mm_atomic.LoadUint64(&m.afterFloatingPageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FloatingPageMock.defaultExpectation != nil && afterFloatingPageCounter < 1 {
		m.t.Errorf("Expected call to BttMock.FloatingPage at\n%s", m.FloatingPageMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFloatingPage != nil && afterFloatingPageCounter < 1 {
		m.t.Errorf("Expected call to BttMock.FloatingPage at\n%s", m.funcFloatingPageOrigin)
	}

	if !m.FloatingPageMock.invocationsDone() && afterFloatingPageCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.FloatingPage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FloatingPageMock.expectedInvocations), m.FloatingPageMock.expectedInvocationsOrigin, afterFloatingPageCounter)
	}
}

type mBttMockHideFloating struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockHideFloatingExpectation
	expectations       []*BttMockHideFloatingExpectation

	callArgs []*BttMockHideFloatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockHideFloatingExpectation specifies expectation struct of the Btt.HideFloating
type BttMockHideFloatingExpectation struct {
	mock               *BttMock
	params             *BttMockHideFloatingParams
	paramPtrs          *BttMockHideFloatingParamPtrs
	expectationOrigins BttMockHideFloatingExpectationOrigins
	results            *BttMockHideFloatingResults
	returnOrigin       string
	Counter            uint64
}

// BttMockHideFloatingParams contains parameters of the Btt.HideFloating
type BttMockHideFloatingParams struct {
	ctx context.Context
}

// BttMockHideFloatingParamPtrs contains pointers to parameters of the Btt.HideFloating
type BttMockHideFloatingParamPtrs struct {
	ctx *context.Context
}

// BttMockHideFloatingResults contains results of the Btt.HideFloating
type BttMockHideFloatingResults struct {
	err error
}

// BttMockHideFloatingOrigins contains origins of expectations of the Btt.HideFloating
type BttMockHideFloatingExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHideFloating *mBttMockHideFloating) Optional() *mBttMockHideFloating {
	mmHideFloating.optional = true
	return mmHideFloating
}

// Expect sets up expected params for Btt.HideFloating
func (mmHideFloating *mBttMockHideFloating) Expect(ctx context.Context) *mBttMockHideFloating {
	if mmHideFloating.mock.funcHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("BttMock.HideFloating mock is already set by Set")
	}

	if mmHideFloating.defaultExpectation == nil {
		mmHideFloating.defaultExpectation = &BttMockHideFloatingExpectation{}
	}

	if mmHideFloating.defaultExpectation.paramPtrs != nil {
		mmHideFloating.mock.t.Fatalf("BttMock.HideFloating mock is already set by ExpectParams functions")
	}

	mmHideFloating.defaultExpectation.params = &BttMockHideFloatingParams{ctx}
	mmHideFloating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHideFloating.expectations {
		if minimock.Equal(e.params, mmHideFloating.defaultExpectation.params) {
			mmHideFloating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHideFloating.defaultExpectation.params)
		}
	}

	return mmHideFloating
}

// ExpectCtxParam1 sets up expected param ctx for Btt.HideFloating
func (mmHideFloating *mBttMockHideFloating) ExpectCtxParam1(ctx context.Context) *mBttMockHideFloating {
	if mmHideFloating.mock.funcHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("BttMock.HideFloating mock is already set by Set")
	}

	if mmHideFloating.defaultExpectation == nil {
		mmHideFloating.defaultExpectation = &BttMockHideFloatingExpectation{}
	}

	if mmHideFloating.defaultExpectation.params != nil {
		mmHideFloating.mock.t.Fatalf("BttMock.HideFloating mock is already set by Expect")
	}

	if mmHideFloating.defaultExpectation.paramPtrs == nil {
		mmHideFloating.defaultExpectation.paramPtrs = &BttMockHideFloatingParamPtrs{}
	}
	mmHideFloating.defaultExpectation.paramPtrs.ctx = &ctx
	mmHideFloating.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHideFloating
}

// Inspect accepts an inspector function that has same arguments as the Btt.HideFloating
func (mmHideFloating *mBttMockHideFloating) Inspect(f func(ctx context.Context)) *mBttMockHideFloating {
	if mmHideFloating.mock.inspectFuncHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("Inspect function is already set for BttMock.HideFloating")
	}

	mmHideFloating.mock.inspectFuncHideFloating = f

	return mmHideFloating
}

// Return sets up results that will be returned by Btt.HideFloating
func (mmHideFloating *mBttMockHideFloating) Return(err error) *BttMock {
	if mmHideFloating.mock.funcHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("BttMock.HideFloating mock is already set by Set")
	}

	if mmHideFloating.defaultExpectation == nil {
		mmHideFloating.defaultExpectation = &BttMockHideFloatingExpectation{mock: mmHideFloating.mock}
	}
	mmHideFloating.defaultExpectation.results = &BttMockHideFloatingResults{err}
	mmHideFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHideFloating.mock
}

// Set uses given function f to mock the Btt.HideFloating method
func (mmHideFloating *mBttMockHideFloating) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmHideFloating.defaultExpectation != nil {
		mmHideFloating.mock.t.Fatalf("Default expectation is already set for the Btt.HideFloating method")
	}

	if len(mmHideFloating.expectations) > 0 {
		mmHideFloating.mock.t.Fatalf("Some expectations are already set for the Btt.HideFloating method")
	}

	mmHideFloating.mock.funcHideFloating = f
	mmHideFloating.mock.funcHideFloatingOrigin = minimock.CallerInfo(1)
	return mmHideFloating.mock
}

// When sets expectation for the Btt.HideFloating which will trigger the result defined by the following
// Then helper
func (mmHideFloating *mBttMockHideFloating) When(ctx context.Context) *BttMockHideFloatingExpectation {
	if mmHideFloating.mock.funcHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("BttMock.HideFloating mock is already set by Set")
	}

	expectation := &BttMockHideFloatingExpectation{
		mock:               mmHideFloating.mock,
		params:             &BttMockHideFloatingParams{ctx},
		expectationOrigins: BttMockHideFloatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHideFloating.expectations = append(mmHideFloating.expectations, expectation)
	return expectation
}

// Then sets up Btt.HideFloating return parameters for the expectation previously defined by the When method
func (e *BttMockHideFloatingExpectation) Then(err error) *BttMock {
	e.results = &BttMockHideFloatingResults{err}
	return e.mock
}

// Times sets number of times Btt.HideFloating should be invoked
func (mmHideFloating *mBttMockHideFloating) Times(n uint64) *mBttMockHideFloating {
	if n == 0 {
		mmHideFloating.mock.t.Fatalf("Times of BttMock.HideFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHideFloating.expectedInvocations, n)
	mmHideFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHideFloating
}

func (mmHideFloating *mBttMockHideFloating) invocationsDone() bool {
	if len(mmHideFloating.expectations) == 0 && mmHideFloating.defaultExpectation == nil && mmHideFloating.mock.funcHideFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHideFloating.mock.afterHideFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHideFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HideFloating implements Btt
func (mmHideFloating *BttMock) HideFloating(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmHideFloating.beforeHideFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmHideFloating.afterHideFloatingCounter, 1)

	mmHideFloating.t.Helper()

	if mmHideFloating.inspectFuncHideFloating != nil {
		mmHideFloating.inspectFuncHideFloating(ctx)
	}

	mm_params := BttMockHideFloatingParams{ctx}

	// Record call args
	mmHideFloating.HideFloatingMock.mutex.Lock()
	mmHideFloating.HideFloatingMock.callArgs = append(mmHideFloating.HideFloatingMock.callArgs, &mm_params)
	mmHideFloating.HideFloatingMock.mutex.Unlock()

	for _, e := range mmHideFloating.HideFloatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHideFloating.HideFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHideFloating.HideFloatingMock.defaultExpectation.Counter, 1)
		mm_want := mmHideFloating.HideFloatingMock.defaultExpectation.params
		mm_want_ptrs := mmHideFloating.HideFloatingMock.defaultExpectation.paramPtrs

		mm_got := BttMockHideFloatingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHideFloating.t.Errorf("BttMock.HideFloating got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHideFloating.HideFloatingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHideFloating.t.Errorf("BttMock.HideFloating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHideFloating.HideFloatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHideFloating.HideFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmHideFloating.t.Fatal("No results are set for the BttMock.HideFloating")
		}
		return (*mm_results).err
	}
	if mmHideFloating.funcHideFloating != nil {
		return mmHideFloating.funcHideFloating(ctx)
	}
	mmHideFloating.t.Fatalf("Unexpected call to BttMock.HideFloating. %v", ctx)
	return
}

// HideFloatingAfterCounter returns a count of finished BttMock.HideFloating invocations
func (mmHideFloating *BttMock) HideFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHideFloating.afterHideFloatingCounter)
}

// HideFloatingBeforeCounter returns a count of BttMock.HideFloating invocations
func (mmHideFloating *BttMock) HideFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHideFloating.beforeHideFloatingCounter)
}

// Calls returns a list of arguments used in each call to BttMock.HideFloating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHideFloating *mBttMockHideFloating) Calls() []*BttMockHideFloatingParams {
	mmHideFloating.mutex.RLock()

	argCopy := make([]*BttMockHideFloatingParams, len(mmHideFloating.callArgs))
	copy(argCopy, mmHideFloating.callArgs)

	mmHideFloating.mutex.RUnlock()

	return argCopy
}

// MinimockHideFloatingDone returns true if the count of the HideFloating invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockHideFloatingDone() bool {
	if m.HideFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HideFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HideFloatingMock.invocationsDone()
}

// MinimockHideFloatingInspect logs each unmet expectation
func (m *BttMock) MinimockHideFloatingInspect() {
	for _, e := range m.HideFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.HideFloating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHideFloatingCounter := mm_atomic.LoadUint64(&m.afterHideFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HideFloatingMock.defaultExpectation != nil && afterHideFloatingCounter < 1 {
		if m.HideFloatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.HideFloating at\n%s", m.HideFloatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.HideFloating at\n%s with params: %#v", m.HideFloatingMock.defaultExpectation.expectationOrigins.origin, *m.HideFloatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHideFloating != nil && afterHideFloatingCounter < 1 {
		m.t.Errorf("Expected call to BttMock.HideFloating at\n%s", m.funcHideFloatingOrigin)
	}

	if !m.HideFloatingMock.invocationsDone() && afterHideFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.HideFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HideFloatingMock.expectedInvocations), m.HideFloatingMock.expectedInvocationsOrigin, afterHideFloatingCounter)
	}
}

type mBttMockInitialize struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockInitializeExpectation
	expectations       []*BttMockInitializeExpectation

	callArgs []*BttMockInitializeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockInitializeExpectation specifies expectation struct of the Btt.Initialize
type BttMockInitializeExpectation struct {
	mock               *BttMock
	params             *BttMockInitializeParams
	paramPtrs          *BttMockInitializeParamPtrs
	expectationOrigins BttMockInitializeExpectationOrigins
	results            *BttMockInitializeResults
	returnOrigin       string
	Counter            uint64
}

// BttMockInitializeParams contains parameters of the Btt.Initialize
type BttMockInitializeParams struct {
	ctx context.Context
}

// BttMockInitializeParamPtrs contains pointers to parameters of the Btt.Initialize
type BttMockInitializeParamPtrs struct {
	ctx *context.Context
}

// BttMockInitializeResults contains results of the Btt.Initialize
type BttMockInitializeResults struct {
	err error
}

// BttMockInitializeOrigins contains origins of expectations of the Btt.Initialize
type BttMockInitializeExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInitialize *mBttMockInitialize) Optional() *mBttMockInitialize {
	mmInitialize.optional = true
	return mmInitialize
}

// Expect sets up expected params for Btt.Initialize
func (mmInitialize *mBttMockInitialize) Expect(ctx context.Context) *mBttMockInitialize {
	if mmInitialize.mock.funcInitialize != nil {
		mmInitialize.mock.t.Fatalf("BttMock.Initialize mock is already set by Set")
	}

	if mmInitialize.defaultExpectation == nil {
		mmInitialize.defaultExpectation = &BttMockInitializeExpectation{}
	}

	if mmInitialize.defaultExpectation.paramPtrs != nil {
		mmInitialize.mock.t.Fatalf("BttMock.Initialize mock is already set by ExpectParams functions")
	}

	mmInitialize.defaultExpectation.params = &BttMockInitializeParams{ctx}
	mmInitialize.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInitialize.expectations {
		if minimock.Equal(e.params, mmInitialize.defaultExpectation.params) {
			mmInitialize.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInitialize.defaultExpectation.params)
		}
	}

	return mmInitialize
}

// ExpectCtxParam1 sets up expected param ctx for Btt.Initialize
func (mmInitialize *mBttMockInitialize) ExpectCtxParam1(ctx context.Context) *mBttMockInitialize {
	if mmInitialize.mock.funcInitialize != nil {
		mmInitialize.mock.t.Fatalf("BttMock.Initialize mock is already set by Set")
	}

	if mmInitialize.defaultExpectation == nil {
		mmInitialize.defaultExpectation = &BttMockInitializeExpectation{}
	}

	if mmInitialize.defaultExpectation.params != nil {
		mmInitialize.mock.t.Fatalf("BttMock.Initialize mock is already set by Expect")
	}

	if mmInitialize.defaultExpectation.paramPtrs == nil {
		mmInitialize.defaultExpectation.paramPtrs = &BttMockInitializeParamPtrs{}
	}
	mmInitialize.defaultExpectation.paramPtrs.ctx = &ctx
	mmInitialize.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInitialize
}

// Inspect accepts an inspector function that has same arguments as the Btt.Initialize
func (mmInitialize *mBttMockInitialize) Inspect(f func(ctx context.Context)) *mBttMockInitialize {
	if mmInitialize.mock.inspectFuncInitialize != nil {
		mmInitialize.mock.t.Fatalf("Inspect function is already set for BttMock.Initialize")
	}

	mmInitialize.mock.inspectFuncInitialize = f

	return mmInitialize
}

// Return sets up results that will be returned by Btt.Initialize
func (mmInitialize *mBttMockInitialize) Return(err error) *BttMock {
	if mmInitialize.mock.funcInitialize != nil {
		mmInitialize.mock.t.Fatalf("BttMock.Initialize mock is already set by Set")
	}

	if mmInitialize.defaultExpectation == nil {
		mmInitialize.defaultExpectation = &BttMockInitializeExpectation{mock: mmInitialize.mock}
	}
	mmInitialize.defaultExpectation.results = &BttMockInitializeResults{err}
	mmInitialize.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInitialize.mock
}

// Set uses given function f to mock the Btt.Initialize method
func (mmInitialize *mBttMockInitialize) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmInitialize.defaultExpectation != nil {
		mmInitialize.mock.t.Fatalf("Default expectation is already set for the Btt.Initialize method")
	}

	if len(mmInitialize.expectations) > 0 {
		mmInitialize.mock.t.Fatalf("Some expectations are already set for the Btt.Initialize method")
	}

	mmInitialize.mock.funcInitialize = f
	mmInitialize.mock.funcInitializeOrigin = minimock.CallerInfo(1)
	return mmInitialize.mock
}

// When sets expectation for the Btt.Initialize which will trigger the result defined by the following
// Then helper
func (mmInitialize *mBttMockInitialize) When(ctx context.Context) *BttMockInitializeExpectation {
	if mmInitialize.mock.funcInitialize != nil {
		mmInitialize.mock.t.Fatalf("BttMock.Initialize mock is already set by Set")
	}

	expectation := &BttMockInitializeExpectation{
		mock:               mmInitialize.mock,
		params:             &BttMockInitializeParams{ctx},
		expectationOrigins: BttMockInitializeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInitialize.expectations = append(mmInitialize.expectations, expectation)
	return expectation
}

// Then sets up Btt.Initialize return parameters for the expectation previously defined by the When method
func (e *BttMockInitializeExpectation) Then(err error) *BttMock {
	e.results = &BttMockInitializeResults{err}
	return e.mock
}

// Times sets number of times Btt.Initialize should be invoked
func (mmInitialize *mBttMockInitialize) Times(n uint64) *mBttMockInitialize {
	if n == 0 {
		mmInitialize.mock.t.Fatalf("Times of BttMock.Initialize mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInitialize.expectedInvocations, n)
	mmInitialize.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInitialize
}

func (mmInitialize *mBttMockInitialize) invocationsDone() bool {
	if len(mmInitialize.expectations) == 0 && mmInitialize.defaultExpectation == nil && mmInitialize.mock.funcInitialize == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInitialize.mock.afterInitializeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInitialize.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Initialize implements Btt
func (mmInitialize *BttMock) Initialize(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmInitialize.beforeInitializeCounter, 1)
	defer mm_atomic.AddUint64(&mmInitialize.afterInitializeCounter, 1)

	mmInitialize.t.Helper()

	if mmInitialize.inspectFuncInitialize != nil {
		mmInitialize.inspectFuncInitialize(ctx)
	}

	mm_params := BttMockInitializeParams{ctx}

	// Record call args
	mmInitialize.InitializeMock.mutex.Lock()
	mmInitialize.InitializeMock.callArgs = append(mmInitialize.InitializeMock.callArgs, &mm_params)
	mmInitialize.InitializeMock.mutex.Unlock()

	for _, e := range mmInitialize.InitializeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInitialize.InitializeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInitialize.InitializeMock.defaultExpectation.Counter, 1)
		mm_want := mmInitialize.InitializeMock.defaultExpectation.params
		mm_want_ptrs := mmInitialize.InitializeMock.defaultExpectation.paramPtrs

		mm_got := BttMockInitializeParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInitialize.t.Errorf("BttMock.Initialize got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInitialize.InitializeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInitialize.t.Errorf("BttMock.Initialize got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInitialize.InitializeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInitialize.InitializeMock.defaultExpectation.results
		if mm_results == nil {
			mmInitialize.t.Fatal("No results are set for the BttMock.Initialize")
		}
		return (*mm_results).err
	}
	if mmInitialize.funcInitialize != nil {
		return mmInitialize.funcInitialize(ctx)
	}
	mmInitialize.t.Fatalf("Unexpected call to BttMock.Initialize. %v", ctx)
	return
}

// InitializeAfterCounter returns a count of finished BttMock.Initialize invocations
func (mmInitialize *BttMock) InitializeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitialize.afterInitializeCounter)
}

// InitializeBeforeCounter returns a count of BttMock.Initialize invocations
func (mmInitialize *BttMock) InitializeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitialize.beforeInitializeCounter)
}

// Calls returns a list of arguments used in each call to BttMock.Initialize.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInitialize *mBttMockInitialize) Calls() []*BttMockInitializeParams {
	mmInitialize.mutex.RLock()

	argCopy := make([]*BttMockInitializeParams, len(mmInitialize.callArgs))
	copy(argCopy, mmInitialize.callArgs)

	mmInitialize.mutex.RUnlock()

	return argCopy
}

// MinimockInitializeDone returns true if the count of the Initialize invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockInitializeDone() bool {
	if m.InitializeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InitializeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InitializeMock.invocationsDone()
}

// MinimockInitializeInspect logs each unmet expectation
func (m *BttMock) MinimockInitializeInspect() {
	for _, e := range m.InitializeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.Initialize at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInitializeCounter := mm_atomic.LoadUint64(&m.afterInitializeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InitializeMock.defaultExpectation != nil && afterInitializeCounter < 1 {
		if m.InitializeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.Initialize at\n%s", m.InitializeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.Initialize at\n%s with params: %#v", m.InitializeMock.defaultExpectation.expectationOrigins.origin, *m.InitializeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitialize != nil && afterInitializeCounter < 1 {
		m.t.Errorf("Expected call to BttMock.Initialize at\n%s", m.funcInitializeOrigin)
	}

	if !m.InitializeMock.invocationsDone() && afterInitializeCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.Initialize at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InitializeMock.expectedInvocations), m.InitializeMock.expectedInvocationsOrigin, afterInitializeCounter)
	}
}

type mBttMockIsRunning struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockIsRunningExpectation
	expectations       []*BttMockIsRunningExpectation

	callArgs []*BttMockIsRunningParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockIsRunningExpectation specifies expectation struct of the Btt.IsRunning
type BttMockIsRunningExpectation struct {
	mock               *BttMock
	params             *BttMockIsRunningParams
	paramPtrs          *BttMockIsRunningParamPtrs
	expectationOrigins BttMockIsRunningExpectationOrigins
	results            *BttMockIsRunningResults
	returnOrigin       string
	Counter            uint64
}

// BttMockIsRunningParams contains parameters of the Btt.IsRunning
type BttMockIsRunningParams struct {
	ctx context.Context
}

// BttMockIsRunningParamPtrs contains pointers to parameters of the Btt.IsRunning
type BttMockIsRunningParamPtrs struct {
	ctx *context.Context
}

// BttMockIsRunningResults contains results of the Btt.IsRunning
type BttMockIsRunningResults struct {
	b1  bool
	err error
}

// BttMockIsRunningOrigins contains origins of expectations of the Btt.IsRunning
type BttMockIsRunningExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsRunning *mBttMockIsRunning) Optional() *mBttMockIsRunning {
	mmIsRunning.optional = true
	return mmIsRunning
}

// Expect sets up expected params for Btt.IsRunning
func (mmIsRunning *mBttMockIsRunning) Expect(ctx context.Context) *mBttMockIsRunning {
	if mmIsRunning.mock.funcIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("BttMock.IsRunning mock is already set by Set")
	}

	if mmIsRunning.defaultExpectation == nil {
		mmIsRunning.defaultExpectation = &BttMockIsRunningExpectation{}
	}

	if mmIsRunning.defaultExpectation.paramPtrs != nil {
		mmIsRunning.mock.t.Fatalf("BttMock.IsRunning mock is already set by ExpectParams functions")
	}

	mmIsRunning.defaultExpectation.params = &BttMockIsRunningParams{ctx}
	mmIsRunning.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsRunning.expectations {
		if minimock.Equal(e.params, mmIsRunning.defaultExpectation.params) {
			mmIsRunning.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsRunning.defaultExpectation.params)
		}
	}

	return mmIsRunning
}

// ExpectCtxParam1 sets up expected param ctx for Btt.IsRunning
func (mmIsRunning *mBttMockIsRunning) ExpectCtxParam1(ctx context.Context) *mBttMockIsRunning {
	if mmIsRunning.mock.funcIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("BttMock.IsRunning mock is already set by Set")
	}

	if mmIsRunning.defaultExpectation == nil {
		mmIsRunning.defaultExpectation = &BttMockIsRunningExpectation{}
	}

	if mmIsRunning.defaultExpectation.params != nil {
		mmIsRunning.mock.t.Fatalf("BttMock.IsRunning mock is already set by Expect")
	}

	if mmIsRunning.defaultExpectation.paramPtrs == nil {
		mmIsRunning.defaultExpectation.paramPtrs = &BttMockIsRunningParamPtrs{}
	}
	mmIsRunning.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsRunning.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsRunning
}

// Inspect accepts an inspector function that has same arguments as the Btt.IsRunning
func (mmIsRunning *mBttMockIsRunning) Inspect(f func(ctx context.Context)) *mBttMockIsRunning {
	if mmIsRunning.mock.inspectFuncIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("Inspect function is already set for BttMock.IsRunning")
	}

	mmIsRunning.mock.inspectFuncIsRunning = f

	return mmIsRunning
}

// Return sets up results that will be returned by Btt.IsRunning
func (mmIsRunning *mBttMockIsRunning) Return(b1 bool, err error) *BttMock {
	if mmIsRunning.mock.funcIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("BttMock.IsRunning mock is already set by Set")
	}

	if mmIsRunning.defaultExpectation == nil {
		mmIsRunning.defaultExpectation = &BttMockIsRunningExpectation{mock: mmIsRunning.mock}
	}
	mmIsRunning.defaultExpectation.results = &BttMockIsRunningResults{b1, err}
	mmIsRunning.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsRunning.mock
}

// Set uses given function f to mock the Btt.IsRunning method
func (mmIsRunning *mBttMockIsRunning) Set(f func(ctx context.Context) (b1 bool, err error)) *BttMock {
	if mmIsRunning.defaultExpectation != nil {
		mmIsRunning.mock.t.Fatalf("Default expectation is already set for the Btt.IsRunning method")
	}

	if len(mmIsRunning.expectations) > 0 {
		mmIsRunning.mock.t.Fatalf("Some expectations are already set for the Btt.IsRunning method")
	}

	mmIsRunning.mock.funcIsRunning = f
	mmIsRunning.mock.funcIsRunningOrigin = minimock.CallerInfo(1)
	return mmIsRunning.mock
}

// When sets expectation for the Btt.IsRunning which will trigger the result defined by the following
// Then helper
func (mmIsRunning *mBttMockIsRunning) When(ctx context.Context) *BttMockIsRunningExpectation {
	if mmIsRunning.mock.funcIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("BttMock.IsRunning mock is already set by Set")
	}

	expectation := &BttMockIsRunningExpectation{
		mock:               mmIsRunning.mock,
		params:             &BttMockIsRunningParams{ctx},
		expectationOrigins: BttMockIsRunningExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsRunning.expectations = append(mmIsRunning.expectations, expectation)
	return expectation
}

// Then sets up Btt.IsRunning return parameters for the expectation previously defined by the When method
func (e *BttMockIsRunningExpectation) Then(b1 bool, err error) *BttMock {
	e.results = &BttMockIsRunningResults{b1, err}
	return e.mock
}

// Times sets number of times Btt.IsRunning should be invoked
func (mmIsRunning *mBttMockIsRunning) Times(n uint64) *mBttMockIsRunning {
	if n == 0 {
		mmIsRunning.mock.t.Fatalf("Times of BttMock.IsRunning mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsRunning.expectedInvocations, n)
	mmIsRunning.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsRunning
}

func (mmIsRunning *mBttMockIsRunning) invocationsDone() bool {
	if len(mmIsRunning.expectations) == 0 && mmIsRunning.defaultExpectation == nil && mmIsRunning.mock.funcIsRunning == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsRunning.mock.afterIsRunningCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsRunning.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsRunning implements Btt
func (mmIsRunning *BttMock) IsRunning(ctx context.Context) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsRunning.beforeIsRunningCounter, 1)
	defer mm_atomic.AddUint64(&mmIsRunning.afterIsRunningCounter, 1)

	mmIsRunning.t.Helper()

	if mmIsRunning.inspectFuncIsRunning != nil {
		mmIsRunning.inspectFuncIsRunning(ctx)
	}

	mm_params := BttMockIsRunningParams{ctx}

	// Record call args
	mmIsRunning.IsRunningMock.mutex.Lock()
	mmIsRunning.IsRunningMock.callArgs = append(mmIsRunning.IsRunningMock.callArgs, &mm_params)
	mmIsRunning.IsRunningMock.mutex.Unlock()

	for _, e := range mmIsRunning.IsRunningMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsRunning.IsRunningMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsRunning.IsRunningMock.defaultExpectation.Counter, 1)
		mm_want := mmIsRunning.IsRunningMock.defaultExpectation.params
		mm_want_ptrs := mmIsRunning.IsRunningMock.defaultExpectation.paramPtrs

		mm_got := BttMockIsRunningParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsRunning.t.Errorf("BttMock.IsRunning got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsRunning.IsRunningMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsRunning.t.Errorf("BttMock.IsRunning got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsRunning.IsRunningMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsRunning.IsRunningMock.defaultExpectation.results
		if mm_results == nil {
			mmIsRunning.t.Fatal("No results are set for the BttMock.IsRunning")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsRunning.funcIsRunning != nil {
		return mmIsRunning.funcIsRunning(ctx)
	}
	mmIsRunning.t.Fatalf("Unexpected call to BttMock.IsRunning. %v", ctx)
	return
}

// IsRunningAfterCounter returns a count of finished BttMock.IsRunning invocations
func (mmIsRunning *BttMock) IsRunningAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRunning.afterIsRunningCounter)
}

// IsRunningBeforeCounter returns a count of BttMock.IsRunning invocations
func (mmIsRunning *BttMock) IsRunningBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRunning.beforeIsRunningCounter)
}

// Calls returns a list of arguments used in each call to BttMock.IsRunning.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsRunning *mBttMockIsRunning) Calls() []*BttMockIsRunningParams {
	mmIsRunning.mutex.RLock()

	argCopy := make([]*BttMockIsRunningParams, len(mmIsRunning.callArgs))
	copy(argCopy, mmIsRunning.callArgs)

	mmIsRunning.mutex.RUnlock()

	return argCopy
}

// MinimockIsRunningDone returns true if the count of the IsRunning invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockIsRunningDone() bool {
	if m.IsRunningMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsRunningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsRunningMock.invocationsDone()
}

// MinimockIsRunningInspect logs each unmet expectation
func (m *BttMock) MinimockIsRunningInspect() {
	for _, e := range m.IsRunningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.IsRunning at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsRunningCounter := mm_atomic.LoadUint64(&m.afterIsRunningCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsRunningMock.defaultExpectation != nil && afterIsRunningCounter < 1 {
		if m.IsRunningMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.IsRunning at\n%s", m.IsRunningMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.IsRunning at\n%s with params: %#v", m.IsRunningMock.defaultExpectation.expectationOrigins.origin, *m.IsRunningMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsRunning != nil && afterIsRunningCounter < 1 {
		m.t.Errorf("Expected call to BttMock.IsRunning at\n%s", m.funcIsRunningOrigin)
	}

	if !m.IsRunningMock.invocationsDone() && afterIsRunningCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.IsRunning at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsRunningMock.expectedInvocations), m.IsRunningMock.expectedInvocationsOrigin, afterIsRunningCounter)
	}
}

type mBttMockLoadDevices struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockLoadDevicesExpectation
	expectations       []*BttMockLoadDevicesExpectation

	callArgs []*BttMockLoadDevicesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockLoadDevicesExpectation specifies expectation struct of the Btt.LoadDevices
type BttMockLoadDevicesExpectation struct {
	mock               *BttMock
	params             *BttMockLoadDevicesParams
	paramPtrs          *BttMockLoadDevicesParamPtrs
	expectationOrigins BttMockLoadDevicesExpectationOrigins
	results            *BttMockLoadDevicesResults
	returnOrigin       string
	Counter            uint64
}

// BttMockLoadDevicesParams contains parameters of the Btt.LoadDevices
type BttMockLoadDevicesParams struct {
	ctx context.Context
}

// BttMockLoadDevicesParamPtrs contains pointers to parameters of the Btt.LoadDevices
type BttMockLoadDevicesParamPtrs struct {
	ctx *context.Context
}

// BttMockLoadDevicesResults contains results of the Btt.LoadDevices
type BttMockLoadDevicesResults struct {
	err error
}

// BttMockLoadDevicesOrigins contains origins of expectations of the Btt.LoadDevices
type BttMockLoadDevicesExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLoadDevices *mBttMockLoadDevices) Optional() *mBttMockLoadDevices {
	mmLoadDevices.optional = true
	return mmLoadDevices
}

// Expect sets up expected params for Btt.LoadDevices
func (mmLoadDevices *mBttMockLoadDevices) Expect(ctx context.Context) *mBttMockLoadDevices {
	if mmLoadDevices.mock.funcLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("BttMock.LoadDevices mock is already set by Set")
	}

	if mmLoadDevices.defaultExpectation == nil {
		mmLoadDevices.defaultExpectation = &BttMockLoadDevicesExpectation{}
	}

	if mmLoadDevices.defaultExpectation.paramPtrs != nil {
		mmLoadDevices.mock.t.Fatalf("BttMock.LoadDevices mock is already set by ExpectParams functions")
	}

	mmLoadDevices.defaultExpectation.params = &BttMockLoadDevicesParams{ctx}
	mmLoadDevices.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLoadDevices.expectations {
		if minimock.Equal(e.params, mmLoadDevices.defaultExpectation.params) {
			mmLoadDevices.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLoadDevices.defaultExpectation.params)
		}
	}

	return mmLoadDevices
}

// ExpectCtxParam1 sets up expected param ctx for Btt.LoadDevices
func (mmLoadDevices *mBttMockLoadDevices) ExpectCtxParam1(ctx context.Context) *mBttMockLoadDevices {
	if mmLoadDevices.mock.funcLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("BttMock.LoadDevices mock is already set by Set")
	}

	if mmLoadDevices.defaultExpectation == nil {
		mmLoadDevices.defaultExpectation = &BttMockLoadDevicesExpectation{}
	}

	if mmLoadDevices.defaultExpectation.params != nil {
		mmLoadDevices.mock.t.Fatalf("BttMock.LoadDevices mock is already set by Expect")
	}

	if mmLoadDevices.defaultExpectation.paramPtrs == nil {
		mmLoadDevices.defaultExpectation.paramPtrs = &BttMockLoadDevicesParamPtrs{}
	}
	mmLoadDevices.defaultExpectation.paramPtrs.ctx = &ctx
	mmLoadDevices.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLoadDevices
}

// Inspect accepts an inspector function that has same arguments as the Btt.LoadDevices
func (mmLoadDevices *mBttMockLoadDevices) Inspect(f func(ctx context.Context)) *mBttMockLoadDevices {
	if mmLoadDevices.mock.inspectFuncLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("Inspect function is already set for BttMock.LoadDevices")
	}

	mmLoadDevices.mock.inspectFuncLoadDevices = f

	return mmLoadDevices
}

// Return sets up results that will be returned by Btt.LoadDevices
func (mmLoadDevices *mBttMockLoadDevices) Return(err error) *BttMock {
	if mmLoadDevices.mock.funcLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("BttMock.LoadDevices mock is already set by Set")
	}

	if mmLoadDevices.defaultExpectation == nil {
		mmLoadDevices.defaultExpectation = &BttMockLoadDevicesExpectation{mock: mmLoadDevices.mock}
	}
	mmLoadDevices.defaultExpectation.results = &BttMockLoadDevicesResults{err}
	mmLoadDevices.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLoadDevices.mock
}

// Set uses given function f to mock the Btt.LoadDevices method
func (mmLoadDevices *mBttMockLoadDevices) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmLoadDevices.defaultExpectation != nil {
		mmLoadDevices.mock.t.Fatalf("Default expectation is already set for the Btt.LoadDevices method")
	}

	if len(mmLoadDevices.expectations) > 0 {
		mmLoadDevices.mock.t.Fatalf("Some expectations are already set for the Btt.LoadDevices method")
	}

	mmLoadDevices.mock.funcLoadDevices = f
	mmLoadDevices.mock.funcLoadDevicesOrigin = minimock.CallerInfo(1)
	return mmLoadDevices.mock
}

// When sets expectation for the Btt.LoadDevices which will trigger the result defined by the following
// Then helper
func (mmLoadDevices *mBttMockLoadDevices) When(ctx context.Context) *BttMockLoadDevicesExpectation {
	if mmLoadDevices.mock.funcLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("BttMock.LoadDevices mock is already set by Set")
	}

	expectation := &BttMockLoadDevicesExpectation{
		mock:               mmLoadDevices.mock,
		params:             &BttMockLoadDevicesParams{ctx},
		expectationOrigins: BttMockLoadDevicesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLoadDevices.expectations = append(mmLoadDevices.expectations, expectation)
	return expectation
}

// Then sets up Btt.LoadDevices return parameters for the expectation previously defined by the When method
func (e *BttMockLoadDevicesExpectation) Then(err error) *BttMock {
	e.results = &BttMockLoadDevicesResults{err}
	return e.mock
}

// Times sets number of times Btt.LoadDevices should be invoked
func (mmLoadDevices *mBttMockLoadDevices) Times(n uint64) *mBttMockLoadDevices {
	if n == 0 {
		mmLoadDevices.mock.t.Fatalf("Times of BttMock.LoadDevices mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLoadDevices.expectedInvocations, n)
	mmLoadDevices.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLoadDevices
}

func (mmLoadDevices *mBttMockLoadDevices) invocationsDone() bool {
	if len(mmLoadDevices.expectations) == 0 && mmLoadDevices.defaultExpectation == nil && mmLoadDevices.mock.funcLoadDevices == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLoadDevices.mock.afterLoadDevicesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLoadDevices.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LoadDevices implements Btt
func (mmLoadDevices *BttMock) LoadDevices(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmLoadDevices.beforeLoadDevicesCounter, 1)
	defer mm_atomic.AddUint64(&mmLoadDevices.afterLoadDevicesCounter, 1)

	mmLoadDevices.t.Helper()

	if mmLoadDevices.inspectFuncLoadDevices != nil {
		mmLoadDevices.inspectFuncLoadDevices(ctx)
	}

	mm_params := BttMockLoadDevicesParams{ctx}

	// Record call args
	mmLoadDevices.LoadDevicesMock.mutex.Lock()
	mmLoadDevices.LoadDevicesMock.callArgs = append(mmLoadDevices.LoadDevicesMock.callArgs, &mm_params)
	mmLoadDevices.LoadDevicesMock.mutex.Unlock()

	for _, e := range mmLoadDevices.LoadDevicesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLoadDevices.LoadDevicesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLoadDevices.LoadDevicesMock.defaultExpectation.Counter, 1)
		mm_want := mmLoadDevices.LoadDevicesMock.defaultExpectation.params
		mm_want_ptrs := mmLoadDevices.LoadDevicesMock.defaultExpectation.paramPtrs

		mm_got := BttMockLoadDevicesParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLoadDevices.t.Errorf("BttMock.LoadDevices got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLoadDevices.LoadDevicesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLoadDevices.t.Errorf("BttMock.LoadDevices got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLoadDevices.LoadDevicesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLoadDevices.LoadDevicesMock.defaultExpectation.results
		if mm_results == nil {
			mmLoadDevices.t.Fatal("No results are set for the BttMock.LoadDevices")
		}
		return (*mm_results).err
	}
	if mmLoadDevices.funcLoadDevices != nil {
		return mmLoadDevices.funcLoadDevices(ctx)
	}
	mmLoadDevices.t.Fatalf("Unexpected call to BttMock.LoadDevices. %v", ctx)
	return
}

// LoadDevicesAfterCounter returns a count of finished BttMock.LoadDevices invocations
func (mmLoadDevices *BttMock) LoadDevicesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadDevices.afterLoadDevicesCounter)
}

// LoadDevicesBeforeCounter returns a count of BttMock.LoadDevices invocations
func (mmLoadDevices *BttMock) LoadDevicesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadDevices.beforeLoadDevicesCounter)
}

// Calls returns a list of arguments used in each call to BttMock.LoadDevices.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLoadDevices *mBttMockLoadDevices) Calls() []*BttMockLoadDevicesParams {
	mmLoadDevices.mutex.RLock()

	argCopy := make([]*BttMockLoadDevicesParams, len(mmLoadDevices.callArgs))
	copy(argCopy, mmLoadDevices.callArgs)

	mmLoadDevices.mutex.RUnlock()

	return argCopy
}

// MinimockLoadDevicesDone returns true if the count of the LoadDevices invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockLoadDevicesDone() bool {
	if m.LoadDevicesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoadDevicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoadDevicesMock.invocationsDone()
}

// MinimockLoadDevicesInspect logs each unmet expectation
func (m *BttMock) MinimockLoadDevicesInspect() {
	for _, e := range m.LoadDevicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.LoadDevices at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoadDevicesCounter := mm_atomic.LoadUint64(&m.afterLoadDevicesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoadDevicesMock.defaultExpectation != nil && afterLoadDevicesCounter < 1 {
		if m.LoadDevicesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.LoadDevices at\n%s", m.LoadDevicesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.LoadDevices at\n%s with params: %#v", m.LoadDevicesMock.defaultExpectation.expectationOrigins.origin, *m.LoadDevicesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoadDevices != nil && afterLoadDevicesCounter < 1 {
		m.t.Errorf("Expected call to BttMock.LoadDevices at\n%s", m.funcLoadDevicesOrigin)
	}

	if !m.LoadDevicesMock.invocationsDone() && afterLoadDevicesCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.LoadDevices at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoadDevicesMock.expectedInvocations), m.LoadDevicesMock.expectedInvocationsOrigin, afterLoadDevicesCounter)
	}
}

type mBttMockSelectDevice struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectDeviceExpectation
	expectations       []*BttMockSelectDeviceExpectation

	callArgs []*BttMockSelectDeviceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectDeviceExpectation specifies expectation struct of the Btt.SelectDevice
type BttMockSelectDeviceExpectation struct {
	mock               *BttMock
	params             *BttMockSelectDeviceParams
	paramPtrs          *BttMockSelectDeviceParamPtrs
	expectationOrigins BttMockSelectDeviceExpectationOrigins
	results            *BttMockSelectDeviceResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectDeviceParams contains parameters of the Btt.SelectDevice
type BttMockSelectDeviceParams struct {
	ctx    context.Context
	device string
}

// BttMockSelectDeviceParamPtrs contains pointers to parameters of the Btt.SelectDevice
type BttMockSelectDeviceParamPtrs struct {
	ctx    *context.Context
	device *string
}

// BttMockSelectDeviceResults contains results of the Btt.SelectDevice
type BttMockSelectDeviceResults struct {
	err error
}

// BttMockSelectDeviceOrigins contains origins of expectations of the Btt.SelectDevice
type BttMockSelectDeviceExpectationOrigins struct {
	origin       string
	originCtx    string
	originDevice string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectDevice *mBttMockSelectDevice) Optional() *mBttMockSelectDevice {
	mmSelectDevice.optional = true
	return mmSelectDevice
}

// Expect sets up expected params for Btt.SelectDevice
func (mmSelectDevice *mBttMockSelectDevice) Expect(ctx context.Context, device string) *mBttMockSelectDevice {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &BttMockSelectDeviceExpectation{}
	}

	if mmSelectDevice.defaultExpectation.paramPtrs != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by ExpectParams functions")
	}

	mmSelectDevice.defaultExpectation.params = &BttMockSelectDeviceParams{ctx, device}
	mmSelectDevice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectDevice.expectations {
		if minimock.Equal(e.params, mmSelectDevice.defaultExpectation.params) {
			mmSelectDevice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectDevice.defaultExpectation.params)
		}
	}

	return mmSelectDevice
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectDevice
func (mmSelectDevice *mBttMockSelectDevice) ExpectCtxParam1(ctx context.Context) *mBttMockSelectDevice {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &BttMockSelectDeviceExpectation{}
	}

	if mmSelectDevice.defaultExpectation.params != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Expect")
	}

	if mmSelectDevice.defaultExpectation.paramPtrs == nil {
		mmSelectDevice.defaultExpectation.paramPtrs = &BttMockSelectDeviceParamPtrs{}
	}
	mmSelectDevice.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectDevice.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectDevice
}

// ExpectDeviceParam2 sets up expected param device for Btt.SelectDevice
func (mmSelectDevice *mBttMockSelectDevice) ExpectDeviceParam2(device string) *mBttMockSelectDevice {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &BttMockSelectDeviceExpectation{}
	}

	if mmSelectDevice.defaultExpectation.params != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Expect")
	}

	if mmSelectDevice.defaultExpectation.paramPtrs == nil {
		mmSelectDevice.defaultExpectation.paramPtrs = &BttMockSelectDeviceParamPtrs{}
	}
	mmSelectDevice.defaultExpectation.paramPtrs.device = &device
	mmSelectDevice.defaultExpectation.expectationOrigins.originDevice = minimock.CallerInfo(1)

	return mmSelectDevice
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectDevice
func (mmSelectDevice *mBttMockSelectDevice) Inspect(f func(ctx context.Context, device string)) *mBttMockSelectDevice {
	if mmSelectDevice.mock.inspectFuncSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("Inspect function is already set for BttMock.SelectDevice")
	}

	mmSelectDevice.mock.inspectFuncSelectDevice = f

	return mmSelectDevice
}

// Return sets up results that will be returned by Btt.SelectDevice
func (mmSelectDevice *mBttMockSelectDevice) Return(err error) *BttMock {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &BttMockSelectDeviceExpectation{mock: mmSelectDevice.mock}
	}
	mmSelectDevice.defaultExpectation.results = &BttMockSelectDeviceResults{err}
	mmSelectDevice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectDevice.mock
}

// Set uses given function f to mock the Btt.SelectDevice method
func (mmSelectDevice *mBttMockSelectDevice) Set(f func(ctx context.Context, device string) (err error)) *BttMock {
	if mmSelectDevice.defaultExpectation != nil {
		mmSelectDevice.mock.t.Fatalf("Default expectation is already set for the Btt.SelectDevice method")
	}

	if len(mmSelectDevice.expectations) > 0 {
		mmSelectDevice.mock.t.Fatalf("Some expectations are already set for the Btt.SelectDevice method")
	}

	mmSelectDevice.mock.funcSelectDevice = f
	mmSelectDevice.mock.funcSelectDeviceOrigin = minimock.CallerInfo(1)
	return mmSelectDevice.mock
}

// When sets expectation for the Btt.SelectDevice which will trigger the result defined by the following
// Then helper
func (mmSelectDevice *mBttMockSelectDevice) When(ctx context.Context, device string) *BttMockSelectDeviceExpectation {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("BttMock.SelectDevice mock is already set by Set")
	}

	expectation := &BttMockSelectDeviceExpectation{
		mock:               mmSelectDevice.mock,
		params:             &BttMockSelectDeviceParams{ctx, device},
		expectationOrigins: BttMockSelectDeviceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectDevice.expectations = append(mmSelectDevice.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectDevice return parameters for the expectation previously defined by the When method
func (e *BttMockSelectDeviceExpectation) Then(err error) *BttMock {
	e.results = &BttMockSelectDeviceResults{err}
	return e.mock
}

// Times sets number of times Btt.SelectDevice should be invoked
func (mmSelectDevice *mBttMockSelectDevice) Times(n uint64) *mBttMockSelectDevice {
	if n == 0 {
		mmSelectDevice.mock.t.Fatalf("Times of BttMock.SelectDevice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectDevice.expectedInvocations, n)
	mmSelectDevice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectDevice
}

func (mmSelectDevice *mBttMockSelectDevice) invocationsDone() bool {
	if len(mmSelectDevice.expectations) == 0 && mmSelectDevice.defaultExpectation == nil && mmSelectDevice.mock.funcSelectDevice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectDevice.mock.afterSelectDeviceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectDevice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectDevice implements Btt
func (mmSelectDevice *BttMock) SelectDevice(ctx context.Context, device string) (err error) {
	mm_atomic.AddUint64(&mmSelectDevice.beforeSelectDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectDevice.afterSelectDeviceCounter, 1)

	mmSelectDevice.t.Helper()

	if mmSelectDevice.inspectFuncSelectDevice != nil {
		mmSelectDevice.inspectFuncSelectDevice(ctx, device)
	}

	mm_params := BttMockSelectDeviceParams{ctx, device}

	// Record call args
	mmSelectDevice.SelectDeviceMock.mutex.Lock()
	mmSelectDevice.SelectDeviceMock.callArgs = append(mmSelectDevice.SelectDeviceMock.callArgs, &mm_params)
	mmSelectDevice.SelectDeviceMock.mutex.Unlock()

	for _, e := range mmSelectDevice.SelectDeviceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectDevice.SelectDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectDevice.SelectDeviceMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectDevice.SelectDeviceMock.defaultExpectation.params
		mm_want_ptrs := mmSelectDevice.SelectDeviceMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectDeviceParams{ctx, device}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectDevice.t.Errorf("BttMock.SelectDevice got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectDevice.SelectDeviceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.device != nil && !minimock.Equal(*mm_want_ptrs.device, mm_got.device) {
				mmSelectDevice.t.Errorf("BttMock.SelectDevice got unexpected parameter device, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectDevice.SelectDeviceMock.defaultExpectation.expectationOrigins.originDevice, *mm_want_ptrs.device, mm_got.device, minimock.Diff(*mm_want_ptrs.device, mm_got.device))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectDevice.t.Errorf("BttMock.SelectDevice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectDevice.SelectDeviceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectDevice.SelectDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectDevice.t.Fatal("No results are set for the BttMock.SelectDevice")
		}
		return (*mm_results).err
	}
	if mmSelectDevice.funcSelectDevice != nil {
		return mmSelectDevice.funcSelectDevice(ctx, device)
	}
	mmSelectDevice.t.Fatalf("Unexpected call to BttMock.SelectDevice. %v %v", ctx, device)
	return
}

// SelectDeviceAfterCounter returns a count of finished BttMock.SelectDevice invocations
func (mmSelectDevice *BttMock) SelectDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectDevice.afterSelectDeviceCounter)
}

// SelectDeviceBeforeCounter returns a count of BttMock.SelectDevice invocations
func (mmSelectDevice *BttMock) SelectDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectDevice.beforeSelectDeviceCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectDevice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectDevice *mBttMockSelectDevice) Calls() []*BttMockSelectDeviceParams {
	mmSelectDevice.mutex.RLock()

	argCopy := make([]*BttMockSelectDeviceParams, len(mmSelectDevice.callArgs))
	copy(argCopy, mmSelectDevice.callArgs)

	mmSelectDevice.mutex.RUnlock()

	return argCopy
}

// MinimockSelectDeviceDone returns true if the count of the SelectDevice invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectDeviceDone() bool {
	if m.SelectDeviceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectDeviceMock.invocationsDone()
}

// MinimockSelectDeviceInspect logs each unmet expectation
func (m *BttMock) MinimockSelectDeviceInspect() {
	for _, e := range m.SelectDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectDevice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectDeviceCounter := mm_atomic.LoadUint64(&m.afterSelectDeviceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectDeviceMock.defaultExpectation != nil && afterSelectDeviceCounter < 1 {
		if m.SelectDeviceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectDevice at\n%s", m.SelectDeviceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectDevice at\n%s with params: %#v", m.SelectDeviceMock.defaultExpectation.expectationOrigins.origin, *m.SelectDeviceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectDevice != nil && afterSelectDeviceCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectDevice at\n%s", m.funcSelectDeviceOrigin)
	}

	if !m.SelectDeviceMock.invocationsDone() && afterSelectDeviceCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectDevice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectDeviceMock.expectedInvocations), m.SelectDeviceMock.expectedInvocationsOrigin, afterSelectDeviceCounter)
	}
}

type mBttMockSelectFloating struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectFloatingExpectation
	expectations       []*BttMockSelectFloatingExpectation

	callArgs []*BttMockSelectFloatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectFloatingExpectation specifies expectation struct of the Btt.SelectFloating
type BttMockSelectFloatingExpectation struct {
	mock               *BttMock
	params             *BttMockSelectFloatingParams
	paramPtrs          *BttMockSelectFloatingParamPtrs
	expectationOrigins BttMockSelectFloatingExpectationOrigins
	results            *BttMockSelectFloatingResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectFloatingParams contains parameters of the Btt.SelectFloating
type BttMockSelectFloatingParams struct {
	ctx      context.Context
	floating Floating
}

// BttMockSelectFloatingParamPtrs contains pointers to parameters of the Btt.SelectFloating
type BttMockSelectFloatingParamPtrs struct {
	ctx      *context.Context
	floating *Floating
}

// BttMockSelectFloatingResults contains results of the Btt.SelectFloating
type BttMockSelectFloatingResults struct {
	err error
}

// BttMockSelectFloatingOrigins contains origins of expectations of the Btt.SelectFloating
type BttMockSelectFloatingExpectationOrigins struct {
	origin         string
	originCtx      string
	originFloating string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectFloating *mBttMockSelectFloating) Optional() *mBttMockSelectFloating {
	mmSelectFloating.optional = true
	return mmSelectFloating
}

// Expect sets up expected params for Btt.SelectFloating
func (mmSelectFloating *mBttMockSelectFloating) Expect(ctx context.Context, floating Floating) *mBttMockSelectFloating {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &BttMockSelectFloatingExpectation{}
	}

	if mmSelectFloating.defaultExpectation.paramPtrs != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by ExpectParams functions")
	}

	mmSelectFloating.defaultExpectation.params = &BttMockSelectFloatingParams{ctx, floating}
	mmSelectFloating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectFloating.expectations {
		if minimock.Equal(e.params, mmSelectFloating.defaultExpectation.params) {
			mmSelectFloating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectFloating.defaultExpectation.params)
		}
	}

	return mmSelectFloating
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectFloating
func (mmSelectFloating *mBttMockSelectFloating) ExpectCtxParam1(ctx context.Context) *mBttMockSelectFloating {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &BttMockSelectFloatingExpectation{}
	}

	if mmSelectFloating.defaultExpectation.params != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Expect")
	}

	if mmSelectFloating.defaultExpectation.paramPtrs == nil {
		mmSelectFloating.defaultExpectation.paramPtrs = &BttMockSelectFloatingParamPtrs{}
	}
	mmSelectFloating.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectFloating.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectFloating
}

// ExpectFloatingParam2 sets up expected param floating for Btt.SelectFloating
func (mmSelectFloating *mBttMockSelectFloating) ExpectFloatingParam2(floating Floating) *mBttMockSelectFloating {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &BttMockSelectFloatingExpectation{}
	}

	if mmSelectFloating.defaultExpectation.params != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Expect")
	}

	if mmSelectFloating.defaultExpectation.paramPtrs == nil {
		mmSelectFloating.defaultExpectation.paramPtrs = &BttMockSelectFloatingParamPtrs{}
	}
	mmSelectFloating.defaultExpectation.paramPtrs.floating = &floating
	mmSelectFloating.defaultExpectation.expectationOrigins.originFloating = minimock.CallerInfo(1)

	return mmSelectFloating
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectFloating
func (mmSelectFloating *mBttMockSelectFloating) Inspect(f func(ctx context.Context, floating Floating)) *mBttMockSelectFloating {
	if mmSelectFloating.mock.inspectFuncSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("Inspect function is already set for BttMock.SelectFloating")
	}

	mmSelectFloating.mock.inspectFuncSelectFloating = f

	return mmSelectFloating
}

// Return sets up results that will be returned by Btt.SelectFloating
func (mmSelectFloating *mBttMockSelectFloating) Return(err error) *BttMock {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &BttMockSelectFloatingExpectation{mock: mmSelectFloating.mock}
	}
	mmSelectFloating.defaultExpectation.results = &BttMockSelectFloatingResults{err}
	mmSelectFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectFloating.mock
}

// Set uses given function f to mock the Btt.SelectFloating method
func (mmSelectFloating *mBttMockSelectFloating) Set(f func(ctx context.Context, floating Floating) (err error)) *BttMock {
	if mmSelectFloating.defaultExpectation != nil {
		mmSelectFloating.mock.t.Fatalf("Default expectation is already set for the Btt.SelectFloating method")
	}

	if len(mmSelectFloating.expectations) > 0 {
		mmSelectFloating.mock.t.Fatalf("Some expectations are already set for the Btt.SelectFloating method")
	}

	mmSelectFloating.mock.funcSelectFloating = f
	mmSelectFloating.mock.funcSelectFloatingOrigin = minimock.CallerInfo(1)
	return mmSelectFloating.mock
}

// When sets expectation for the Btt.SelectFloating which will trigger the result defined by the following
// Then helper
func (mmSelectFloating *mBttMockSelectFloating) When(ctx context.Context, floating Floating) *BttMockSelectFloatingExpectation {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("BttMock.SelectFloating mock is already set by Set")
	}

	expectation := &BttMockSelectFloatingExpectation{
		mock:               mmSelectFloating.mock,
		params:             &BttMockSelectFloatingParams{ctx, floating},
		expectationOrigins: BttMockSelectFloatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectFloating.expectations = append(mmSelectFloating.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectFloating return parameters for the expectation previously defined by the When method
func (e *BttMockSelectFloatingExpectation) Then(err error) *BttMock {
	e.results = &BttMockSelectFloatingResults{err}
	return e.mock
}

// Times sets number of times Btt.SelectFloating should be invoked
func (mmSelectFloating *mBttMockSelectFloating) Times(n uint64) *mBttMockSelectFloating {
	if n == 0 {
		mmSelectFloating.mock.t.Fatalf("Times of BttMock.SelectFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectFloating.expectedInvocations, n)
	mmSelectFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectFloating
}

func (mmSelectFloating *mBttMockSelectFloating) invocationsDone() bool {
	if len(mmSelectFloating.expectations) == 0 && mmSelectFloating.defaultExpectation == nil && mmSelectFloating.mock.funcSelectFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectFloating.mock.afterSelectFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectFloating implements Btt
func (mmSelectFloating *BttMock) SelectFloating(ctx context.Context, floating Floating) (err error) {
	mm_atomic.AddUint64(&mmSelectFloating.beforeSelectFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectFloating.afterSelectFloatingCounter, 1)

	mmSelectFloating.t.Helper()

	if mmSelectFloating.inspectFuncSelectFloating != nil {
		mmSelectFloating.inspectFuncSelectFloating(ctx, floating)
	}

	mm_params := BttMockSelectFloatingParams{ctx, floating}

	// Record call args
	mmSelectFloating.SelectFloatingMock.mutex.Lock()
	mmSelectFloating.SelectFloatingMock.callArgs = append(mmSelectFloating.SelectFloatingMock.callArgs, &mm_params)
	mmSelectFloating.SelectFloatingMock.mutex.Unlock()

	for _, e := range mmSelectFloating.SelectFloatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectFloating.SelectFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectFloating.SelectFloatingMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectFloating.SelectFloatingMock.defaultExpectation.params
		mm_want_ptrs := mmSelectFloating.SelectFloatingMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectFloatingParams{ctx, floating}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectFloating.t.Errorf("BttMock.SelectFloating got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectFloating.SelectFloatingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.floating != nil && !minimock.Equal(*mm_want_ptrs.floating, mm_got.floating) {
				mmSelectFloating.t.Errorf("BttMock.SelectFloating got unexpected parameter floating, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectFloating.SelectFloatingMock.defaultExpectation.expectationOrigins.originFloating, *mm_want_ptrs.floating, mm_got.floating, minimock.Diff(*mm_want_ptrs.floating, mm_got.floating))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectFloating.t.Errorf("BttMock.SelectFloating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectFloating.SelectFloatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectFloating.SelectFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectFloating.t.Fatal("No results are set for the BttMock.SelectFloating")
		}
		return (*mm_results).err
	}
	if mmSelectFloating.funcSelectFloating != nil {
		return mmSelectFloating.funcSelectFloating(ctx, floating)
	}
	mmSelectFloating.t.Fatalf("Unexpected call to BttMock.SelectFloating. %v %v", ctx, floating)
	return
}

// SelectFloatingAfterCounter returns a count of finished BttMock.SelectFloating invocations
func (mmSelectFloating *BttMock) SelectFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectFloating.afterSelectFloatingCounter)
}

// SelectFloatingBeforeCounter returns a count of BttMock.SelectFloating invocations
func (mmSelectFloating *BttMock) SelectFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectFloating.beforeSelectFloatingCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectFloating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectFloating *mBttMockSelectFloating) Calls() []*BttMockSelectFloatingParams {
	mmSelectFloating.mutex.RLock()

	argCopy := make([]*BttMockSelectFloatingParams, len(mmSelectFloating.callArgs))
	copy(argCopy, mmSelectFloating.callArgs)

	mmSelectFloating.mutex.RUnlock()

	return argCopy
}

// MinimockSelectFloatingDone returns true if the count of the SelectFloating invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectFloatingDone() bool {
	if m.SelectFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectFloatingMock.invocationsDone()
}

// MinimockSelectFloatingInspect logs each unmet expectation
func (m *BttMock) MinimockSelectFloatingInspect() {
	for _, e := range m.SelectFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectFloating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectFloatingCounter := mm_atomic.LoadUint64(&m.afterSelectFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectFloatingMock.defaultExpectation != nil && afterSelectFloatingCounter < 1 {
		if m.SelectFloatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectFloating at\n%s", m.SelectFloatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectFloating at\n%s with params: %#v", m.SelectFloatingMock.defaultExpectation.expectationOrigins.origin, *m.SelectFloatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectFloating != nil && afterSelectFloatingCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectFloating at\n%s", m.funcSelectFloatingOrigin)
	}

	if !m.SelectFloatingMock.invocationsDone() && afterSelectFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectFloatingMock.expectedInvocations), m.SelectFloatingMock.expectedInvocationsOrigin, afterSelectFloatingCounter)
	}
}

type mBttMockSelectLanguage struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectLanguageExpectation
	expectations       []*BttMockSelectLanguageExpectation

	callArgs []*BttMockSelectLanguageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectLanguageExpectation specifies expectation struct of the Btt.SelectLanguage
type BttMockSelectLanguageExpectation struct {
	mock               *BttMock
	params             *BttMockSelectLanguageParams
	paramPtrs          *BttMockSelectLanguageParamPtrs
	expectationOrigins BttMockSelectLanguageExpectationOrigins
	results            *BttMockSelectLanguageResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectLanguageParams contains parameters of the Btt.SelectLanguage
type BttMockSelectLanguageParams struct {
	ctx      context.Context
	language string
}

// BttMockSelectLanguageParamPtrs contains pointers to parameters of the Btt.SelectLanguage
type BttMockSelectLanguageParamPtrs struct {
	ctx      *context.Context
	language *string
}

// BttMockSelectLanguageResults contains results of the Btt.SelectLanguage
type BttMockSelectLanguageResults struct {
	err error
}

// BttMockSelectLanguageOrigins contains origins of expectations of the Btt.SelectLanguage
type BttMockSelectLanguageExpectationOrigins struct {
	origin         string
	originCtx      string
	originLanguage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectLanguage *mBttMockSelectLanguage) Optional() *mBttMockSelectLanguage {
	mmSelectLanguage.optional = true
	return mmSelectLanguage
}

// Expect sets up expected params for Btt.SelectLanguage
func (mmSelectLanguage *mBttMockSelectLanguage) Expect(ctx context.Context, language string) *mBttMockSelectLanguage {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &BttMockSelectLanguageExpectation{}
	}

	if mmSelectLanguage.defaultExpectation.paramPtrs != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by ExpectParams functions")
	}

	mmSelectLanguage.defaultExpectation.params = &BttMockSelectLanguageParams{ctx, language}
	mmSelectLanguage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectLanguage.expectations {
		if minimock.Equal(e.params, mmSelectLanguage.defaultExpectation.params) {
			mmSelectLanguage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectLanguage.defaultExpectation.params)
		}
	}

	return mmSelectLanguage
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectLanguage
func (mmSelectLanguage *mBttMockSelectLanguage) ExpectCtxParam1(ctx context.Context) *mBttMockSelectLanguage {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &BttMockSelectLanguageExpectation{}
	}

	if mmSelectLanguage.defaultExpectation.params != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Expect")
	}

	if mmSelectLanguage.defaultExpectation.paramPtrs == nil {
		mmSelectLanguage.defaultExpectation.paramPtrs = &BttMockSelectLanguageParamPtrs{}
	}
	mmSelectLanguage.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectLanguage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectLanguage
}

// ExpectLanguageParam2 sets up expected param language for Btt.SelectLanguage
func (mmSelectLanguage *mBttMockSelectLanguage) ExpectLanguageParam2(language string) *mBttMockSelectLanguage {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &BttMockSelectLanguageExpectation{}
	}

	if mmSelectLanguage.defaultExpectation.params != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Expect")
	}

	if mmSelectLanguage.defaultExpectation.paramPtrs == nil {
		mmSelectLanguage.defaultExpectation.paramPtrs = &BttMockSelectLanguageParamPtrs{}
	}
	mmSelectLanguage.defaultExpectation.paramPtrs.language = &language
	mmSelectLanguage.defaultExpectation.expectationOrigins.originLanguage = minimock.CallerInfo(1)

	return mmSelectLanguage
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectLanguage
func (mmSelectLanguage *mBttMockSelectLanguage) Inspect(f func(ctx context.Context, language string)) *mBttMockSelectLanguage {
	if mmSelectLanguage.mock.inspectFuncSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("Inspect function is already set for BttMock.SelectLanguage")
	}

	mmSelectLanguage.mock.inspectFuncSelectLanguage = f

	return mmSelectLanguage
}

// Return sets up results that will be returned by Btt.SelectLanguage
func (mmSelectLanguage *mBttMockSelectLanguage) Return(err error) *BttMock {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &BttMockSelectLanguageExpectation{mock: mmSelectLanguage.mock}
	}
	mmSelectLanguage.defaultExpectation.results = &BttMockSelectLanguageResults{err}
	mmSelectLanguage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectLanguage.mock
}

// Set uses given function f to mock the Btt.SelectLanguage method
func (mmSelectLanguage *mBttMockSelectLanguage) Set(f func(ctx context.Context, language string) (err error)) *BttMock {
	if mmSelectLanguage.defaultExpectation != nil {
		mmSelectLanguage.mock.t.Fatalf("Default expectation is already set for the Btt.SelectLanguage method")
	}

	if len(mmSelectLanguage.expectations) > 0 {
		mmSelectLanguage.mock.t.Fatalf("Some expectations are already set for the Btt.SelectLanguage method")
	}

	mmSelectLanguage.mock.funcSelectLanguage = f
	mmSelectLanguage.mock.funcSelectLanguageOrigin = minimock.CallerInfo(1)
	return mmSelectLanguage.mock
}

// When sets expectation for the Btt.SelectLanguage which will trigger the result defined by the following
// Then helper
func (mmSelectLanguage *mBttMockSelectLanguage) When(ctx context.Context, language string) *BttMockSelectLanguageExpectation {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("BttMock.SelectLanguage mock is already set by Set")
	}

	expectation := &BttMockSelectLanguageExpectation{
		mock:               mmSelectLanguage.mock,
		params:             &BttMockSelectLanguageParams{ctx, language},
		expectationOrigins: BttMockSelectLanguageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectLanguage.expectations = append(mmSelectLanguage.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectLanguage return parameters for the expectation previously defined by the When method
func (e *BttMockSelectLanguageExpectation) Then(err error) *BttMock {
	e.results = &BttMockSelectLanguageResults{err}
	return e.mock
}

// Times sets number of times Btt.SelectLanguage should be invoked
func (mmSelectLanguage *mBttMockSelectLanguage) Times(n uint64) *mBttMockSelectLanguage {
	if n == 0 {
		mmSelectLanguage.mock.t.Fatalf("Times of BttMock.SelectLanguage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectLanguage.expectedInvocations, n)
	mmSelectLanguage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectLanguage
}

func (mmSelectLanguage *mBttMockSelectLanguage) invocationsDone() bool {
	if len(mmSelectLanguage.expectations) == 0 && mmSelectLanguage.defaultExpectation == nil && mmSelectLanguage.mock.funcSelectLanguage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectLanguage.mock.afterSelectLanguageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectLanguage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectLanguage implements Btt
func (mmSelectLanguage *BttMock) SelectLanguage(ctx context.Context, language string) (err error) {
	mm_atomic.AddUint64(&mmSelectLanguage.beforeSelectLanguageCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectLanguage.afterSelectLanguageCounter, 1)

	mmSelectLanguage.t.Helper()

	if mmSelectLanguage.inspectFuncSelectLanguage != nil {
		mmSelectLanguage.inspectFuncSelectLanguage(ctx, language)
	}

	mm_params := BttMockSelectLanguageParams{ctx, language}

	// Record call args
	mmSelectLanguage.SelectLanguageMock.mutex.Lock()
	mmSelectLanguage.SelectLanguageMock.callArgs = append(mmSelectLanguage.SelectLanguageMock.callArgs, &mm_params)
	mmSelectLanguage.SelectLanguageMock.mutex.Unlock()

	for _, e := range mmSelectLanguage.SelectLanguageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectLanguage.SelectLanguageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectLanguage.SelectLanguageMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectLanguage.SelectLanguageMock.defaultExpectation.params
		mm_want_ptrs := mmSelectLanguage.SelectLanguageMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectLanguageParams{ctx, language}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectLanguage.t.Errorf("BttMock.SelectLanguage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectLanguage.SelectLanguageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.language != nil && !minimock.Equal(*mm_want_ptrs.language, mm_got.language) {
				mmSelectLanguage.t.Errorf("BttMock.SelectLanguage got unexpected parameter language, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectLanguage.SelectLanguageMock.defaultExpectation.expectationOrigins.originLanguage, *mm_want_ptrs.language, mm_got.language, minimock.Diff(*mm_want_ptrs.language, mm_got.language))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectLanguage.t.Errorf("BttMock.SelectLanguage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectLanguage.SelectLanguageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectLanguage.SelectLanguageMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectLanguage.t.Fatal("No results are set for the BttMock.SelectLanguage")
		}
		return (*mm_results).err
	}
	if mmSelectLanguage.funcSelectLanguage != nil {
		return mmSelectLanguage.funcSelectLanguage(ctx, language)
	}
	mmSelectLanguage.t.Fatalf("Unexpected call to BttMock.SelectLanguage. %v %v", ctx, language)
	return
}

// SelectLanguageAfterCounter returns a count of finished BttMock.SelectLanguage invocations
func (mmSelectLanguage *BttMock) SelectLanguageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectLanguage.afterSelectLanguageCounter)
}

// SelectLanguageBeforeCounter returns a count of BttMock.SelectLanguage invocations
func (mmSelectLanguage *BttMock) SelectLanguageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectLanguage.beforeSelectLanguageCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectLanguage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectLanguage *mBttMockSelectLanguage) Calls() []*BttMockSelectLanguageParams {
	mmSelectLanguage.mutex.RLock()

	argCopy := make([]*BttMockSelectLanguageParams, len(mmSelectLanguage.callArgs))
	copy(argCopy, mmSelectLanguage.callArgs)

	mmSelectLanguage.mutex.RUnlock()

	return argCopy
}

// MinimockSelectLanguageDone returns true if the count of the SelectLanguage invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectLanguageDone() bool {
	if m.SelectLanguageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectLanguageMock.invocationsDone()
}

// MinimockSelectLanguageInspect logs each unmet expectation
func (m *BttMock) MinimockSelectLanguageInspect() {
	for _, e := range m.SelectLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectLanguage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectLanguageCounter := mm_atomic.LoadUint64(&m.afterSelectLanguageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectLanguageMock.defaultExpectation != nil && afterSelectLanguageCounter < 1 {
		if m.SelectLanguageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectLanguage at\n%s", m.SelectLanguageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectLanguage at\n%s with params: %#v", m.SelectLanguageMock.defaultExpectation.expectationOrigins.origin, *m.SelectLanguageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectLanguage != nil && afterSelectLanguageCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectLanguage at\n%s", m.funcSelectLanguageOrigin)
	}

	if !m.SelectLanguageMock.invocationsDone() && afterSelectLanguageCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectLanguage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectLanguageMock.expectedInvocations), m.SelectLanguageMock.expectedInvocationsOrigin, afterSelectLanguageCounter)
	}
}

type mBttMockSelectViewMode struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectViewModeExpectation
	expectations       []*BttMockSelectViewModeExpectation

	callArgs []*BttMockSelectViewModeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectViewModeExpectation specifies expectation struct of the Btt.SelectViewMode
type BttMockSelectViewModeExpectation struct {
	mock               *BttMock
	params             *BttMockSelectViewModeParams
	paramPtrs          *BttMockSelectViewModeParamPtrs
	expectationOrigins BttMockSelectViewModeExpectationOrigins
	results            *BttMockSelectViewModeResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectViewModeParams contains parameters of the Btt.SelectViewMode
type BttMockSelectViewModeParams struct {
	ctx      context.Context
	viewMode ViewMode
}

// BttMockSelectViewModeParamPtrs contains pointers to parameters of the Btt.SelectViewMode
type BttMockSelectViewModeParamPtrs struct {
	ctx      *context.Context
	viewMode *ViewMode
}

// BttMockSelectViewModeResults contains results of the Btt.SelectViewMode
type BttMockSelectViewModeResults struct {
	err error
}

// BttMockSelectViewModeOrigins contains origins of expectations of the Btt.SelectViewMode
type BttMockSelectViewModeExpectationOrigins struct {
	origin         string
	originCtx      string
	originViewMode string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectViewMode *mBttMockSelectViewMode) Optional() *mBttMockSelectViewMode {
	mmSelectViewMode.optional = true
	return mmSelectViewMode
}

// Expect sets up expected params for Btt.SelectViewMode
func (mmSelectViewMode *mBttMockSelectViewMode) Expect(ctx context.Context, viewMode ViewMode) *mBttMockSelectViewMode {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &BttMockSelectViewModeExpectation{}
	}

	if mmSelectViewMode.defaultExpectation.paramPtrs != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by ExpectParams functions")
	}

	mmSelectViewMode.defaultExpectation.params = &BttMockSelectViewModeParams{ctx, viewMode}
	mmSelectViewMode.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectViewMode.expectations {
		if minimock.Equal(e.params, mmSelectViewMode.defaultExpectation.params) {
			mmSelectViewMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectViewMode.defaultExpectation.params)
		}
	}

	return mmSelectViewMode
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectViewMode
func (mmSelectViewMode *mBttMockSelectViewMode) ExpectCtxParam1(ctx context.Context) *mBttMockSelectViewMode {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &BttMockSelectViewModeExpectation{}
	}

	if mmSelectViewMode.defaultExpectation.params != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Expect")
	}

	if mmSelectViewMode.defaultExpectation.paramPtrs == nil {
		mmSelectViewMode.defaultExpectation.paramPtrs = &BttMockSelectViewModeParamPtrs{}
	}
	mmSelectViewMode.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectViewMode.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectViewMode
}

// ExpectViewModeParam2 sets up expected param viewMode for Btt.SelectViewMode
func (mmSelectViewMode *mBttMockSelectViewMode) ExpectViewModeParam2(viewMode ViewMode) *mBttMockSelectViewMode {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &BttMockSelectViewModeExpectation{}
	}

	if mmSelectViewMode.defaultExpectation.params != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Expect")
	}

	if mmSelectViewMode.defaultExpectation.paramPtrs == nil {
		mmSelectViewMode.defaultExpectation.paramPtrs = &BttMockSelectViewModeParamPtrs{}
	}
	mmSelectViewMode.defaultExpectation.paramPtrs.viewMode = &viewMode
	mmSelectViewMode.defaultExpectation.expectationOrigins.originViewMode = minimock.CallerInfo(1)

	return mmSelectViewMode
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectViewMode
func (mmSelectViewMode *mBttMockSelectViewMode) Inspect(f func(ctx context.Context, viewMode ViewMode)) *mBttMockSelectViewMode {
	if mmSelectViewMode.mock.inspectFuncSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("Inspect function is already set for BttMock.SelectViewMode")
	}

	mmSelectViewMode.mock.inspectFuncSelectViewMode = f

	return mmSelectViewMode
}

// Return sets up results that will be returned by Btt.SelectViewMode
func (mmSelectViewMode *mBttMockSelectViewMode) Return(err error) *BttMock {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &BttMockSelectViewModeExpectation{mock: mmSelectViewMode.mock}
	}
	mmSelectViewMode.defaultExpectation.results = &BttMockSelectViewModeResults{err}
	mmSelectViewMode.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectViewMode.mock
}

// Set uses given function f to mock the Btt.SelectViewMode method
func (mmSelectViewMode *mBttMockSelectViewMode) Set(f func(ctx context.Context, viewMode ViewMode) (err error)) *BttMock {
	if mmSelectViewMode.defaultExpectation != nil {
		mmSelectViewMode.mock.t.Fatalf("Default expectation is already set for the Btt.SelectViewMode method")
	}

	if len(mmSelectViewMode.expectations) > 0 {
		mmSelectViewMode.mock.t.Fatalf("Some expectations are already set for the Btt.SelectViewMode method")
	}

	mmSelectViewMode.mock.funcSelectViewMode = f
	mmSelectViewMode.mock.funcSelectViewModeOrigin = minimock.CallerInfo(1)
	return mmSelectViewMode.mock
}

// When sets expectation for the Btt.SelectViewMode which will trigger the result defined by the following
// Then helper
func (mmSelectViewMode *mBttMockSelectViewMode) When(ctx context.Context, viewMode ViewMode) *BttMockSelectViewModeExpectation {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("BttMock.SelectViewMode mock is already set by Set")
	}

	expectation := &BttMockSelectViewModeExpectation{
		mock:               mmSelectViewMode.mock,
		params:             &BttMockSelectViewModeParams{ctx, viewMode},
		expectationOrigins: BttMockSelectViewModeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectViewMode.expectations = append(mmSelectViewMode.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectViewMode return parameters for the expectation previously defined by the When method
func (e *BttMockSelectViewModeExpectation) Then(err error) *BttMock {
	e.results = &BttMockSelectViewModeResults{err}
	return e.mock
}

// Times sets number of times Btt.SelectViewMode should be invoked
func (mmSelectViewMode *mBttMockSelectViewMode) Times(n uint64) *mBttMockSelectViewMode {
	if n == 0 {
		mmSelectViewMode.mock.t.Fatalf("Times of BttMock.SelectViewMode mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectViewMode.expectedInvocations, n)
	mmSelectViewMode.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectViewMode
}

func (mmSelectViewMode *mBttMockSelectViewMode) invocationsDone() bool {
	if len(mmSelectViewMode.expectations) == 0 && mmSelectViewMode.defaultExpectation == nil && mmSelectViewMode.mock.funcSelectViewMode == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectViewMode.mock.afterSelectViewModeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectViewMode.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectViewMode implements Btt
func (mmSelectViewMode *BttMock) SelectViewMode(ctx context.Context, viewMode ViewMode) (err error) {
	mm_atomic.AddUint64(&mmSelectViewMode.beforeSelectViewModeCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectViewMode.afterSelectViewModeCounter, 1)

	mmSelectViewMode.t.Helper()

	if mmSelectViewMode.inspectFuncSelectViewMode != nil {
		mmSelectViewMode.inspectFuncSelectViewMode(ctx, viewMode)
	}

	mm_params := BttMockSelectViewModeParams{ctx, viewMode}

	// Record call args
	mmSelectViewMode.SelectViewModeMock.mutex.Lock()
	mmSelectViewMode.SelectViewModeMock.callArgs = append(mmSelectViewMode.SelectViewModeMock.callArgs, &mm_params)
	mmSelectViewMode.SelectViewModeMock.mutex.Unlock()

	for _, e := range mmSelectViewMode.SelectViewModeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectViewMode.SelectViewModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectViewMode.SelectViewModeMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectViewMode.SelectViewModeMock.defaultExpectation.params
		mm_want_ptrs := mmSelectViewMode.SelectViewModeMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectViewModeParams{ctx, viewMode}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectViewMode.t.Errorf("BttMock.SelectViewMode got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectViewMode.SelectViewModeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.viewMode != nil && !minimock.Equal(*mm_want_ptrs.viewMode, mm_got.viewMode) {
				mmSelectViewMode.t.Errorf("BttMock.SelectViewMode got unexpected parameter viewMode, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectViewMode.SelectViewModeMock.defaultExpectation.expectationOrigins.originViewMode, *mm_want_ptrs.viewMode, mm_got.viewMode, minimock.Diff(*mm_want_ptrs.viewMode, mm_got.viewMode))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectViewMode.t.Errorf("BttMock.SelectViewMode got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectViewMode.SelectViewModeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectViewMode.SelectViewModeMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectViewMode.t.Fatal("No results are set for the BttMock.SelectViewMode")
		}
		return (*mm_results).err
	}
	if mmSelectViewMode.funcSelectViewMode != nil {
		return mmSelectViewMode.funcSelectViewMode(ctx, viewMode)
	}
	mmSelectViewMode.t.Fatalf("Unexpected call to BttMock.SelectViewMode. %v %v", ctx, viewMode)
	return
}

// SelectViewModeAfterCounter returns a count of finished BttMock.SelectViewMode invocations
func (mmSelectViewMode *BttMock) SelectViewModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectViewMode.afterSelectViewModeCounter)
}

// SelectViewModeBeforeCounter returns a count of BttMock.SelectViewMode invocations
func (mmSelectViewMode *BttMock) SelectViewModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectViewMode.beforeSelectViewModeCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectViewMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectViewMode *mBttMockSelectViewMode) Calls() []*BttMockSelectViewModeParams {
	mmSelectViewMode.mutex.RLock()

	argCopy := make([]*BttMockSelectViewModeParams, len(mmSelectViewMode.callArgs))
	copy(argCopy, mmSelectViewMode.callArgs)

	mmSelectViewMode.mutex.RUnlock()

	return argCopy
}

// MinimockSelectViewModeDone returns true if the count of the SelectViewMode invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectViewModeDone() bool {
	if m.SelectViewModeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectViewModeMock.invocationsDone()
}

// MinimockSelectViewModeInspect logs each unmet expectation
func (m *BttMock) MinimockSelectViewModeInspect() {
	for _, e := range m.SelectViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectViewMode at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectViewModeCounter := mm_atomic.LoadUint64(&m.afterSelectViewModeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectViewModeMock.defaultExpectation != nil && afterSelectViewModeCounter < 1 {
		if m.SelectViewModeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectViewMode at\n%s", m.SelectViewModeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectViewMode at\n%s with params: %#v", m.SelectViewModeMock.defaultExpectation.expectationOrigins.origin, *m.SelectViewModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectViewMode != nil && afterSelectViewModeCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectViewMode at\n%s", m.funcSelectViewModeOrigin)
	}

	if !m.SelectViewModeMock.invocationsDone() && afterSelectViewModeCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectViewMode at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectViewModeMock.expectedInvocations), m.SelectViewModeMock.expectedInvocationsOrigin, afterSelectViewModeCounter)
	}
}

type mBttMockSelectedDevice struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectedDeviceExpectation
	expectations       []*BttMockSelectedDeviceExpectation

	callArgs []*BttMockSelectedDeviceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectedDeviceExpectation specifies expectation struct of the Btt.SelectedDevice
type BttMockSelectedDeviceExpectation struct {
	mock               *BttMock
	params             *BttMockSelectedDeviceParams
	paramPtrs          *BttMockSelectedDeviceParamPtrs
	expectationOrigins BttMockSelectedDeviceExpectationOrigins
	results            *BttMockSelectedDeviceResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectedDeviceParams contains parameters of the Btt.SelectedDevice
type BttMockSelectedDeviceParams struct {
	ctx context.Context
}

// BttMockSelectedDeviceParamPtrs contains pointers to parameters of the Btt.SelectedDevice
type BttMockSelectedDeviceParamPtrs struct {
	ctx *context.Context
}

// BttMockSelectedDeviceResults contains results of the Btt.SelectedDevice
type BttMockSelectedDeviceResults struct {
	s1  string
	err error
}

// BttMockSelectedDeviceOrigins contains origins of expectations of the Btt.SelectedDevice
type BttMockSelectedDeviceExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedDevice *mBttMockSelectedDevice) Optional() *mBttMockSelectedDevice {
	mmSelectedDevice.optional = true
	return mmSelectedDevice
}

// Expect sets up expected params for Btt.SelectedDevice
func (mmSelectedDevice *mBttMockSelectedDevice) Expect(ctx context.Context) *mBttMockSelectedDevice {
	if mmSelectedDevice.mock.funcSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("BttMock.SelectedDevice mock is already set by Set")
	}

	if mmSelectedDevice.defaultExpectation == nil {
		mmSelectedDevice.defaultExpectation = &BttMockSelectedDeviceExpectation{}
	}

	if mmSelectedDevice.defaultExpectation.paramPtrs != nil {
		mmSelectedDevice.mock.t.Fatalf("BttMock.SelectedDevice mock is already set by ExpectParams functions")
	}

	mmSelectedDevice.defaultExpectation.params = &BttMockSelectedDeviceParams{ctx}
	mmSelectedDevice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedDevice.expectations {
		if minimock.Equal(e.params, mmSelectedDevice.defaultExpectation.params) {
			mmSelectedDevice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedDevice.defaultExpectation.params)
		}
	}

	return mmSelectedDevice
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectedDevice
func (mmSelectedDevice *mBttMockSelectedDevice) ExpectCtxParam1(ctx context.Context) *mBttMockSelectedDevice {
	if mmSelectedDevice.mock.funcSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("BttMock.SelectedDevice mock is already set by Set")
	}

	if mmSelectedDevice.defaultExpectation == nil {
		mmSelectedDevice.defaultExpectation = &BttMockSelectedDeviceExpectation{}
	}

	if mmSelectedDevice.defaultExpectation.params != nil {
		mmSelectedDevice.mock.t.Fatalf("BttMock.SelectedDevice mock is already set by Expect")
	}

	if mmSelectedDevice.defaultExpectation.paramPtrs == nil {
		mmSelectedDevice.defaultExpectation.paramPtrs = &BttMockSelectedDeviceParamPtrs{}
	}
	mmSelectedDevice.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedDevice.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedDevice
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectedDevice
func (mmSelectedDevice *mBttMockSelectedDevice) Inspect(f func(ctx context.Context)) *mBttMockSelectedDevice {
	if mmSelectedDevice.mock.inspectFuncSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("Inspect function is already set for BttMock.SelectedDevice")
	}

	mmSelectedDevice.mock.inspectFuncSelectedDevice = f

	return mmSelectedDevice
}

// Return sets up results that will be returned by Btt.SelectedDevice
func (mmSelectedDevice *mBttMockSelectedDevice) Return(s1 string, err error) *BttMock {
	if mmSelectedDevice.mock.funcSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("BttMock.SelectedDevice mock is already set by Set")
	}

	if mmSelectedDevice.defaultExpectation == nil {
		mmSelectedDevice.defaultExpectation = &BttMockSelectedDeviceExpectation{mock: mmSelectedDevice.mock}
	}
	mmSelectedDevice.defaultExpectation.results = &BttMockSelectedDeviceResults{s1, err}
	mmSelectedDevice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedDevice.mock
}

// Set uses given function f to mock the Btt.SelectedDevice method
func (mmSelectedDevice *mBttMockSelectedDevice) Set(f func(ctx context.Context) (s1 string, err error)) *BttMock {
	if mmSelectedDevice.defaultExpectation != nil {
		mmSelectedDevice.mock.t.Fatalf("Default expectation is already set for the Btt.SelectedDevice method")
	}

	if len(mmSelectedDevice.expectations) > 0 {
		mmSelectedDevice.mock.t.Fatalf("Some expectations are already set for the Btt.SelectedDevice method")
	}

	mmSelectedDevice.mock.funcSelectedDevice = f
	mmSelectedDevice.mock.funcSelectedDeviceOrigin = minimock.CallerInfo(1)
	return mmSelectedDevice.mock
}

// When sets expectation for the Btt.SelectedDevice which will trigger the result defined by the following
// Then helper
func (mmSelectedDevice *mBttMockSelectedDevice) When(ctx context.Context) *BttMockSelectedDeviceExpectation {
	if mmSelectedDevice.mock.funcSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("BttMock.SelectedDevice mock is already set by Set")
	}

	expectation := &BttMockSelectedDeviceExpectation{
		mock:               mmSelectedDevice.mock,
		params:             &BttMockSelectedDeviceParams{ctx},
		expectationOrigins: BttMockSelectedDeviceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedDevice.expectations = append(mmSelectedDevice.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectedDevice return parameters for the expectation previously defined by the When method
func (e *BttMockSelectedDeviceExpectation) Then(s1 string, err error) *BttMock {
	e.results = &BttMockSelectedDeviceResults{s1, err}
	return e.mock
}

// Times sets number of times Btt.SelectedDevice should be invoked
func (mmSelectedDevice *mBttMockSelectedDevice) Times(n uint64) *mBttMockSelectedDevice {
	if n == 0 {
		mmSelectedDevice.mock.t.Fatalf("Times of BttMock.SelectedDevice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedDevice.expectedInvocations, n)
	mmSelectedDevice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedDevice
}

func (mmSelectedDevice *mBttMockSelectedDevice) invocationsDone() bool {
	if len(mmSelectedDevice.expectations) == 0 && mmSelectedDevice.defaultExpectation == nil && mmSelectedDevice.mock.funcSelectedDevice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedDevice.mock.afterSelectedDeviceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedDevice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedDevice implements Btt
func (mmSelectedDevice *BttMock) SelectedDevice(ctx context.Context) (s1 string, err error) {
	mm_atomic.AddUint64(&mmSelectedDevice.beforeSelectedDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedDevice.afterSelectedDeviceCounter, 1)

	mmSelectedDevice.t.Helper()

	if mmSelectedDevice.inspectFuncSelectedDevice != nil {
		mmSelectedDevice.inspectFuncSelectedDevice(ctx)
	}

	mm_params := BttMockSelectedDeviceParams{ctx}

	// Record call args
	mmSelectedDevice.SelectedDeviceMock.mutex.Lock()
	mmSelectedDevice.SelectedDeviceMock.callArgs = append(mmSelectedDevice.SelectedDeviceMock.callArgs, &mm_params)
	mmSelectedDevice.SelectedDeviceMock.mutex.Unlock()

	for _, e := range mmSelectedDevice.SelectedDeviceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmSelectedDevice.SelectedDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedDevice.SelectedDeviceMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedDevice.SelectedDeviceMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedDevice.SelectedDeviceMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectedDeviceParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedDevice.t.Errorf("BttMock.SelectedDevice got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedDevice.SelectedDeviceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedDevice.t.Errorf("BttMock.SelectedDevice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedDevice.SelectedDeviceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedDevice.SelectedDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedDevice.t.Fatal("No results are set for the BttMock.SelectedDevice")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmSelectedDevice.funcSelectedDevice != nil {
		return mmSelectedDevice.funcSelectedDevice(ctx)
	}
	mmSelectedDevice.t.Fatalf("Unexpected call to BttMock.SelectedDevice. %v", ctx)
	return
}

// SelectedDeviceAfterCounter returns a count of finished BttMock.SelectedDevice invocations
func (mmSelectedDevice *BttMock) SelectedDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedDevice.afterSelectedDeviceCounter)
}

// SelectedDeviceBeforeCounter returns a count of BttMock.SelectedDevice invocations
func (mmSelectedDevice *BttMock) SelectedDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedDevice.beforeSelectedDeviceCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectedDevice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedDevice *mBttMockSelectedDevice) Calls() []*BttMockSelectedDeviceParams {
	mmSelectedDevice.mutex.RLock()

	argCopy := make([]*BttMockSelectedDeviceParams, len(mmSelectedDevice.callArgs))
	copy(argCopy, mmSelectedDevice.callArgs)

	mmSelectedDevice.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedDeviceDone returns true if the count of the SelectedDevice invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectedDeviceDone() bool {
	if m.SelectedDeviceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedDeviceMock.invocationsDone()
}

// MinimockSelectedDeviceInspect logs each unmet expectation
func (m *BttMock) MinimockSelectedDeviceInspect() {
	for _, e := range m.SelectedDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectedDevice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedDeviceCounter := mm_atomic.LoadUint64(&m.afterSelectedDeviceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedDeviceMock.defaultExpectation != nil && afterSelectedDeviceCounter < 1 {
		if m.SelectedDeviceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectedDevice at\n%s", m.SelectedDeviceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectedDevice at\n%s with params: %#v", m.SelectedDeviceMock.defaultExpectation.expectationOrigins.origin, *m.SelectedDeviceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedDevice != nil && afterSelectedDeviceCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectedDevice at\n%s", m.funcSelectedDeviceOrigin)
	}

	if !m.SelectedDeviceMock.invocationsDone() && afterSelectedDeviceCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectedDevice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedDeviceMock.expectedInvocations), m.SelectedDeviceMock.expectedInvocationsOrigin, afterSelectedDeviceCounter)
	}
}

type mBttMockSelectedFloating struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectedFloatingExpectation
	expectations       []*BttMockSelectedFloatingExpectation

	callArgs []*BttMockSelectedFloatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectedFloatingExpectation specifies expectation struct of the Btt.SelectedFloating
type BttMockSelectedFloatingExpectation struct {
	mock               *BttMock
	params             *BttMockSelectedFloatingParams
	paramPtrs          *BttMockSelectedFloatingParamPtrs
	expectationOrigins BttMockSelectedFloatingExpectationOrigins
	results            *BttMockSelectedFloatingResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectedFloatingParams contains parameters of the Btt.SelectedFloating
type BttMockSelectedFloatingParams struct {
	ctx context.Context
}

// BttMockSelectedFloatingParamPtrs contains pointers to parameters of the Btt.SelectedFloating
type BttMockSelectedFloatingParamPtrs struct {
	ctx *context.Context
}

// BttMockSelectedFloatingResults contains results of the Btt.SelectedFloating
type BttMockSelectedFloatingResults struct {
	f1  Floating
	err error
}

// BttMockSelectedFloatingOrigins contains origins of expectations of the Btt.SelectedFloating
type BttMockSelectedFloatingExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedFloating *mBttMockSelectedFloating) Optional() *mBttMockSelectedFloating {
	mmSelectedFloating.optional = true
	return mmSelectedFloating
}

// Expect sets up expected params for Btt.SelectedFloating
func (mmSelectedFloating *mBttMockSelectedFloating) Expect(ctx context.Context) *mBttMockSelectedFloating {
	if mmSelectedFloating.mock.funcSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("BttMock.SelectedFloating mock is already set by Set")
	}

	if mmSelectedFloating.defaultExpectation == nil {
		mmSelectedFloating.defaultExpectation = &BttMockSelectedFloatingExpectation{}
	}

	if mmSelectedFloating.defaultExpectation.paramPtrs != nil {
		mmSelectedFloating.mock.t.Fatalf("BttMock.SelectedFloating mock is already set by ExpectParams functions")
	}

	mmSelectedFloating.defaultExpectation.params = &BttMockSelectedFloatingParams{ctx}
	mmSelectedFloating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedFloating.expectations {
		if minimock.Equal(e.params, mmSelectedFloating.defaultExpectation.params) {
			mmSelectedFloating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedFloating.defaultExpectation.params)
		}
	}

	return mmSelectedFloating
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectedFloating
func (mmSelectedFloating *mBttMockSelectedFloating) ExpectCtxParam1(ctx context.Context) *mBttMockSelectedFloating {
	if mmSelectedFloating.mock.funcSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("BttMock.SelectedFloating mock is already set by Set")
	}

	if mmSelectedFloating.defaultExpectation == nil {
		mmSelectedFloating.defaultExpectation = &BttMockSelectedFloatingExpectation{}
	}

	if mmSelectedFloating.defaultExpectation.params != nil {
		mmSelectedFloating.mock.t.Fatalf("BttMock.SelectedFloating mock is already set by Expect")
	}

	if mmSelectedFloating.defaultExpectation.paramPtrs == nil {
		mmSelectedFloating.defaultExpectation.paramPtrs = &BttMockSelectedFloatingParamPtrs{}
	}
	mmSelectedFloating.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedFloating.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedFloating
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectedFloating
func (mmSelectedFloating *mBttMockSelectedFloating) Inspect(f func(ctx context.Context)) *mBttMockSelectedFloating {
	if mmSelectedFloating.mock.inspectFuncSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("Inspect function is already set for BttMock.SelectedFloating")
	}

	mmSelectedFloating.mock.inspectFuncSelectedFloating = f

	return mmSelectedFloating
}

// Return sets up results that will be returned by Btt.SelectedFloating
func (mmSelectedFloating *mBttMockSelectedFloating) Return(f1 Floating, err error) *BttMock {
	if mmSelectedFloating.mock.funcSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("BttMock.SelectedFloating mock is already set by Set")
	}

	if mmSelectedFloating.defaultExpectation == nil {
		mmSelectedFloating.defaultExpectation = &BttMockSelectedFloatingExpectation{mock: mmSelectedFloating.mock}
	}
	mmSelectedFloating.defaultExpectation.results = &BttMockSelectedFloatingResults{f1, err}
	mmSelectedFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedFloating.mock
}

// Set uses given function f to mock the Btt.SelectedFloating method
func (mmSelectedFloating *mBttMockSelectedFloating) Set(f func(ctx context.Context) (f1 Floating, err error)) *BttMock {
	if mmSelectedFloating.defaultExpectation != nil {
		mmSelectedFloating.mock.t.Fatalf("Default expectation is already set for the Btt.SelectedFloating method")
	}

	if len(mmSelectedFloating.expectations) > 0 {
		mmSelectedFloating.mock.t.Fatalf("Some expectations are already set for the Btt.SelectedFloating method")
	}

	mmSelectedFloating.mock.funcSelectedFloating = f
	mmSelectedFloating.mock.funcSelectedFloatingOrigin = minimock.CallerInfo(1)
	return mmSelectedFloating.mock
}

// When sets expectation for the Btt.SelectedFloating which will trigger the result defined by the following
// Then helper
func (mmSelectedFloating *mBttMockSelectedFloating) When(ctx context.Context) *BttMockSelectedFloatingExpectation {
	if mmSelectedFloating.mock.funcSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("BttMock.SelectedFloating mock is already set by Set")
	}

	expectation := &BttMockSelectedFloatingExpectation{
		mock:               mmSelectedFloating.mock,
		params:             &BttMockSelectedFloatingParams{ctx},
		expectationOrigins: BttMockSelectedFloatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedFloating.expectations = append(mmSelectedFloating.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectedFloating return parameters for the expectation previously defined by the When method
func (e *BttMockSelectedFloatingExpectation) Then(f1 Floating, err error) *BttMock {
	e.results = &BttMockSelectedFloatingResults{f1, err}
	return e.mock
}

// Times sets number of times Btt.SelectedFloating should be invoked
func (mmSelectedFloating *mBttMockSelectedFloating) Times(n uint64) *mBttMockSelectedFloating {
	if n == 0 {
		mmSelectedFloating.mock.t.Fatalf("Times of BttMock.SelectedFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedFloating.expectedInvocations, n)
	mmSelectedFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedFloating
}

func (mmSelectedFloating *mBttMockSelectedFloating) invocationsDone() bool {
	if len(mmSelectedFloating.expectations) == 0 && mmSelectedFloating.defaultExpectation == nil && mmSelectedFloating.mock.funcSelectedFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedFloating.mock.afterSelectedFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedFloating implements Btt
func (mmSelectedFloating *BttMock) SelectedFloating(ctx context.Context) (f1 Floating, err error) {
	mm_atomic.AddUint64(&mmSelectedFloating.beforeSelectedFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedFloating.afterSelectedFloatingCounter, 1)

	mmSelectedFloating.t.Helper()

	if mmSelectedFloating.inspectFuncSelectedFloating != nil {
		mmSelectedFloating.inspectFuncSelectedFloating(ctx)
	}

	mm_params := BttMockSelectedFloatingParams{ctx}

	// Record call args
	mmSelectedFloating.SelectedFloatingMock.mutex.Lock()
	mmSelectedFloating.SelectedFloatingMock.callArgs = append(mmSelectedFloating.SelectedFloatingMock.callArgs, &mm_params)
	mmSelectedFloating.SelectedFloatingMock.mutex.Unlock()

	for _, e := range mmSelectedFloating.SelectedFloatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmSelectedFloating.SelectedFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedFloating.SelectedFloatingMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedFloating.SelectedFloatingMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedFloating.SelectedFloatingMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectedFloatingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedFloating.t.Errorf("BttMock.SelectedFloating got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedFloating.SelectedFloatingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedFloating.t.Errorf("BttMock.SelectedFloating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedFloating.SelectedFloatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedFloating.SelectedFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedFloating.t.Fatal("No results are set for the BttMock.SelectedFloating")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmSelectedFloating.funcSelectedFloating != nil {
		return mmSelectedFloating.funcSelectedFloating(ctx)
	}
	mmSelectedFloating.t.Fatalf("Unexpected call to BttMock.SelectedFloating. %v", ctx)
	return
}

// SelectedFloatingAfterCounter returns a count of finished BttMock.SelectedFloating invocations
func (mmSelectedFloating *BttMock) SelectedFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedFloating.afterSelectedFloatingCounter)
}

// SelectedFloatingBeforeCounter returns a count of BttMock.SelectedFloating invocations
func (mmSelectedFloating *BttMock) SelectedFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedFloating.beforeSelectedFloatingCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectedFloating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedFloating *mBttMockSelectedFloating) Calls() []*BttMockSelectedFloatingParams {
	mmSelectedFloating.mutex.RLock()

	argCopy := make([]*BttMockSelectedFloatingParams, len(mmSelectedFloating.callArgs))
	copy(argCopy, mmSelectedFloating.callArgs)

	mmSelectedFloating.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedFloatingDone returns true if the count of the SelectedFloating invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectedFloatingDone() bool {
	if m.SelectedFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedFloatingMock.invocationsDone()
}

// MinimockSelectedFloatingInspect logs each unmet expectation
func (m *BttMock) MinimockSelectedFloatingInspect() {
	for _, e := range m.SelectedFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectedFloating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedFloatingCounter := mm_atomic.LoadUint64(&m.afterSelectedFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedFloatingMock.defaultExpectation != nil && afterSelectedFloatingCounter < 1 {
		if m.SelectedFloatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectedFloating at\n%s", m.SelectedFloatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectedFloating at\n%s with params: %#v", m.SelectedFloatingMock.defaultExpectation.expectationOrigins.origin, *m.SelectedFloatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedFloating != nil && afterSelectedFloatingCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectedFloating at\n%s", m.funcSelectedFloatingOrigin)
	}

	if !m.SelectedFloatingMock.invocationsDone() && afterSelectedFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectedFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedFloatingMock.expectedInvocations), m.SelectedFloatingMock.expectedInvocationsOrigin, afterSelectedFloatingCounter)
	}
}

type mBttMockSelectedLanguage struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectedLanguageExpectation
	expectations       []*BttMockSelectedLanguageExpectation

	callArgs []*BttMockSelectedLanguageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectedLanguageExpectation specifies expectation struct of the Btt.SelectedLanguage
type BttMockSelectedLanguageExpectation struct {
	mock               *BttMock
	params             *BttMockSelectedLanguageParams
	paramPtrs          *BttMockSelectedLanguageParamPtrs
	expectationOrigins BttMockSelectedLanguageExpectationOrigins
	results            *BttMockSelectedLanguageResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectedLanguageParams contains parameters of the Btt.SelectedLanguage
type BttMockSelectedLanguageParams struct {
	ctx context.Context
}

// BttMockSelectedLanguageParamPtrs contains pointers to parameters of the Btt.SelectedLanguage
type BttMockSelectedLanguageParamPtrs struct {
	ctx *context.Context
}

// BttMockSelectedLanguageResults contains results of the Btt.SelectedLanguage
type BttMockSelectedLanguageResults struct {
	s1  string
	err error
}

// BttMockSelectedLanguageOrigins contains origins of expectations of the Btt.SelectedLanguage
type BttMockSelectedLanguageExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedLanguage *mBttMockSelectedLanguage) Optional() *mBttMockSelectedLanguage {
	mmSelectedLanguage.optional = true
	return mmSelectedLanguage
}

// Expect sets up expected params for Btt.SelectedLanguage
func (mmSelectedLanguage *mBttMockSelectedLanguage) Expect(ctx context.Context) *mBttMockSelectedLanguage {
	if mmSelectedLanguage.mock.funcSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("BttMock.SelectedLanguage mock is already set by Set")
	}

	if mmSelectedLanguage.defaultExpectation == nil {
		mmSelectedLanguage.defaultExpectation = &BttMockSelectedLanguageExpectation{}
	}

	if mmSelectedLanguage.defaultExpectation.paramPtrs != nil {
		mmSelectedLanguage.mock.t.Fatalf("BttMock.SelectedLanguage mock is already set by ExpectParams functions")
	}

	mmSelectedLanguage.defaultExpectation.params = &BttMockSelectedLanguageParams{ctx}
	mmSelectedLanguage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedLanguage.expectations {
		if minimock.Equal(e.params, mmSelectedLanguage.defaultExpectation.params) {
			mmSelectedLanguage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedLanguage.defaultExpectation.params)
		}
	}

	return mmSelectedLanguage
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectedLanguage
func (mmSelectedLanguage *mBttMockSelectedLanguage) ExpectCtxParam1(ctx context.Context) *mBttMockSelectedLanguage {
	if mmSelectedLanguage.mock.funcSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("BttMock.SelectedLanguage mock is already set by Set")
	}

	if mmSelectedLanguage.defaultExpectation == nil {
		mmSelectedLanguage.defaultExpectation = &BttMockSelectedLanguageExpectation{}
	}

	if mmSelectedLanguage.defaultExpectation.params != nil {
		mmSelectedLanguage.mock.t.Fatalf("BttMock.SelectedLanguage mock is already set by Expect")
	}

	if mmSelectedLanguage.defaultExpectation.paramPtrs == nil {
		mmSelectedLanguage.defaultExpectation.paramPtrs = &BttMockSelectedLanguageParamPtrs{}
	}
	mmSelectedLanguage.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedLanguage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedLanguage
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectedLanguage
func (mmSelectedLanguage *mBttMockSelectedLanguage) Inspect(f func(ctx context.Context)) *mBttMockSelectedLanguage {
	if mmSelectedLanguage.mock.inspectFuncSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("Inspect function is already set for BttMock.SelectedLanguage")
	}

	mmSelectedLanguage.mock.inspectFuncSelectedLanguage = f

	return mmSelectedLanguage
}

// Return sets up results that will be returned by Btt.SelectedLanguage
func (mmSelectedLanguage *mBttMockSelectedLanguage) Return(s1 string, err error) *BttMock {
	if mmSelectedLanguage.mock.funcSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("BttMock.SelectedLanguage mock is already set by Set")
	}

	if mmSelectedLanguage.defaultExpectation == nil {
		mmSelectedLanguage.defaultExpectation = &BttMockSelectedLanguageExpectation{mock: mmSelectedLanguage.mock}
	}
	mmSelectedLanguage.defaultExpectation.results = &BttMockSelectedLanguageResults{s1, err}
	mmSelectedLanguage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedLanguage.mock
}

// Set uses given function f to mock the Btt.SelectedLanguage method
func (mmSelectedLanguage *mBttMockSelectedLanguage) Set(f func(ctx context.Context) (s1 string, err error)) *BttMock {
	if mmSelectedLanguage.defaultExpectation != nil {
		mmSelectedLanguage.mock.t.Fatalf("Default expectation is already set for the Btt.SelectedLanguage method")
	}

	if len(mmSelectedLanguage.expectations) > 0 {
		mmSelectedLanguage.mock.t.Fatalf("Some expectations are already set for the Btt.SelectedLanguage method")
	}

	mmSelectedLanguage.mock.funcSelectedLanguage = f
	mmSelectedLanguage.mock.funcSelectedLanguageOrigin = minimock.CallerInfo(1)
	return mmSelectedLanguage.mock
}

// When sets expectation for the Btt.SelectedLanguage which will trigger the result defined by the following
// Then helper
func (mmSelectedLanguage *mBttMockSelectedLanguage) When(ctx context.Context) *BttMockSelectedLanguageExpectation {
	if mmSelectedLanguage.mock.funcSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("BttMock.SelectedLanguage mock is already set by Set")
	}

	expectation := &BttMockSelectedLanguageExpectation{
		mock:               mmSelectedLanguage.mock,
		params:             &BttMockSelectedLanguageParams{ctx},
		expectationOrigins: BttMockSelectedLanguageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedLanguage.expectations = append(mmSelectedLanguage.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectedLanguage return parameters for the expectation previously defined by the When method
func (e *BttMockSelectedLanguageExpectation) Then(s1 string, err error) *BttMock {
	e.results = &BttMockSelectedLanguageResults{s1, err}
	return e.mock
}

// Times sets number of times Btt.SelectedLanguage should be invoked
func (mmSelectedLanguage *mBttMockSelectedLanguage) Times(n uint64) *mBttMockSelectedLanguage {
	if n == 0 {
		mmSelectedLanguage.mock.t.Fatalf("Times of BttMock.SelectedLanguage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedLanguage.expectedInvocations, n)
	mmSelectedLanguage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedLanguage
}

func (mmSelectedLanguage *mBttMockSelectedLanguage) invocationsDone() bool {
	if len(mmSelectedLanguage.expectations) == 0 && mmSelectedLanguage.defaultExpectation == nil && mmSelectedLanguage.mock.funcSelectedLanguage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedLanguage.mock.afterSelectedLanguageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedLanguage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedLanguage implements Btt
func (mmSelectedLanguage *BttMock) SelectedLanguage(ctx context.Context) (s1 string, err error) {
	mm_atomic.AddUint64(&mmSelectedLanguage.beforeSelectedLanguageCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedLanguage.afterSelectedLanguageCounter, 1)

	mmSelectedLanguage.t.Helper()

	if mmSelectedLanguage.inspectFuncSelectedLanguage != nil {
		mmSelectedLanguage.inspectFuncSelectedLanguage(ctx)
	}

	mm_params := BttMockSelectedLanguageParams{ctx}

	// Record call args
	mmSelectedLanguage.SelectedLanguageMock.mutex.Lock()
	mmSelectedLanguage.SelectedLanguageMock.callArgs = append(mmSelectedLanguage.SelectedLanguageMock.callArgs, &mm_params)
	mmSelectedLanguage.SelectedLanguageMock.mutex.Unlock()

	for _, e := range mmSelectedLanguage.SelectedLanguageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmSelectedLanguage.SelectedLanguageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectedLanguageParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedLanguage.t.Errorf("BttMock.SelectedLanguage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedLanguage.t.Errorf("BttMock.SelectedLanguage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedLanguage.t.Fatal("No results are set for the BttMock.SelectedLanguage")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmSelectedLanguage.funcSelectedLanguage != nil {
		return mmSelectedLanguage.funcSelectedLanguage(ctx)
	}
	mmSelectedLanguage.t.Fatalf("Unexpected call to BttMock.SelectedLanguage. %v", ctx)
	return
}

// SelectedLanguageAfterCounter returns a count of finished BttMock.SelectedLanguage invocations
func (mmSelectedLanguage *BttMock) SelectedLanguageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedLanguage.afterSelectedLanguageCounter)
}

// SelectedLanguageBeforeCounter returns a count of BttMock.SelectedLanguage invocations
func (mmSelectedLanguage *BttMock) SelectedLanguageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedLanguage.beforeSelectedLanguageCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectedLanguage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedLanguage *mBttMockSelectedLanguage) Calls() []*BttMockSelectedLanguageParams {
	mmSelectedLanguage.mutex.RLock()

	argCopy := make([]*BttMockSelectedLanguageParams, len(mmSelectedLanguage.callArgs))
	copy(argCopy, mmSelectedLanguage.callArgs)

	mmSelectedLanguage.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedLanguageDone returns true if the count of the SelectedLanguage invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectedLanguageDone() bool {
	if m.SelectedLanguageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedLanguageMock.invocationsDone()
}

// MinimockSelectedLanguageInspect logs each unmet expectation
func (m *BttMock) MinimockSelectedLanguageInspect() {
	for _, e := range m.SelectedLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectedLanguage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedLanguageCounter := mm_atomic.LoadUint64(&m.afterSelectedLanguageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedLanguageMock.defaultExpectation != nil && afterSelectedLanguageCounter < 1 {
		if m.SelectedLanguageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectedLanguage at\n%s", m.SelectedLanguageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectedLanguage at\n%s with params: %#v", m.SelectedLanguageMock.defaultExpectation.expectationOrigins.origin, *m.SelectedLanguageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedLanguage != nil && afterSelectedLanguageCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectedLanguage at\n%s", m.funcSelectedLanguageOrigin)
	}

	if !m.SelectedLanguageMock.invocationsDone() && afterSelectedLanguageCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectedLanguage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedLanguageMock.expectedInvocations), m.SelectedLanguageMock.expectedInvocationsOrigin, afterSelectedLanguageCounter)
	}
}

type mBttMockSelectedViewMode struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockSelectedViewModeExpectation
	expectations       []*BttMockSelectedViewModeExpectation

	callArgs []*BttMockSelectedViewModeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockSelectedViewModeExpectation specifies expectation struct of the Btt.SelectedViewMode
type BttMockSelectedViewModeExpectation struct {
	mock               *BttMock
	params             *BttMockSelectedViewModeParams
	paramPtrs          *BttMockSelectedViewModeParamPtrs
	expectationOrigins BttMockSelectedViewModeExpectationOrigins
	results            *BttMockSelectedViewModeResults
	returnOrigin       string
	Counter            uint64
}

// BttMockSelectedViewModeParams contains parameters of the Btt.SelectedViewMode
type BttMockSelectedViewModeParams struct {
	ctx context.Context
}

// BttMockSelectedViewModeParamPtrs contains pointers to parameters of the Btt.SelectedViewMode
type BttMockSelectedViewModeParamPtrs struct {
	ctx *context.Context
}

// BttMockSelectedViewModeResults contains results of the Btt.SelectedViewMode
type BttMockSelectedViewModeResults struct {
	v1  ViewMode
	err error
}

// BttMockSelectedViewModeOrigins contains origins of expectations of the Btt.SelectedViewMode
type BttMockSelectedViewModeExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedViewMode *mBttMockSelectedViewMode) Optional() *mBttMockSelectedViewMode {
	mmSelectedViewMode.optional = true
	return mmSelectedViewMode
}

// Expect sets up expected params for Btt.SelectedViewMode
func (mmSelectedViewMode *mBttMockSelectedViewMode) Expect(ctx context.Context) *mBttMockSelectedViewMode {
	if mmSelectedViewMode.mock.funcSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("BttMock.SelectedViewMode mock is already set by Set")
	}

	if mmSelectedViewMode.defaultExpectation == nil {
		mmSelectedViewMode.defaultExpectation = &BttMockSelectedViewModeExpectation{}
	}

	if mmSelectedViewMode.defaultExpectation.paramPtrs != nil {
		mmSelectedViewMode.mock.t.Fatalf("BttMock.SelectedViewMode mock is already set by ExpectParams functions")
	}

	mmSelectedViewMode.defaultExpectation.params = &BttMockSelectedViewModeParams{ctx}
	mmSelectedViewMode.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedViewMode.expectations {
		if minimock.Equal(e.params, mmSelectedViewMode.defaultExpectation.params) {
			mmSelectedViewMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedViewMode.defaultExpectation.params)
		}
	}

	return mmSelectedViewMode
}

// ExpectCtxParam1 sets up expected param ctx for Btt.SelectedViewMode
func (mmSelectedViewMode *mBttMockSelectedViewMode) ExpectCtxParam1(ctx context.Context) *mBttMockSelectedViewMode {
	if mmSelectedViewMode.mock.funcSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("BttMock.SelectedViewMode mock is already set by Set")
	}

	if mmSelectedViewMode.defaultExpectation == nil {
		mmSelectedViewMode.defaultExpectation = &BttMockSelectedViewModeExpectation{}
	}

	if mmSelectedViewMode.defaultExpectation.params != nil {
		mmSelectedViewMode.mock.t.Fatalf("BttMock.SelectedViewMode mock is already set by Expect")
	}

	if mmSelectedViewMode.defaultExpectation.paramPtrs == nil {
		mmSelectedViewMode.defaultExpectation.paramPtrs = &BttMockSelectedViewModeParamPtrs{}
	}
	mmSelectedViewMode.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedViewMode.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedViewMode
}

// Inspect accepts an inspector function that has same arguments as the Btt.SelectedViewMode
func (mmSelectedViewMode *mBttMockSelectedViewMode) Inspect(f func(ctx context.Context)) *mBttMockSelectedViewMode {
	if mmSelectedViewMode.mock.inspectFuncSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("Inspect function is already set for BttMock.SelectedViewMode")
	}

	mmSelectedViewMode.mock.inspectFuncSelectedViewMode = f

	return mmSelectedViewMode
}

// Return sets up results that will be returned by Btt.SelectedViewMode
func (mmSelectedViewMode *mBttMockSelectedViewMode) Return(v1 ViewMode, err error) *BttMock {
	if mmSelectedViewMode.mock.funcSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("BttMock.SelectedViewMode mock is already set by Set")
	}

	if mmSelectedViewMode.defaultExpectation == nil {
		mmSelectedViewMode.defaultExpectation = &BttMockSelectedViewModeExpectation{mock: mmSelectedViewMode.mock}
	}
	mmSelectedViewMode.defaultExpectation.results = &BttMockSelectedViewModeResults{v1, err}
	mmSelectedViewMode.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedViewMode.mock
}

// Set uses given function f to mock the Btt.SelectedViewMode method
func (mmSelectedViewMode *mBttMockSelectedViewMode) Set(f func(ctx context.Context) (v1 ViewMode, err error)) *BttMock {
	if mmSelectedViewMode.defaultExpectation != nil {
		mmSelectedViewMode.mock.t.Fatalf("Default expectation is already set for the Btt.SelectedViewMode method")
	}

	if len(mmSelectedViewMode.expectations) > 0 {
		mmSelectedViewMode.mock.t.Fatalf("Some expectations are already set for the Btt.SelectedViewMode method")
	}

	mmSelectedViewMode.mock.funcSelectedViewMode = f
	mmSelectedViewMode.mock.funcSelectedViewModeOrigin = minimock.CallerInfo(1)
	return mmSelectedViewMode.mock
}

// When sets expectation for the Btt.SelectedViewMode which will trigger the result defined by the following
// Then helper
func (mmSelectedViewMode *mBttMockSelectedViewMode) When(ctx context.Context) *BttMockSelectedViewModeExpectation {
	if mmSelectedViewMode.mock.funcSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("BttMock.SelectedViewMode mock is already set by Set")
	}

	expectation := &BttMockSelectedViewModeExpectation{
		mock:               mmSelectedViewMode.mock,
		params:             &BttMockSelectedViewModeParams{ctx},
		expectationOrigins: BttMockSelectedViewModeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedViewMode.expectations = append(mmSelectedViewMode.expectations, expectation)
	return expectation
}

// Then sets up Btt.SelectedViewMode return parameters for the expectation previously defined by the When method
func (e *BttMockSelectedViewModeExpectation) Then(v1 ViewMode, err error) *BttMock {
	e.results = &BttMockSelectedViewModeResults{v1, err}
	return e.mock
}

// Times sets number of times Btt.SelectedViewMode should be invoked
func (mmSelectedViewMode *mBttMockSelectedViewMode) Times(n uint64) *mBttMockSelectedViewMode {
	if n == 0 {
		mmSelectedViewMode.mock.t.Fatalf("Times of BttMock.SelectedViewMode mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedViewMode.expectedInvocations, n)
	mmSelectedViewMode.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedViewMode
}

func (mmSelectedViewMode *mBttMockSelectedViewMode) invocationsDone() bool {
	if len(mmSelectedViewMode.expectations) == 0 && mmSelectedViewMode.defaultExpectation == nil && mmSelectedViewMode.mock.funcSelectedViewMode == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedViewMode.mock.afterSelectedViewModeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedViewMode.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedViewMode implements Btt
func (mmSelectedViewMode *BttMock) SelectedViewMode(ctx context.Context) (v1 ViewMode, err error) {
	mm_atomic.AddUint64(&mmSelectedViewMode.beforeSelectedViewModeCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedViewMode.afterSelectedViewModeCounter, 1)

	mmSelectedViewMode.t.Helper()

	if mmSelectedViewMode.inspectFuncSelectedViewMode != nil {
		mmSelectedViewMode.inspectFuncSelectedViewMode(ctx)
	}

	mm_params := BttMockSelectedViewModeParams{ctx}

	// Record call args
	mmSelectedViewMode.SelectedViewModeMock.mutex.Lock()
	mmSelectedViewMode.SelectedViewModeMock.callArgs = append(mmSelectedViewMode.SelectedViewModeMock.callArgs, &mm_params)
	mmSelectedViewMode.SelectedViewModeMock.mutex.Unlock()

	for _, e := range mmSelectedViewMode.SelectedViewModeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.v1, e.results.err
		}
	}

	if mmSelectedViewMode.SelectedViewModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.paramPtrs

		mm_got := BttMockSelectedViewModeParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedViewMode.t.Errorf("BttMock.SelectedViewMode got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedViewMode.t.Errorf("BttMock.SelectedViewMode got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedViewMode.t.Fatal("No results are set for the BttMock.SelectedViewMode")
		}
		return (*mm_results).v1, (*mm_results).err
	}
	if mmSelectedViewMode.funcSelectedViewMode != nil {
		return mmSelectedViewMode.funcSelectedViewMode(ctx)
	}
	mmSelectedViewMode.t.Fatalf("Unexpected call to BttMock.SelectedViewMode. %v", ctx)
	return
}

// SelectedViewModeAfterCounter returns a count of finished BttMock.SelectedViewMode invocations
func (mmSelectedViewMode *BttMock) SelectedViewModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedViewMode.afterSelectedViewModeCounter)
}

// SelectedViewModeBeforeCounter returns a count of BttMock.SelectedViewMode invocations
func (mmSelectedViewMode *BttMock) SelectedViewModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedViewMode.beforeSelectedViewModeCounter)
}

// Calls returns a list of arguments used in each call to BttMock.SelectedViewMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedViewMode *mBttMockSelectedViewMode) Calls() []*BttMockSelectedViewModeParams {
	mmSelectedViewMode.mutex.RLock()

	argCopy := make([]*BttMockSelectedViewModeParams, len(mmSelectedViewMode.callArgs))
	copy(argCopy, mmSelectedViewMode.callArgs)

	mmSelectedViewMode.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedViewModeDone returns true if the count of the SelectedViewMode invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockSelectedViewModeDone() bool {
	if m.SelectedViewModeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedViewModeMock.invocationsDone()
}

// MinimockSelectedViewModeInspect logs each unmet expectation
func (m *BttMock) MinimockSelectedViewModeInspect() {
	for _, e := range m.SelectedViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.SelectedViewMode at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedViewModeCounter := mm_atomic.LoadUint64(&m.afterSelectedViewModeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedViewModeMock.defaultExpectation != nil && afterSelectedViewModeCounter < 1 {
		if m.SelectedViewModeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.SelectedViewMode at\n%s", m.SelectedViewModeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.SelectedViewMode at\n%s with params: %#v", m.SelectedViewModeMock.defaultExpectation.expectationOrigins.origin, *m.SelectedViewModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedViewMode != nil && afterSelectedViewModeCounter < 1 {
		m.t.Errorf("Expected call to BttMock.SelectedViewMode at\n%s", m.funcSelectedViewModeOrigin)
	}

	if !m.SelectedViewModeMock.invocationsDone() && afterSelectedViewModeCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.SelectedViewMode at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedViewModeMock.expectedInvocations), m.SelectedViewModeMock.expectedInvocationsOrigin, afterSelectedViewModeCounter)
	}
}

type mBttMockShowFloating struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockShowFloatingExpectation
	expectations       []*BttMockShowFloatingExpectation

	callArgs []*BttMockShowFloatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockShowFloatingExpectation specifies expectation struct of the Btt.ShowFloating
type BttMockShowFloatingExpectation struct {
	mock               *BttMock
	params             *BttMockShowFloatingParams
	paramPtrs          *BttMockShowFloatingParamPtrs
	expectationOrigins BttMockShowFloatingExpectationOrigins
	results            *BttMockShowFloatingResults
	returnOrigin       string
	Counter            uint64
}

// BttMockShowFloatingParams contains parameters of the Btt.ShowFloating
type BttMockShowFloatingParams struct {
	ctx context.Context
}

// BttMockShowFloatingParamPtrs contains pointers to parameters of the Btt.ShowFloating
type BttMockShowFloatingParamPtrs struct {
	ctx *context.Context
}

// BttMockShowFloatingResults contains results of the Btt.ShowFloating
type BttMockShowFloatingResults struct {
	err error
}

// BttMockShowFloatingOrigins contains origins of expectations of the Btt.ShowFloating
type BttMockShowFloatingExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmShowFloating *mBttMockShowFloating) Optional() *mBttMockShowFloating {
	mmShowFloating.optional = true
	return mmShowFloating
}

// Expect sets up expected params for Btt.ShowFloating
func (mmShowFloating *mBttMockShowFloating) Expect(ctx context.Context) *mBttMockShowFloating {
	if mmShowFloating.mock.funcShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("BttMock.ShowFloating mock is already set by Set")
	}

	if mmShowFloating.defaultExpectation == nil {
		mmShowFloating.defaultExpectation = &BttMockShowFloatingExpectation{}
	}

	if mmShowFloating.defaultExpectation.paramPtrs != nil {
		mmShowFloating.mock.t.Fatalf("BttMock.ShowFloating mock is already set by ExpectParams functions")
	}

	mmShowFloating.defaultExpectation.params = &BttMockShowFloatingParams{ctx}
	mmShowFloating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmShowFloating.expectations {
		if minimock.Equal(e.params, mmShowFloating.defaultExpectation.params) {
			mmShowFloating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmShowFloating.defaultExpectation.params)
		}
	}

	return mmShowFloating
}

// ExpectCtxParam1 sets up expected param ctx for Btt.ShowFloating
func (mmShowFloating *mBttMockShowFloating) ExpectCtxParam1(ctx context.Context) *mBttMockShowFloating {
	if mmShowFloating.mock.funcShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("BttMock.ShowFloating mock is already set by Set")
	}

	if mmShowFloating.defaultExpectation == nil {
		mmShowFloating.defaultExpectation = &BttMockShowFloatingExpectation{}
	}

	if mmShowFloating.defaultExpectation.params != nil {
		mmShowFloating.mock.t.Fatalf("BttMock.ShowFloating mock is already set by Expect")
	}

	if mmShowFloating.defaultExpectation.paramPtrs == nil {
		mmShowFloating.defaultExpectation.paramPtrs = &BttMockShowFloatingParamPtrs{}
	}
	mmShowFloating.defaultExpectation.paramPtrs.ctx = &ctx
	mmShowFloating.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmShowFloating
}

// Inspect accepts an inspector function that has same arguments as the Btt.ShowFloating
func (mmShowFloating *mBttMockShowFloating) Inspect(f func(ctx context.Context)) *mBttMockShowFloating {
	if mmShowFloating.mock.inspectFuncShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("Inspect function is already set for BttMock.ShowFloating")
	}

	mmShowFloating.mock.inspectFuncShowFloating = f

	return mmShowFloating
}

// Return sets up results that will be returned by Btt.ShowFloating
func (mmShowFloating *mBttMockShowFloating) Return(err error) *BttMock {
	if mmShowFloating.mock.funcShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("BttMock.ShowFloating mock is already set by Set")
	}

	if mmShowFloating.defaultExpectation == nil {
		mmShowFloating.defaultExpectation = &BttMockShowFloatingExpectation{mock: mmShowFloating.mock}
	}
	mmShowFloating.defaultExpectation.results = &BttMockShowFloatingResults{err}
	mmShowFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmShowFloating.mock
}

// Set uses given function f to mock the Btt.ShowFloating method
func (mmShowFloating *mBttMockShowFloating) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmShowFloating.defaultExpectation != nil {
		mmShowFloating.mock.t.Fatalf("Default expectation is already set for the Btt.ShowFloating method")
	}

	if len(mmShowFloating.expectations) > 0 {
		mmShowFloating.mock.t.Fatalf("Some expectations are already set for the Btt.ShowFloating method")
	}

	mmShowFloating.mock.funcShowFloating = f
	mmShowFloating.mock.funcShowFloatingOrigin = minimock.CallerInfo(1)
	return mmShowFloating.mock
}

// When sets expectation for the Btt.ShowFloating which will trigger the result defined by the following
// Then helper
func (mmShowFloating *mBttMockShowFloating) When(ctx context.Context) *BttMockShowFloatingExpectation {
	if mmShowFloating.mock.funcShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("BttMock.ShowFloating mock is already set by Set")
	}

	expectation := &BttMockShowFloatingExpectation{
		mock:               mmShowFloating.mock,
		params:             &BttMockShowFloatingParams{ctx},
		expectationOrigins: BttMockShowFloatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmShowFloating.expectations = append(mmShowFloating.expectations, expectation)
	return expectation
}

// Then sets up Btt.ShowFloating return parameters for the expectation previously defined by the When method
func (e *BttMockShowFloatingExpectation) Then(err error) *BttMock {
	e.results = &BttMockShowFloatingResults{err}
	return e.mock
}

// Times sets number of times Btt.ShowFloating should be invoked
func (mmShowFloating *mBttMockShowFloating) Times(n uint64) *mBttMockShowFloating {
	if n == 0 {
		mmShowFloating.mock.t.Fatalf("Times of BttMock.ShowFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmShowFloating.expectedInvocations, n)
	mmShowFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmShowFloating
}

func (mmShowFloating *mBttMockShowFloating) invocationsDone() bool {
	if len(mmShowFloating.expectations) == 0 && mmShowFloating.defaultExpectation == nil && mmShowFloating.mock.funcShowFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmShowFloating.mock.afterShowFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmShowFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ShowFloating implements Btt
func (mmShowFloating *BttMock) ShowFloating(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmShowFloating.beforeShowFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmShowFloating.afterShowFloatingCounter, 1)

	mmShowFloating.t.Helper()

	if mmShowFloating.inspectFuncShowFloating != nil {
		mmShowFloating.inspectFuncShowFloating(ctx)
	}

	mm_params := BttMockShowFloatingParams{ctx}

	// Record call args
	mmShowFloating.ShowFloatingMock.mutex.Lock()
	mmShowFloating.ShowFloatingMock.callArgs = append(mmShowFloating.ShowFloatingMock.callArgs, &mm_params)
	mmShowFloating.ShowFloatingMock.mutex.Unlock()

	for _, e := range mmShowFloating.ShowFloatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmShowFloating.ShowFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShowFloating.ShowFloatingMock.defaultExpectation.Counter, 1)
		mm_want := mmShowFloating.ShowFloatingMock.defaultExpectation.params
		mm_want_ptrs := mmShowFloating.ShowFloatingMock.defaultExpectation.paramPtrs

		mm_got := BttMockShowFloatingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmShowFloating.t.Errorf("BttMock.ShowFloating got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmShowFloating.ShowFloatingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmShowFloating.t.Errorf("BttMock.ShowFloating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmShowFloating.ShowFloatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmShowFloating.ShowFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmShowFloating.t.Fatal("No results are set for the BttMock.ShowFloating")
		}
		return (*mm_results).err
	}
	if mmShowFloating.funcShowFloating != nil {
		return mmShowFloating.funcShowFloating(ctx)
	}
	mmShowFloating.t.Fatalf("Unexpected call to BttMock.ShowFloating. %v", ctx)
	return
}

// ShowFloatingAfterCounter returns a count of finished BttMock.ShowFloating invocations
func (mmShowFloating *BttMock) ShowFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShowFloating.afterShowFloatingCounter)
}

// ShowFloatingBeforeCounter returns a count of BttMock.ShowFloating invocations
func (mmShowFloating *BttMock) ShowFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShowFloating.beforeShowFloatingCounter)
}

// Calls returns a list of arguments used in each call to BttMock.ShowFloating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmShowFloating *mBttMockShowFloating) Calls() []*BttMockShowFloatingParams {
	mmShowFloating.mutex.RLock()

	argCopy := make([]*BttMockShowFloatingParams, len(mmShowFloating.callArgs))
	copy(argCopy, mmShowFloating.callArgs)

	mmShowFloating.mutex.RUnlock()

	return argCopy
}

// MinimockShowFloatingDone returns true if the count of the ShowFloating invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockShowFloatingDone() bool {
	if m.ShowFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ShowFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ShowFloatingMock.invocationsDone()
}

// MinimockShowFloatingInspect logs each unmet expectation
func (m *BttMock) MinimockShowFloatingInspect() {
	for _, e := range m.ShowFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.ShowFloating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterShowFloatingCounter := mm_atomic.LoadUint64(&m.afterShowFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ShowFloatingMock.defaultExpectation != nil && afterShowFloatingCounter < 1 {
		if m.ShowFloatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.ShowFloating at\n%s", m.ShowFloatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.ShowFloating at\n%s with params: %#v", m.ShowFloatingMock.defaultExpectation.expectationOrigins.origin, *m.ShowFloatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShowFloating != nil && afterShowFloatingCounter < 1 {
		m.t.Errorf("Expected call to BttMock.ShowFloating at\n%s", m.funcShowFloatingOrigin)
	}

	if !m.ShowFloatingMock.invocationsDone() && afterShowFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.ShowFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ShowFloatingMock.expectedInvocations), m.ShowFloatingMock.expectedInvocationsOrigin, afterShowFloatingCounter)
	}
}

type mBttMockStartListening struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockStartListeningExpectation
	expectations       []*BttMockStartListeningExpectation

	callArgs []*BttMockStartListeningParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockStartListeningExpectation specifies expectation struct of the Btt.StartListening
type BttMockStartListeningExpectation struct {
	mock               *BttMock
	params             *BttMockStartListeningParams
	paramPtrs          *BttMockStartListeningParamPtrs
	expectationOrigins BttMockStartListeningExpectationOrigins
	results            *BttMockStartListeningResults
	returnOrigin       string
	Counter            uint64
}

// BttMockStartListeningParams contains parameters of the Btt.StartListening
type BttMockStartListeningParams struct {
	ctx context.Context
}

// BttMockStartListeningParamPtrs contains pointers to parameters of the Btt.StartListening
type BttMockStartListeningParamPtrs struct {
	ctx *context.Context
}

// BttMockStartListeningResults contains results of the Btt.StartListening
type BttMockStartListeningResults struct {
	err error
}

// BttMockStartListeningOrigins contains origins of expectations of the Btt.StartListening
type BttMockStartListeningExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStartListening *mBttMockStartListening) Optional() *mBttMockStartListening {
	mmStartListening.optional = true
	return mmStartListening
}

// Expect sets up expected params for Btt.StartListening
func (mmStartListening *mBttMockStartListening) Expect(ctx context.Context) *mBttMockStartListening {
	if mmStartListening.mock.funcStartListening != nil {
		mmStartListening.mock.t.Fatalf("BttMock.StartListening mock is already set by Set")
	}

	if mmStartListening.defaultExpectation == nil {
		mmStartListening.defaultExpectation = &BttMockStartListeningExpectation{}
	}

	if mmStartListening.defaultExpectation.paramPtrs != nil {
		mmStartListening.mock.t.Fatalf("BttMock.StartListening mock is already set by ExpectParams functions")
	}

	mmStartListening.defaultExpectation.params = &BttMockStartListeningParams{ctx}
	mmStartListening.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStartListening.expectations {
		if minimock.Equal(e.params, mmStartListening.defaultExpectation.params) {
			mmStartListening.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStartListening.defaultExpectation.params)
		}
	}

	return mmStartListening
}

// ExpectCtxParam1 sets up expected param ctx for Btt.StartListening
func (mmStartListening *mBttMockStartListening) ExpectCtxParam1(ctx context.Context) *mBttMockStartListening {
	if mmStartListening.mock.funcStartListening != nil {
		mmStartListening.mock.t.Fatalf("BttMock.StartListening mock is already set by Set")
	}

	if mmStartListening.defaultExpectation == nil {
		mmStartListening.defaultExpectation = &BttMockStartListeningExpectation{}
	}

	if mmStartListening.defaultExpectation.params != nil {
		mmStartListening.mock.t.Fatalf("BttMock.StartListening mock is already set by Expect")
	}

	if mmStartListening.defaultExpectation.paramPtrs == nil {
		mmStartListening.defaultExpectation.paramPtrs = &BttMockStartListeningParamPtrs{}
	}
	mmStartListening.defaultExpectation.paramPtrs.ctx = &ctx
	mmStartListening.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStartListening
}

// Inspect accepts an inspector function that has same arguments as the Btt.StartListening
func (mmStartListening *mBttMockStartListening) Inspect(f func(ctx context.Context)) *mBttMockStartListening {
	if mmStartListening.mock.inspectFuncStartListening != nil {
		mmStartListening.mock.t.Fatalf("Inspect function is already set for BttMock.StartListening")
	}

	mmStartListening.mock.inspectFuncStartListening = f

	return mmStartListening
}

// Return sets up results that will be returned by Btt.StartListening
func (mmStartListening *mBttMockStartListening) Return(err error) *BttMock {
	if mmStartListening.mock.funcStartListening != nil {
		mmStartListening.mock.t.Fatalf("BttMock.StartListening mock is already set by Set")
	}

	if mmStartListening.defaultExpectation == nil {
		mmStartListening.defaultExpectation = &BttMockStartListeningExpectation{mock: mmStartListening.mock}
	}
	mmStartListening.defaultExpectation.results = &BttMockStartListeningResults{err}
	mmStartListening.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStartListening.mock
}

// Set uses given function f to mock the Btt.StartListening method
func (mmStartListening *mBttMockStartListening) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmStartListening.defaultExpectation != nil {
		mmStartListening.mock.t.Fatalf("Default expectation is already set for the Btt.StartListening method")
	}

	if len(mmStartListening.expectations) > 0 {
		mmStartListening.mock.t.Fatalf("Some expectations are already set for the Btt.StartListening method")
	}

	mmStartListening.mock.funcStartListening = f
	mmStartListening.mock.funcStartListeningOrigin = minimock.CallerInfo(1)
	return mmStartListening.mock
}

// When sets expectation for the Btt.StartListening which will trigger the result defined by the following
// Then helper
func (mmStartListening *mBttMockStartListening) When(ctx context.Context) *BttMockStartListeningExpectation {
	if mmStartListening.mock.funcStartListening != nil {
		mmStartListening.mock.t.Fatalf("BttMock.StartListening mock is already set by Set")
	}

	expectation := &BttMockStartListeningExpectation{
		mock:               mmStartListening.mock,
		params:             &BttMockStartListeningParams{ctx},
		expectationOrigins: BttMockStartListeningExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStartListening.expectations = append(mmStartListening.expectations, expectation)
	return expectation
}

// Then sets up Btt.StartListening return parameters for the expectation previously defined by the When method
func (e *BttMockStartListeningExpectation) Then(err error) *BttMock {
	e.results = &BttMockStartListeningResults{err}
	return e.mock
}

// Times sets number of times Btt.StartListening should be invoked
func (mmStartListening *mBttMockStartListening) Times(n uint64) *mBttMockStartListening {
	if n == 0 {
		mmStartListening.mock.t.Fatalf("Times of BttMock.StartListening mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStartListening.expectedInvocations, n)
	mmStartListening.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStartListening
}

func (mmStartListening *mBttMockStartListening) invocationsDone() bool {
	if len(mmStartListening.expectations) == 0 && mmStartListening.defaultExpectation == nil && mmStartListening.mock.funcStartListening == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStartListening.mock.afterStartListeningCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStartListening.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StartListening implements Btt
func (mmStartListening *BttMock) StartListening(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStartListening.beforeStartListeningCounter, 1)
	defer mm_atomic.AddUint64(&mmStartListening.afterStartListeningCounter, 1)

	mmStartListening.t.Helper()

	if mmStartListening.inspectFuncStartListening != nil {
		mmStartListening.inspectFuncStartListening(ctx)
	}

	mm_params := BttMockStartListeningParams{ctx}

	// Record call args
	mmStartListening.StartListeningMock.mutex.Lock()
	mmStartListening.StartListeningMock.callArgs = append(mmStartListening.StartListeningMock.callArgs, &mm_params)
	mmStartListening.StartListeningMock.mutex.Unlock()

	for _, e := range mmStartListening.StartListeningMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStartListening.StartListeningMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStartListening.StartListeningMock.defaultExpectation.Counter, 1)
		mm_want := mmStartListening.StartListeningMock.defaultExpectation.params
		mm_want_ptrs := mmStartListening.StartListeningMock.defaultExpectation.paramPtrs

		mm_got := BttMockStartListeningParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStartListening.t.Errorf("BttMock.StartListening got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStartListening.StartListeningMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStartListening.t.Errorf("BttMock.StartListening got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStartListening.StartListeningMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStartListening.StartListeningMock.defaultExpectation.results
		if mm_results == nil {
			mmStartListening.t.Fatal("No results are set for the BttMock.StartListening")
		}
		return (*mm_results).err
	}
	if mmStartListening.funcStartListening != nil {
		return mmStartListening.funcStartListening(ctx)
	}
	mmStartListening.t.Fatalf("Unexpected call to BttMock.StartListening. %v", ctx)
	return
}

// StartListeningAfterCounter returns a count of finished BttMock.StartListening invocations
func (mmStartListening *BttMock) StartListeningAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartListening.afterStartListeningCounter)
}

// StartListeningBeforeCounter returns a count of BttMock.StartListening invocations
func (mmStartListening *BttMock) StartListeningBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartListening.beforeStartListeningCounter)
}

// Calls returns a list of arguments used in each call to BttMock.StartListening.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStartListening *mBttMockStartListening) Calls() []*BttMockStartListeningParams {
	mmStartListening.mutex.RLock()

	argCopy := make([]*BttMockStartListeningParams, len(mmStartListening.callArgs))
	copy(argCopy, mmStartListening.callArgs)

	mmStartListening.mutex.RUnlock()

	return argCopy
}

// MinimockStartListeningDone returns true if the count of the StartListening invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockStartListeningDone() bool {
	if m.StartListeningMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StartListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StartListeningMock.invocationsDone()
}

// MinimockStartListeningInspect logs each unmet expectation
func (m *BttMock) MinimockStartListeningInspect() {
	for _, e := range m.StartListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.StartListening at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStartListeningCounter := mm_atomic.LoadUint64(&m.afterStartListeningCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StartListeningMock.defaultExpectation != nil && afterStartListeningCounter < 1 {
		if m.StartListeningMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.StartListening at\n%s", m.StartListeningMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.StartListening at\n%s with params: %#v", m.StartListeningMock.defaultExpectation.expectationOrigins.origin, *m.StartListeningMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartListening != nil && afterStartListeningCounter < 1 {
		m.t.Errorf("Expected call to BttMock.StartListening at\n%s", m.funcStartListeningOrigin)
	}

	if !m.StartListeningMock.invocationsDone() && afterStartListeningCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.StartListening at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StartListeningMock.expectedInvocations), m.StartListeningMock.expectedInvocationsOrigin, afterStartListeningCounter)
	}
}

type mBttMockStopListening struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockStopListeningExpectation
	expectations       []*BttMockStopListeningExpectation

	callArgs []*BttMockStopListeningParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockStopListeningExpectation specifies expectation struct of the Btt.StopListening
type BttMockStopListeningExpectation struct {
	mock               *BttMock
	params             *BttMockStopListeningParams
	paramPtrs          *BttMockStopListeningParamPtrs
	expectationOrigins BttMockStopListeningExpectationOrigins
	results            *BttMockStopListeningResults
	returnOrigin       string
	Counter            uint64
}

// BttMockStopListeningParams contains parameters of the Btt.StopListening
type BttMockStopListeningParams struct {
	ctx context.Context
}

// BttMockStopListeningParamPtrs contains pointers to parameters of the Btt.StopListening
type BttMockStopListeningParamPtrs struct {
	ctx *context.Context
}

// BttMockStopListeningResults contains results of the Btt.StopListening
type BttMockStopListeningResults struct {
	err error
}

// BttMockStopListeningOrigins contains origins of expectations of the Btt.StopListening
type BttMockStopListeningExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStopListening *mBttMockStopListening) Optional() *mBttMockStopListening {
	mmStopListening.optional = true
	return mmStopListening
}

// Expect sets up expected params for Btt.StopListening
func (mmStopListening *mBttMockStopListening) Expect(ctx context.Context) *mBttMockStopListening {
	if mmStopListening.mock.funcStopListening != nil {
		mmStopListening.mock.t.Fatalf("BttMock.StopListening mock is already set by Set")
	}

	if mmStopListening.defaultExpectation == nil {
		mmStopListening.defaultExpectation = &BttMockStopListeningExpectation{}
	}

	if mmStopListening.defaultExpectation.paramPtrs != nil {
		mmStopListening.mock.t.Fatalf("BttMock.StopListening mock is already set by ExpectParams functions")
	}

	mmStopListening.defaultExpectation.params = &BttMockStopListeningParams{ctx}
	mmStopListening.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStopListening.expectations {
		if minimock.Equal(e.params, mmStopListening.defaultExpectation.params) {
			mmStopListening.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStopListening.defaultExpectation.params)
		}
	}

	return mmStopListening
}

// ExpectCtxParam1 sets up expected param ctx for Btt.StopListening
func (mmStopListening *mBttMockStopListening) ExpectCtxParam1(ctx context.Context) *mBttMockStopListening {
	if mmStopListening.mock.funcStopListening != nil {
		mmStopListening.mock.t.Fatalf("BttMock.StopListening mock is already set by Set")
	}

	if mmStopListening.defaultExpectation == nil {
		mmStopListening.defaultExpectation = &BttMockStopListeningExpectation{}
	}

	if mmStopListening.defaultExpectation.params != nil {
		mmStopListening.mock.t.Fatalf("BttMock.StopListening mock is already set by Expect")
	}

	if mmStopListening.defaultExpectation.paramPtrs == nil {
		mmStopListening.defaultExpectation.paramPtrs = &BttMockStopListeningParamPtrs{}
	}
	mmStopListening.defaultExpectation.paramPtrs.ctx = &ctx
	mmStopListening.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStopListening
}

// Inspect accepts an inspector function that has same arguments as the Btt.StopListening
func (mmStopListening *mBttMockStopListening) Inspect(f func(ctx context.Context)) *mBttMockStopListening {
	if mmStopListening.mock.inspectFuncStopListening != nil {
		mmStopListening.mock.t.Fatalf("Inspect function is already set for BttMock.StopListening")
	}

	mmStopListening.mock.inspectFuncStopListening = f

	return mmStopListening
}

// Return sets up results that will be returned by Btt.StopListening
func (mmStopListening *mBttMockStopListening) Return(err error) *BttMock {
	if mmStopListening.mock.funcStopListening != nil {
		mmStopListening.mock.t.Fatalf("BttMock.StopListening mock is already set by Set")
	}

	if mmStopListening.defaultExpectation == nil {
		mmStopListening.defaultExpectation = &BttMockStopListeningExpectation{mock: mmStopListening.mock}
	}
	mmStopListening.defaultExpectation.results = &BttMockStopListeningResults{err}
	mmStopListening.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStopListening.mock
}

// Set uses given function f to mock the Btt.StopListening method
func (mmStopListening *mBttMockStopListening) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmStopListening.defaultExpectation != nil {
		mmStopListening.mock.t.Fatalf("Default expectation is already set for the Btt.StopListening method")
	}

	if len(mmStopListening.expectations) > 0 {
		mmStopListening.mock.t.Fatalf("Some expectations are already set for the Btt.StopListening method")
	}

	mmStopListening.mock.funcStopListening = f
	mmStopListening.mock.funcStopListeningOrigin = minimock.CallerInfo(1)
	return mmStopListening.mock
}

// When sets expectation for the Btt.StopListening which will trigger the result defined by the following
// Then helper
func (mmStopListening *mBttMockStopListening) When(ctx context.Context) *BttMockStopListeningExpectation {
	if mmStopListening.mock.funcStopListening != nil {
		mmStopListening.mock.t.Fatalf("BttMock.StopListening mock is already set by Set")
	}

	expectation := &BttMockStopListeningExpectation{
		mock:               mmStopListening.mock,
		params:             &BttMockStopListeningParams{ctx},
		expectationOrigins: BttMockStopListeningExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStopListening.expectations = append(mmStopListening.expectations, expectation)
	return expectation
}

// Then sets up Btt.StopListening return parameters for the expectation previously defined by the When method
func (e *BttMockStopListeningExpectation) Then(err error) *BttMock {
	e.results = &BttMockStopListeningResults{err}
	return e.mock
}

// Times sets number of times Btt.StopListening should be invoked
func (mmStopListening *mBttMockStopListening) Times(n uint64) *mBttMockStopListening {
	if n == 0 {
		mmStopListening.mock.t.Fatalf("Times of BttMock.StopListening mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStopListening.expectedInvocations, n)
	mmStopListening.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStopListening
}

func (mmStopListening *mBttMockStopListening) invocationsDone() bool {
	if len(mmStopListening.expectations) == 0 && mmStopListening.defaultExpectation == nil && mmStopListening.mock.funcStopListening == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStopListening.mock.afterStopListeningCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStopListening.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StopListening implements Btt
func (mmStopListening *BttMock) StopListening(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStopListening.beforeStopListeningCounter, 1)
	defer mm_atomic.AddUint64(&mmStopListening.afterStopListeningCounter, 1)

	mmStopListening.t.Helper()

	if mmStopListening.inspectFuncStopListening != nil {
		mmStopListening.inspectFuncStopListening(ctx)
	}

	mm_params := BttMockStopListeningParams{ctx}

	// Record call args
	mmStopListening.StopListeningMock.mutex.Lock()
	mmStopListening.StopListeningMock.callArgs = append(mmStopListening.StopListeningMock.callArgs, &mm_params)
	mmStopListening.StopListeningMock.mutex.Unlock()

	for _, e := range mmStopListening.StopListeningMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStopListening.StopListeningMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStopListening.StopListeningMock.defaultExpectation.Counter, 1)
		mm_want := mmStopListening.StopListeningMock.defaultExpectation.params
		mm_want_ptrs := mmStopListening.StopListeningMock.defaultExpectation.paramPtrs

		mm_got := BttMockStopListeningParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStopListening.t.Errorf("BttMock.StopListening got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStopListening.StopListeningMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStopListening.t.Errorf("BttMock.StopListening got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStopListening.StopListeningMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStopListening.StopListeningMock.defaultExpectation.results
		if mm_results == nil {
			mmStopListening.t.Fatal("No results are set for the BttMock.StopListening")
		}
		return (*mm_results).err
	}
	if mmStopListening.funcStopListening != nil {
		return mmStopListening.funcStopListening(ctx)
	}
	mmStopListening.t.Fatalf("Unexpected call to BttMock.StopListening. %v", ctx)
	return
}

// StopListeningAfterCounter returns a count of finished BttMock.StopListening invocations
func (mmStopListening *BttMock) StopListeningAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStopListening.afterStopListeningCounter)
}

// StopListeningBeforeCounter returns a count of BttMock.StopListening invocations
func (mmStopListening *BttMock) StopListeningBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStopListening.beforeStopListeningCounter)
}

// Calls returns a list of arguments used in each call to BttMock.StopListening.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStopListening *mBttMockStopListening) Calls() []*BttMockStopListeningParams {
	mmStopListening.mutex.RLock()

	argCopy := make([]*BttMockStopListeningParams, len(mmStopListening.callArgs))
	copy(argCopy, mmStopListening.callArgs)

	mmStopListening.mutex.RUnlock()

	return argCopy
}

// MinimockStopListeningDone returns true if the count of the StopListening invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockStopListeningDone() bool {
	if m.StopListeningMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StopListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StopListeningMock.invocationsDone()
}

// MinimockStopListeningInspect logs each unmet expectation
func (m *BttMock) MinimockStopListeningInspect() {
	for _, e := range m.StopListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.StopListening at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStopListeningCounter := mm_atomic.LoadUint64(&m.afterStopListeningCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StopListeningMock.defaultExpectation != nil && afterStopListeningCounter < 1 {
		if m.StopListeningMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.StopListening at\n%s", m.StopListeningMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.StopListening at\n%s with params: %#v", m.StopListeningMock.defaultExpectation.expectationOrigins.origin, *m.StopListeningMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStopListening != nil && afterStopListeningCounter < 1 {
		m.t.Errorf("Expected call to BttMock.StopListening at\n%s", m.funcStopListeningOrigin)
	}

	if !m.StopListeningMock.invocationsDone() && afterStopListeningCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.StopListening at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StopListeningMock.expectedInvocations), m.StopListeningMock.expectedInvocationsOrigin, afterStopListeningCounter)
	}
}

type mBttMockStreamText struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockStreamTextExpectation
	expectations       []*BttMockStreamTextExpectation

	callArgs []*BttMockStreamTextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockStreamTextExpectation specifies expectation struct of the Btt.StreamText
type BttMockStreamTextExpectation struct {
	mock               *BttMock
	params             *BttMockStreamTextParams
	paramPtrs          *BttMockStreamTextParamPtrs
	expectationOrigins BttMockStreamTextExpectationOrigins
	results            *BttMockStreamTextResults
	returnOrigin       string
	Counter            uint64
}

// BttMockStreamTextParams contains parameters of the Btt.StreamText
type BttMockStreamTextParams struct {
	ctx context.Context
}

// BttMockStreamTextParamPtrs contains pointers to parameters of the Btt.StreamText
type BttMockStreamTextParamPtrs struct {
	ctx *context.Context
}

// BttMockStreamTextResults contains results of the Btt.StreamText
type BttMockStreamTextResults struct {
	ch1 <-chan string
	ch2 <-chan error
	err error
}

// BttMockStreamTextOrigins contains origins of expectations of the Btt.StreamText
type BttMockStreamTextExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStreamText *mBttMockStreamText) Optional() *mBttMockStreamText {
	mmStreamText.optional = true
	return mmStreamText
}

// Expect sets up expected params for Btt.StreamText
func (mmStreamText *mBttMockStreamText) Expect(ctx context.Context) *mBttMockStreamText {
	if mmStreamText.mock.funcStreamText != nil {
		mmStreamText.mock.t.Fatalf("BttMock.StreamText mock is already set by Set")
	}

	if mmStreamText.defaultExpectation == nil {
		mmStreamText.defaultExpectation = &BttMockStreamTextExpectation{}
	}

	if mmStreamText.defaultExpectation.paramPtrs != nil {
		mmStreamText.mock.t.Fatalf("BttMock.StreamText mock is already set by ExpectParams functions")
	}

	mmStreamText.defaultExpectation.params = &BttMockStreamTextParams{ctx}
	mmStreamText.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStreamText.expectations {
		if minimock.Equal(e.params, mmStreamText.defaultExpectation.params) {
			mmStreamText.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStreamText.defaultExpectation.params)
		}
	}

	return mmStreamText
}

// ExpectCtxParam1 sets up expected param ctx for Btt.StreamText
func (mmStreamText *mBttMockStreamText) ExpectCtxParam1(ctx context.Context) *mBttMockStreamText {
	if mmStreamText.mock.funcStreamText != nil {
		mmStreamText.mock.t.Fatalf("BttMock.StreamText mock is already set by Set")
	}

	if mmStreamText.defaultExpectation == nil {
		mmStreamText.defaultExpectation = &BttMockStreamTextExpectation{}
	}

	if mmStreamText.defaultExpectation.params != nil {
		mmStreamText.mock.t.Fatalf("BttMock.StreamText mock is already set by Expect")
	}

	if mmStreamText.defaultExpectation.paramPtrs == nil {
		mmStreamText.defaultExpectation.paramPtrs = &BttMockStreamTextParamPtrs{}
	}
	mmStreamText.defaultExpectation.paramPtrs.ctx = &ctx
	mmStreamText.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStreamText
}

// Inspect accepts an inspector function that has same arguments as the Btt.StreamText
func (mmStreamText *mBttMockStreamText) Inspect(f func(ctx context.Context)) *mBttMockStreamText {
	if mmStreamText.mock.inspectFuncStreamText != nil {
		mmStreamText.mock.t.Fatalf("Inspect function is already set for BttMock.StreamText")
	}

	mmStreamText.mock.inspectFuncStreamText = f

	return mmStreamText
}

// Return sets up results that will be returned by Btt.StreamText
func (mmStreamText *mBttMockStreamText) Return(ch1 <-chan string, ch2 <-chan error, err error) *BttMock {
	if mmStreamText.mock.funcStreamText != nil {
		mmStreamText.mock.t.Fatalf("BttMock.StreamText mock is already set by Set")
	}

	if mmStreamText.defaultExpectation == nil {
		mmStreamText.defaultExpectation = &BttMockStreamTextExpectation{mock: mmStreamText.mock}
	}
	mmStreamText.defaultExpectation.results = &BttMockStreamTextResults{ch1, ch2, err}
	mmStreamText.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStreamText.mock
}

// Set uses given function f to mock the Btt.StreamText method
func (mmStreamText *mBttMockStreamText) Set(f func(ctx context.Context) (ch1 <-chan string, ch2 <-chan error, err error)) *BttMock {
	if mmStreamText.defaultExpectation != nil {
		mmStreamText.mock.t.Fatalf("Default expectation is already set for the Btt.StreamText method")
	}

	if len(mmStreamText.expectations) > 0 {
		mmStreamText.mock.t.Fatalf("Some expectations are already set for the Btt.StreamText method")
	}

	mmStreamText.mock.funcStreamText = f
	mmStreamText.mock.funcStreamTextOrigin = minimock.CallerInfo(1)
	return mmStreamText.mock
}

// When sets expectation for the Btt.StreamText which will trigger the result defined by the following
// Then helper
func (mmStreamText *mBttMockStreamText) When(ctx context.Context) *BttMockStreamTextExpectation {
	if mmStreamText.mock.funcStreamText != nil {
		mmStreamText.mock.t.Fatalf("BttMock.StreamText mock is already set by Set")
	}

	expectation := &BttMockStreamTextExpectation{
		mock:               mmStreamText.mock,
		params:             &BttMockStreamTextParams{ctx},
		expectationOrigins: BttMockStreamTextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStreamText.expectations = append(mmStreamText.expectations, expectation)
	return expectation
}

// Then sets up Btt.StreamText return parameters for the expectation previously defined by the When method
func (e *BttMockStreamTextExpectation) Then(ch1 <-chan string, ch2 <-chan error, err error) *BttMock {
	e.results = &BttMockStreamTextResults{ch1, ch2, err}
	return e.mock
}

// Times sets number of times Btt.StreamText should be invoked
func (mmStreamText *mBttMockStreamText) Times(n uint64) *mBttMockStreamText {
	if n == 0 {
		mmStreamText.mock.t.Fatalf("Times of BttMock.StreamText mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStreamText.expectedInvocations, n)
	mmStreamText.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStreamText
}

func (mmStreamText *mBttMockStreamText) invocationsDone() bool {
	if len(mmStreamText.expectations) == 0 && mmStreamText.defaultExpectation == nil && mmStreamText.mock.funcStreamText == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStreamText.mock.afterStreamTextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStreamText.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StreamText implements Btt
func (mmStreamText *BttMock) StreamText(ctx context.Context) (ch1 <-chan string, ch2 <-chan error, err error) {
	mm_atomic.AddUint64(&mmStreamText.beforeStreamTextCounter, 1)
	defer mm_atomic.AddUint64(&mmStreamText.afterStreamTextCounter, 1)

	mmStreamText.t.Helper()

	if mmStreamText.inspectFuncStreamText != nil {
		mmStreamText.inspectFuncStreamText(ctx)
	}

	mm_params := BttMockStreamTextParams{ctx}

	// Record call args
	mmStreamText.StreamTextMock.mutex.Lock()
	mmStreamText.StreamTextMock.callArgs = append(mmStreamText.StreamTextMock.callArgs, &mm_params)
	mmStreamText.StreamTextMock.mutex.Unlock()

	for _, e := range mmStreamText.StreamTextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ch1, e.results.ch2, e.results.err
		}
	}

	if mmStreamText.StreamTextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStreamText.StreamTextMock.defaultExpectation.Counter, 1)
		mm_want := mmStreamText.StreamTextMock.defaultExpectation.params
		mm_want_ptrs := mmStreamText.StreamTextMock.defaultExpectation.paramPtrs

		mm_got := BttMockStreamTextParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStreamText.t.Errorf("BttMock.StreamText got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStreamText.StreamTextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStreamText.t.Errorf("BttMock.StreamText got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStreamText.StreamTextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStreamText.StreamTextMock.defaultExpectation.results
		if mm_results == nil {
			mmStreamText.t.Fatal("No results are set for the BttMock.StreamText")
		}
		return (*mm_results).ch1, (*mm_results).ch2, (*mm_results).err
	}
	if mmStreamText.funcStreamText != nil {
		return mmStreamText.funcStreamText(ctx)
	}
	mmStreamText.t.Fatalf("Unexpected call to BttMock.StreamText. %v", ctx)
	return
}

// StreamTextAfterCounter returns a count of finished BttMock.StreamText invocations
func (mmStreamText *BttMock) StreamTextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStreamText.afterStreamTextCounter)
}

// StreamTextBeforeCounter returns a count of BttMock.StreamText invocations
func (mmStreamText *BttMock) StreamTextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStreamText.beforeStreamTextCounter)
}

// Calls returns a list of arguments used in each call to BttMock.StreamText.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStreamText *mBttMockStreamText) Calls() []*BttMockStreamTextParams {
	mmStreamText.mutex.RLock()

	argCopy := make([]*BttMockStreamTextParams, len(mmStreamText.callArgs))
	copy(argCopy, mmStreamText.callArgs)

	mmStreamText.mutex.RUnlock()

	return argCopy
}

// MinimockStreamTextDone returns true if the count of the StreamText invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockStreamTextDone() bool {
	if m.StreamTextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StreamTextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StreamTextMock.invocationsDone()
}

// MinimockStreamTextInspect logs each unmet expectation
func (m *BttMock) MinimockStreamTextInspect() {
	for _, e := range m.StreamTextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.StreamText at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStreamTextCounter := mm_atomic.LoadUint64(&m.afterStreamTextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StreamTextMock.defaultExpectation != nil && afterStreamTextCounter < 1 {
		if m.StreamTextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.StreamText at\n%s", m.StreamTextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.StreamText at\n%s with params: %#v", m.StreamTextMock.defaultExpectation.expectationOrigins.origin, *m.StreamTextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStreamText != nil && afterStreamTextCounter < 1 {
		m.t.Errorf("Expected call to BttMock.StreamText at\n%s", m.funcStreamTextOrigin)
	}

	if !m.StreamTextMock.invocationsDone() && afterStreamTextCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.StreamText at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StreamTextMock.expectedInvocations), m.StreamTextMock.expectedInvocationsOrigin, afterStreamTextCounter)
	}
}

type mBttMockToggleListening struct {
	optional           bool
	mock               *BttMock
	defaultExpectation *BttMockToggleListeningExpectation
	expectations       []*BttMockToggleListeningExpectation

	callArgs []*BttMockToggleListeningParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BttMockToggleListeningExpectation specifies expectation struct of the Btt.ToggleListening
type BttMockToggleListeningExpectation struct {
	mock               *BttMock
	params             *BttMockToggleListeningParams
	paramPtrs          *BttMockToggleListeningParamPtrs
	expectationOrigins BttMockToggleListeningExpectationOrigins
	results            *BttMockToggleListeningResults
	returnOrigin       string
	Counter            uint64
}

// BttMockToggleListeningParams contains parameters of the Btt.ToggleListening
type BttMockToggleListeningParams struct {
	ctx context.Context
}

// BttMockToggleListeningParamPtrs contains pointers to parameters of the Btt.ToggleListening
type BttMockToggleListeningParamPtrs struct {
	ctx *context.Context
}

// BttMockToggleListeningResults contains results of the Btt.ToggleListening
type BttMockToggleListeningResults struct {
	err error
}

// BttMockToggleListeningOrigins contains origins of expectations of the Btt.ToggleListening
type BttMockToggleListeningExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToggleListening *mBttMockToggleListening) Optional() *mBttMockToggleListening {
	mmToggleListening.optional = true
	return mmToggleListening
}

// Expect sets up expected params for Btt.ToggleListening
func (mmToggleListening *mBttMockToggleListening) Expect(ctx context.Context) *mBttMockToggleListening {
	if mmToggleListening.mock.funcToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("BttMock.ToggleListening mock is already set by Set")
	}

	if mmToggleListening.defaultExpectation == nil {
		mmToggleListening.defaultExpectation = &BttMockToggleListeningExpectation{}
	}

	if mmToggleListening.defaultExpectation.paramPtrs != nil {
		mmToggleListening.mock.t.Fatalf("BttMock.ToggleListening mock is already set by ExpectParams functions")
	}

	mmToggleListening.defaultExpectation.params = &BttMockToggleListeningParams{ctx}
	mmToggleListening.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToggleListening.expectations {
		if minimock.Equal(e.params, mmToggleListening.defaultExpectation.params) {
			mmToggleListening.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToggleListening.defaultExpectation.params)
		}
	}

	return mmToggleListening
}

// ExpectCtxParam1 sets up expected param ctx for Btt.ToggleListening
func (mmToggleListening *mBttMockToggleListening) ExpectCtxParam1(ctx context.Context) *mBttMockToggleListening {
	if mmToggleListening.mock.funcToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("BttMock.ToggleListening mock is already set by Set")
	}

	if mmToggleListening.defaultExpectation == nil {
		mmToggleListening.defaultExpectation = &BttMockToggleListeningExpectation{}
	}

	if mmToggleListening.defaultExpectation.params != nil {
		mmToggleListening.mock.t.Fatalf("BttMock.ToggleListening mock is already set by Expect")
	}

	if mmToggleListening.defaultExpectation.paramPtrs == nil {
		mmToggleListening.defaultExpectation.paramPtrs = &BttMockToggleListeningParamPtrs{}
	}
	mmToggleListening.defaultExpectation.paramPtrs.ctx = &ctx
	mmToggleListening.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmToggleListening
}

// Inspect accepts an inspector function that has same arguments as the Btt.ToggleListening
func (mmToggleListening *mBttMockToggleListening) Inspect(f func(ctx context.Context)) *mBttMockToggleListening {
	if mmToggleListening.mock.inspectFuncToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("Inspect function is already set for BttMock.ToggleListening")
	}

	mmToggleListening.mock.inspectFuncToggleListening = f

	return mmToggleListening
}

// Return sets up results that will be returned by Btt.ToggleListening
func (mmToggleListening *mBttMockToggleListening) Return(err error) *BttMock {
	if mmToggleListening.mock.funcToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("BttMock.ToggleListening mock is already set by Set")
	}

	if mmToggleListening.defaultExpectation == nil {
		mmToggleListening.defaultExpectation = &BttMockToggleListeningExpectation{mock: mmToggleListening.mock}
	}
	mmToggleListening.defaultExpectation.results = &BttMockToggleListeningResults{err}
	mmToggleListening.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToggleListening.mock
}

// Set uses given function f to mock the Btt.ToggleListening method
func (mmToggleListening *mBttMockToggleListening) Set(f func(ctx context.Context) (err error)) *BttMock {
	if mmToggleListening.defaultExpectation != nil {
		mmToggleListening.mock.t.Fatalf("Default expectation is already set for the Btt.ToggleListening method")
	}

	if len(mmToggleListening.expectations) > 0 {
		mmToggleListening.mock.t.Fatalf("Some expectations are already set for the Btt.ToggleListening method")
	}

	mmToggleListening.mock.funcToggleListening = f
	mmToggleListening.mock.funcToggleListeningOrigin = minimock.CallerInfo(1)
	return mmToggleListening.mock
}

// When sets expectation for the Btt.ToggleListening which will trigger the result defined by the following
// Then helper
func (mmToggleListening *mBttMockToggleListening) When(ctx context.Context) *BttMockToggleListeningExpectation {
	if mmToggleListening.mock.funcToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("BttMock.ToggleListening mock is already set by Set")
	}

	expectation := &BttMockToggleListeningExpectation{
		mock:               mmToggleListening.mock,
		params:             &BttMockToggleListeningParams{ctx},
		expectationOrigins: BttMockToggleListeningExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToggleListening.expectations = append(mmToggleListening.expectations, expectation)
	return expectation
}

// Then sets up Btt.ToggleListening return parameters for the expectation previously defined by the When method
func (e *BttMockToggleListeningExpectation) Then(err error) *BttMock {
	e.results = &BttMockToggleListeningResults{err}
	return e.mock
}

// Times sets number of times Btt.ToggleListening should be invoked
func (mmToggleListening *mBttMockToggleListening) Times(n uint64) *mBttMockToggleListening {
	if n == 0 {
		mmToggleListening.mock.t.Fatalf("Times of BttMock.ToggleListening mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToggleListening.expectedInvocations, n)
	mmToggleListening.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToggleListening
}

func (mmToggleListening *mBttMockToggleListening) invocationsDone() bool {
	if len(mmToggleListening.expectations) == 0 && mmToggleListening.defaultExpectation == nil && mmToggleListening.mock.funcToggleListening == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToggleListening.mock.afterToggleListeningCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToggleListening.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToggleListening implements Btt
func (mmToggleListening *BttMock) ToggleListening(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmToggleListening.beforeToggleListeningCounter, 1)
	defer mm_atomic.AddUint64(&mmToggleListening.afterToggleListeningCounter, 1)

	mmToggleListening.t.Helper()

	if mmToggleListening.inspectFuncToggleListening != nil {
		mmToggleListening.inspectFuncToggleListening(ctx)
	}

	mm_params := BttMockToggleListeningParams{ctx}

	// Record call args
	mmToggleListening.ToggleListeningMock.mutex.Lock()
	mmToggleListening.ToggleListeningMock.callArgs = append(mmToggleListening.ToggleListeningMock.callArgs, &mm_params)
	mmToggleListening.ToggleListeningMock.mutex.Unlock()

	for _, e := range mmToggleListening.ToggleListeningMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmToggleListening.ToggleListeningMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToggleListening.ToggleListeningMock.defaultExpectation.Counter, 1)
		mm_want := mmToggleListening.ToggleListeningMock.defaultExpectation.params
		mm_want_ptrs := mmToggleListening.ToggleListeningMock.defaultExpectation.paramPtrs

		mm_got := BttMockToggleListeningParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmToggleListening.t.Errorf("BttMock.ToggleListening got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToggleListening.ToggleListeningMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToggleListening.t.Errorf("BttMock.ToggleListening got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToggleListening.ToggleListeningMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToggleListening.ToggleListeningMock.defaultExpectation.results
		if mm_results == nil {
			mmToggleListening.t.Fatal("No results are set for the BttMock.ToggleListening")
		}
		return (*mm_results).err
	}
	if mmToggleListening.funcToggleListening != nil {
		return mmToggleListening.funcToggleListening(ctx)
	}
	mmToggleListening.t.Fatalf("Unexpected call to BttMock.ToggleListening. %v", ctx)
	return
}

// ToggleListeningAfterCounter returns a count of finished BttMock.ToggleListening invocations
func (mmToggleListening *BttMock) ToggleListeningAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToggleListening.afterToggleListeningCounter)
}

// ToggleListeningBeforeCounter returns a count of BttMock.ToggleListening invocations
func (mmToggleListening *BttMock) ToggleListeningBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToggleListening.beforeToggleListeningCounter)
}

// Calls returns a list of arguments used in each call to BttMock.ToggleListening.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToggleListening *mBttMockToggleListening) Calls() []*BttMockToggleListeningParams {
	mmToggleListening.mutex.RLock()

	argCopy := make([]*BttMockToggleListeningParams, len(mmToggleListening.callArgs))
	copy(argCopy, mmToggleListening.callArgs)

	mmToggleListening.mutex.RUnlock()

	return argCopy
}

// MinimockToggleListeningDone returns true if the count of the ToggleListening invocations corresponds
// the number of defined expectations
func (m *BttMock) MinimockToggleListeningDone() bool {
	if m.ToggleListeningMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToggleListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToggleListeningMock.invocationsDone()
}

// MinimockToggleListeningInspect logs each unmet expectation
func (m *BttMock) MinimockToggleListeningInspect() {
	for _, e := range m.ToggleListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BttMock.ToggleListening at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToggleListeningCounter := mm_atomic.LoadUint64(&m.afterToggleListeningCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToggleListeningMock.defaultExpectation != nil && afterToggleListeningCounter < 1 {
		if m.ToggleListeningMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BttMock.ToggleListening at\n%s", m.ToggleListeningMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BttMock.ToggleListening at\n%s with params: %#v", m.ToggleListeningMock.defaultExpectation.expectationOrigins.origin, *m.ToggleListeningMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToggleListening != nil && afterToggleListeningCounter < 1 {
		m.t.Errorf("Expected call to BttMock.ToggleListening at\n%s", m.funcToggleListeningOrigin)
	}

	if !m.ToggleListeningMock.invocationsDone() && afterToggleListeningCounter > 0 {
		m.t.Errorf("Expected %d calls to BttMock.ToggleListening at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToggleListeningMock.expectedInvocations), m.ToggleListeningMock.expectedInvocationsOrigin, afterToggleListeningCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BttMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockClearInspect()

			m.MinimockDisableCleanViewInspect()

			m.MinimockEnableCleanModeInspect()

			m.MinimockFloatingPageInspect()

			m.MinimockHideFloatingInspect()

			m.MinimockInitializeInspect()

			m.MinimockIsRunningInspect()

			m.MinimockLoadDevicesInspect()

			m.MinimockSelectDeviceInspect()

			m.MinimockSelectFloatingInspect()

			m.MinimockSelectLanguageInspect()

			m.MinimockSelectViewModeInspect()

			m.MinimockSelectedDeviceInspect()

			m.MinimockSelectedFloatingInspect()

			m.MinimockSelectedLanguageInspect()

			m.MinimockSelectedViewModeInspect()

			m.MinimockShowFloatingInspect()

			m.MinimockStartListeningInspect()

			m.MinimockStopListeningInspect()

			m.MinimockStreamTextInspect()

			m.MinimockToggleListeningInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BttMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BttMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockClearDone() &&
		m.MinimockDisableCleanViewDone() &&
		m.MinimockEnableCleanModeDone() &&
		m.MinimockFloatingPageDone() &&
		m.MinimockHideFloatingDone() &&
		m.MinimockInitializeDone() &&
		m.MinimockIsRunningDone() &&
		m.MinimockLoadDevicesDone() &&
		m.MinimockSelectDeviceDone() &&
		m.MinimockSelectFloatingDone() &&
		m.MinimockSelectLanguageDone() &&
		m.MinimockSelectViewModeDone() &&
		m.MinimockSelectedDeviceDone() &&
		m.MinimockSelectedFloatingDone() &&
		m.MinimockSelectedLanguageDone() &&
		m.MinimockSelectedViewModeDone() &&
		m.MinimockShowFloatingDone() &&
		m.MinimockStartListeningDone() &&
		m.MinimockStopListeningDone() &&
		m.MinimockStreamTextDone() &&
		m.MinimockToggleListeningDone()
}
