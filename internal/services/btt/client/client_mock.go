// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package client

import (
	"context"
	"live2text/internal/services/btt/client/trigger"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClientMock implements Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddTrigger          func(ctx context.Context, trigger trigger.Trigger, parentUUID trigger.UUID) (u1 trigger.UUID, err error)
	funcAddTriggerOrigin    string
	inspectFuncAddTrigger   func(ctx context.Context, trigger trigger.Trigger, parentUUID trigger.UUID)
	afterAddTriggerCounter  uint64
	beforeAddTriggerCounter uint64
	AddTriggerMock          mClientMockAddTrigger

	funcDeleteTriggers          func(ctx context.Context, triggers []trigger.Trigger) (err error)
	funcDeleteTriggersOrigin    string
	inspectFuncDeleteTriggers   func(ctx context.Context, triggers []trigger.Trigger)
	afterDeleteTriggersCounter  uint64
	beforeDeleteTriggersCounter uint64
	DeleteTriggersMock          mClientMockDeleteTriggers

	funcGetTrigger          func(ctx context.Context, title trigger.Title) (t1 trigger.Trigger, err error)
	funcGetTriggerOrigin    string
	inspectFuncGetTrigger   func(ctx context.Context, title trigger.Title)
	afterGetTriggerCounter  uint64
	beforeGetTriggerCounter uint64
	GetTriggerMock          mClientMockGetTrigger

	funcGetTriggers          func(ctx context.Context, parentUUID trigger.UUID) (ta1 []trigger.Trigger, err error)
	funcGetTriggersOrigin    string
	inspectFuncGetTriggers   func(ctx context.Context, parentUUID trigger.UUID)
	afterGetTriggersCounter  uint64
	beforeGetTriggersCounter uint64
	GetTriggersMock          mClientMockGetTriggers

	funcHealth          func(ctx context.Context) (b1 bool)
	funcHealthOrigin    string
	inspectFuncHealth   func(ctx context.Context)
	afterHealthCounter  uint64
	beforeHealthCounter uint64
	HealthMock          mClientMockHealth

	funcRefreshTrigger          func(ctx context.Context, title trigger.Title) (err error)
	funcRefreshTriggerOrigin    string
	inspectFuncRefreshTrigger   func(ctx context.Context, title trigger.Title)
	afterRefreshTriggerCounter  uint64
	beforeRefreshTriggerCounter uint64
	RefreshTriggerMock          mClientMockRefreshTrigger

	funcTriggerAction          func(ctx context.Context, action trigger.Trigger) (err error)
	funcTriggerActionOrigin    string
	inspectFuncTriggerAction   func(ctx context.Context, action trigger.Trigger)
	afterTriggerActionCounter  uint64
	beforeTriggerActionCounter uint64
	TriggerActionMock          mClientMockTriggerAction

	funcUpdateTrigger          func(ctx context.Context, title trigger.Title, patch trigger.Trigger) (err error)
	funcUpdateTriggerOrigin    string
	inspectFuncUpdateTrigger   func(ctx context.Context, title trigger.Title, patch trigger.Trigger)
	afterUpdateTriggerCounter  uint64
	beforeUpdateTriggerCounter uint64
	UpdateTriggerMock          mClientMockUpdateTrigger
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddTriggerMock = mClientMockAddTrigger{mock: m}
	m.AddTriggerMock.callArgs = []*ClientMockAddTriggerParams{}

	m.DeleteTriggersMock = mClientMockDeleteTriggers{mock: m}
	m.DeleteTriggersMock.callArgs = []*ClientMockDeleteTriggersParams{}

	m.GetTriggerMock = mClientMockGetTrigger{mock: m}
	m.GetTriggerMock.callArgs = []*ClientMockGetTriggerParams{}

	m.GetTriggersMock = mClientMockGetTriggers{mock: m}
	m.GetTriggersMock.callArgs = []*ClientMockGetTriggersParams{}

	m.HealthMock = mClientMockHealth{mock: m}
	m.HealthMock.callArgs = []*ClientMockHealthParams{}

	m.RefreshTriggerMock = mClientMockRefreshTrigger{mock: m}
	m.RefreshTriggerMock.callArgs = []*ClientMockRefreshTriggerParams{}

	m.TriggerActionMock = mClientMockTriggerAction{mock: m}
	m.TriggerActionMock.callArgs = []*ClientMockTriggerActionParams{}

	m.UpdateTriggerMock = mClientMockUpdateTrigger{mock: m}
	m.UpdateTriggerMock.callArgs = []*ClientMockUpdateTriggerParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockAddTrigger struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockAddTriggerExpectation
	expectations       []*ClientMockAddTriggerExpectation

	callArgs []*ClientMockAddTriggerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockAddTriggerExpectation specifies expectation struct of the Client.AddTrigger
type ClientMockAddTriggerExpectation struct {
	mock               *ClientMock
	params             *ClientMockAddTriggerParams
	paramPtrs          *ClientMockAddTriggerParamPtrs
	expectationOrigins ClientMockAddTriggerExpectationOrigins
	results            *ClientMockAddTriggerResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockAddTriggerParams contains parameters of the Client.AddTrigger
type ClientMockAddTriggerParams struct {
	ctx        context.Context
	trigger    trigger.Trigger
	parentUUID trigger.UUID
}

// ClientMockAddTriggerParamPtrs contains pointers to parameters of the Client.AddTrigger
type ClientMockAddTriggerParamPtrs struct {
	ctx        *context.Context
	trigger    *trigger.Trigger
	parentUUID *trigger.UUID
}

// ClientMockAddTriggerResults contains results of the Client.AddTrigger
type ClientMockAddTriggerResults struct {
	u1  trigger.UUID
	err error
}

// ClientMockAddTriggerOrigins contains origins of expectations of the Client.AddTrigger
type ClientMockAddTriggerExpectationOrigins struct {
	origin           string
	originCtx        string
	originTrigger    string
	originParentUUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddTrigger *mClientMockAddTrigger) Optional() *mClientMockAddTrigger {
	mmAddTrigger.optional = true
	return mmAddTrigger
}

// Expect sets up expected params for Client.AddTrigger
func (mmAddTrigger *mClientMockAddTrigger) Expect(ctx context.Context, trigger trigger.Trigger, parentUUID trigger.UUID) *mClientMockAddTrigger {
	if mmAddTrigger.mock.funcAddTrigger != nil {
		mmAddTrigger.mock.t.Fatalf("ClientMock.AddTrigger mock is already set by Set")
	}

	if mmAddTrigger.defaultExpectation == nil {
		mmAddTrigger.defaultExpectation = &ClientMockAddTriggerExpectation{}
	}

	if mmAddTrigger.defaultExpectation.paramPtrs != nil {
		mmAddTrigger.mock.t.Fatalf("ClientMock.AddTrigger mock is already set by ExpectParams functions")
	}

	mmAddTrigger.defaultExpectation.params = &ClientMockAddTriggerParams{ctx, trigger, parentUUID}
	mmAddTrigger.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddTrigger.expectations {
		if minimock.Equal(e.params, mmAddTrigger.defaultExpectation.params) {
			mmAddTrigger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddTrigger.defaultExpectation.params)
		}
	}

	return mmAddTrigger
}

// ExpectCtxParam1 sets up expected param ctx for Client.AddTrigger
func (mmAddTrigger *mClientMockAddTrigger) ExpectCtxParam1(ctx context.Context) *mClientMockAddTrigger {
	if mmAddTrigger.mock.funcAddTrigger != nil {
		mmAddTrigger.mock.t.Fatalf("ClientMock.AddTrigger mock is already set by Set")
	}

	if mmAddTrigger.defaultExpectation == nil {
		mmAddTrigger.defaultExpectation = &ClientMockAddTriggerExpectation{}
	}

	if mmAddTrigger.defaultExpectation.params != nil {
		mmAddTrigger.mock.t.Fatalf("ClientMock.AddTrigger mock is already set by Expect")
	}

	if mmAddTrigger.defaultExpectation.paramPtrs == nil {
		mmAddTrigger.defaultExpectation.paramPtrs = &ClientMockAddTriggerParamPtrs{}
	}
	mmAddTrigger.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddTrigger.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddTrigger
}

// ExpectTriggerParam2 sets up expected param trigger for Client.AddTrigger
func (mmAddTrigger *mClientMockAddTrigger) ExpectTriggerParam2(trigger trigger.Trigger) *mClientMockAddTrigger {
	if mmAddTrigger.mock.funcAddTrigger != nil {
		mmAddTrigger.mock.t.Fatalf("ClientMock.AddTrigger mock is already set by Set")
	}

	if mmAddTrigger.defaultExpectation == nil {
		mmAddTrigger.defaultExpectation = &ClientMockAddTriggerExpectation{}
	}

	if mmAddTrigger.defaultExpectation.params != nil {
		mmAddTrigger.mock.t.Fatalf("ClientMock.AddTrigger mock is already set by Expect")
	}

	if mmAddTrigger.defaultExpectation.paramPtrs == nil {
		mmAddTrigger.defaultExpectation.paramPtrs = &ClientMockAddTriggerParamPtrs{}
	}
	mmAddTrigger.defaultExpectation.paramPtrs.trigger = &trigger
	mmAddTrigger.defaultExpectation.expectationOrigins.originTrigger = minimock.CallerInfo(1)

	return mmAddTrigger
}

// ExpectParentUUIDParam3 sets up expected param parentUUID for Client.AddTrigger
func (mmAddTrigger *mClientMockAddTrigger) ExpectParentUUIDParam3(parentUUID trigger.UUID) *mClientMockAddTrigger {
	if mmAddTrigger.mock.funcAddTrigger != nil {
		mmAddTrigger.mock.t.Fatalf("ClientMock.AddTrigger mock is already set by Set")
	}

	if mmAddTrigger.defaultExpectation == nil {
		mmAddTrigger.defaultExpectation = &ClientMockAddTriggerExpectation{}
	}

	if mmAddTrigger.defaultExpectation.params != nil {
		mmAddTrigger.mock.t.Fatalf("ClientMock.AddTrigger mock is already set by Expect")
	}

	if mmAddTrigger.defaultExpectation.paramPtrs == nil {
		mmAddTrigger.defaultExpectation.paramPtrs = &ClientMockAddTriggerParamPtrs{}
	}
	mmAddTrigger.defaultExpectation.paramPtrs.parentUUID = &parentUUID
	mmAddTrigger.defaultExpectation.expectationOrigins.originParentUUID = minimock.CallerInfo(1)

	return mmAddTrigger
}

// Inspect accepts an inspector function that has same arguments as the Client.AddTrigger
func (mmAddTrigger *mClientMockAddTrigger) Inspect(f func(ctx context.Context, trigger trigger.Trigger, parentUUID trigger.UUID)) *mClientMockAddTrigger {
	if mmAddTrigger.mock.inspectFuncAddTrigger != nil {
		mmAddTrigger.mock.t.Fatalf("Inspect function is already set for ClientMock.AddTrigger")
	}

	mmAddTrigger.mock.inspectFuncAddTrigger = f

	return mmAddTrigger
}

// Return sets up results that will be returned by Client.AddTrigger
func (mmAddTrigger *mClientMockAddTrigger) Return(u1 trigger.UUID, err error) *ClientMock {
	if mmAddTrigger.mock.funcAddTrigger != nil {
		mmAddTrigger.mock.t.Fatalf("ClientMock.AddTrigger mock is already set by Set")
	}

	if mmAddTrigger.defaultExpectation == nil {
		mmAddTrigger.defaultExpectation = &ClientMockAddTriggerExpectation{mock: mmAddTrigger.mock}
	}
	mmAddTrigger.defaultExpectation.results = &ClientMockAddTriggerResults{u1, err}
	mmAddTrigger.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddTrigger.mock
}

// Set uses given function f to mock the Client.AddTrigger method
func (mmAddTrigger *mClientMockAddTrigger) Set(f func(ctx context.Context, trigger trigger.Trigger, parentUUID trigger.UUID) (u1 trigger.UUID, err error)) *ClientMock {
	if mmAddTrigger.defaultExpectation != nil {
		mmAddTrigger.mock.t.Fatalf("Default expectation is already set for the Client.AddTrigger method")
	}

	if len(mmAddTrigger.expectations) > 0 {
		mmAddTrigger.mock.t.Fatalf("Some expectations are already set for the Client.AddTrigger method")
	}

	mmAddTrigger.mock.funcAddTrigger = f
	mmAddTrigger.mock.funcAddTriggerOrigin = minimock.CallerInfo(1)
	return mmAddTrigger.mock
}

// When sets expectation for the Client.AddTrigger which will trigger the result defined by the following
// Then helper
func (mmAddTrigger *mClientMockAddTrigger) When(ctx context.Context, trigger trigger.Trigger, parentUUID trigger.UUID) *ClientMockAddTriggerExpectation {
	if mmAddTrigger.mock.funcAddTrigger != nil {
		mmAddTrigger.mock.t.Fatalf("ClientMock.AddTrigger mock is already set by Set")
	}

	expectation := &ClientMockAddTriggerExpectation{
		mock:               mmAddTrigger.mock,
		params:             &ClientMockAddTriggerParams{ctx, trigger, parentUUID},
		expectationOrigins: ClientMockAddTriggerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddTrigger.expectations = append(mmAddTrigger.expectations, expectation)
	return expectation
}

// Then sets up Client.AddTrigger return parameters for the expectation previously defined by the When method
func (e *ClientMockAddTriggerExpectation) Then(u1 trigger.UUID, err error) *ClientMock {
	e.results = &ClientMockAddTriggerResults{u1, err}
	return e.mock
}

// Times sets number of times Client.AddTrigger should be invoked
func (mmAddTrigger *mClientMockAddTrigger) Times(n uint64) *mClientMockAddTrigger {
	if n == 0 {
		mmAddTrigger.mock.t.Fatalf("Times of ClientMock.AddTrigger mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddTrigger.expectedInvocations, n)
	mmAddTrigger.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddTrigger
}

func (mmAddTrigger *mClientMockAddTrigger) invocationsDone() bool {
	if len(mmAddTrigger.expectations) == 0 && mmAddTrigger.defaultExpectation == nil && mmAddTrigger.mock.funcAddTrigger == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddTrigger.mock.afterAddTriggerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddTrigger.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddTrigger implements Client
func (mmAddTrigger *ClientMock) AddTrigger(ctx context.Context, trigger trigger.Trigger, parentUUID trigger.UUID) (u1 trigger.UUID, err error) {
	mm_atomic.AddUint64(&mmAddTrigger.beforeAddTriggerCounter, 1)
	defer mm_atomic.AddUint64(&mmAddTrigger.afterAddTriggerCounter, 1)

	mmAddTrigger.t.Helper()

	if mmAddTrigger.inspectFuncAddTrigger != nil {
		mmAddTrigger.inspectFuncAddTrigger(ctx, trigger, parentUUID)
	}

	mm_params := ClientMockAddTriggerParams{ctx, trigger, parentUUID}

	// Record call args
	mmAddTrigger.AddTriggerMock.mutex.Lock()
	mmAddTrigger.AddTriggerMock.callArgs = append(mmAddTrigger.AddTriggerMock.callArgs, &mm_params)
	mmAddTrigger.AddTriggerMock.mutex.Unlock()

	for _, e := range mmAddTrigger.AddTriggerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmAddTrigger.AddTriggerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddTrigger.AddTriggerMock.defaultExpectation.Counter, 1)
		mm_want := mmAddTrigger.AddTriggerMock.defaultExpectation.params
		mm_want_ptrs := mmAddTrigger.AddTriggerMock.defaultExpectation.paramPtrs

		mm_got := ClientMockAddTriggerParams{ctx, trigger, parentUUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddTrigger.t.Errorf("ClientMock.AddTrigger got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddTrigger.AddTriggerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.trigger != nil && !minimock.Equal(*mm_want_ptrs.trigger, mm_got.trigger) {
				mmAddTrigger.t.Errorf("ClientMock.AddTrigger got unexpected parameter trigger, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddTrigger.AddTriggerMock.defaultExpectation.expectationOrigins.originTrigger, *mm_want_ptrs.trigger, mm_got.trigger, minimock.Diff(*mm_want_ptrs.trigger, mm_got.trigger))
			}

			if mm_want_ptrs.parentUUID != nil && !minimock.Equal(*mm_want_ptrs.parentUUID, mm_got.parentUUID) {
				mmAddTrigger.t.Errorf("ClientMock.AddTrigger got unexpected parameter parentUUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddTrigger.AddTriggerMock.defaultExpectation.expectationOrigins.originParentUUID, *mm_want_ptrs.parentUUID, mm_got.parentUUID, minimock.Diff(*mm_want_ptrs.parentUUID, mm_got.parentUUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddTrigger.t.Errorf("ClientMock.AddTrigger got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddTrigger.AddTriggerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddTrigger.AddTriggerMock.defaultExpectation.results
		if mm_results == nil {
			mmAddTrigger.t.Fatal("No results are set for the ClientMock.AddTrigger")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmAddTrigger.funcAddTrigger != nil {
		return mmAddTrigger.funcAddTrigger(ctx, trigger, parentUUID)
	}
	mmAddTrigger.t.Fatalf("Unexpected call to ClientMock.AddTrigger. %v %v %v", ctx, trigger, parentUUID)
	return
}

// AddTriggerAfterCounter returns a count of finished ClientMock.AddTrigger invocations
func (mmAddTrigger *ClientMock) AddTriggerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTrigger.afterAddTriggerCounter)
}

// AddTriggerBeforeCounter returns a count of ClientMock.AddTrigger invocations
func (mmAddTrigger *ClientMock) AddTriggerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTrigger.beforeAddTriggerCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.AddTrigger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddTrigger *mClientMockAddTrigger) Calls() []*ClientMockAddTriggerParams {
	mmAddTrigger.mutex.RLock()

	argCopy := make([]*ClientMockAddTriggerParams, len(mmAddTrigger.callArgs))
	copy(argCopy, mmAddTrigger.callArgs)

	mmAddTrigger.mutex.RUnlock()

	return argCopy
}

// MinimockAddTriggerDone returns true if the count of the AddTrigger invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockAddTriggerDone() bool {
	if m.AddTriggerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddTriggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddTriggerMock.invocationsDone()
}

// MinimockAddTriggerInspect logs each unmet expectation
func (m *ClientMock) MinimockAddTriggerInspect() {
	for _, e := range m.AddTriggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.AddTrigger at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddTriggerCounter := mm_atomic.LoadUint64(&m.afterAddTriggerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddTriggerMock.defaultExpectation != nil && afterAddTriggerCounter < 1 {
		if m.AddTriggerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.AddTrigger at\n%s", m.AddTriggerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.AddTrigger at\n%s with params: %#v", m.AddTriggerMock.defaultExpectation.expectationOrigins.origin, *m.AddTriggerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddTrigger != nil && afterAddTriggerCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.AddTrigger at\n%s", m.funcAddTriggerOrigin)
	}

	if !m.AddTriggerMock.invocationsDone() && afterAddTriggerCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.AddTrigger at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddTriggerMock.expectedInvocations), m.AddTriggerMock.expectedInvocationsOrigin, afterAddTriggerCounter)
	}
}

type mClientMockDeleteTriggers struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteTriggersExpectation
	expectations       []*ClientMockDeleteTriggersExpectation

	callArgs []*ClientMockDeleteTriggersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockDeleteTriggersExpectation specifies expectation struct of the Client.DeleteTriggers
type ClientMockDeleteTriggersExpectation struct {
	mock               *ClientMock
	params             *ClientMockDeleteTriggersParams
	paramPtrs          *ClientMockDeleteTriggersParamPtrs
	expectationOrigins ClientMockDeleteTriggersExpectationOrigins
	results            *ClientMockDeleteTriggersResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockDeleteTriggersParams contains parameters of the Client.DeleteTriggers
type ClientMockDeleteTriggersParams struct {
	ctx      context.Context
	triggers []trigger.Trigger
}

// ClientMockDeleteTriggersParamPtrs contains pointers to parameters of the Client.DeleteTriggers
type ClientMockDeleteTriggersParamPtrs struct {
	ctx      *context.Context
	triggers *[]trigger.Trigger
}

// ClientMockDeleteTriggersResults contains results of the Client.DeleteTriggers
type ClientMockDeleteTriggersResults struct {
	err error
}

// ClientMockDeleteTriggersOrigins contains origins of expectations of the Client.DeleteTriggers
type ClientMockDeleteTriggersExpectationOrigins struct {
	origin         string
	originCtx      string
	originTriggers string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteTriggers *mClientMockDeleteTriggers) Optional() *mClientMockDeleteTriggers {
	mmDeleteTriggers.optional = true
	return mmDeleteTriggers
}

// Expect sets up expected params for Client.DeleteTriggers
func (mmDeleteTriggers *mClientMockDeleteTriggers) Expect(ctx context.Context, triggers []trigger.Trigger) *mClientMockDeleteTriggers {
	if mmDeleteTriggers.mock.funcDeleteTriggers != nil {
		mmDeleteTriggers.mock.t.Fatalf("ClientMock.DeleteTriggers mock is already set by Set")
	}

	if mmDeleteTriggers.defaultExpectation == nil {
		mmDeleteTriggers.defaultExpectation = &ClientMockDeleteTriggersExpectation{}
	}

	if mmDeleteTriggers.defaultExpectation.paramPtrs != nil {
		mmDeleteTriggers.mock.t.Fatalf("ClientMock.DeleteTriggers mock is already set by ExpectParams functions")
	}

	mmDeleteTriggers.defaultExpectation.params = &ClientMockDeleteTriggersParams{ctx, triggers}
	mmDeleteTriggers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteTriggers.expectations {
		if minimock.Equal(e.params, mmDeleteTriggers.defaultExpectation.params) {
			mmDeleteTriggers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteTriggers.defaultExpectation.params)
		}
	}

	return mmDeleteTriggers
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteTriggers
func (mmDeleteTriggers *mClientMockDeleteTriggers) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteTriggers {
	if mmDeleteTriggers.mock.funcDeleteTriggers != nil {
		mmDeleteTriggers.mock.t.Fatalf("ClientMock.DeleteTriggers mock is already set by Set")
	}

	if mmDeleteTriggers.defaultExpectation == nil {
		mmDeleteTriggers.defaultExpectation = &ClientMockDeleteTriggersExpectation{}
	}

	if mmDeleteTriggers.defaultExpectation.params != nil {
		mmDeleteTriggers.mock.t.Fatalf("ClientMock.DeleteTriggers mock is already set by Expect")
	}

	if mmDeleteTriggers.defaultExpectation.paramPtrs == nil {
		mmDeleteTriggers.defaultExpectation.paramPtrs = &ClientMockDeleteTriggersParamPtrs{}
	}
	mmDeleteTriggers.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteTriggers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteTriggers
}

// ExpectTriggersParam2 sets up expected param triggers for Client.DeleteTriggers
func (mmDeleteTriggers *mClientMockDeleteTriggers) ExpectTriggersParam2(triggers []trigger.Trigger) *mClientMockDeleteTriggers {
	if mmDeleteTriggers.mock.funcDeleteTriggers != nil {
		mmDeleteTriggers.mock.t.Fatalf("ClientMock.DeleteTriggers mock is already set by Set")
	}

	if mmDeleteTriggers.defaultExpectation == nil {
		mmDeleteTriggers.defaultExpectation = &ClientMockDeleteTriggersExpectation{}
	}

	if mmDeleteTriggers.defaultExpectation.params != nil {
		mmDeleteTriggers.mock.t.Fatalf("ClientMock.DeleteTriggers mock is already set by Expect")
	}

	if mmDeleteTriggers.defaultExpectation.paramPtrs == nil {
		mmDeleteTriggers.defaultExpectation.paramPtrs = &ClientMockDeleteTriggersParamPtrs{}
	}
	mmDeleteTriggers.defaultExpectation.paramPtrs.triggers = &triggers
	mmDeleteTriggers.defaultExpectation.expectationOrigins.originTriggers = minimock.CallerInfo(1)

	return mmDeleteTriggers
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteTriggers
func (mmDeleteTriggers *mClientMockDeleteTriggers) Inspect(f func(ctx context.Context, triggers []trigger.Trigger)) *mClientMockDeleteTriggers {
	if mmDeleteTriggers.mock.inspectFuncDeleteTriggers != nil {
		mmDeleteTriggers.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteTriggers")
	}

	mmDeleteTriggers.mock.inspectFuncDeleteTriggers = f

	return mmDeleteTriggers
}

// Return sets up results that will be returned by Client.DeleteTriggers
func (mmDeleteTriggers *mClientMockDeleteTriggers) Return(err error) *ClientMock {
	if mmDeleteTriggers.mock.funcDeleteTriggers != nil {
		mmDeleteTriggers.mock.t.Fatalf("ClientMock.DeleteTriggers mock is already set by Set")
	}

	if mmDeleteTriggers.defaultExpectation == nil {
		mmDeleteTriggers.defaultExpectation = &ClientMockDeleteTriggersExpectation{mock: mmDeleteTriggers.mock}
	}
	mmDeleteTriggers.defaultExpectation.results = &ClientMockDeleteTriggersResults{err}
	mmDeleteTriggers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteTriggers.mock
}

// Set uses given function f to mock the Client.DeleteTriggers method
func (mmDeleteTriggers *mClientMockDeleteTriggers) Set(f func(ctx context.Context, triggers []trigger.Trigger) (err error)) *ClientMock {
	if mmDeleteTriggers.defaultExpectation != nil {
		mmDeleteTriggers.mock.t.Fatalf("Default expectation is already set for the Client.DeleteTriggers method")
	}

	if len(mmDeleteTriggers.expectations) > 0 {
		mmDeleteTriggers.mock.t.Fatalf("Some expectations are already set for the Client.DeleteTriggers method")
	}

	mmDeleteTriggers.mock.funcDeleteTriggers = f
	mmDeleteTriggers.mock.funcDeleteTriggersOrigin = minimock.CallerInfo(1)
	return mmDeleteTriggers.mock
}

// When sets expectation for the Client.DeleteTriggers which will trigger the result defined by the following
// Then helper
func (mmDeleteTriggers *mClientMockDeleteTriggers) When(ctx context.Context, triggers []trigger.Trigger) *ClientMockDeleteTriggersExpectation {
	if mmDeleteTriggers.mock.funcDeleteTriggers != nil {
		mmDeleteTriggers.mock.t.Fatalf("ClientMock.DeleteTriggers mock is already set by Set")
	}

	expectation := &ClientMockDeleteTriggersExpectation{
		mock:               mmDeleteTriggers.mock,
		params:             &ClientMockDeleteTriggersParams{ctx, triggers},
		expectationOrigins: ClientMockDeleteTriggersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteTriggers.expectations = append(mmDeleteTriggers.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteTriggers return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteTriggersExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteTriggersResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteTriggers should be invoked
func (mmDeleteTriggers *mClientMockDeleteTriggers) Times(n uint64) *mClientMockDeleteTriggers {
	if n == 0 {
		mmDeleteTriggers.mock.t.Fatalf("Times of ClientMock.DeleteTriggers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteTriggers.expectedInvocations, n)
	mmDeleteTriggers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteTriggers
}

func (mmDeleteTriggers *mClientMockDeleteTriggers) invocationsDone() bool {
	if len(mmDeleteTriggers.expectations) == 0 && mmDeleteTriggers.defaultExpectation == nil && mmDeleteTriggers.mock.funcDeleteTriggers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteTriggers.mock.afterDeleteTriggersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteTriggers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteTriggers implements Client
func (mmDeleteTriggers *ClientMock) DeleteTriggers(ctx context.Context, triggers []trigger.Trigger) (err error) {
	mm_atomic.AddUint64(&mmDeleteTriggers.beforeDeleteTriggersCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteTriggers.afterDeleteTriggersCounter, 1)

	mmDeleteTriggers.t.Helper()

	if mmDeleteTriggers.inspectFuncDeleteTriggers != nil {
		mmDeleteTriggers.inspectFuncDeleteTriggers(ctx, triggers)
	}

	mm_params := ClientMockDeleteTriggersParams{ctx, triggers}

	// Record call args
	mmDeleteTriggers.DeleteTriggersMock.mutex.Lock()
	mmDeleteTriggers.DeleteTriggersMock.callArgs = append(mmDeleteTriggers.DeleteTriggersMock.callArgs, &mm_params)
	mmDeleteTriggers.DeleteTriggersMock.mutex.Unlock()

	for _, e := range mmDeleteTriggers.DeleteTriggersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteTriggers.DeleteTriggersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteTriggers.DeleteTriggersMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteTriggers.DeleteTriggersMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteTriggers.DeleteTriggersMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteTriggersParams{ctx, triggers}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteTriggers.t.Errorf("ClientMock.DeleteTriggers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTriggers.DeleteTriggersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.triggers != nil && !minimock.Equal(*mm_want_ptrs.triggers, mm_got.triggers) {
				mmDeleteTriggers.t.Errorf("ClientMock.DeleteTriggers got unexpected parameter triggers, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTriggers.DeleteTriggersMock.defaultExpectation.expectationOrigins.originTriggers, *mm_want_ptrs.triggers, mm_got.triggers, minimock.Diff(*mm_want_ptrs.triggers, mm_got.triggers))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteTriggers.t.Errorf("ClientMock.DeleteTriggers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteTriggers.DeleteTriggersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteTriggers.DeleteTriggersMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteTriggers.t.Fatal("No results are set for the ClientMock.DeleteTriggers")
		}
		return (*mm_results).err
	}
	if mmDeleteTriggers.funcDeleteTriggers != nil {
		return mmDeleteTriggers.funcDeleteTriggers(ctx, triggers)
	}
	mmDeleteTriggers.t.Fatalf("Unexpected call to ClientMock.DeleteTriggers. %v %v", ctx, triggers)
	return
}

// DeleteTriggersAfterCounter returns a count of finished ClientMock.DeleteTriggers invocations
func (mmDeleteTriggers *ClientMock) DeleteTriggersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTriggers.afterDeleteTriggersCounter)
}

// DeleteTriggersBeforeCounter returns a count of ClientMock.DeleteTriggers invocations
func (mmDeleteTriggers *ClientMock) DeleteTriggersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTriggers.beforeDeleteTriggersCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteTriggers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteTriggers *mClientMockDeleteTriggers) Calls() []*ClientMockDeleteTriggersParams {
	mmDeleteTriggers.mutex.RLock()

	argCopy := make([]*ClientMockDeleteTriggersParams, len(mmDeleteTriggers.callArgs))
	copy(argCopy, mmDeleteTriggers.callArgs)

	mmDeleteTriggers.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteTriggersDone returns true if the count of the DeleteTriggers invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteTriggersDone() bool {
	if m.DeleteTriggersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteTriggersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteTriggersMock.invocationsDone()
}

// MinimockDeleteTriggersInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteTriggersInspect() {
	for _, e := range m.DeleteTriggersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteTriggers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteTriggersCounter := mm_atomic.LoadUint64(&m.afterDeleteTriggersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteTriggersMock.defaultExpectation != nil && afterDeleteTriggersCounter < 1 {
		if m.DeleteTriggersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.DeleteTriggers at\n%s", m.DeleteTriggersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteTriggers at\n%s with params: %#v", m.DeleteTriggersMock.defaultExpectation.expectationOrigins.origin, *m.DeleteTriggersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteTriggers != nil && afterDeleteTriggersCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.DeleteTriggers at\n%s", m.funcDeleteTriggersOrigin)
	}

	if !m.DeleteTriggersMock.invocationsDone() && afterDeleteTriggersCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteTriggers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteTriggersMock.expectedInvocations), m.DeleteTriggersMock.expectedInvocationsOrigin, afterDeleteTriggersCounter)
	}
}

type mClientMockGetTrigger struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetTriggerExpectation
	expectations       []*ClientMockGetTriggerExpectation

	callArgs []*ClientMockGetTriggerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetTriggerExpectation specifies expectation struct of the Client.GetTrigger
type ClientMockGetTriggerExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetTriggerParams
	paramPtrs          *ClientMockGetTriggerParamPtrs
	expectationOrigins ClientMockGetTriggerExpectationOrigins
	results            *ClientMockGetTriggerResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetTriggerParams contains parameters of the Client.GetTrigger
type ClientMockGetTriggerParams struct {
	ctx   context.Context
	title trigger.Title
}

// ClientMockGetTriggerParamPtrs contains pointers to parameters of the Client.GetTrigger
type ClientMockGetTriggerParamPtrs struct {
	ctx   *context.Context
	title *trigger.Title
}

// ClientMockGetTriggerResults contains results of the Client.GetTrigger
type ClientMockGetTriggerResults struct {
	t1  trigger.Trigger
	err error
}

// ClientMockGetTriggerOrigins contains origins of expectations of the Client.GetTrigger
type ClientMockGetTriggerExpectationOrigins struct {
	origin      string
	originCtx   string
	originTitle string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTrigger *mClientMockGetTrigger) Optional() *mClientMockGetTrigger {
	mmGetTrigger.optional = true
	return mmGetTrigger
}

// Expect sets up expected params for Client.GetTrigger
func (mmGetTrigger *mClientMockGetTrigger) Expect(ctx context.Context, title trigger.Title) *mClientMockGetTrigger {
	if mmGetTrigger.mock.funcGetTrigger != nil {
		mmGetTrigger.mock.t.Fatalf("ClientMock.GetTrigger mock is already set by Set")
	}

	if mmGetTrigger.defaultExpectation == nil {
		mmGetTrigger.defaultExpectation = &ClientMockGetTriggerExpectation{}
	}

	if mmGetTrigger.defaultExpectation.paramPtrs != nil {
		mmGetTrigger.mock.t.Fatalf("ClientMock.GetTrigger mock is already set by ExpectParams functions")
	}

	mmGetTrigger.defaultExpectation.params = &ClientMockGetTriggerParams{ctx, title}
	mmGetTrigger.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTrigger.expectations {
		if minimock.Equal(e.params, mmGetTrigger.defaultExpectation.params) {
			mmGetTrigger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTrigger.defaultExpectation.params)
		}
	}

	return mmGetTrigger
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetTrigger
func (mmGetTrigger *mClientMockGetTrigger) ExpectCtxParam1(ctx context.Context) *mClientMockGetTrigger {
	if mmGetTrigger.mock.funcGetTrigger != nil {
		mmGetTrigger.mock.t.Fatalf("ClientMock.GetTrigger mock is already set by Set")
	}

	if mmGetTrigger.defaultExpectation == nil {
		mmGetTrigger.defaultExpectation = &ClientMockGetTriggerExpectation{}
	}

	if mmGetTrigger.defaultExpectation.params != nil {
		mmGetTrigger.mock.t.Fatalf("ClientMock.GetTrigger mock is already set by Expect")
	}

	if mmGetTrigger.defaultExpectation.paramPtrs == nil {
		mmGetTrigger.defaultExpectation.paramPtrs = &ClientMockGetTriggerParamPtrs{}
	}
	mmGetTrigger.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTrigger.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTrigger
}

// ExpectTitleParam2 sets up expected param title for Client.GetTrigger
func (mmGetTrigger *mClientMockGetTrigger) ExpectTitleParam2(title trigger.Title) *mClientMockGetTrigger {
	if mmGetTrigger.mock.funcGetTrigger != nil {
		mmGetTrigger.mock.t.Fatalf("ClientMock.GetTrigger mock is already set by Set")
	}

	if mmGetTrigger.defaultExpectation == nil {
		mmGetTrigger.defaultExpectation = &ClientMockGetTriggerExpectation{}
	}

	if mmGetTrigger.defaultExpectation.params != nil {
		mmGetTrigger.mock.t.Fatalf("ClientMock.GetTrigger mock is already set by Expect")
	}

	if mmGetTrigger.defaultExpectation.paramPtrs == nil {
		mmGetTrigger.defaultExpectation.paramPtrs = &ClientMockGetTriggerParamPtrs{}
	}
	mmGetTrigger.defaultExpectation.paramPtrs.title = &title
	mmGetTrigger.defaultExpectation.expectationOrigins.originTitle = minimock.CallerInfo(1)

	return mmGetTrigger
}

// Inspect accepts an inspector function that has same arguments as the Client.GetTrigger
func (mmGetTrigger *mClientMockGetTrigger) Inspect(f func(ctx context.Context, title trigger.Title)) *mClientMockGetTrigger {
	if mmGetTrigger.mock.inspectFuncGetTrigger != nil {
		mmGetTrigger.mock.t.Fatalf("Inspect function is already set for ClientMock.GetTrigger")
	}

	mmGetTrigger.mock.inspectFuncGetTrigger = f

	return mmGetTrigger
}

// Return sets up results that will be returned by Client.GetTrigger
func (mmGetTrigger *mClientMockGetTrigger) Return(t1 trigger.Trigger, err error) *ClientMock {
	if mmGetTrigger.mock.funcGetTrigger != nil {
		mmGetTrigger.mock.t.Fatalf("ClientMock.GetTrigger mock is already set by Set")
	}

	if mmGetTrigger.defaultExpectation == nil {
		mmGetTrigger.defaultExpectation = &ClientMockGetTriggerExpectation{mock: mmGetTrigger.mock}
	}
	mmGetTrigger.defaultExpectation.results = &ClientMockGetTriggerResults{t1, err}
	mmGetTrigger.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTrigger.mock
}

// Set uses given function f to mock the Client.GetTrigger method
func (mmGetTrigger *mClientMockGetTrigger) Set(f func(ctx context.Context, title trigger.Title) (t1 trigger.Trigger, err error)) *ClientMock {
	if mmGetTrigger.defaultExpectation != nil {
		mmGetTrigger.mock.t.Fatalf("Default expectation is already set for the Client.GetTrigger method")
	}

	if len(mmGetTrigger.expectations) > 0 {
		mmGetTrigger.mock.t.Fatalf("Some expectations are already set for the Client.GetTrigger method")
	}

	mmGetTrigger.mock.funcGetTrigger = f
	mmGetTrigger.mock.funcGetTriggerOrigin = minimock.CallerInfo(1)
	return mmGetTrigger.mock
}

// When sets expectation for the Client.GetTrigger which will trigger the result defined by the following
// Then helper
func (mmGetTrigger *mClientMockGetTrigger) When(ctx context.Context, title trigger.Title) *ClientMockGetTriggerExpectation {
	if mmGetTrigger.mock.funcGetTrigger != nil {
		mmGetTrigger.mock.t.Fatalf("ClientMock.GetTrigger mock is already set by Set")
	}

	expectation := &ClientMockGetTriggerExpectation{
		mock:               mmGetTrigger.mock,
		params:             &ClientMockGetTriggerParams{ctx, title},
		expectationOrigins: ClientMockGetTriggerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTrigger.expectations = append(mmGetTrigger.expectations, expectation)
	return expectation
}

// Then sets up Client.GetTrigger return parameters for the expectation previously defined by the When method
func (e *ClientMockGetTriggerExpectation) Then(t1 trigger.Trigger, err error) *ClientMock {
	e.results = &ClientMockGetTriggerResults{t1, err}
	return e.mock
}

// Times sets number of times Client.GetTrigger should be invoked
func (mmGetTrigger *mClientMockGetTrigger) Times(n uint64) *mClientMockGetTrigger {
	if n == 0 {
		mmGetTrigger.mock.t.Fatalf("Times of ClientMock.GetTrigger mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTrigger.expectedInvocations, n)
	mmGetTrigger.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTrigger
}

func (mmGetTrigger *mClientMockGetTrigger) invocationsDone() bool {
	if len(mmGetTrigger.expectations) == 0 && mmGetTrigger.defaultExpectation == nil && mmGetTrigger.mock.funcGetTrigger == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTrigger.mock.afterGetTriggerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTrigger.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTrigger implements Client
func (mmGetTrigger *ClientMock) GetTrigger(ctx context.Context, title trigger.Title) (t1 trigger.Trigger, err error) {
	mm_atomic.AddUint64(&mmGetTrigger.beforeGetTriggerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTrigger.afterGetTriggerCounter, 1)

	mmGetTrigger.t.Helper()

	if mmGetTrigger.inspectFuncGetTrigger != nil {
		mmGetTrigger.inspectFuncGetTrigger(ctx, title)
	}

	mm_params := ClientMockGetTriggerParams{ctx, title}

	// Record call args
	mmGetTrigger.GetTriggerMock.mutex.Lock()
	mmGetTrigger.GetTriggerMock.callArgs = append(mmGetTrigger.GetTriggerMock.callArgs, &mm_params)
	mmGetTrigger.GetTriggerMock.mutex.Unlock()

	for _, e := range mmGetTrigger.GetTriggerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmGetTrigger.GetTriggerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTrigger.GetTriggerMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTrigger.GetTriggerMock.defaultExpectation.params
		mm_want_ptrs := mmGetTrigger.GetTriggerMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetTriggerParams{ctx, title}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTrigger.t.Errorf("ClientMock.GetTrigger got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTrigger.GetTriggerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.title != nil && !minimock.Equal(*mm_want_ptrs.title, mm_got.title) {
				mmGetTrigger.t.Errorf("ClientMock.GetTrigger got unexpected parameter title, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTrigger.GetTriggerMock.defaultExpectation.expectationOrigins.originTitle, *mm_want_ptrs.title, mm_got.title, minimock.Diff(*mm_want_ptrs.title, mm_got.title))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTrigger.t.Errorf("ClientMock.GetTrigger got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTrigger.GetTriggerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTrigger.GetTriggerMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTrigger.t.Fatal("No results are set for the ClientMock.GetTrigger")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmGetTrigger.funcGetTrigger != nil {
		return mmGetTrigger.funcGetTrigger(ctx, title)
	}
	mmGetTrigger.t.Fatalf("Unexpected call to ClientMock.GetTrigger. %v %v", ctx, title)
	return
}

// GetTriggerAfterCounter returns a count of finished ClientMock.GetTrigger invocations
func (mmGetTrigger *ClientMock) GetTriggerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTrigger.afterGetTriggerCounter)
}

// GetTriggerBeforeCounter returns a count of ClientMock.GetTrigger invocations
func (mmGetTrigger *ClientMock) GetTriggerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTrigger.beforeGetTriggerCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetTrigger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTrigger *mClientMockGetTrigger) Calls() []*ClientMockGetTriggerParams {
	mmGetTrigger.mutex.RLock()

	argCopy := make([]*ClientMockGetTriggerParams, len(mmGetTrigger.callArgs))
	copy(argCopy, mmGetTrigger.callArgs)

	mmGetTrigger.mutex.RUnlock()

	return argCopy
}

// MinimockGetTriggerDone returns true if the count of the GetTrigger invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetTriggerDone() bool {
	if m.GetTriggerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTriggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTriggerMock.invocationsDone()
}

// MinimockGetTriggerInspect logs each unmet expectation
func (m *ClientMock) MinimockGetTriggerInspect() {
	for _, e := range m.GetTriggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetTrigger at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTriggerCounter := mm_atomic.LoadUint64(&m.afterGetTriggerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTriggerMock.defaultExpectation != nil && afterGetTriggerCounter < 1 {
		if m.GetTriggerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetTrigger at\n%s", m.GetTriggerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetTrigger at\n%s with params: %#v", m.GetTriggerMock.defaultExpectation.expectationOrigins.origin, *m.GetTriggerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTrigger != nil && afterGetTriggerCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetTrigger at\n%s", m.funcGetTriggerOrigin)
	}

	if !m.GetTriggerMock.invocationsDone() && afterGetTriggerCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetTrigger at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTriggerMock.expectedInvocations), m.GetTriggerMock.expectedInvocationsOrigin, afterGetTriggerCounter)
	}
}

type mClientMockGetTriggers struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetTriggersExpectation
	expectations       []*ClientMockGetTriggersExpectation

	callArgs []*ClientMockGetTriggersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetTriggersExpectation specifies expectation struct of the Client.GetTriggers
type ClientMockGetTriggersExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetTriggersParams
	paramPtrs          *ClientMockGetTriggersParamPtrs
	expectationOrigins ClientMockGetTriggersExpectationOrigins
	results            *ClientMockGetTriggersResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetTriggersParams contains parameters of the Client.GetTriggers
type ClientMockGetTriggersParams struct {
	ctx        context.Context
	parentUUID trigger.UUID
}

// ClientMockGetTriggersParamPtrs contains pointers to parameters of the Client.GetTriggers
type ClientMockGetTriggersParamPtrs struct {
	ctx        *context.Context
	parentUUID *trigger.UUID
}

// ClientMockGetTriggersResults contains results of the Client.GetTriggers
type ClientMockGetTriggersResults struct {
	ta1 []trigger.Trigger
	err error
}

// ClientMockGetTriggersOrigins contains origins of expectations of the Client.GetTriggers
type ClientMockGetTriggersExpectationOrigins struct {
	origin           string
	originCtx        string
	originParentUUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTriggers *mClientMockGetTriggers) Optional() *mClientMockGetTriggers {
	mmGetTriggers.optional = true
	return mmGetTriggers
}

// Expect sets up expected params for Client.GetTriggers
func (mmGetTriggers *mClientMockGetTriggers) Expect(ctx context.Context, parentUUID trigger.UUID) *mClientMockGetTriggers {
	if mmGetTriggers.mock.funcGetTriggers != nil {
		mmGetTriggers.mock.t.Fatalf("ClientMock.GetTriggers mock is already set by Set")
	}

	if mmGetTriggers.defaultExpectation == nil {
		mmGetTriggers.defaultExpectation = &ClientMockGetTriggersExpectation{}
	}

	if mmGetTriggers.defaultExpectation.paramPtrs != nil {
		mmGetTriggers.mock.t.Fatalf("ClientMock.GetTriggers mock is already set by ExpectParams functions")
	}

	mmGetTriggers.defaultExpectation.params = &ClientMockGetTriggersParams{ctx, parentUUID}
	mmGetTriggers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTriggers.expectations {
		if minimock.Equal(e.params, mmGetTriggers.defaultExpectation.params) {
			mmGetTriggers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTriggers.defaultExpectation.params)
		}
	}

	return mmGetTriggers
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetTriggers
func (mmGetTriggers *mClientMockGetTriggers) ExpectCtxParam1(ctx context.Context) *mClientMockGetTriggers {
	if mmGetTriggers.mock.funcGetTriggers != nil {
		mmGetTriggers.mock.t.Fatalf("ClientMock.GetTriggers mock is already set by Set")
	}

	if mmGetTriggers.defaultExpectation == nil {
		mmGetTriggers.defaultExpectation = &ClientMockGetTriggersExpectation{}
	}

	if mmGetTriggers.defaultExpectation.params != nil {
		mmGetTriggers.mock.t.Fatalf("ClientMock.GetTriggers mock is already set by Expect")
	}

	if mmGetTriggers.defaultExpectation.paramPtrs == nil {
		mmGetTriggers.defaultExpectation.paramPtrs = &ClientMockGetTriggersParamPtrs{}
	}
	mmGetTriggers.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTriggers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTriggers
}

// ExpectParentUUIDParam2 sets up expected param parentUUID for Client.GetTriggers
func (mmGetTriggers *mClientMockGetTriggers) ExpectParentUUIDParam2(parentUUID trigger.UUID) *mClientMockGetTriggers {
	if mmGetTriggers.mock.funcGetTriggers != nil {
		mmGetTriggers.mock.t.Fatalf("ClientMock.GetTriggers mock is already set by Set")
	}

	if mmGetTriggers.defaultExpectation == nil {
		mmGetTriggers.defaultExpectation = &ClientMockGetTriggersExpectation{}
	}

	if mmGetTriggers.defaultExpectation.params != nil {
		mmGetTriggers.mock.t.Fatalf("ClientMock.GetTriggers mock is already set by Expect")
	}

	if mmGetTriggers.defaultExpectation.paramPtrs == nil {
		mmGetTriggers.defaultExpectation.paramPtrs = &ClientMockGetTriggersParamPtrs{}
	}
	mmGetTriggers.defaultExpectation.paramPtrs.parentUUID = &parentUUID
	mmGetTriggers.defaultExpectation.expectationOrigins.originParentUUID = minimock.CallerInfo(1)

	return mmGetTriggers
}

// Inspect accepts an inspector function that has same arguments as the Client.GetTriggers
func (mmGetTriggers *mClientMockGetTriggers) Inspect(f func(ctx context.Context, parentUUID trigger.UUID)) *mClientMockGetTriggers {
	if mmGetTriggers.mock.inspectFuncGetTriggers != nil {
		mmGetTriggers.mock.t.Fatalf("Inspect function is already set for ClientMock.GetTriggers")
	}

	mmGetTriggers.mock.inspectFuncGetTriggers = f

	return mmGetTriggers
}

// Return sets up results that will be returned by Client.GetTriggers
func (mmGetTriggers *mClientMockGetTriggers) Return(ta1 []trigger.Trigger, err error) *ClientMock {
	if mmGetTriggers.mock.funcGetTriggers != nil {
		mmGetTriggers.mock.t.Fatalf("ClientMock.GetTriggers mock is already set by Set")
	}

	if mmGetTriggers.defaultExpectation == nil {
		mmGetTriggers.defaultExpectation = &ClientMockGetTriggersExpectation{mock: mmGetTriggers.mock}
	}
	mmGetTriggers.defaultExpectation.results = &ClientMockGetTriggersResults{ta1, err}
	mmGetTriggers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTriggers.mock
}

// Set uses given function f to mock the Client.GetTriggers method
func (mmGetTriggers *mClientMockGetTriggers) Set(f func(ctx context.Context, parentUUID trigger.UUID) (ta1 []trigger.Trigger, err error)) *ClientMock {
	if mmGetTriggers.defaultExpectation != nil {
		mmGetTriggers.mock.t.Fatalf("Default expectation is already set for the Client.GetTriggers method")
	}

	if len(mmGetTriggers.expectations) > 0 {
		mmGetTriggers.mock.t.Fatalf("Some expectations are already set for the Client.GetTriggers method")
	}

	mmGetTriggers.mock.funcGetTriggers = f
	mmGetTriggers.mock.funcGetTriggersOrigin = minimock.CallerInfo(1)
	return mmGetTriggers.mock
}

// When sets expectation for the Client.GetTriggers which will trigger the result defined by the following
// Then helper
func (mmGetTriggers *mClientMockGetTriggers) When(ctx context.Context, parentUUID trigger.UUID) *ClientMockGetTriggersExpectation {
	if mmGetTriggers.mock.funcGetTriggers != nil {
		mmGetTriggers.mock.t.Fatalf("ClientMock.GetTriggers mock is already set by Set")
	}

	expectation := &ClientMockGetTriggersExpectation{
		mock:               mmGetTriggers.mock,
		params:             &ClientMockGetTriggersParams{ctx, parentUUID},
		expectationOrigins: ClientMockGetTriggersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTriggers.expectations = append(mmGetTriggers.expectations, expectation)
	return expectation
}

// Then sets up Client.GetTriggers return parameters for the expectation previously defined by the When method
func (e *ClientMockGetTriggersExpectation) Then(ta1 []trigger.Trigger, err error) *ClientMock {
	e.results = &ClientMockGetTriggersResults{ta1, err}
	return e.mock
}

// Times sets number of times Client.GetTriggers should be invoked
func (mmGetTriggers *mClientMockGetTriggers) Times(n uint64) *mClientMockGetTriggers {
	if n == 0 {
		mmGetTriggers.mock.t.Fatalf("Times of ClientMock.GetTriggers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTriggers.expectedInvocations, n)
	mmGetTriggers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTriggers
}

func (mmGetTriggers *mClientMockGetTriggers) invocationsDone() bool {
	if len(mmGetTriggers.expectations) == 0 && mmGetTriggers.defaultExpectation == nil && mmGetTriggers.mock.funcGetTriggers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTriggers.mock.afterGetTriggersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTriggers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTriggers implements Client
func (mmGetTriggers *ClientMock) GetTriggers(ctx context.Context, parentUUID trigger.UUID) (ta1 []trigger.Trigger, err error) {
	mm_atomic.AddUint64(&mmGetTriggers.beforeGetTriggersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTriggers.afterGetTriggersCounter, 1)

	mmGetTriggers.t.Helper()

	if mmGetTriggers.inspectFuncGetTriggers != nil {
		mmGetTriggers.inspectFuncGetTriggers(ctx, parentUUID)
	}

	mm_params := ClientMockGetTriggersParams{ctx, parentUUID}

	// Record call args
	mmGetTriggers.GetTriggersMock.mutex.Lock()
	mmGetTriggers.GetTriggersMock.callArgs = append(mmGetTriggers.GetTriggersMock.callArgs, &mm_params)
	mmGetTriggers.GetTriggersMock.mutex.Unlock()

	for _, e := range mmGetTriggers.GetTriggersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetTriggers.GetTriggersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTriggers.GetTriggersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTriggers.GetTriggersMock.defaultExpectation.params
		mm_want_ptrs := mmGetTriggers.GetTriggersMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetTriggersParams{ctx, parentUUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTriggers.t.Errorf("ClientMock.GetTriggers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTriggers.GetTriggersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.parentUUID != nil && !minimock.Equal(*mm_want_ptrs.parentUUID, mm_got.parentUUID) {
				mmGetTriggers.t.Errorf("ClientMock.GetTriggers got unexpected parameter parentUUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTriggers.GetTriggersMock.defaultExpectation.expectationOrigins.originParentUUID, *mm_want_ptrs.parentUUID, mm_got.parentUUID, minimock.Diff(*mm_want_ptrs.parentUUID, mm_got.parentUUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTriggers.t.Errorf("ClientMock.GetTriggers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTriggers.GetTriggersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTriggers.GetTriggersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTriggers.t.Fatal("No results are set for the ClientMock.GetTriggers")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetTriggers.funcGetTriggers != nil {
		return mmGetTriggers.funcGetTriggers(ctx, parentUUID)
	}
	mmGetTriggers.t.Fatalf("Unexpected call to ClientMock.GetTriggers. %v %v", ctx, parentUUID)
	return
}

// GetTriggersAfterCounter returns a count of finished ClientMock.GetTriggers invocations
func (mmGetTriggers *ClientMock) GetTriggersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTriggers.afterGetTriggersCounter)
}

// GetTriggersBeforeCounter returns a count of ClientMock.GetTriggers invocations
func (mmGetTriggers *ClientMock) GetTriggersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTriggers.beforeGetTriggersCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetTriggers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTriggers *mClientMockGetTriggers) Calls() []*ClientMockGetTriggersParams {
	mmGetTriggers.mutex.RLock()

	argCopy := make([]*ClientMockGetTriggersParams, len(mmGetTriggers.callArgs))
	copy(argCopy, mmGetTriggers.callArgs)

	mmGetTriggers.mutex.RUnlock()

	return argCopy
}

// MinimockGetTriggersDone returns true if the count of the GetTriggers invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetTriggersDone() bool {
	if m.GetTriggersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTriggersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTriggersMock.invocationsDone()
}

// MinimockGetTriggersInspect logs each unmet expectation
func (m *ClientMock) MinimockGetTriggersInspect() {
	for _, e := range m.GetTriggersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetTriggers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTriggersCounter := mm_atomic.LoadUint64(&m.afterGetTriggersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTriggersMock.defaultExpectation != nil && afterGetTriggersCounter < 1 {
		if m.GetTriggersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetTriggers at\n%s", m.GetTriggersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetTriggers at\n%s with params: %#v", m.GetTriggersMock.defaultExpectation.expectationOrigins.origin, *m.GetTriggersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTriggers != nil && afterGetTriggersCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetTriggers at\n%s", m.funcGetTriggersOrigin)
	}

	if !m.GetTriggersMock.invocationsDone() && afterGetTriggersCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetTriggers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTriggersMock.expectedInvocations), m.GetTriggersMock.expectedInvocationsOrigin, afterGetTriggersCounter)
	}
}

type mClientMockHealth struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockHealthExpectation
	expectations       []*ClientMockHealthExpectation

	callArgs []*ClientMockHealthParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockHealthExpectation specifies expectation struct of the Client.Health
type ClientMockHealthExpectation struct {
	mock               *ClientMock
	params             *ClientMockHealthParams
	paramPtrs          *ClientMockHealthParamPtrs
	expectationOrigins ClientMockHealthExpectationOrigins
	results            *ClientMockHealthResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockHealthParams contains parameters of the Client.Health
type ClientMockHealthParams struct {
	ctx context.Context
}

// ClientMockHealthParamPtrs contains pointers to parameters of the Client.Health
type ClientMockHealthParamPtrs struct {
	ctx *context.Context
}

// ClientMockHealthResults contains results of the Client.Health
type ClientMockHealthResults struct {
	b1 bool
}

// ClientMockHealthOrigins contains origins of expectations of the Client.Health
type ClientMockHealthExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHealth *mClientMockHealth) Optional() *mClientMockHealth {
	mmHealth.optional = true
	return mmHealth
}

// Expect sets up expected params for Client.Health
func (mmHealth *mClientMockHealth) Expect(ctx context.Context) *mClientMockHealth {
	if mmHealth.mock.funcHealth != nil {
		mmHealth.mock.t.Fatalf("ClientMock.Health mock is already set by Set")
	}

	if mmHealth.defaultExpectation == nil {
		mmHealth.defaultExpectation = &ClientMockHealthExpectation{}
	}

	if mmHealth.defaultExpectation.paramPtrs != nil {
		mmHealth.mock.t.Fatalf("ClientMock.Health mock is already set by ExpectParams functions")
	}

	mmHealth.defaultExpectation.params = &ClientMockHealthParams{ctx}
	mmHealth.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHealth.expectations {
		if minimock.Equal(e.params, mmHealth.defaultExpectation.params) {
			mmHealth.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHealth.defaultExpectation.params)
		}
	}

	return mmHealth
}

// ExpectCtxParam1 sets up expected param ctx for Client.Health
func (mmHealth *mClientMockHealth) ExpectCtxParam1(ctx context.Context) *mClientMockHealth {
	if mmHealth.mock.funcHealth != nil {
		mmHealth.mock.t.Fatalf("ClientMock.Health mock is already set by Set")
	}

	if mmHealth.defaultExpectation == nil {
		mmHealth.defaultExpectation = &ClientMockHealthExpectation{}
	}

	if mmHealth.defaultExpectation.params != nil {
		mmHealth.mock.t.Fatalf("ClientMock.Health mock is already set by Expect")
	}

	if mmHealth.defaultExpectation.paramPtrs == nil {
		mmHealth.defaultExpectation.paramPtrs = &ClientMockHealthParamPtrs{}
	}
	mmHealth.defaultExpectation.paramPtrs.ctx = &ctx
	mmHealth.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHealth
}

// Inspect accepts an inspector function that has same arguments as the Client.Health
func (mmHealth *mClientMockHealth) Inspect(f func(ctx context.Context)) *mClientMockHealth {
	if mmHealth.mock.inspectFuncHealth != nil {
		mmHealth.mock.t.Fatalf("Inspect function is already set for ClientMock.Health")
	}

	mmHealth.mock.inspectFuncHealth = f

	return mmHealth
}

// Return sets up results that will be returned by Client.Health
func (mmHealth *mClientMockHealth) Return(b1 bool) *ClientMock {
	if mmHealth.mock.funcHealth != nil {
		mmHealth.mock.t.Fatalf("ClientMock.Health mock is already set by Set")
	}

	if mmHealth.defaultExpectation == nil {
		mmHealth.defaultExpectation = &ClientMockHealthExpectation{mock: mmHealth.mock}
	}
	mmHealth.defaultExpectation.results = &ClientMockHealthResults{b1}
	mmHealth.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHealth.mock
}

// Set uses given function f to mock the Client.Health method
func (mmHealth *mClientMockHealth) Set(f func(ctx context.Context) (b1 bool)) *ClientMock {
	if mmHealth.defaultExpectation != nil {
		mmHealth.mock.t.Fatalf("Default expectation is already set for the Client.Health method")
	}

	if len(mmHealth.expectations) > 0 {
		mmHealth.mock.t.Fatalf("Some expectations are already set for the Client.Health method")
	}

	mmHealth.mock.funcHealth = f
	mmHealth.mock.funcHealthOrigin = minimock.CallerInfo(1)
	return mmHealth.mock
}

// When sets expectation for the Client.Health which will trigger the result defined by the following
// Then helper
func (mmHealth *mClientMockHealth) When(ctx context.Context) *ClientMockHealthExpectation {
	if mmHealth.mock.funcHealth != nil {
		mmHealth.mock.t.Fatalf("ClientMock.Health mock is already set by Set")
	}

	expectation := &ClientMockHealthExpectation{
		mock:               mmHealth.mock,
		params:             &ClientMockHealthParams{ctx},
		expectationOrigins: ClientMockHealthExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHealth.expectations = append(mmHealth.expectations, expectation)
	return expectation
}

// Then sets up Client.Health return parameters for the expectation previously defined by the When method
func (e *ClientMockHealthExpectation) Then(b1 bool) *ClientMock {
	e.results = &ClientMockHealthResults{b1}
	return e.mock
}

// Times sets number of times Client.Health should be invoked
func (mmHealth *mClientMockHealth) Times(n uint64) *mClientMockHealth {
	if n == 0 {
		mmHealth.mock.t.Fatalf("Times of ClientMock.Health mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHealth.expectedInvocations, n)
	mmHealth.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHealth
}

func (mmHealth *mClientMockHealth) invocationsDone() bool {
	if len(mmHealth.expectations) == 0 && mmHealth.defaultExpectation == nil && mmHealth.mock.funcHealth == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHealth.mock.afterHealthCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHealth.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Health implements Client
func (mmHealth *ClientMock) Health(ctx context.Context) (b1 bool) {
	mm_atomic.AddUint64(&mmHealth.beforeHealthCounter, 1)
	defer mm_atomic.AddUint64(&mmHealth.afterHealthCounter, 1)

	mmHealth.t.Helper()

	if mmHealth.inspectFuncHealth != nil {
		mmHealth.inspectFuncHealth(ctx)
	}

	mm_params := ClientMockHealthParams{ctx}

	// Record call args
	mmHealth.HealthMock.mutex.Lock()
	mmHealth.HealthMock.callArgs = append(mmHealth.HealthMock.callArgs, &mm_params)
	mmHealth.HealthMock.mutex.Unlock()

	for _, e := range mmHealth.HealthMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmHealth.HealthMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHealth.HealthMock.defaultExpectation.Counter, 1)
		mm_want := mmHealth.HealthMock.defaultExpectation.params
		mm_want_ptrs := mmHealth.HealthMock.defaultExpectation.paramPtrs

		mm_got := ClientMockHealthParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHealth.t.Errorf("ClientMock.Health got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHealth.HealthMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHealth.t.Errorf("ClientMock.Health got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHealth.HealthMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHealth.HealthMock.defaultExpectation.results
		if mm_results == nil {
			mmHealth.t.Fatal("No results are set for the ClientMock.Health")
		}
		return (*mm_results).b1
	}
	if mmHealth.funcHealth != nil {
		return mmHealth.funcHealth(ctx)
	}
	mmHealth.t.Fatalf("Unexpected call to ClientMock.Health. %v", ctx)
	return
}

// HealthAfterCounter returns a count of finished ClientMock.Health invocations
func (mmHealth *ClientMock) HealthAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHealth.afterHealthCounter)
}

// HealthBeforeCounter returns a count of ClientMock.Health invocations
func (mmHealth *ClientMock) HealthBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHealth.beforeHealthCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Health.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHealth *mClientMockHealth) Calls() []*ClientMockHealthParams {
	mmHealth.mutex.RLock()

	argCopy := make([]*ClientMockHealthParams, len(mmHealth.callArgs))
	copy(argCopy, mmHealth.callArgs)

	mmHealth.mutex.RUnlock()

	return argCopy
}

// MinimockHealthDone returns true if the count of the Health invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockHealthDone() bool {
	if m.HealthMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HealthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HealthMock.invocationsDone()
}

// MinimockHealthInspect logs each unmet expectation
func (m *ClientMock) MinimockHealthInspect() {
	for _, e := range m.HealthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Health at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHealthCounter := mm_atomic.LoadUint64(&m.afterHealthCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HealthMock.defaultExpectation != nil && afterHealthCounter < 1 {
		if m.HealthMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Health at\n%s", m.HealthMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Health at\n%s with params: %#v", m.HealthMock.defaultExpectation.expectationOrigins.origin, *m.HealthMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHealth != nil && afterHealthCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Health at\n%s", m.funcHealthOrigin)
	}

	if !m.HealthMock.invocationsDone() && afterHealthCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Health at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HealthMock.expectedInvocations), m.HealthMock.expectedInvocationsOrigin, afterHealthCounter)
	}
}

type mClientMockRefreshTrigger struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockRefreshTriggerExpectation
	expectations       []*ClientMockRefreshTriggerExpectation

	callArgs []*ClientMockRefreshTriggerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockRefreshTriggerExpectation specifies expectation struct of the Client.RefreshTrigger
type ClientMockRefreshTriggerExpectation struct {
	mock               *ClientMock
	params             *ClientMockRefreshTriggerParams
	paramPtrs          *ClientMockRefreshTriggerParamPtrs
	expectationOrigins ClientMockRefreshTriggerExpectationOrigins
	results            *ClientMockRefreshTriggerResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockRefreshTriggerParams contains parameters of the Client.RefreshTrigger
type ClientMockRefreshTriggerParams struct {
	ctx   context.Context
	title trigger.Title
}

// ClientMockRefreshTriggerParamPtrs contains pointers to parameters of the Client.RefreshTrigger
type ClientMockRefreshTriggerParamPtrs struct {
	ctx   *context.Context
	title *trigger.Title
}

// ClientMockRefreshTriggerResults contains results of the Client.RefreshTrigger
type ClientMockRefreshTriggerResults struct {
	err error
}

// ClientMockRefreshTriggerOrigins contains origins of expectations of the Client.RefreshTrigger
type ClientMockRefreshTriggerExpectationOrigins struct {
	origin      string
	originCtx   string
	originTitle string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRefreshTrigger *mClientMockRefreshTrigger) Optional() *mClientMockRefreshTrigger {
	mmRefreshTrigger.optional = true
	return mmRefreshTrigger
}

// Expect sets up expected params for Client.RefreshTrigger
func (mmRefreshTrigger *mClientMockRefreshTrigger) Expect(ctx context.Context, title trigger.Title) *mClientMockRefreshTrigger {
	if mmRefreshTrigger.mock.funcRefreshTrigger != nil {
		mmRefreshTrigger.mock.t.Fatalf("ClientMock.RefreshTrigger mock is already set by Set")
	}

	if mmRefreshTrigger.defaultExpectation == nil {
		mmRefreshTrigger.defaultExpectation = &ClientMockRefreshTriggerExpectation{}
	}

	if mmRefreshTrigger.defaultExpectation.paramPtrs != nil {
		mmRefreshTrigger.mock.t.Fatalf("ClientMock.RefreshTrigger mock is already set by ExpectParams functions")
	}

	mmRefreshTrigger.defaultExpectation.params = &ClientMockRefreshTriggerParams{ctx, title}
	mmRefreshTrigger.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRefreshTrigger.expectations {
		if minimock.Equal(e.params, mmRefreshTrigger.defaultExpectation.params) {
			mmRefreshTrigger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRefreshTrigger.defaultExpectation.params)
		}
	}

	return mmRefreshTrigger
}

// ExpectCtxParam1 sets up expected param ctx for Client.RefreshTrigger
func (mmRefreshTrigger *mClientMockRefreshTrigger) ExpectCtxParam1(ctx context.Context) *mClientMockRefreshTrigger {
	if mmRefreshTrigger.mock.funcRefreshTrigger != nil {
		mmRefreshTrigger.mock.t.Fatalf("ClientMock.RefreshTrigger mock is already set by Set")
	}

	if mmRefreshTrigger.defaultExpectation == nil {
		mmRefreshTrigger.defaultExpectation = &ClientMockRefreshTriggerExpectation{}
	}

	if mmRefreshTrigger.defaultExpectation.params != nil {
		mmRefreshTrigger.mock.t.Fatalf("ClientMock.RefreshTrigger mock is already set by Expect")
	}

	if mmRefreshTrigger.defaultExpectation.paramPtrs == nil {
		mmRefreshTrigger.defaultExpectation.paramPtrs = &ClientMockRefreshTriggerParamPtrs{}
	}
	mmRefreshTrigger.defaultExpectation.paramPtrs.ctx = &ctx
	mmRefreshTrigger.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRefreshTrigger
}

// ExpectTitleParam2 sets up expected param title for Client.RefreshTrigger
func (mmRefreshTrigger *mClientMockRefreshTrigger) ExpectTitleParam2(title trigger.Title) *mClientMockRefreshTrigger {
	if mmRefreshTrigger.mock.funcRefreshTrigger != nil {
		mmRefreshTrigger.mock.t.Fatalf("ClientMock.RefreshTrigger mock is already set by Set")
	}

	if mmRefreshTrigger.defaultExpectation == nil {
		mmRefreshTrigger.defaultExpectation = &ClientMockRefreshTriggerExpectation{}
	}

	if mmRefreshTrigger.defaultExpectation.params != nil {
		mmRefreshTrigger.mock.t.Fatalf("ClientMock.RefreshTrigger mock is already set by Expect")
	}

	if mmRefreshTrigger.defaultExpectation.paramPtrs == nil {
		mmRefreshTrigger.defaultExpectation.paramPtrs = &ClientMockRefreshTriggerParamPtrs{}
	}
	mmRefreshTrigger.defaultExpectation.paramPtrs.title = &title
	mmRefreshTrigger.defaultExpectation.expectationOrigins.originTitle = minimock.CallerInfo(1)

	return mmRefreshTrigger
}

// Inspect accepts an inspector function that has same arguments as the Client.RefreshTrigger
func (mmRefreshTrigger *mClientMockRefreshTrigger) Inspect(f func(ctx context.Context, title trigger.Title)) *mClientMockRefreshTrigger {
	if mmRefreshTrigger.mock.inspectFuncRefreshTrigger != nil {
		mmRefreshTrigger.mock.t.Fatalf("Inspect function is already set for ClientMock.RefreshTrigger")
	}

	mmRefreshTrigger.mock.inspectFuncRefreshTrigger = f

	return mmRefreshTrigger
}

// Return sets up results that will be returned by Client.RefreshTrigger
func (mmRefreshTrigger *mClientMockRefreshTrigger) Return(err error) *ClientMock {
	if mmRefreshTrigger.mock.funcRefreshTrigger != nil {
		mmRefreshTrigger.mock.t.Fatalf("ClientMock.RefreshTrigger mock is already set by Set")
	}

	if mmRefreshTrigger.defaultExpectation == nil {
		mmRefreshTrigger.defaultExpectation = &ClientMockRefreshTriggerExpectation{mock: mmRefreshTrigger.mock}
	}
	mmRefreshTrigger.defaultExpectation.results = &ClientMockRefreshTriggerResults{err}
	mmRefreshTrigger.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRefreshTrigger.mock
}

// Set uses given function f to mock the Client.RefreshTrigger method
func (mmRefreshTrigger *mClientMockRefreshTrigger) Set(f func(ctx context.Context, title trigger.Title) (err error)) *ClientMock {
	if mmRefreshTrigger.defaultExpectation != nil {
		mmRefreshTrigger.mock.t.Fatalf("Default expectation is already set for the Client.RefreshTrigger method")
	}

	if len(mmRefreshTrigger.expectations) > 0 {
		mmRefreshTrigger.mock.t.Fatalf("Some expectations are already set for the Client.RefreshTrigger method")
	}

	mmRefreshTrigger.mock.funcRefreshTrigger = f
	mmRefreshTrigger.mock.funcRefreshTriggerOrigin = minimock.CallerInfo(1)
	return mmRefreshTrigger.mock
}

// When sets expectation for the Client.RefreshTrigger which will trigger the result defined by the following
// Then helper
func (mmRefreshTrigger *mClientMockRefreshTrigger) When(ctx context.Context, title trigger.Title) *ClientMockRefreshTriggerExpectation {
	if mmRefreshTrigger.mock.funcRefreshTrigger != nil {
		mmRefreshTrigger.mock.t.Fatalf("ClientMock.RefreshTrigger mock is already set by Set")
	}

	expectation := &ClientMockRefreshTriggerExpectation{
		mock:               mmRefreshTrigger.mock,
		params:             &ClientMockRefreshTriggerParams{ctx, title},
		expectationOrigins: ClientMockRefreshTriggerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRefreshTrigger.expectations = append(mmRefreshTrigger.expectations, expectation)
	return expectation
}

// Then sets up Client.RefreshTrigger return parameters for the expectation previously defined by the When method
func (e *ClientMockRefreshTriggerExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockRefreshTriggerResults{err}
	return e.mock
}

// Times sets number of times Client.RefreshTrigger should be invoked
func (mmRefreshTrigger *mClientMockRefreshTrigger) Times(n uint64) *mClientMockRefreshTrigger {
	if n == 0 {
		mmRefreshTrigger.mock.t.Fatalf("Times of ClientMock.RefreshTrigger mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRefreshTrigger.expectedInvocations, n)
	mmRefreshTrigger.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRefreshTrigger
}

func (mmRefreshTrigger *mClientMockRefreshTrigger) invocationsDone() bool {
	if len(mmRefreshTrigger.expectations) == 0 && mmRefreshTrigger.defaultExpectation == nil && mmRefreshTrigger.mock.funcRefreshTrigger == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRefreshTrigger.mock.afterRefreshTriggerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRefreshTrigger.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RefreshTrigger implements Client
func (mmRefreshTrigger *ClientMock) RefreshTrigger(ctx context.Context, title trigger.Title) (err error) {
	mm_atomic.AddUint64(&mmRefreshTrigger.beforeRefreshTriggerCounter, 1)
	defer mm_atomic.AddUint64(&mmRefreshTrigger.afterRefreshTriggerCounter, 1)

	mmRefreshTrigger.t.Helper()

	if mmRefreshTrigger.inspectFuncRefreshTrigger != nil {
		mmRefreshTrigger.inspectFuncRefreshTrigger(ctx, title)
	}

	mm_params := ClientMockRefreshTriggerParams{ctx, title}

	// Record call args
	mmRefreshTrigger.RefreshTriggerMock.mutex.Lock()
	mmRefreshTrigger.RefreshTriggerMock.callArgs = append(mmRefreshTrigger.RefreshTriggerMock.callArgs, &mm_params)
	mmRefreshTrigger.RefreshTriggerMock.mutex.Unlock()

	for _, e := range mmRefreshTrigger.RefreshTriggerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRefreshTrigger.RefreshTriggerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRefreshTrigger.RefreshTriggerMock.defaultExpectation.Counter, 1)
		mm_want := mmRefreshTrigger.RefreshTriggerMock.defaultExpectation.params
		mm_want_ptrs := mmRefreshTrigger.RefreshTriggerMock.defaultExpectation.paramPtrs

		mm_got := ClientMockRefreshTriggerParams{ctx, title}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRefreshTrigger.t.Errorf("ClientMock.RefreshTrigger got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefreshTrigger.RefreshTriggerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.title != nil && !minimock.Equal(*mm_want_ptrs.title, mm_got.title) {
				mmRefreshTrigger.t.Errorf("ClientMock.RefreshTrigger got unexpected parameter title, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefreshTrigger.RefreshTriggerMock.defaultExpectation.expectationOrigins.originTitle, *mm_want_ptrs.title, mm_got.title, minimock.Diff(*mm_want_ptrs.title, mm_got.title))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRefreshTrigger.t.Errorf("ClientMock.RefreshTrigger got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRefreshTrigger.RefreshTriggerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRefreshTrigger.RefreshTriggerMock.defaultExpectation.results
		if mm_results == nil {
			mmRefreshTrigger.t.Fatal("No results are set for the ClientMock.RefreshTrigger")
		}
		return (*mm_results).err
	}
	if mmRefreshTrigger.funcRefreshTrigger != nil {
		return mmRefreshTrigger.funcRefreshTrigger(ctx, title)
	}
	mmRefreshTrigger.t.Fatalf("Unexpected call to ClientMock.RefreshTrigger. %v %v", ctx, title)
	return
}

// RefreshTriggerAfterCounter returns a count of finished ClientMock.RefreshTrigger invocations
func (mmRefreshTrigger *ClientMock) RefreshTriggerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshTrigger.afterRefreshTriggerCounter)
}

// RefreshTriggerBeforeCounter returns a count of ClientMock.RefreshTrigger invocations
func (mmRefreshTrigger *ClientMock) RefreshTriggerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshTrigger.beforeRefreshTriggerCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RefreshTrigger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRefreshTrigger *mClientMockRefreshTrigger) Calls() []*ClientMockRefreshTriggerParams {
	mmRefreshTrigger.mutex.RLock()

	argCopy := make([]*ClientMockRefreshTriggerParams, len(mmRefreshTrigger.callArgs))
	copy(argCopy, mmRefreshTrigger.callArgs)

	mmRefreshTrigger.mutex.RUnlock()

	return argCopy
}

// MinimockRefreshTriggerDone returns true if the count of the RefreshTrigger invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRefreshTriggerDone() bool {
	if m.RefreshTriggerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RefreshTriggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RefreshTriggerMock.invocationsDone()
}

// MinimockRefreshTriggerInspect logs each unmet expectation
func (m *ClientMock) MinimockRefreshTriggerInspect() {
	for _, e := range m.RefreshTriggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RefreshTrigger at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRefreshTriggerCounter := mm_atomic.LoadUint64(&m.afterRefreshTriggerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RefreshTriggerMock.defaultExpectation != nil && afterRefreshTriggerCounter < 1 {
		if m.RefreshTriggerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.RefreshTrigger at\n%s", m.RefreshTriggerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.RefreshTrigger at\n%s with params: %#v", m.RefreshTriggerMock.defaultExpectation.expectationOrigins.origin, *m.RefreshTriggerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefreshTrigger != nil && afterRefreshTriggerCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.RefreshTrigger at\n%s", m.funcRefreshTriggerOrigin)
	}

	if !m.RefreshTriggerMock.invocationsDone() && afterRefreshTriggerCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.RefreshTrigger at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RefreshTriggerMock.expectedInvocations), m.RefreshTriggerMock.expectedInvocationsOrigin, afterRefreshTriggerCounter)
	}
}

type mClientMockTriggerAction struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockTriggerActionExpectation
	expectations       []*ClientMockTriggerActionExpectation

	callArgs []*ClientMockTriggerActionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockTriggerActionExpectation specifies expectation struct of the Client.TriggerAction
type ClientMockTriggerActionExpectation struct {
	mock               *ClientMock
	params             *ClientMockTriggerActionParams
	paramPtrs          *ClientMockTriggerActionParamPtrs
	expectationOrigins ClientMockTriggerActionExpectationOrigins
	results            *ClientMockTriggerActionResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockTriggerActionParams contains parameters of the Client.TriggerAction
type ClientMockTriggerActionParams struct {
	ctx    context.Context
	action trigger.Trigger
}

// ClientMockTriggerActionParamPtrs contains pointers to parameters of the Client.TriggerAction
type ClientMockTriggerActionParamPtrs struct {
	ctx    *context.Context
	action *trigger.Trigger
}

// ClientMockTriggerActionResults contains results of the Client.TriggerAction
type ClientMockTriggerActionResults struct {
	err error
}

// ClientMockTriggerActionOrigins contains origins of expectations of the Client.TriggerAction
type ClientMockTriggerActionExpectationOrigins struct {
	origin       string
	originCtx    string
	originAction string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerAction *mClientMockTriggerAction) Optional() *mClientMockTriggerAction {
	mmTriggerAction.optional = true
	return mmTriggerAction
}

// Expect sets up expected params for Client.TriggerAction
func (mmTriggerAction *mClientMockTriggerAction) Expect(ctx context.Context, action trigger.Trigger) *mClientMockTriggerAction {
	if mmTriggerAction.mock.funcTriggerAction != nil {
		mmTriggerAction.mock.t.Fatalf("ClientMock.TriggerAction mock is already set by Set")
	}

	if mmTriggerAction.defaultExpectation == nil {
		mmTriggerAction.defaultExpectation = &ClientMockTriggerActionExpectation{}
	}

	if mmTriggerAction.defaultExpectation.paramPtrs != nil {
		mmTriggerAction.mock.t.Fatalf("ClientMock.TriggerAction mock is already set by ExpectParams functions")
	}

	mmTriggerAction.defaultExpectation.params = &ClientMockTriggerActionParams{ctx, action}
	mmTriggerAction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerAction.expectations {
		if minimock.Equal(e.params, mmTriggerAction.defaultExpectation.params) {
			mmTriggerAction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerAction.defaultExpectation.params)
		}
	}

	return mmTriggerAction
}

// ExpectCtxParam1 sets up expected param ctx for Client.TriggerAction
func (mmTriggerAction *mClientMockTriggerAction) ExpectCtxParam1(ctx context.Context) *mClientMockTriggerAction {
	if mmTriggerAction.mock.funcTriggerAction != nil {
		mmTriggerAction.mock.t.Fatalf("ClientMock.TriggerAction mock is already set by Set")
	}

	if mmTriggerAction.defaultExpectation == nil {
		mmTriggerAction.defaultExpectation = &ClientMockTriggerActionExpectation{}
	}

	if mmTriggerAction.defaultExpectation.params != nil {
		mmTriggerAction.mock.t.Fatalf("ClientMock.TriggerAction mock is already set by Expect")
	}

	if mmTriggerAction.defaultExpectation.paramPtrs == nil {
		mmTriggerAction.defaultExpectation.paramPtrs = &ClientMockTriggerActionParamPtrs{}
	}
	mmTriggerAction.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerAction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerAction
}

// ExpectActionParam2 sets up expected param action for Client.TriggerAction
func (mmTriggerAction *mClientMockTriggerAction) ExpectActionParam2(action trigger.Trigger) *mClientMockTriggerAction {
	if mmTriggerAction.mock.funcTriggerAction != nil {
		mmTriggerAction.mock.t.Fatalf("ClientMock.TriggerAction mock is already set by Set")
	}

	if mmTriggerAction.defaultExpectation == nil {
		mmTriggerAction.defaultExpectation = &ClientMockTriggerActionExpectation{}
	}

	if mmTriggerAction.defaultExpectation.params != nil {
		mmTriggerAction.mock.t.Fatalf("ClientMock.TriggerAction mock is already set by Expect")
	}

	if mmTriggerAction.defaultExpectation.paramPtrs == nil {
		mmTriggerAction.defaultExpectation.paramPtrs = &ClientMockTriggerActionParamPtrs{}
	}
	mmTriggerAction.defaultExpectation.paramPtrs.action = &action
	mmTriggerAction.defaultExpectation.expectationOrigins.originAction = minimock.CallerInfo(1)

	return mmTriggerAction
}

// Inspect accepts an inspector function that has same arguments as the Client.TriggerAction
func (mmTriggerAction *mClientMockTriggerAction) Inspect(f func(ctx context.Context, action trigger.Trigger)) *mClientMockTriggerAction {
	if mmTriggerAction.mock.inspectFuncTriggerAction != nil {
		mmTriggerAction.mock.t.Fatalf("Inspect function is already set for ClientMock.TriggerAction")
	}

	mmTriggerAction.mock.inspectFuncTriggerAction = f

	return mmTriggerAction
}

// Return sets up results that will be returned by Client.TriggerAction
func (mmTriggerAction *mClientMockTriggerAction) Return(err error) *ClientMock {
	if mmTriggerAction.mock.funcTriggerAction != nil {
		mmTriggerAction.mock.t.Fatalf("ClientMock.TriggerAction mock is already set by Set")
	}

	if mmTriggerAction.defaultExpectation == nil {
		mmTriggerAction.defaultExpectation = &ClientMockTriggerActionExpectation{mock: mmTriggerAction.mock}
	}
	mmTriggerAction.defaultExpectation.results = &ClientMockTriggerActionResults{err}
	mmTriggerAction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerAction.mock
}

// Set uses given function f to mock the Client.TriggerAction method
func (mmTriggerAction *mClientMockTriggerAction) Set(f func(ctx context.Context, action trigger.Trigger) (err error)) *ClientMock {
	if mmTriggerAction.defaultExpectation != nil {
		mmTriggerAction.mock.t.Fatalf("Default expectation is already set for the Client.TriggerAction method")
	}

	if len(mmTriggerAction.expectations) > 0 {
		mmTriggerAction.mock.t.Fatalf("Some expectations are already set for the Client.TriggerAction method")
	}

	mmTriggerAction.mock.funcTriggerAction = f
	mmTriggerAction.mock.funcTriggerActionOrigin = minimock.CallerInfo(1)
	return mmTriggerAction.mock
}

// When sets expectation for the Client.TriggerAction which will trigger the result defined by the following
// Then helper
func (mmTriggerAction *mClientMockTriggerAction) When(ctx context.Context, action trigger.Trigger) *ClientMockTriggerActionExpectation {
	if mmTriggerAction.mock.funcTriggerAction != nil {
		mmTriggerAction.mock.t.Fatalf("ClientMock.TriggerAction mock is already set by Set")
	}

	expectation := &ClientMockTriggerActionExpectation{
		mock:               mmTriggerAction.mock,
		params:             &ClientMockTriggerActionParams{ctx, action},
		expectationOrigins: ClientMockTriggerActionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerAction.expectations = append(mmTriggerAction.expectations, expectation)
	return expectation
}

// Then sets up Client.TriggerAction return parameters for the expectation previously defined by the When method
func (e *ClientMockTriggerActionExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockTriggerActionResults{err}
	return e.mock
}

// Times sets number of times Client.TriggerAction should be invoked
func (mmTriggerAction *mClientMockTriggerAction) Times(n uint64) *mClientMockTriggerAction {
	if n == 0 {
		mmTriggerAction.mock.t.Fatalf("Times of ClientMock.TriggerAction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerAction.expectedInvocations, n)
	mmTriggerAction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerAction
}

func (mmTriggerAction *mClientMockTriggerAction) invocationsDone() bool {
	if len(mmTriggerAction.expectations) == 0 && mmTriggerAction.defaultExpectation == nil && mmTriggerAction.mock.funcTriggerAction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerAction.mock.afterTriggerActionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerAction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerAction implements Client
func (mmTriggerAction *ClientMock) TriggerAction(ctx context.Context, action trigger.Trigger) (err error) {
	mm_atomic.AddUint64(&mmTriggerAction.beforeTriggerActionCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerAction.afterTriggerActionCounter, 1)

	mmTriggerAction.t.Helper()

	if mmTriggerAction.inspectFuncTriggerAction != nil {
		mmTriggerAction.inspectFuncTriggerAction(ctx, action)
	}

	mm_params := ClientMockTriggerActionParams{ctx, action}

	// Record call args
	mmTriggerAction.TriggerActionMock.mutex.Lock()
	mmTriggerAction.TriggerActionMock.callArgs = append(mmTriggerAction.TriggerActionMock.callArgs, &mm_params)
	mmTriggerAction.TriggerActionMock.mutex.Unlock()

	for _, e := range mmTriggerAction.TriggerActionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTriggerAction.TriggerActionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerAction.TriggerActionMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerAction.TriggerActionMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerAction.TriggerActionMock.defaultExpectation.paramPtrs

		mm_got := ClientMockTriggerActionParams{ctx, action}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerAction.t.Errorf("ClientMock.TriggerAction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAction.TriggerActionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.action != nil && !minimock.Equal(*mm_want_ptrs.action, mm_got.action) {
				mmTriggerAction.t.Errorf("ClientMock.TriggerAction got unexpected parameter action, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAction.TriggerActionMock.defaultExpectation.expectationOrigins.originAction, *mm_want_ptrs.action, mm_got.action, minimock.Diff(*mm_want_ptrs.action, mm_got.action))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerAction.t.Errorf("ClientMock.TriggerAction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerAction.TriggerActionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerAction.TriggerActionMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerAction.t.Fatal("No results are set for the ClientMock.TriggerAction")
		}
		return (*mm_results).err
	}
	if mmTriggerAction.funcTriggerAction != nil {
		return mmTriggerAction.funcTriggerAction(ctx, action)
	}
	mmTriggerAction.t.Fatalf("Unexpected call to ClientMock.TriggerAction. %v %v", ctx, action)
	return
}

// TriggerActionAfterCounter returns a count of finished ClientMock.TriggerAction invocations
func (mmTriggerAction *ClientMock) TriggerActionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAction.afterTriggerActionCounter)
}

// TriggerActionBeforeCounter returns a count of ClientMock.TriggerAction invocations
func (mmTriggerAction *ClientMock) TriggerActionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAction.beforeTriggerActionCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.TriggerAction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerAction *mClientMockTriggerAction) Calls() []*ClientMockTriggerActionParams {
	mmTriggerAction.mutex.RLock()

	argCopy := make([]*ClientMockTriggerActionParams, len(mmTriggerAction.callArgs))
	copy(argCopy, mmTriggerAction.callArgs)

	mmTriggerAction.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerActionDone returns true if the count of the TriggerAction invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockTriggerActionDone() bool {
	if m.TriggerActionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerActionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerActionMock.invocationsDone()
}

// MinimockTriggerActionInspect logs each unmet expectation
func (m *ClientMock) MinimockTriggerActionInspect() {
	for _, e := range m.TriggerActionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.TriggerAction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerActionCounter := mm_atomic.LoadUint64(&m.afterTriggerActionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerActionMock.defaultExpectation != nil && afterTriggerActionCounter < 1 {
		if m.TriggerActionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.TriggerAction at\n%s", m.TriggerActionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.TriggerAction at\n%s with params: %#v", m.TriggerActionMock.defaultExpectation.expectationOrigins.origin, *m.TriggerActionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerAction != nil && afterTriggerActionCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.TriggerAction at\n%s", m.funcTriggerActionOrigin)
	}

	if !m.TriggerActionMock.invocationsDone() && afterTriggerActionCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.TriggerAction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerActionMock.expectedInvocations), m.TriggerActionMock.expectedInvocationsOrigin, afterTriggerActionCounter)
	}
}

type mClientMockUpdateTrigger struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateTriggerExpectation
	expectations       []*ClientMockUpdateTriggerExpectation

	callArgs []*ClientMockUpdateTriggerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUpdateTriggerExpectation specifies expectation struct of the Client.UpdateTrigger
type ClientMockUpdateTriggerExpectation struct {
	mock               *ClientMock
	params             *ClientMockUpdateTriggerParams
	paramPtrs          *ClientMockUpdateTriggerParamPtrs
	expectationOrigins ClientMockUpdateTriggerExpectationOrigins
	results            *ClientMockUpdateTriggerResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUpdateTriggerParams contains parameters of the Client.UpdateTrigger
type ClientMockUpdateTriggerParams struct {
	ctx   context.Context
	title trigger.Title
	patch trigger.Trigger
}

// ClientMockUpdateTriggerParamPtrs contains pointers to parameters of the Client.UpdateTrigger
type ClientMockUpdateTriggerParamPtrs struct {
	ctx   *context.Context
	title *trigger.Title
	patch *trigger.Trigger
}

// ClientMockUpdateTriggerResults contains results of the Client.UpdateTrigger
type ClientMockUpdateTriggerResults struct {
	err error
}

// ClientMockUpdateTriggerOrigins contains origins of expectations of the Client.UpdateTrigger
type ClientMockUpdateTriggerExpectationOrigins struct {
	origin      string
	originCtx   string
	originTitle string
	originPatch string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateTrigger *mClientMockUpdateTrigger) Optional() *mClientMockUpdateTrigger {
	mmUpdateTrigger.optional = true
	return mmUpdateTrigger
}

// Expect sets up expected params for Client.UpdateTrigger
func (mmUpdateTrigger *mClientMockUpdateTrigger) Expect(ctx context.Context, title trigger.Title, patch trigger.Trigger) *mClientMockUpdateTrigger {
	if mmUpdateTrigger.mock.funcUpdateTrigger != nil {
		mmUpdateTrigger.mock.t.Fatalf("ClientMock.UpdateTrigger mock is already set by Set")
	}

	if mmUpdateTrigger.defaultExpectation == nil {
		mmUpdateTrigger.defaultExpectation = &ClientMockUpdateTriggerExpectation{}
	}

	if mmUpdateTrigger.defaultExpectation.paramPtrs != nil {
		mmUpdateTrigger.mock.t.Fatalf("ClientMock.UpdateTrigger mock is already set by ExpectParams functions")
	}

	mmUpdateTrigger.defaultExpectation.params = &ClientMockUpdateTriggerParams{ctx, title, patch}
	mmUpdateTrigger.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateTrigger.expectations {
		if minimock.Equal(e.params, mmUpdateTrigger.defaultExpectation.params) {
			mmUpdateTrigger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateTrigger.defaultExpectation.params)
		}
	}

	return mmUpdateTrigger
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateTrigger
func (mmUpdateTrigger *mClientMockUpdateTrigger) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateTrigger {
	if mmUpdateTrigger.mock.funcUpdateTrigger != nil {
		mmUpdateTrigger.mock.t.Fatalf("ClientMock.UpdateTrigger mock is already set by Set")
	}

	if mmUpdateTrigger.defaultExpectation == nil {
		mmUpdateTrigger.defaultExpectation = &ClientMockUpdateTriggerExpectation{}
	}

	if mmUpdateTrigger.defaultExpectation.params != nil {
		mmUpdateTrigger.mock.t.Fatalf("ClientMock.UpdateTrigger mock is already set by Expect")
	}

	if mmUpdateTrigger.defaultExpectation.paramPtrs == nil {
		mmUpdateTrigger.defaultExpectation.paramPtrs = &ClientMockUpdateTriggerParamPtrs{}
	}
	mmUpdateTrigger.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateTrigger.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateTrigger
}

// ExpectTitleParam2 sets up expected param title for Client.UpdateTrigger
func (mmUpdateTrigger *mClientMockUpdateTrigger) ExpectTitleParam2(title trigger.Title) *mClientMockUpdateTrigger {
	if mmUpdateTrigger.mock.funcUpdateTrigger != nil {
		mmUpdateTrigger.mock.t.Fatalf("ClientMock.UpdateTrigger mock is already set by Set")
	}

	if mmUpdateTrigger.defaultExpectation == nil {
		mmUpdateTrigger.defaultExpectation = &ClientMockUpdateTriggerExpectation{}
	}

	if mmUpdateTrigger.defaultExpectation.params != nil {
		mmUpdateTrigger.mock.t.Fatalf("ClientMock.UpdateTrigger mock is already set by Expect")
	}

	if mmUpdateTrigger.defaultExpectation.paramPtrs == nil {
		mmUpdateTrigger.defaultExpectation.paramPtrs = &ClientMockUpdateTriggerParamPtrs{}
	}
	mmUpdateTrigger.defaultExpectation.paramPtrs.title = &title
	mmUpdateTrigger.defaultExpectation.expectationOrigins.originTitle = minimock.CallerInfo(1)

	return mmUpdateTrigger
}

// ExpectPatchParam3 sets up expected param patch for Client.UpdateTrigger
func (mmUpdateTrigger *mClientMockUpdateTrigger) ExpectPatchParam3(patch trigger.Trigger) *mClientMockUpdateTrigger {
	if mmUpdateTrigger.mock.funcUpdateTrigger != nil {
		mmUpdateTrigger.mock.t.Fatalf("ClientMock.UpdateTrigger mock is already set by Set")
	}

	if mmUpdateTrigger.defaultExpectation == nil {
		mmUpdateTrigger.defaultExpectation = &ClientMockUpdateTriggerExpectation{}
	}

	if mmUpdateTrigger.defaultExpectation.params != nil {
		mmUpdateTrigger.mock.t.Fatalf("ClientMock.UpdateTrigger mock is already set by Expect")
	}

	if mmUpdateTrigger.defaultExpectation.paramPtrs == nil {
		mmUpdateTrigger.defaultExpectation.paramPtrs = &ClientMockUpdateTriggerParamPtrs{}
	}
	mmUpdateTrigger.defaultExpectation.paramPtrs.patch = &patch
	mmUpdateTrigger.defaultExpectation.expectationOrigins.originPatch = minimock.CallerInfo(1)

	return mmUpdateTrigger
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateTrigger
func (mmUpdateTrigger *mClientMockUpdateTrigger) Inspect(f func(ctx context.Context, title trigger.Title, patch trigger.Trigger)) *mClientMockUpdateTrigger {
	if mmUpdateTrigger.mock.inspectFuncUpdateTrigger != nil {
		mmUpdateTrigger.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateTrigger")
	}

	mmUpdateTrigger.mock.inspectFuncUpdateTrigger = f

	return mmUpdateTrigger
}

// Return sets up results that will be returned by Client.UpdateTrigger
func (mmUpdateTrigger *mClientMockUpdateTrigger) Return(err error) *ClientMock {
	if mmUpdateTrigger.mock.funcUpdateTrigger != nil {
		mmUpdateTrigger.mock.t.Fatalf("ClientMock.UpdateTrigger mock is already set by Set")
	}

	if mmUpdateTrigger.defaultExpectation == nil {
		mmUpdateTrigger.defaultExpectation = &ClientMockUpdateTriggerExpectation{mock: mmUpdateTrigger.mock}
	}
	mmUpdateTrigger.defaultExpectation.results = &ClientMockUpdateTriggerResults{err}
	mmUpdateTrigger.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateTrigger.mock
}

// Set uses given function f to mock the Client.UpdateTrigger method
func (mmUpdateTrigger *mClientMockUpdateTrigger) Set(f func(ctx context.Context, title trigger.Title, patch trigger.Trigger) (err error)) *ClientMock {
	if mmUpdateTrigger.defaultExpectation != nil {
		mmUpdateTrigger.mock.t.Fatalf("Default expectation is already set for the Client.UpdateTrigger method")
	}

	if len(mmUpdateTrigger.expectations) > 0 {
		mmUpdateTrigger.mock.t.Fatalf("Some expectations are already set for the Client.UpdateTrigger method")
	}

	mmUpdateTrigger.mock.funcUpdateTrigger = f
	mmUpdateTrigger.mock.funcUpdateTriggerOrigin = minimock.CallerInfo(1)
	return mmUpdateTrigger.mock
}

// When sets expectation for the Client.UpdateTrigger which will trigger the result defined by the following
// Then helper
func (mmUpdateTrigger *mClientMockUpdateTrigger) When(ctx context.Context, title trigger.Title, patch trigger.Trigger) *ClientMockUpdateTriggerExpectation {
	if mmUpdateTrigger.mock.funcUpdateTrigger != nil {
		mmUpdateTrigger.mock.t.Fatalf("ClientMock.UpdateTrigger mock is already set by Set")
	}

	expectation := &ClientMockUpdateTriggerExpectation{
		mock:               mmUpdateTrigger.mock,
		params:             &ClientMockUpdateTriggerParams{ctx, title, patch},
		expectationOrigins: ClientMockUpdateTriggerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateTrigger.expectations = append(mmUpdateTrigger.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateTrigger return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateTriggerExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockUpdateTriggerResults{err}
	return e.mock
}

// Times sets number of times Client.UpdateTrigger should be invoked
func (mmUpdateTrigger *mClientMockUpdateTrigger) Times(n uint64) *mClientMockUpdateTrigger {
	if n == 0 {
		mmUpdateTrigger.mock.t.Fatalf("Times of ClientMock.UpdateTrigger mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateTrigger.expectedInvocations, n)
	mmUpdateTrigger.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateTrigger
}

func (mmUpdateTrigger *mClientMockUpdateTrigger) invocationsDone() bool {
	if len(mmUpdateTrigger.expectations) == 0 && mmUpdateTrigger.defaultExpectation == nil && mmUpdateTrigger.mock.funcUpdateTrigger == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateTrigger.mock.afterUpdateTriggerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateTrigger.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateTrigger implements Client
func (mmUpdateTrigger *ClientMock) UpdateTrigger(ctx context.Context, title trigger.Title, patch trigger.Trigger) (err error) {
	mm_atomic.AddUint64(&mmUpdateTrigger.beforeUpdateTriggerCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateTrigger.afterUpdateTriggerCounter, 1)

	mmUpdateTrigger.t.Helper()

	if mmUpdateTrigger.inspectFuncUpdateTrigger != nil {
		mmUpdateTrigger.inspectFuncUpdateTrigger(ctx, title, patch)
	}

	mm_params := ClientMockUpdateTriggerParams{ctx, title, patch}

	// Record call args
	mmUpdateTrigger.UpdateTriggerMock.mutex.Lock()
	mmUpdateTrigger.UpdateTriggerMock.callArgs = append(mmUpdateTrigger.UpdateTriggerMock.callArgs, &mm_params)
	mmUpdateTrigger.UpdateTriggerMock.mutex.Unlock()

	for _, e := range mmUpdateTrigger.UpdateTriggerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateTrigger.UpdateTriggerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateTrigger.UpdateTriggerMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateTrigger.UpdateTriggerMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateTrigger.UpdateTriggerMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateTriggerParams{ctx, title, patch}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateTrigger.t.Errorf("ClientMock.UpdateTrigger got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTrigger.UpdateTriggerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.title != nil && !minimock.Equal(*mm_want_ptrs.title, mm_got.title) {
				mmUpdateTrigger.t.Errorf("ClientMock.UpdateTrigger got unexpected parameter title, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTrigger.UpdateTriggerMock.defaultExpectation.expectationOrigins.originTitle, *mm_want_ptrs.title, mm_got.title, minimock.Diff(*mm_want_ptrs.title, mm_got.title))
			}

			if mm_want_ptrs.patch != nil && !minimock.Equal(*mm_want_ptrs.patch, mm_got.patch) {
				mmUpdateTrigger.t.Errorf("ClientMock.UpdateTrigger got unexpected parameter patch, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTrigger.UpdateTriggerMock.defaultExpectation.expectationOrigins.originPatch, *mm_want_ptrs.patch, mm_got.patch, minimock.Diff(*mm_want_ptrs.patch, mm_got.patch))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateTrigger.t.Errorf("ClientMock.UpdateTrigger got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateTrigger.UpdateTriggerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateTrigger.UpdateTriggerMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateTrigger.t.Fatal("No results are set for the ClientMock.UpdateTrigger")
		}
		return (*mm_results).err
	}
	if mmUpdateTrigger.funcUpdateTrigger != nil {
		return mmUpdateTrigger.funcUpdateTrigger(ctx, title, patch)
	}
	mmUpdateTrigger.t.Fatalf("Unexpected call to ClientMock.UpdateTrigger. %v %v %v", ctx, title, patch)
	return
}

// UpdateTriggerAfterCounter returns a count of finished ClientMock.UpdateTrigger invocations
func (mmUpdateTrigger *ClientMock) UpdateTriggerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTrigger.afterUpdateTriggerCounter)
}

// UpdateTriggerBeforeCounter returns a count of ClientMock.UpdateTrigger invocations
func (mmUpdateTrigger *ClientMock) UpdateTriggerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTrigger.beforeUpdateTriggerCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateTrigger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateTrigger *mClientMockUpdateTrigger) Calls() []*ClientMockUpdateTriggerParams {
	mmUpdateTrigger.mutex.RLock()

	argCopy := make([]*ClientMockUpdateTriggerParams, len(mmUpdateTrigger.callArgs))
	copy(argCopy, mmUpdateTrigger.callArgs)

	mmUpdateTrigger.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateTriggerDone returns true if the count of the UpdateTrigger invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateTriggerDone() bool {
	if m.UpdateTriggerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateTriggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateTriggerMock.invocationsDone()
}

// MinimockUpdateTriggerInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateTriggerInspect() {
	for _, e := range m.UpdateTriggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateTrigger at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateTriggerCounter := mm_atomic.LoadUint64(&m.afterUpdateTriggerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateTriggerMock.defaultExpectation != nil && afterUpdateTriggerCounter < 1 {
		if m.UpdateTriggerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UpdateTrigger at\n%s", m.UpdateTriggerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateTrigger at\n%s with params: %#v", m.UpdateTriggerMock.defaultExpectation.expectationOrigins.origin, *m.UpdateTriggerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateTrigger != nil && afterUpdateTriggerCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UpdateTrigger at\n%s", m.funcUpdateTriggerOrigin)
	}

	if !m.UpdateTriggerMock.invocationsDone() && afterUpdateTriggerCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateTrigger at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateTriggerMock.expectedInvocations), m.UpdateTriggerMock.expectedInvocationsOrigin, afterUpdateTriggerCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddTriggerInspect()

			m.MinimockDeleteTriggersInspect()

			m.MinimockGetTriggerInspect()

			m.MinimockGetTriggersInspect()

			m.MinimockHealthInspect()

			m.MinimockRefreshTriggerInspect()

			m.MinimockTriggerActionInspect()

			m.MinimockUpdateTriggerInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddTriggerDone() &&
		m.MinimockDeleteTriggersDone() &&
		m.MinimockGetTriggerDone() &&
		m.MinimockGetTriggersDone() &&
		m.MinimockHealthDone() &&
		m.MinimockRefreshTriggerDone() &&
		m.MinimockTriggerActionDone() &&
		m.MinimockUpdateTriggerDone()
}
