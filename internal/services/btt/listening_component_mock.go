// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package btt

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ListeningComponentMock implements ListeningComponent
type ListeningComponentMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcIsRunning          func(ctx context.Context) (b1 bool, err error)
	funcIsRunningOrigin    string
	inspectFuncIsRunning   func(ctx context.Context)
	afterIsRunningCounter  uint64
	beforeIsRunningCounter uint64
	IsRunningMock          mListeningComponentMockIsRunning

	funcStartListening          func(ctx context.Context) (err error)
	funcStartListeningOrigin    string
	inspectFuncStartListening   func(ctx context.Context)
	afterStartListeningCounter  uint64
	beforeStartListeningCounter uint64
	StartListeningMock          mListeningComponentMockStartListening

	funcStopListening          func(ctx context.Context) (err error)
	funcStopListeningOrigin    string
	inspectFuncStopListening   func(ctx context.Context)
	afterStopListeningCounter  uint64
	beforeStopListeningCounter uint64
	StopListeningMock          mListeningComponentMockStopListening

	funcToggleListening          func(ctx context.Context) (err error)
	funcToggleListeningOrigin    string
	inspectFuncToggleListening   func(ctx context.Context)
	afterToggleListeningCounter  uint64
	beforeToggleListeningCounter uint64
	ToggleListeningMock          mListeningComponentMockToggleListening
}

// NewListeningComponentMock returns a mock for ListeningComponent
func NewListeningComponentMock(t minimock.Tester) *ListeningComponentMock {
	m := &ListeningComponentMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IsRunningMock = mListeningComponentMockIsRunning{mock: m}
	m.IsRunningMock.callArgs = []*ListeningComponentMockIsRunningParams{}

	m.StartListeningMock = mListeningComponentMockStartListening{mock: m}
	m.StartListeningMock.callArgs = []*ListeningComponentMockStartListeningParams{}

	m.StopListeningMock = mListeningComponentMockStopListening{mock: m}
	m.StopListeningMock.callArgs = []*ListeningComponentMockStopListeningParams{}

	m.ToggleListeningMock = mListeningComponentMockToggleListening{mock: m}
	m.ToggleListeningMock.callArgs = []*ListeningComponentMockToggleListeningParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mListeningComponentMockIsRunning struct {
	optional           bool
	mock               *ListeningComponentMock
	defaultExpectation *ListeningComponentMockIsRunningExpectation
	expectations       []*ListeningComponentMockIsRunningExpectation

	callArgs []*ListeningComponentMockIsRunningParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ListeningComponentMockIsRunningExpectation specifies expectation struct of the ListeningComponent.IsRunning
type ListeningComponentMockIsRunningExpectation struct {
	mock               *ListeningComponentMock
	params             *ListeningComponentMockIsRunningParams
	paramPtrs          *ListeningComponentMockIsRunningParamPtrs
	expectationOrigins ListeningComponentMockIsRunningExpectationOrigins
	results            *ListeningComponentMockIsRunningResults
	returnOrigin       string
	Counter            uint64
}

// ListeningComponentMockIsRunningParams contains parameters of the ListeningComponent.IsRunning
type ListeningComponentMockIsRunningParams struct {
	ctx context.Context
}

// ListeningComponentMockIsRunningParamPtrs contains pointers to parameters of the ListeningComponent.IsRunning
type ListeningComponentMockIsRunningParamPtrs struct {
	ctx *context.Context
}

// ListeningComponentMockIsRunningResults contains results of the ListeningComponent.IsRunning
type ListeningComponentMockIsRunningResults struct {
	b1  bool
	err error
}

// ListeningComponentMockIsRunningOrigins contains origins of expectations of the ListeningComponent.IsRunning
type ListeningComponentMockIsRunningExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsRunning *mListeningComponentMockIsRunning) Optional() *mListeningComponentMockIsRunning {
	mmIsRunning.optional = true
	return mmIsRunning
}

// Expect sets up expected params for ListeningComponent.IsRunning
func (mmIsRunning *mListeningComponentMockIsRunning) Expect(ctx context.Context) *mListeningComponentMockIsRunning {
	if mmIsRunning.mock.funcIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("ListeningComponentMock.IsRunning mock is already set by Set")
	}

	if mmIsRunning.defaultExpectation == nil {
		mmIsRunning.defaultExpectation = &ListeningComponentMockIsRunningExpectation{}
	}

	if mmIsRunning.defaultExpectation.paramPtrs != nil {
		mmIsRunning.mock.t.Fatalf("ListeningComponentMock.IsRunning mock is already set by ExpectParams functions")
	}

	mmIsRunning.defaultExpectation.params = &ListeningComponentMockIsRunningParams{ctx}
	mmIsRunning.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsRunning.expectations {
		if minimock.Equal(e.params, mmIsRunning.defaultExpectation.params) {
			mmIsRunning.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsRunning.defaultExpectation.params)
		}
	}

	return mmIsRunning
}

// ExpectCtxParam1 sets up expected param ctx for ListeningComponent.IsRunning
func (mmIsRunning *mListeningComponentMockIsRunning) ExpectCtxParam1(ctx context.Context) *mListeningComponentMockIsRunning {
	if mmIsRunning.mock.funcIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("ListeningComponentMock.IsRunning mock is already set by Set")
	}

	if mmIsRunning.defaultExpectation == nil {
		mmIsRunning.defaultExpectation = &ListeningComponentMockIsRunningExpectation{}
	}

	if mmIsRunning.defaultExpectation.params != nil {
		mmIsRunning.mock.t.Fatalf("ListeningComponentMock.IsRunning mock is already set by Expect")
	}

	if mmIsRunning.defaultExpectation.paramPtrs == nil {
		mmIsRunning.defaultExpectation.paramPtrs = &ListeningComponentMockIsRunningParamPtrs{}
	}
	mmIsRunning.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsRunning.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsRunning
}

// Inspect accepts an inspector function that has same arguments as the ListeningComponent.IsRunning
func (mmIsRunning *mListeningComponentMockIsRunning) Inspect(f func(ctx context.Context)) *mListeningComponentMockIsRunning {
	if mmIsRunning.mock.inspectFuncIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("Inspect function is already set for ListeningComponentMock.IsRunning")
	}

	mmIsRunning.mock.inspectFuncIsRunning = f

	return mmIsRunning
}

// Return sets up results that will be returned by ListeningComponent.IsRunning
func (mmIsRunning *mListeningComponentMockIsRunning) Return(b1 bool, err error) *ListeningComponentMock {
	if mmIsRunning.mock.funcIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("ListeningComponentMock.IsRunning mock is already set by Set")
	}

	if mmIsRunning.defaultExpectation == nil {
		mmIsRunning.defaultExpectation = &ListeningComponentMockIsRunningExpectation{mock: mmIsRunning.mock}
	}
	mmIsRunning.defaultExpectation.results = &ListeningComponentMockIsRunningResults{b1, err}
	mmIsRunning.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsRunning.mock
}

// Set uses given function f to mock the ListeningComponent.IsRunning method
func (mmIsRunning *mListeningComponentMockIsRunning) Set(f func(ctx context.Context) (b1 bool, err error)) *ListeningComponentMock {
	if mmIsRunning.defaultExpectation != nil {
		mmIsRunning.mock.t.Fatalf("Default expectation is already set for the ListeningComponent.IsRunning method")
	}

	if len(mmIsRunning.expectations) > 0 {
		mmIsRunning.mock.t.Fatalf("Some expectations are already set for the ListeningComponent.IsRunning method")
	}

	mmIsRunning.mock.funcIsRunning = f
	mmIsRunning.mock.funcIsRunningOrigin = minimock.CallerInfo(1)
	return mmIsRunning.mock
}

// When sets expectation for the ListeningComponent.IsRunning which will trigger the result defined by the following
// Then helper
func (mmIsRunning *mListeningComponentMockIsRunning) When(ctx context.Context) *ListeningComponentMockIsRunningExpectation {
	if mmIsRunning.mock.funcIsRunning != nil {
		mmIsRunning.mock.t.Fatalf("ListeningComponentMock.IsRunning mock is already set by Set")
	}

	expectation := &ListeningComponentMockIsRunningExpectation{
		mock:               mmIsRunning.mock,
		params:             &ListeningComponentMockIsRunningParams{ctx},
		expectationOrigins: ListeningComponentMockIsRunningExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsRunning.expectations = append(mmIsRunning.expectations, expectation)
	return expectation
}

// Then sets up ListeningComponent.IsRunning return parameters for the expectation previously defined by the When method
func (e *ListeningComponentMockIsRunningExpectation) Then(b1 bool, err error) *ListeningComponentMock {
	e.results = &ListeningComponentMockIsRunningResults{b1, err}
	return e.mock
}

// Times sets number of times ListeningComponent.IsRunning should be invoked
func (mmIsRunning *mListeningComponentMockIsRunning) Times(n uint64) *mListeningComponentMockIsRunning {
	if n == 0 {
		mmIsRunning.mock.t.Fatalf("Times of ListeningComponentMock.IsRunning mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsRunning.expectedInvocations, n)
	mmIsRunning.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsRunning
}

func (mmIsRunning *mListeningComponentMockIsRunning) invocationsDone() bool {
	if len(mmIsRunning.expectations) == 0 && mmIsRunning.defaultExpectation == nil && mmIsRunning.mock.funcIsRunning == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsRunning.mock.afterIsRunningCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsRunning.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsRunning implements ListeningComponent
func (mmIsRunning *ListeningComponentMock) IsRunning(ctx context.Context) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsRunning.beforeIsRunningCounter, 1)
	defer mm_atomic.AddUint64(&mmIsRunning.afterIsRunningCounter, 1)

	mmIsRunning.t.Helper()

	if mmIsRunning.inspectFuncIsRunning != nil {
		mmIsRunning.inspectFuncIsRunning(ctx)
	}

	mm_params := ListeningComponentMockIsRunningParams{ctx}

	// Record call args
	mmIsRunning.IsRunningMock.mutex.Lock()
	mmIsRunning.IsRunningMock.callArgs = append(mmIsRunning.IsRunningMock.callArgs, &mm_params)
	mmIsRunning.IsRunningMock.mutex.Unlock()

	for _, e := range mmIsRunning.IsRunningMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsRunning.IsRunningMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsRunning.IsRunningMock.defaultExpectation.Counter, 1)
		mm_want := mmIsRunning.IsRunningMock.defaultExpectation.params
		mm_want_ptrs := mmIsRunning.IsRunningMock.defaultExpectation.paramPtrs

		mm_got := ListeningComponentMockIsRunningParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsRunning.t.Errorf("ListeningComponentMock.IsRunning got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsRunning.IsRunningMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsRunning.t.Errorf("ListeningComponentMock.IsRunning got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsRunning.IsRunningMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsRunning.IsRunningMock.defaultExpectation.results
		if mm_results == nil {
			mmIsRunning.t.Fatal("No results are set for the ListeningComponentMock.IsRunning")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsRunning.funcIsRunning != nil {
		return mmIsRunning.funcIsRunning(ctx)
	}
	mmIsRunning.t.Fatalf("Unexpected call to ListeningComponentMock.IsRunning. %v", ctx)
	return
}

// IsRunningAfterCounter returns a count of finished ListeningComponentMock.IsRunning invocations
func (mmIsRunning *ListeningComponentMock) IsRunningAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRunning.afterIsRunningCounter)
}

// IsRunningBeforeCounter returns a count of ListeningComponentMock.IsRunning invocations
func (mmIsRunning *ListeningComponentMock) IsRunningBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRunning.beforeIsRunningCounter)
}

// Calls returns a list of arguments used in each call to ListeningComponentMock.IsRunning.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsRunning *mListeningComponentMockIsRunning) Calls() []*ListeningComponentMockIsRunningParams {
	mmIsRunning.mutex.RLock()

	argCopy := make([]*ListeningComponentMockIsRunningParams, len(mmIsRunning.callArgs))
	copy(argCopy, mmIsRunning.callArgs)

	mmIsRunning.mutex.RUnlock()

	return argCopy
}

// MinimockIsRunningDone returns true if the count of the IsRunning invocations corresponds
// the number of defined expectations
func (m *ListeningComponentMock) MinimockIsRunningDone() bool {
	if m.IsRunningMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsRunningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsRunningMock.invocationsDone()
}

// MinimockIsRunningInspect logs each unmet expectation
func (m *ListeningComponentMock) MinimockIsRunningInspect() {
	for _, e := range m.IsRunningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ListeningComponentMock.IsRunning at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsRunningCounter := mm_atomic.LoadUint64(&m.afterIsRunningCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsRunningMock.defaultExpectation != nil && afterIsRunningCounter < 1 {
		if m.IsRunningMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ListeningComponentMock.IsRunning at\n%s", m.IsRunningMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ListeningComponentMock.IsRunning at\n%s with params: %#v", m.IsRunningMock.defaultExpectation.expectationOrigins.origin, *m.IsRunningMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsRunning != nil && afterIsRunningCounter < 1 {
		m.t.Errorf("Expected call to ListeningComponentMock.IsRunning at\n%s", m.funcIsRunningOrigin)
	}

	if !m.IsRunningMock.invocationsDone() && afterIsRunningCounter > 0 {
		m.t.Errorf("Expected %d calls to ListeningComponentMock.IsRunning at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsRunningMock.expectedInvocations), m.IsRunningMock.expectedInvocationsOrigin, afterIsRunningCounter)
	}
}

type mListeningComponentMockStartListening struct {
	optional           bool
	mock               *ListeningComponentMock
	defaultExpectation *ListeningComponentMockStartListeningExpectation
	expectations       []*ListeningComponentMockStartListeningExpectation

	callArgs []*ListeningComponentMockStartListeningParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ListeningComponentMockStartListeningExpectation specifies expectation struct of the ListeningComponent.StartListening
type ListeningComponentMockStartListeningExpectation struct {
	mock               *ListeningComponentMock
	params             *ListeningComponentMockStartListeningParams
	paramPtrs          *ListeningComponentMockStartListeningParamPtrs
	expectationOrigins ListeningComponentMockStartListeningExpectationOrigins
	results            *ListeningComponentMockStartListeningResults
	returnOrigin       string
	Counter            uint64
}

// ListeningComponentMockStartListeningParams contains parameters of the ListeningComponent.StartListening
type ListeningComponentMockStartListeningParams struct {
	ctx context.Context
}

// ListeningComponentMockStartListeningParamPtrs contains pointers to parameters of the ListeningComponent.StartListening
type ListeningComponentMockStartListeningParamPtrs struct {
	ctx *context.Context
}

// ListeningComponentMockStartListeningResults contains results of the ListeningComponent.StartListening
type ListeningComponentMockStartListeningResults struct {
	err error
}

// ListeningComponentMockStartListeningOrigins contains origins of expectations of the ListeningComponent.StartListening
type ListeningComponentMockStartListeningExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStartListening *mListeningComponentMockStartListening) Optional() *mListeningComponentMockStartListening {
	mmStartListening.optional = true
	return mmStartListening
}

// Expect sets up expected params for ListeningComponent.StartListening
func (mmStartListening *mListeningComponentMockStartListening) Expect(ctx context.Context) *mListeningComponentMockStartListening {
	if mmStartListening.mock.funcStartListening != nil {
		mmStartListening.mock.t.Fatalf("ListeningComponentMock.StartListening mock is already set by Set")
	}

	if mmStartListening.defaultExpectation == nil {
		mmStartListening.defaultExpectation = &ListeningComponentMockStartListeningExpectation{}
	}

	if mmStartListening.defaultExpectation.paramPtrs != nil {
		mmStartListening.mock.t.Fatalf("ListeningComponentMock.StartListening mock is already set by ExpectParams functions")
	}

	mmStartListening.defaultExpectation.params = &ListeningComponentMockStartListeningParams{ctx}
	mmStartListening.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStartListening.expectations {
		if minimock.Equal(e.params, mmStartListening.defaultExpectation.params) {
			mmStartListening.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStartListening.defaultExpectation.params)
		}
	}

	return mmStartListening
}

// ExpectCtxParam1 sets up expected param ctx for ListeningComponent.StartListening
func (mmStartListening *mListeningComponentMockStartListening) ExpectCtxParam1(ctx context.Context) *mListeningComponentMockStartListening {
	if mmStartListening.mock.funcStartListening != nil {
		mmStartListening.mock.t.Fatalf("ListeningComponentMock.StartListening mock is already set by Set")
	}

	if mmStartListening.defaultExpectation == nil {
		mmStartListening.defaultExpectation = &ListeningComponentMockStartListeningExpectation{}
	}

	if mmStartListening.defaultExpectation.params != nil {
		mmStartListening.mock.t.Fatalf("ListeningComponentMock.StartListening mock is already set by Expect")
	}

	if mmStartListening.defaultExpectation.paramPtrs == nil {
		mmStartListening.defaultExpectation.paramPtrs = &ListeningComponentMockStartListeningParamPtrs{}
	}
	mmStartListening.defaultExpectation.paramPtrs.ctx = &ctx
	mmStartListening.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStartListening
}

// Inspect accepts an inspector function that has same arguments as the ListeningComponent.StartListening
func (mmStartListening *mListeningComponentMockStartListening) Inspect(f func(ctx context.Context)) *mListeningComponentMockStartListening {
	if mmStartListening.mock.inspectFuncStartListening != nil {
		mmStartListening.mock.t.Fatalf("Inspect function is already set for ListeningComponentMock.StartListening")
	}

	mmStartListening.mock.inspectFuncStartListening = f

	return mmStartListening
}

// Return sets up results that will be returned by ListeningComponent.StartListening
func (mmStartListening *mListeningComponentMockStartListening) Return(err error) *ListeningComponentMock {
	if mmStartListening.mock.funcStartListening != nil {
		mmStartListening.mock.t.Fatalf("ListeningComponentMock.StartListening mock is already set by Set")
	}

	if mmStartListening.defaultExpectation == nil {
		mmStartListening.defaultExpectation = &ListeningComponentMockStartListeningExpectation{mock: mmStartListening.mock}
	}
	mmStartListening.defaultExpectation.results = &ListeningComponentMockStartListeningResults{err}
	mmStartListening.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStartListening.mock
}

// Set uses given function f to mock the ListeningComponent.StartListening method
func (mmStartListening *mListeningComponentMockStartListening) Set(f func(ctx context.Context) (err error)) *ListeningComponentMock {
	if mmStartListening.defaultExpectation != nil {
		mmStartListening.mock.t.Fatalf("Default expectation is already set for the ListeningComponent.StartListening method")
	}

	if len(mmStartListening.expectations) > 0 {
		mmStartListening.mock.t.Fatalf("Some expectations are already set for the ListeningComponent.StartListening method")
	}

	mmStartListening.mock.funcStartListening = f
	mmStartListening.mock.funcStartListeningOrigin = minimock.CallerInfo(1)
	return mmStartListening.mock
}

// When sets expectation for the ListeningComponent.StartListening which will trigger the result defined by the following
// Then helper
func (mmStartListening *mListeningComponentMockStartListening) When(ctx context.Context) *ListeningComponentMockStartListeningExpectation {
	if mmStartListening.mock.funcStartListening != nil {
		mmStartListening.mock.t.Fatalf("ListeningComponentMock.StartListening mock is already set by Set")
	}

	expectation := &ListeningComponentMockStartListeningExpectation{
		mock:               mmStartListening.mock,
		params:             &ListeningComponentMockStartListeningParams{ctx},
		expectationOrigins: ListeningComponentMockStartListeningExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStartListening.expectations = append(mmStartListening.expectations, expectation)
	return expectation
}

// Then sets up ListeningComponent.StartListening return parameters for the expectation previously defined by the When method
func (e *ListeningComponentMockStartListeningExpectation) Then(err error) *ListeningComponentMock {
	e.results = &ListeningComponentMockStartListeningResults{err}
	return e.mock
}

// Times sets number of times ListeningComponent.StartListening should be invoked
func (mmStartListening *mListeningComponentMockStartListening) Times(n uint64) *mListeningComponentMockStartListening {
	if n == 0 {
		mmStartListening.mock.t.Fatalf("Times of ListeningComponentMock.StartListening mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStartListening.expectedInvocations, n)
	mmStartListening.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStartListening
}

func (mmStartListening *mListeningComponentMockStartListening) invocationsDone() bool {
	if len(mmStartListening.expectations) == 0 && mmStartListening.defaultExpectation == nil && mmStartListening.mock.funcStartListening == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStartListening.mock.afterStartListeningCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStartListening.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StartListening implements ListeningComponent
func (mmStartListening *ListeningComponentMock) StartListening(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStartListening.beforeStartListeningCounter, 1)
	defer mm_atomic.AddUint64(&mmStartListening.afterStartListeningCounter, 1)

	mmStartListening.t.Helper()

	if mmStartListening.inspectFuncStartListening != nil {
		mmStartListening.inspectFuncStartListening(ctx)
	}

	mm_params := ListeningComponentMockStartListeningParams{ctx}

	// Record call args
	mmStartListening.StartListeningMock.mutex.Lock()
	mmStartListening.StartListeningMock.callArgs = append(mmStartListening.StartListeningMock.callArgs, &mm_params)
	mmStartListening.StartListeningMock.mutex.Unlock()

	for _, e := range mmStartListening.StartListeningMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStartListening.StartListeningMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStartListening.StartListeningMock.defaultExpectation.Counter, 1)
		mm_want := mmStartListening.StartListeningMock.defaultExpectation.params
		mm_want_ptrs := mmStartListening.StartListeningMock.defaultExpectation.paramPtrs

		mm_got := ListeningComponentMockStartListeningParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStartListening.t.Errorf("ListeningComponentMock.StartListening got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStartListening.StartListeningMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStartListening.t.Errorf("ListeningComponentMock.StartListening got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStartListening.StartListeningMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStartListening.StartListeningMock.defaultExpectation.results
		if mm_results == nil {
			mmStartListening.t.Fatal("No results are set for the ListeningComponentMock.StartListening")
		}
		return (*mm_results).err
	}
	if mmStartListening.funcStartListening != nil {
		return mmStartListening.funcStartListening(ctx)
	}
	mmStartListening.t.Fatalf("Unexpected call to ListeningComponentMock.StartListening. %v", ctx)
	return
}

// StartListeningAfterCounter returns a count of finished ListeningComponentMock.StartListening invocations
func (mmStartListening *ListeningComponentMock) StartListeningAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartListening.afterStartListeningCounter)
}

// StartListeningBeforeCounter returns a count of ListeningComponentMock.StartListening invocations
func (mmStartListening *ListeningComponentMock) StartListeningBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartListening.beforeStartListeningCounter)
}

// Calls returns a list of arguments used in each call to ListeningComponentMock.StartListening.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStartListening *mListeningComponentMockStartListening) Calls() []*ListeningComponentMockStartListeningParams {
	mmStartListening.mutex.RLock()

	argCopy := make([]*ListeningComponentMockStartListeningParams, len(mmStartListening.callArgs))
	copy(argCopy, mmStartListening.callArgs)

	mmStartListening.mutex.RUnlock()

	return argCopy
}

// MinimockStartListeningDone returns true if the count of the StartListening invocations corresponds
// the number of defined expectations
func (m *ListeningComponentMock) MinimockStartListeningDone() bool {
	if m.StartListeningMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StartListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StartListeningMock.invocationsDone()
}

// MinimockStartListeningInspect logs each unmet expectation
func (m *ListeningComponentMock) MinimockStartListeningInspect() {
	for _, e := range m.StartListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ListeningComponentMock.StartListening at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStartListeningCounter := mm_atomic.LoadUint64(&m.afterStartListeningCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StartListeningMock.defaultExpectation != nil && afterStartListeningCounter < 1 {
		if m.StartListeningMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ListeningComponentMock.StartListening at\n%s", m.StartListeningMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ListeningComponentMock.StartListening at\n%s with params: %#v", m.StartListeningMock.defaultExpectation.expectationOrigins.origin, *m.StartListeningMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartListening != nil && afterStartListeningCounter < 1 {
		m.t.Errorf("Expected call to ListeningComponentMock.StartListening at\n%s", m.funcStartListeningOrigin)
	}

	if !m.StartListeningMock.invocationsDone() && afterStartListeningCounter > 0 {
		m.t.Errorf("Expected %d calls to ListeningComponentMock.StartListening at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StartListeningMock.expectedInvocations), m.StartListeningMock.expectedInvocationsOrigin, afterStartListeningCounter)
	}
}

type mListeningComponentMockStopListening struct {
	optional           bool
	mock               *ListeningComponentMock
	defaultExpectation *ListeningComponentMockStopListeningExpectation
	expectations       []*ListeningComponentMockStopListeningExpectation

	callArgs []*ListeningComponentMockStopListeningParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ListeningComponentMockStopListeningExpectation specifies expectation struct of the ListeningComponent.StopListening
type ListeningComponentMockStopListeningExpectation struct {
	mock               *ListeningComponentMock
	params             *ListeningComponentMockStopListeningParams
	paramPtrs          *ListeningComponentMockStopListeningParamPtrs
	expectationOrigins ListeningComponentMockStopListeningExpectationOrigins
	results            *ListeningComponentMockStopListeningResults
	returnOrigin       string
	Counter            uint64
}

// ListeningComponentMockStopListeningParams contains parameters of the ListeningComponent.StopListening
type ListeningComponentMockStopListeningParams struct {
	ctx context.Context
}

// ListeningComponentMockStopListeningParamPtrs contains pointers to parameters of the ListeningComponent.StopListening
type ListeningComponentMockStopListeningParamPtrs struct {
	ctx *context.Context
}

// ListeningComponentMockStopListeningResults contains results of the ListeningComponent.StopListening
type ListeningComponentMockStopListeningResults struct {
	err error
}

// ListeningComponentMockStopListeningOrigins contains origins of expectations of the ListeningComponent.StopListening
type ListeningComponentMockStopListeningExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStopListening *mListeningComponentMockStopListening) Optional() *mListeningComponentMockStopListening {
	mmStopListening.optional = true
	return mmStopListening
}

// Expect sets up expected params for ListeningComponent.StopListening
func (mmStopListening *mListeningComponentMockStopListening) Expect(ctx context.Context) *mListeningComponentMockStopListening {
	if mmStopListening.mock.funcStopListening != nil {
		mmStopListening.mock.t.Fatalf("ListeningComponentMock.StopListening mock is already set by Set")
	}

	if mmStopListening.defaultExpectation == nil {
		mmStopListening.defaultExpectation = &ListeningComponentMockStopListeningExpectation{}
	}

	if mmStopListening.defaultExpectation.paramPtrs != nil {
		mmStopListening.mock.t.Fatalf("ListeningComponentMock.StopListening mock is already set by ExpectParams functions")
	}

	mmStopListening.defaultExpectation.params = &ListeningComponentMockStopListeningParams{ctx}
	mmStopListening.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStopListening.expectations {
		if minimock.Equal(e.params, mmStopListening.defaultExpectation.params) {
			mmStopListening.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStopListening.defaultExpectation.params)
		}
	}

	return mmStopListening
}

// ExpectCtxParam1 sets up expected param ctx for ListeningComponent.StopListening
func (mmStopListening *mListeningComponentMockStopListening) ExpectCtxParam1(ctx context.Context) *mListeningComponentMockStopListening {
	if mmStopListening.mock.funcStopListening != nil {
		mmStopListening.mock.t.Fatalf("ListeningComponentMock.StopListening mock is already set by Set")
	}

	if mmStopListening.defaultExpectation == nil {
		mmStopListening.defaultExpectation = &ListeningComponentMockStopListeningExpectation{}
	}

	if mmStopListening.defaultExpectation.params != nil {
		mmStopListening.mock.t.Fatalf("ListeningComponentMock.StopListening mock is already set by Expect")
	}

	if mmStopListening.defaultExpectation.paramPtrs == nil {
		mmStopListening.defaultExpectation.paramPtrs = &ListeningComponentMockStopListeningParamPtrs{}
	}
	mmStopListening.defaultExpectation.paramPtrs.ctx = &ctx
	mmStopListening.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStopListening
}

// Inspect accepts an inspector function that has same arguments as the ListeningComponent.StopListening
func (mmStopListening *mListeningComponentMockStopListening) Inspect(f func(ctx context.Context)) *mListeningComponentMockStopListening {
	if mmStopListening.mock.inspectFuncStopListening != nil {
		mmStopListening.mock.t.Fatalf("Inspect function is already set for ListeningComponentMock.StopListening")
	}

	mmStopListening.mock.inspectFuncStopListening = f

	return mmStopListening
}

// Return sets up results that will be returned by ListeningComponent.StopListening
func (mmStopListening *mListeningComponentMockStopListening) Return(err error) *ListeningComponentMock {
	if mmStopListening.mock.funcStopListening != nil {
		mmStopListening.mock.t.Fatalf("ListeningComponentMock.StopListening mock is already set by Set")
	}

	if mmStopListening.defaultExpectation == nil {
		mmStopListening.defaultExpectation = &ListeningComponentMockStopListeningExpectation{mock: mmStopListening.mock}
	}
	mmStopListening.defaultExpectation.results = &ListeningComponentMockStopListeningResults{err}
	mmStopListening.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStopListening.mock
}

// Set uses given function f to mock the ListeningComponent.StopListening method
func (mmStopListening *mListeningComponentMockStopListening) Set(f func(ctx context.Context) (err error)) *ListeningComponentMock {
	if mmStopListening.defaultExpectation != nil {
		mmStopListening.mock.t.Fatalf("Default expectation is already set for the ListeningComponent.StopListening method")
	}

	if len(mmStopListening.expectations) > 0 {
		mmStopListening.mock.t.Fatalf("Some expectations are already set for the ListeningComponent.StopListening method")
	}

	mmStopListening.mock.funcStopListening = f
	mmStopListening.mock.funcStopListeningOrigin = minimock.CallerInfo(1)
	return mmStopListening.mock
}

// When sets expectation for the ListeningComponent.StopListening which will trigger the result defined by the following
// Then helper
func (mmStopListening *mListeningComponentMockStopListening) When(ctx context.Context) *ListeningComponentMockStopListeningExpectation {
	if mmStopListening.mock.funcStopListening != nil {
		mmStopListening.mock.t.Fatalf("ListeningComponentMock.StopListening mock is already set by Set")
	}

	expectation := &ListeningComponentMockStopListeningExpectation{
		mock:               mmStopListening.mock,
		params:             &ListeningComponentMockStopListeningParams{ctx},
		expectationOrigins: ListeningComponentMockStopListeningExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStopListening.expectations = append(mmStopListening.expectations, expectation)
	return expectation
}

// Then sets up ListeningComponent.StopListening return parameters for the expectation previously defined by the When method
func (e *ListeningComponentMockStopListeningExpectation) Then(err error) *ListeningComponentMock {
	e.results = &ListeningComponentMockStopListeningResults{err}
	return e.mock
}

// Times sets number of times ListeningComponent.StopListening should be invoked
func (mmStopListening *mListeningComponentMockStopListening) Times(n uint64) *mListeningComponentMockStopListening {
	if n == 0 {
		mmStopListening.mock.t.Fatalf("Times of ListeningComponentMock.StopListening mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStopListening.expectedInvocations, n)
	mmStopListening.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStopListening
}

func (mmStopListening *mListeningComponentMockStopListening) invocationsDone() bool {
	if len(mmStopListening.expectations) == 0 && mmStopListening.defaultExpectation == nil && mmStopListening.mock.funcStopListening == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStopListening.mock.afterStopListeningCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStopListening.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StopListening implements ListeningComponent
func (mmStopListening *ListeningComponentMock) StopListening(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStopListening.beforeStopListeningCounter, 1)
	defer mm_atomic.AddUint64(&mmStopListening.afterStopListeningCounter, 1)

	mmStopListening.t.Helper()

	if mmStopListening.inspectFuncStopListening != nil {
		mmStopListening.inspectFuncStopListening(ctx)
	}

	mm_params := ListeningComponentMockStopListeningParams{ctx}

	// Record call args
	mmStopListening.StopListeningMock.mutex.Lock()
	mmStopListening.StopListeningMock.callArgs = append(mmStopListening.StopListeningMock.callArgs, &mm_params)
	mmStopListening.StopListeningMock.mutex.Unlock()

	for _, e := range mmStopListening.StopListeningMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStopListening.StopListeningMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStopListening.StopListeningMock.defaultExpectation.Counter, 1)
		mm_want := mmStopListening.StopListeningMock.defaultExpectation.params
		mm_want_ptrs := mmStopListening.StopListeningMock.defaultExpectation.paramPtrs

		mm_got := ListeningComponentMockStopListeningParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStopListening.t.Errorf("ListeningComponentMock.StopListening got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStopListening.StopListeningMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStopListening.t.Errorf("ListeningComponentMock.StopListening got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStopListening.StopListeningMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStopListening.StopListeningMock.defaultExpectation.results
		if mm_results == nil {
			mmStopListening.t.Fatal("No results are set for the ListeningComponentMock.StopListening")
		}
		return (*mm_results).err
	}
	if mmStopListening.funcStopListening != nil {
		return mmStopListening.funcStopListening(ctx)
	}
	mmStopListening.t.Fatalf("Unexpected call to ListeningComponentMock.StopListening. %v", ctx)
	return
}

// StopListeningAfterCounter returns a count of finished ListeningComponentMock.StopListening invocations
func (mmStopListening *ListeningComponentMock) StopListeningAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStopListening.afterStopListeningCounter)
}

// StopListeningBeforeCounter returns a count of ListeningComponentMock.StopListening invocations
func (mmStopListening *ListeningComponentMock) StopListeningBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStopListening.beforeStopListeningCounter)
}

// Calls returns a list of arguments used in each call to ListeningComponentMock.StopListening.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStopListening *mListeningComponentMockStopListening) Calls() []*ListeningComponentMockStopListeningParams {
	mmStopListening.mutex.RLock()

	argCopy := make([]*ListeningComponentMockStopListeningParams, len(mmStopListening.callArgs))
	copy(argCopy, mmStopListening.callArgs)

	mmStopListening.mutex.RUnlock()

	return argCopy
}

// MinimockStopListeningDone returns true if the count of the StopListening invocations corresponds
// the number of defined expectations
func (m *ListeningComponentMock) MinimockStopListeningDone() bool {
	if m.StopListeningMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StopListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StopListeningMock.invocationsDone()
}

// MinimockStopListeningInspect logs each unmet expectation
func (m *ListeningComponentMock) MinimockStopListeningInspect() {
	for _, e := range m.StopListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ListeningComponentMock.StopListening at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStopListeningCounter := mm_atomic.LoadUint64(&m.afterStopListeningCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StopListeningMock.defaultExpectation != nil && afterStopListeningCounter < 1 {
		if m.StopListeningMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ListeningComponentMock.StopListening at\n%s", m.StopListeningMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ListeningComponentMock.StopListening at\n%s with params: %#v", m.StopListeningMock.defaultExpectation.expectationOrigins.origin, *m.StopListeningMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStopListening != nil && afterStopListeningCounter < 1 {
		m.t.Errorf("Expected call to ListeningComponentMock.StopListening at\n%s", m.funcStopListeningOrigin)
	}

	if !m.StopListeningMock.invocationsDone() && afterStopListeningCounter > 0 {
		m.t.Errorf("Expected %d calls to ListeningComponentMock.StopListening at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StopListeningMock.expectedInvocations), m.StopListeningMock.expectedInvocationsOrigin, afterStopListeningCounter)
	}
}

type mListeningComponentMockToggleListening struct {
	optional           bool
	mock               *ListeningComponentMock
	defaultExpectation *ListeningComponentMockToggleListeningExpectation
	expectations       []*ListeningComponentMockToggleListeningExpectation

	callArgs []*ListeningComponentMockToggleListeningParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ListeningComponentMockToggleListeningExpectation specifies expectation struct of the ListeningComponent.ToggleListening
type ListeningComponentMockToggleListeningExpectation struct {
	mock               *ListeningComponentMock
	params             *ListeningComponentMockToggleListeningParams
	paramPtrs          *ListeningComponentMockToggleListeningParamPtrs
	expectationOrigins ListeningComponentMockToggleListeningExpectationOrigins
	results            *ListeningComponentMockToggleListeningResults
	returnOrigin       string
	Counter            uint64
}

// ListeningComponentMockToggleListeningParams contains parameters of the ListeningComponent.ToggleListening
type ListeningComponentMockToggleListeningParams struct {
	ctx context.Context
}

// ListeningComponentMockToggleListeningParamPtrs contains pointers to parameters of the ListeningComponent.ToggleListening
type ListeningComponentMockToggleListeningParamPtrs struct {
	ctx *context.Context
}

// ListeningComponentMockToggleListeningResults contains results of the ListeningComponent.ToggleListening
type ListeningComponentMockToggleListeningResults struct {
	err error
}

// ListeningComponentMockToggleListeningOrigins contains origins of expectations of the ListeningComponent.ToggleListening
type ListeningComponentMockToggleListeningExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToggleListening *mListeningComponentMockToggleListening) Optional() *mListeningComponentMockToggleListening {
	mmToggleListening.optional = true
	return mmToggleListening
}

// Expect sets up expected params for ListeningComponent.ToggleListening
func (mmToggleListening *mListeningComponentMockToggleListening) Expect(ctx context.Context) *mListeningComponentMockToggleListening {
	if mmToggleListening.mock.funcToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("ListeningComponentMock.ToggleListening mock is already set by Set")
	}

	if mmToggleListening.defaultExpectation == nil {
		mmToggleListening.defaultExpectation = &ListeningComponentMockToggleListeningExpectation{}
	}

	if mmToggleListening.defaultExpectation.paramPtrs != nil {
		mmToggleListening.mock.t.Fatalf("ListeningComponentMock.ToggleListening mock is already set by ExpectParams functions")
	}

	mmToggleListening.defaultExpectation.params = &ListeningComponentMockToggleListeningParams{ctx}
	mmToggleListening.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToggleListening.expectations {
		if minimock.Equal(e.params, mmToggleListening.defaultExpectation.params) {
			mmToggleListening.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToggleListening.defaultExpectation.params)
		}
	}

	return mmToggleListening
}

// ExpectCtxParam1 sets up expected param ctx for ListeningComponent.ToggleListening
func (mmToggleListening *mListeningComponentMockToggleListening) ExpectCtxParam1(ctx context.Context) *mListeningComponentMockToggleListening {
	if mmToggleListening.mock.funcToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("ListeningComponentMock.ToggleListening mock is already set by Set")
	}

	if mmToggleListening.defaultExpectation == nil {
		mmToggleListening.defaultExpectation = &ListeningComponentMockToggleListeningExpectation{}
	}

	if mmToggleListening.defaultExpectation.params != nil {
		mmToggleListening.mock.t.Fatalf("ListeningComponentMock.ToggleListening mock is already set by Expect")
	}

	if mmToggleListening.defaultExpectation.paramPtrs == nil {
		mmToggleListening.defaultExpectation.paramPtrs = &ListeningComponentMockToggleListeningParamPtrs{}
	}
	mmToggleListening.defaultExpectation.paramPtrs.ctx = &ctx
	mmToggleListening.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmToggleListening
}

// Inspect accepts an inspector function that has same arguments as the ListeningComponent.ToggleListening
func (mmToggleListening *mListeningComponentMockToggleListening) Inspect(f func(ctx context.Context)) *mListeningComponentMockToggleListening {
	if mmToggleListening.mock.inspectFuncToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("Inspect function is already set for ListeningComponentMock.ToggleListening")
	}

	mmToggleListening.mock.inspectFuncToggleListening = f

	return mmToggleListening
}

// Return sets up results that will be returned by ListeningComponent.ToggleListening
func (mmToggleListening *mListeningComponentMockToggleListening) Return(err error) *ListeningComponentMock {
	if mmToggleListening.mock.funcToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("ListeningComponentMock.ToggleListening mock is already set by Set")
	}

	if mmToggleListening.defaultExpectation == nil {
		mmToggleListening.defaultExpectation = &ListeningComponentMockToggleListeningExpectation{mock: mmToggleListening.mock}
	}
	mmToggleListening.defaultExpectation.results = &ListeningComponentMockToggleListeningResults{err}
	mmToggleListening.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToggleListening.mock
}

// Set uses given function f to mock the ListeningComponent.ToggleListening method
func (mmToggleListening *mListeningComponentMockToggleListening) Set(f func(ctx context.Context) (err error)) *ListeningComponentMock {
	if mmToggleListening.defaultExpectation != nil {
		mmToggleListening.mock.t.Fatalf("Default expectation is already set for the ListeningComponent.ToggleListening method")
	}

	if len(mmToggleListening.expectations) > 0 {
		mmToggleListening.mock.t.Fatalf("Some expectations are already set for the ListeningComponent.ToggleListening method")
	}

	mmToggleListening.mock.funcToggleListening = f
	mmToggleListening.mock.funcToggleListeningOrigin = minimock.CallerInfo(1)
	return mmToggleListening.mock
}

// When sets expectation for the ListeningComponent.ToggleListening which will trigger the result defined by the following
// Then helper
func (mmToggleListening *mListeningComponentMockToggleListening) When(ctx context.Context) *ListeningComponentMockToggleListeningExpectation {
	if mmToggleListening.mock.funcToggleListening != nil {
		mmToggleListening.mock.t.Fatalf("ListeningComponentMock.ToggleListening mock is already set by Set")
	}

	expectation := &ListeningComponentMockToggleListeningExpectation{
		mock:               mmToggleListening.mock,
		params:             &ListeningComponentMockToggleListeningParams{ctx},
		expectationOrigins: ListeningComponentMockToggleListeningExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToggleListening.expectations = append(mmToggleListening.expectations, expectation)
	return expectation
}

// Then sets up ListeningComponent.ToggleListening return parameters for the expectation previously defined by the When method
func (e *ListeningComponentMockToggleListeningExpectation) Then(err error) *ListeningComponentMock {
	e.results = &ListeningComponentMockToggleListeningResults{err}
	return e.mock
}

// Times sets number of times ListeningComponent.ToggleListening should be invoked
func (mmToggleListening *mListeningComponentMockToggleListening) Times(n uint64) *mListeningComponentMockToggleListening {
	if n == 0 {
		mmToggleListening.mock.t.Fatalf("Times of ListeningComponentMock.ToggleListening mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToggleListening.expectedInvocations, n)
	mmToggleListening.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToggleListening
}

func (mmToggleListening *mListeningComponentMockToggleListening) invocationsDone() bool {
	if len(mmToggleListening.expectations) == 0 && mmToggleListening.defaultExpectation == nil && mmToggleListening.mock.funcToggleListening == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToggleListening.mock.afterToggleListeningCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToggleListening.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToggleListening implements ListeningComponent
func (mmToggleListening *ListeningComponentMock) ToggleListening(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmToggleListening.beforeToggleListeningCounter, 1)
	defer mm_atomic.AddUint64(&mmToggleListening.afterToggleListeningCounter, 1)

	mmToggleListening.t.Helper()

	if mmToggleListening.inspectFuncToggleListening != nil {
		mmToggleListening.inspectFuncToggleListening(ctx)
	}

	mm_params := ListeningComponentMockToggleListeningParams{ctx}

	// Record call args
	mmToggleListening.ToggleListeningMock.mutex.Lock()
	mmToggleListening.ToggleListeningMock.callArgs = append(mmToggleListening.ToggleListeningMock.callArgs, &mm_params)
	mmToggleListening.ToggleListeningMock.mutex.Unlock()

	for _, e := range mmToggleListening.ToggleListeningMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmToggleListening.ToggleListeningMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToggleListening.ToggleListeningMock.defaultExpectation.Counter, 1)
		mm_want := mmToggleListening.ToggleListeningMock.defaultExpectation.params
		mm_want_ptrs := mmToggleListening.ToggleListeningMock.defaultExpectation.paramPtrs

		mm_got := ListeningComponentMockToggleListeningParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmToggleListening.t.Errorf("ListeningComponentMock.ToggleListening got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToggleListening.ToggleListeningMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToggleListening.t.Errorf("ListeningComponentMock.ToggleListening got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToggleListening.ToggleListeningMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToggleListening.ToggleListeningMock.defaultExpectation.results
		if mm_results == nil {
			mmToggleListening.t.Fatal("No results are set for the ListeningComponentMock.ToggleListening")
		}
		return (*mm_results).err
	}
	if mmToggleListening.funcToggleListening != nil {
		return mmToggleListening.funcToggleListening(ctx)
	}
	mmToggleListening.t.Fatalf("Unexpected call to ListeningComponentMock.ToggleListening. %v", ctx)
	return
}

// ToggleListeningAfterCounter returns a count of finished ListeningComponentMock.ToggleListening invocations
func (mmToggleListening *ListeningComponentMock) ToggleListeningAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToggleListening.afterToggleListeningCounter)
}

// ToggleListeningBeforeCounter returns a count of ListeningComponentMock.ToggleListening invocations
func (mmToggleListening *ListeningComponentMock) ToggleListeningBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToggleListening.beforeToggleListeningCounter)
}

// Calls returns a list of arguments used in each call to ListeningComponentMock.ToggleListening.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToggleListening *mListeningComponentMockToggleListening) Calls() []*ListeningComponentMockToggleListeningParams {
	mmToggleListening.mutex.RLock()

	argCopy := make([]*ListeningComponentMockToggleListeningParams, len(mmToggleListening.callArgs))
	copy(argCopy, mmToggleListening.callArgs)

	mmToggleListening.mutex.RUnlock()

	return argCopy
}

// MinimockToggleListeningDone returns true if the count of the ToggleListening invocations corresponds
// the number of defined expectations
func (m *ListeningComponentMock) MinimockToggleListeningDone() bool {
	if m.ToggleListeningMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToggleListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToggleListeningMock.invocationsDone()
}

// MinimockToggleListeningInspect logs each unmet expectation
func (m *ListeningComponentMock) MinimockToggleListeningInspect() {
	for _, e := range m.ToggleListeningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ListeningComponentMock.ToggleListening at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToggleListeningCounter := mm_atomic.LoadUint64(&m.afterToggleListeningCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToggleListeningMock.defaultExpectation != nil && afterToggleListeningCounter < 1 {
		if m.ToggleListeningMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ListeningComponentMock.ToggleListening at\n%s", m.ToggleListeningMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ListeningComponentMock.ToggleListening at\n%s with params: %#v", m.ToggleListeningMock.defaultExpectation.expectationOrigins.origin, *m.ToggleListeningMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToggleListening != nil && afterToggleListeningCounter < 1 {
		m.t.Errorf("Expected call to ListeningComponentMock.ToggleListening at\n%s", m.funcToggleListeningOrigin)
	}

	if !m.ToggleListeningMock.invocationsDone() && afterToggleListeningCounter > 0 {
		m.t.Errorf("Expected %d calls to ListeningComponentMock.ToggleListening at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToggleListeningMock.expectedInvocations), m.ToggleListeningMock.expectedInvocationsOrigin, afterToggleListeningCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ListeningComponentMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockIsRunningInspect()

			m.MinimockStartListeningInspect()

			m.MinimockStopListeningInspect()

			m.MinimockToggleListeningInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ListeningComponentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ListeningComponentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIsRunningDone() &&
		m.MinimockStartListeningDone() &&
		m.MinimockStopListeningDone() &&
		m.MinimockToggleListeningDone()
}
