// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package btt

import (
	"context"
	"live2text/internal/services/btt/client/trigger"
	"live2text/internal/services/btt/storage"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SettingsComponentMock implements SettingsComponent
type SettingsComponentMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcSelectSettings          func(ctx context.Context, title trigger.Title, key storage.Key, value string) (err error)
	funcSelectSettingsOrigin    string
	inspectFuncSelectSettings   func(ctx context.Context, title trigger.Title, key storage.Key, value string)
	afterSelectSettingsCounter  uint64
	beforeSelectSettingsCounter uint64
	SelectSettingsMock          mSettingsComponentMockSelectSettings

	funcSelectedSetting          func(ctx context.Context, key storage.Key) (s1 string, err error)
	funcSelectedSettingOrigin    string
	inspectFuncSelectedSetting   func(ctx context.Context, key storage.Key)
	afterSelectedSettingCounter  uint64
	beforeSelectedSettingCounter uint64
	SelectedSettingMock          mSettingsComponentMockSelectedSetting
}

// NewSettingsComponentMock returns a mock for SettingsComponent
func NewSettingsComponentMock(t minimock.Tester) *SettingsComponentMock {
	m := &SettingsComponentMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.SelectSettingsMock = mSettingsComponentMockSelectSettings{mock: m}
	m.SelectSettingsMock.callArgs = []*SettingsComponentMockSelectSettingsParams{}

	m.SelectedSettingMock = mSettingsComponentMockSelectedSetting{mock: m}
	m.SelectedSettingMock.callArgs = []*SettingsComponentMockSelectedSettingParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSettingsComponentMockSelectSettings struct {
	optional           bool
	mock               *SettingsComponentMock
	defaultExpectation *SettingsComponentMockSelectSettingsExpectation
	expectations       []*SettingsComponentMockSelectSettingsExpectation

	callArgs []*SettingsComponentMockSelectSettingsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SettingsComponentMockSelectSettingsExpectation specifies expectation struct of the SettingsComponent.SelectSettings
type SettingsComponentMockSelectSettingsExpectation struct {
	mock               *SettingsComponentMock
	params             *SettingsComponentMockSelectSettingsParams
	paramPtrs          *SettingsComponentMockSelectSettingsParamPtrs
	expectationOrigins SettingsComponentMockSelectSettingsExpectationOrigins
	results            *SettingsComponentMockSelectSettingsResults
	returnOrigin       string
	Counter            uint64
}

// SettingsComponentMockSelectSettingsParams contains parameters of the SettingsComponent.SelectSettings
type SettingsComponentMockSelectSettingsParams struct {
	ctx   context.Context
	title trigger.Title
	key   storage.Key
	value string
}

// SettingsComponentMockSelectSettingsParamPtrs contains pointers to parameters of the SettingsComponent.SelectSettings
type SettingsComponentMockSelectSettingsParamPtrs struct {
	ctx   *context.Context
	title *trigger.Title
	key   *storage.Key
	value *string
}

// SettingsComponentMockSelectSettingsResults contains results of the SettingsComponent.SelectSettings
type SettingsComponentMockSelectSettingsResults struct {
	err error
}

// SettingsComponentMockSelectSettingsOrigins contains origins of expectations of the SettingsComponent.SelectSettings
type SettingsComponentMockSelectSettingsExpectationOrigins struct {
	origin      string
	originCtx   string
	originTitle string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectSettings *mSettingsComponentMockSelectSettings) Optional() *mSettingsComponentMockSelectSettings {
	mmSelectSettings.optional = true
	return mmSelectSettings
}

// Expect sets up expected params for SettingsComponent.SelectSettings
func (mmSelectSettings *mSettingsComponentMockSelectSettings) Expect(ctx context.Context, title trigger.Title, key storage.Key, value string) *mSettingsComponentMockSelectSettings {
	if mmSelectSettings.mock.funcSelectSettings != nil {
		mmSelectSettings.mock.t.Fatalf("SettingsComponentMock.SelectSettings mock is already set by Set")
	}

	if mmSelectSettings.defaultExpectation == nil {
		mmSelectSettings.defaultExpectation = &SettingsComponentMockSelectSettingsExpectation{}
	}

	if mmSelectSettings.defaultExpectation.paramPtrs != nil {
		mmSelectSettings.mock.t.Fatalf("SettingsComponentMock.SelectSettings mock is already set by ExpectParams functions")
	}

	mmSelectSettings.defaultExpectation.params = &SettingsComponentMockSelectSettingsParams{ctx, title, key, value}
	mmSelectSettings.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectSettings.expectations {
		if minimock.Equal(e.params, mmSelectSettings.defaultExpectation.params) {
			mmSelectSettings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectSettings.defaultExpectation.params)
		}
	}

	return mmSelectSettings
}

// ExpectCtxParam1 sets up expected param ctx for SettingsComponent.SelectSettings
func (mmSelectSettings *mSettingsComponentMockSelectSettings) ExpectCtxParam1(ctx context.Context) *mSettingsComponentMockSelectSettings {
	if mmSelectSettings.mock.funcSelectSettings != nil {
		mmSelectSettings.mock.t.Fatalf("SettingsComponentMock.SelectSettings mock is already set by Set")
	}

	if mmSelectSettings.defaultExpectation == nil {
		mmSelectSettings.defaultExpectation = &SettingsComponentMockSelectSettingsExpectation{}
	}

	if mmSelectSettings.defaultExpectation.params != nil {
		mmSelectSettings.mock.t.Fatalf("SettingsComponentMock.SelectSettings mock is already set by Expect")
	}

	if mmSelectSettings.defaultExpectation.paramPtrs == nil {
		mmSelectSettings.defaultExpectation.paramPtrs = &SettingsComponentMockSelectSettingsParamPtrs{}
	}
	mmSelectSettings.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectSettings.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectSettings
}

// ExpectTitleParam2 sets up expected param title for SettingsComponent.SelectSettings
func (mmSelectSettings *mSettingsComponentMockSelectSettings) ExpectTitleParam2(title trigger.Title) *mSettingsComponentMockSelectSettings {
	if mmSelectSettings.mock.funcSelectSettings != nil {
		mmSelectSettings.mock.t.Fatalf("SettingsComponentMock.SelectSettings mock is already set by Set")
	}

	if mmSelectSettings.defaultExpectation == nil {
		mmSelectSettings.defaultExpectation = &SettingsComponentMockSelectSettingsExpectation{}
	}

	if mmSelectSettings.defaultExpectation.params != nil {
		mmSelectSettings.mock.t.Fatalf("SettingsComponentMock.SelectSettings mock is already set by Expect")
	}

	if mmSelectSettings.defaultExpectation.paramPtrs == nil {
		mmSelectSettings.defaultExpectation.paramPtrs = &SettingsComponentMockSelectSettingsParamPtrs{}
	}
	mmSelectSettings.defaultExpectation.paramPtrs.title = &title
	mmSelectSettings.defaultExpectation.expectationOrigins.originTitle = minimock.CallerInfo(1)

	return mmSelectSettings
}

// ExpectKeyParam3 sets up expected param key for SettingsComponent.SelectSettings
func (mmSelectSettings *mSettingsComponentMockSelectSettings) ExpectKeyParam3(key storage.Key) *mSettingsComponentMockSelectSettings {
	if mmSelectSettings.mock.funcSelectSettings != nil {
		mmSelectSettings.mock.t.Fatalf("SettingsComponentMock.SelectSettings mock is already set by Set")
	}

	if mmSelectSettings.defaultExpectation == nil {
		mmSelectSettings.defaultExpectation = &SettingsComponentMockSelectSettingsExpectation{}
	}

	if mmSelectSettings.defaultExpectation.params != nil {
		mmSelectSettings.mock.t.Fatalf("SettingsComponentMock.SelectSettings mock is already set by Expect")
	}

	if mmSelectSettings.defaultExpectation.paramPtrs == nil {
		mmSelectSettings.defaultExpectation.paramPtrs = &SettingsComponentMockSelectSettingsParamPtrs{}
	}
	mmSelectSettings.defaultExpectation.paramPtrs.key = &key
	mmSelectSettings.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSelectSettings
}

// ExpectValueParam4 sets up expected param value for SettingsComponent.SelectSettings
func (mmSelectSettings *mSettingsComponentMockSelectSettings) ExpectValueParam4(value string) *mSettingsComponentMockSelectSettings {
	if mmSelectSettings.mock.funcSelectSettings != nil {
		mmSelectSettings.mock.t.Fatalf("SettingsComponentMock.SelectSettings mock is already set by Set")
	}

	if mmSelectSettings.defaultExpectation == nil {
		mmSelectSettings.defaultExpectation = &SettingsComponentMockSelectSettingsExpectation{}
	}

	if mmSelectSettings.defaultExpectation.params != nil {
		mmSelectSettings.mock.t.Fatalf("SettingsComponentMock.SelectSettings mock is already set by Expect")
	}

	if mmSelectSettings.defaultExpectation.paramPtrs == nil {
		mmSelectSettings.defaultExpectation.paramPtrs = &SettingsComponentMockSelectSettingsParamPtrs{}
	}
	mmSelectSettings.defaultExpectation.paramPtrs.value = &value
	mmSelectSettings.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSelectSettings
}

// Inspect accepts an inspector function that has same arguments as the SettingsComponent.SelectSettings
func (mmSelectSettings *mSettingsComponentMockSelectSettings) Inspect(f func(ctx context.Context, title trigger.Title, key storage.Key, value string)) *mSettingsComponentMockSelectSettings {
	if mmSelectSettings.mock.inspectFuncSelectSettings != nil {
		mmSelectSettings.mock.t.Fatalf("Inspect function is already set for SettingsComponentMock.SelectSettings")
	}

	mmSelectSettings.mock.inspectFuncSelectSettings = f

	return mmSelectSettings
}

// Return sets up results that will be returned by SettingsComponent.SelectSettings
func (mmSelectSettings *mSettingsComponentMockSelectSettings) Return(err error) *SettingsComponentMock {
	if mmSelectSettings.mock.funcSelectSettings != nil {
		mmSelectSettings.mock.t.Fatalf("SettingsComponentMock.SelectSettings mock is already set by Set")
	}

	if mmSelectSettings.defaultExpectation == nil {
		mmSelectSettings.defaultExpectation = &SettingsComponentMockSelectSettingsExpectation{mock: mmSelectSettings.mock}
	}
	mmSelectSettings.defaultExpectation.results = &SettingsComponentMockSelectSettingsResults{err}
	mmSelectSettings.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectSettings.mock
}

// Set uses given function f to mock the SettingsComponent.SelectSettings method
func (mmSelectSettings *mSettingsComponentMockSelectSettings) Set(f func(ctx context.Context, title trigger.Title, key storage.Key, value string) (err error)) *SettingsComponentMock {
	if mmSelectSettings.defaultExpectation != nil {
		mmSelectSettings.mock.t.Fatalf("Default expectation is already set for the SettingsComponent.SelectSettings method")
	}

	if len(mmSelectSettings.expectations) > 0 {
		mmSelectSettings.mock.t.Fatalf("Some expectations are already set for the SettingsComponent.SelectSettings method")
	}

	mmSelectSettings.mock.funcSelectSettings = f
	mmSelectSettings.mock.funcSelectSettingsOrigin = minimock.CallerInfo(1)
	return mmSelectSettings.mock
}

// When sets expectation for the SettingsComponent.SelectSettings which will trigger the result defined by the following
// Then helper
func (mmSelectSettings *mSettingsComponentMockSelectSettings) When(ctx context.Context, title trigger.Title, key storage.Key, value string) *SettingsComponentMockSelectSettingsExpectation {
	if mmSelectSettings.mock.funcSelectSettings != nil {
		mmSelectSettings.mock.t.Fatalf("SettingsComponentMock.SelectSettings mock is already set by Set")
	}

	expectation := &SettingsComponentMockSelectSettingsExpectation{
		mock:               mmSelectSettings.mock,
		params:             &SettingsComponentMockSelectSettingsParams{ctx, title, key, value},
		expectationOrigins: SettingsComponentMockSelectSettingsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectSettings.expectations = append(mmSelectSettings.expectations, expectation)
	return expectation
}

// Then sets up SettingsComponent.SelectSettings return parameters for the expectation previously defined by the When method
func (e *SettingsComponentMockSelectSettingsExpectation) Then(err error) *SettingsComponentMock {
	e.results = &SettingsComponentMockSelectSettingsResults{err}
	return e.mock
}

// Times sets number of times SettingsComponent.SelectSettings should be invoked
func (mmSelectSettings *mSettingsComponentMockSelectSettings) Times(n uint64) *mSettingsComponentMockSelectSettings {
	if n == 0 {
		mmSelectSettings.mock.t.Fatalf("Times of SettingsComponentMock.SelectSettings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectSettings.expectedInvocations, n)
	mmSelectSettings.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectSettings
}

func (mmSelectSettings *mSettingsComponentMockSelectSettings) invocationsDone() bool {
	if len(mmSelectSettings.expectations) == 0 && mmSelectSettings.defaultExpectation == nil && mmSelectSettings.mock.funcSelectSettings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectSettings.mock.afterSelectSettingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectSettings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectSettings implements SettingsComponent
func (mmSelectSettings *SettingsComponentMock) SelectSettings(ctx context.Context, title trigger.Title, key storage.Key, value string) (err error) {
	mm_atomic.AddUint64(&mmSelectSettings.beforeSelectSettingsCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectSettings.afterSelectSettingsCounter, 1)

	mmSelectSettings.t.Helper()

	if mmSelectSettings.inspectFuncSelectSettings != nil {
		mmSelectSettings.inspectFuncSelectSettings(ctx, title, key, value)
	}

	mm_params := SettingsComponentMockSelectSettingsParams{ctx, title, key, value}

	// Record call args
	mmSelectSettings.SelectSettingsMock.mutex.Lock()
	mmSelectSettings.SelectSettingsMock.callArgs = append(mmSelectSettings.SelectSettingsMock.callArgs, &mm_params)
	mmSelectSettings.SelectSettingsMock.mutex.Unlock()

	for _, e := range mmSelectSettings.SelectSettingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectSettings.SelectSettingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectSettings.SelectSettingsMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectSettings.SelectSettingsMock.defaultExpectation.params
		mm_want_ptrs := mmSelectSettings.SelectSettingsMock.defaultExpectation.paramPtrs

		mm_got := SettingsComponentMockSelectSettingsParams{ctx, title, key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectSettings.t.Errorf("SettingsComponentMock.SelectSettings got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectSettings.SelectSettingsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.title != nil && !minimock.Equal(*mm_want_ptrs.title, mm_got.title) {
				mmSelectSettings.t.Errorf("SettingsComponentMock.SelectSettings got unexpected parameter title, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectSettings.SelectSettingsMock.defaultExpectation.expectationOrigins.originTitle, *mm_want_ptrs.title, mm_got.title, minimock.Diff(*mm_want_ptrs.title, mm_got.title))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSelectSettings.t.Errorf("SettingsComponentMock.SelectSettings got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectSettings.SelectSettingsMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSelectSettings.t.Errorf("SettingsComponentMock.SelectSettings got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectSettings.SelectSettingsMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectSettings.t.Errorf("SettingsComponentMock.SelectSettings got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectSettings.SelectSettingsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectSettings.SelectSettingsMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectSettings.t.Fatal("No results are set for the SettingsComponentMock.SelectSettings")
		}
		return (*mm_results).err
	}
	if mmSelectSettings.funcSelectSettings != nil {
		return mmSelectSettings.funcSelectSettings(ctx, title, key, value)
	}
	mmSelectSettings.t.Fatalf("Unexpected call to SettingsComponentMock.SelectSettings. %v %v %v %v", ctx, title, key, value)
	return
}

// SelectSettingsAfterCounter returns a count of finished SettingsComponentMock.SelectSettings invocations
func (mmSelectSettings *SettingsComponentMock) SelectSettingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectSettings.afterSelectSettingsCounter)
}

// SelectSettingsBeforeCounter returns a count of SettingsComponentMock.SelectSettings invocations
func (mmSelectSettings *SettingsComponentMock) SelectSettingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectSettings.beforeSelectSettingsCounter)
}

// Calls returns a list of arguments used in each call to SettingsComponentMock.SelectSettings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectSettings *mSettingsComponentMockSelectSettings) Calls() []*SettingsComponentMockSelectSettingsParams {
	mmSelectSettings.mutex.RLock()

	argCopy := make([]*SettingsComponentMockSelectSettingsParams, len(mmSelectSettings.callArgs))
	copy(argCopy, mmSelectSettings.callArgs)

	mmSelectSettings.mutex.RUnlock()

	return argCopy
}

// MinimockSelectSettingsDone returns true if the count of the SelectSettings invocations corresponds
// the number of defined expectations
func (m *SettingsComponentMock) MinimockSelectSettingsDone() bool {
	if m.SelectSettingsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectSettingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectSettingsMock.invocationsDone()
}

// MinimockSelectSettingsInspect logs each unmet expectation
func (m *SettingsComponentMock) MinimockSelectSettingsInspect() {
	for _, e := range m.SelectSettingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SettingsComponentMock.SelectSettings at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectSettingsCounter := mm_atomic.LoadUint64(&m.afterSelectSettingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectSettingsMock.defaultExpectation != nil && afterSelectSettingsCounter < 1 {
		if m.SelectSettingsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SettingsComponentMock.SelectSettings at\n%s", m.SelectSettingsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SettingsComponentMock.SelectSettings at\n%s with params: %#v", m.SelectSettingsMock.defaultExpectation.expectationOrigins.origin, *m.SelectSettingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectSettings != nil && afterSelectSettingsCounter < 1 {
		m.t.Errorf("Expected call to SettingsComponentMock.SelectSettings at\n%s", m.funcSelectSettingsOrigin)
	}

	if !m.SelectSettingsMock.invocationsDone() && afterSelectSettingsCounter > 0 {
		m.t.Errorf("Expected %d calls to SettingsComponentMock.SelectSettings at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectSettingsMock.expectedInvocations), m.SelectSettingsMock.expectedInvocationsOrigin, afterSelectSettingsCounter)
	}
}

type mSettingsComponentMockSelectedSetting struct {
	optional           bool
	mock               *SettingsComponentMock
	defaultExpectation *SettingsComponentMockSelectedSettingExpectation
	expectations       []*SettingsComponentMockSelectedSettingExpectation

	callArgs []*SettingsComponentMockSelectedSettingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SettingsComponentMockSelectedSettingExpectation specifies expectation struct of the SettingsComponent.SelectedSetting
type SettingsComponentMockSelectedSettingExpectation struct {
	mock               *SettingsComponentMock
	params             *SettingsComponentMockSelectedSettingParams
	paramPtrs          *SettingsComponentMockSelectedSettingParamPtrs
	expectationOrigins SettingsComponentMockSelectedSettingExpectationOrigins
	results            *SettingsComponentMockSelectedSettingResults
	returnOrigin       string
	Counter            uint64
}

// SettingsComponentMockSelectedSettingParams contains parameters of the SettingsComponent.SelectedSetting
type SettingsComponentMockSelectedSettingParams struct {
	ctx context.Context
	key storage.Key
}

// SettingsComponentMockSelectedSettingParamPtrs contains pointers to parameters of the SettingsComponent.SelectedSetting
type SettingsComponentMockSelectedSettingParamPtrs struct {
	ctx *context.Context
	key *storage.Key
}

// SettingsComponentMockSelectedSettingResults contains results of the SettingsComponent.SelectedSetting
type SettingsComponentMockSelectedSettingResults struct {
	s1  string
	err error
}

// SettingsComponentMockSelectedSettingOrigins contains origins of expectations of the SettingsComponent.SelectedSetting
type SettingsComponentMockSelectedSettingExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedSetting *mSettingsComponentMockSelectedSetting) Optional() *mSettingsComponentMockSelectedSetting {
	mmSelectedSetting.optional = true
	return mmSelectedSetting
}

// Expect sets up expected params for SettingsComponent.SelectedSetting
func (mmSelectedSetting *mSettingsComponentMockSelectedSetting) Expect(ctx context.Context, key storage.Key) *mSettingsComponentMockSelectedSetting {
	if mmSelectedSetting.mock.funcSelectedSetting != nil {
		mmSelectedSetting.mock.t.Fatalf("SettingsComponentMock.SelectedSetting mock is already set by Set")
	}

	if mmSelectedSetting.defaultExpectation == nil {
		mmSelectedSetting.defaultExpectation = &SettingsComponentMockSelectedSettingExpectation{}
	}

	if mmSelectedSetting.defaultExpectation.paramPtrs != nil {
		mmSelectedSetting.mock.t.Fatalf("SettingsComponentMock.SelectedSetting mock is already set by ExpectParams functions")
	}

	mmSelectedSetting.defaultExpectation.params = &SettingsComponentMockSelectedSettingParams{ctx, key}
	mmSelectedSetting.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedSetting.expectations {
		if minimock.Equal(e.params, mmSelectedSetting.defaultExpectation.params) {
			mmSelectedSetting.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedSetting.defaultExpectation.params)
		}
	}

	return mmSelectedSetting
}

// ExpectCtxParam1 sets up expected param ctx for SettingsComponent.SelectedSetting
func (mmSelectedSetting *mSettingsComponentMockSelectedSetting) ExpectCtxParam1(ctx context.Context) *mSettingsComponentMockSelectedSetting {
	if mmSelectedSetting.mock.funcSelectedSetting != nil {
		mmSelectedSetting.mock.t.Fatalf("SettingsComponentMock.SelectedSetting mock is already set by Set")
	}

	if mmSelectedSetting.defaultExpectation == nil {
		mmSelectedSetting.defaultExpectation = &SettingsComponentMockSelectedSettingExpectation{}
	}

	if mmSelectedSetting.defaultExpectation.params != nil {
		mmSelectedSetting.mock.t.Fatalf("SettingsComponentMock.SelectedSetting mock is already set by Expect")
	}

	if mmSelectedSetting.defaultExpectation.paramPtrs == nil {
		mmSelectedSetting.defaultExpectation.paramPtrs = &SettingsComponentMockSelectedSettingParamPtrs{}
	}
	mmSelectedSetting.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedSetting.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedSetting
}

// ExpectKeyParam2 sets up expected param key for SettingsComponent.SelectedSetting
func (mmSelectedSetting *mSettingsComponentMockSelectedSetting) ExpectKeyParam2(key storage.Key) *mSettingsComponentMockSelectedSetting {
	if mmSelectedSetting.mock.funcSelectedSetting != nil {
		mmSelectedSetting.mock.t.Fatalf("SettingsComponentMock.SelectedSetting mock is already set by Set")
	}

	if mmSelectedSetting.defaultExpectation == nil {
		mmSelectedSetting.defaultExpectation = &SettingsComponentMockSelectedSettingExpectation{}
	}

	if mmSelectedSetting.defaultExpectation.params != nil {
		mmSelectedSetting.mock.t.Fatalf("SettingsComponentMock.SelectedSetting mock is already set by Expect")
	}

	if mmSelectedSetting.defaultExpectation.paramPtrs == nil {
		mmSelectedSetting.defaultExpectation.paramPtrs = &SettingsComponentMockSelectedSettingParamPtrs{}
	}
	mmSelectedSetting.defaultExpectation.paramPtrs.key = &key
	mmSelectedSetting.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSelectedSetting
}

// Inspect accepts an inspector function that has same arguments as the SettingsComponent.SelectedSetting
func (mmSelectedSetting *mSettingsComponentMockSelectedSetting) Inspect(f func(ctx context.Context, key storage.Key)) *mSettingsComponentMockSelectedSetting {
	if mmSelectedSetting.mock.inspectFuncSelectedSetting != nil {
		mmSelectedSetting.mock.t.Fatalf("Inspect function is already set for SettingsComponentMock.SelectedSetting")
	}

	mmSelectedSetting.mock.inspectFuncSelectedSetting = f

	return mmSelectedSetting
}

// Return sets up results that will be returned by SettingsComponent.SelectedSetting
func (mmSelectedSetting *mSettingsComponentMockSelectedSetting) Return(s1 string, err error) *SettingsComponentMock {
	if mmSelectedSetting.mock.funcSelectedSetting != nil {
		mmSelectedSetting.mock.t.Fatalf("SettingsComponentMock.SelectedSetting mock is already set by Set")
	}

	if mmSelectedSetting.defaultExpectation == nil {
		mmSelectedSetting.defaultExpectation = &SettingsComponentMockSelectedSettingExpectation{mock: mmSelectedSetting.mock}
	}
	mmSelectedSetting.defaultExpectation.results = &SettingsComponentMockSelectedSettingResults{s1, err}
	mmSelectedSetting.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedSetting.mock
}

// Set uses given function f to mock the SettingsComponent.SelectedSetting method
func (mmSelectedSetting *mSettingsComponentMockSelectedSetting) Set(f func(ctx context.Context, key storage.Key) (s1 string, err error)) *SettingsComponentMock {
	if mmSelectedSetting.defaultExpectation != nil {
		mmSelectedSetting.mock.t.Fatalf("Default expectation is already set for the SettingsComponent.SelectedSetting method")
	}

	if len(mmSelectedSetting.expectations) > 0 {
		mmSelectedSetting.mock.t.Fatalf("Some expectations are already set for the SettingsComponent.SelectedSetting method")
	}

	mmSelectedSetting.mock.funcSelectedSetting = f
	mmSelectedSetting.mock.funcSelectedSettingOrigin = minimock.CallerInfo(1)
	return mmSelectedSetting.mock
}

// When sets expectation for the SettingsComponent.SelectedSetting which will trigger the result defined by the following
// Then helper
func (mmSelectedSetting *mSettingsComponentMockSelectedSetting) When(ctx context.Context, key storage.Key) *SettingsComponentMockSelectedSettingExpectation {
	if mmSelectedSetting.mock.funcSelectedSetting != nil {
		mmSelectedSetting.mock.t.Fatalf("SettingsComponentMock.SelectedSetting mock is already set by Set")
	}

	expectation := &SettingsComponentMockSelectedSettingExpectation{
		mock:               mmSelectedSetting.mock,
		params:             &SettingsComponentMockSelectedSettingParams{ctx, key},
		expectationOrigins: SettingsComponentMockSelectedSettingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedSetting.expectations = append(mmSelectedSetting.expectations, expectation)
	return expectation
}

// Then sets up SettingsComponent.SelectedSetting return parameters for the expectation previously defined by the When method
func (e *SettingsComponentMockSelectedSettingExpectation) Then(s1 string, err error) *SettingsComponentMock {
	e.results = &SettingsComponentMockSelectedSettingResults{s1, err}
	return e.mock
}

// Times sets number of times SettingsComponent.SelectedSetting should be invoked
func (mmSelectedSetting *mSettingsComponentMockSelectedSetting) Times(n uint64) *mSettingsComponentMockSelectedSetting {
	if n == 0 {
		mmSelectedSetting.mock.t.Fatalf("Times of SettingsComponentMock.SelectedSetting mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedSetting.expectedInvocations, n)
	mmSelectedSetting.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedSetting
}

func (mmSelectedSetting *mSettingsComponentMockSelectedSetting) invocationsDone() bool {
	if len(mmSelectedSetting.expectations) == 0 && mmSelectedSetting.defaultExpectation == nil && mmSelectedSetting.mock.funcSelectedSetting == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedSetting.mock.afterSelectedSettingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedSetting.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedSetting implements SettingsComponent
func (mmSelectedSetting *SettingsComponentMock) SelectedSetting(ctx context.Context, key storage.Key) (s1 string, err error) {
	mm_atomic.AddUint64(&mmSelectedSetting.beforeSelectedSettingCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedSetting.afterSelectedSettingCounter, 1)

	mmSelectedSetting.t.Helper()

	if mmSelectedSetting.inspectFuncSelectedSetting != nil {
		mmSelectedSetting.inspectFuncSelectedSetting(ctx, key)
	}

	mm_params := SettingsComponentMockSelectedSettingParams{ctx, key}

	// Record call args
	mmSelectedSetting.SelectedSettingMock.mutex.Lock()
	mmSelectedSetting.SelectedSettingMock.callArgs = append(mmSelectedSetting.SelectedSettingMock.callArgs, &mm_params)
	mmSelectedSetting.SelectedSettingMock.mutex.Unlock()

	for _, e := range mmSelectedSetting.SelectedSettingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmSelectedSetting.SelectedSettingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedSetting.SelectedSettingMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedSetting.SelectedSettingMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedSetting.SelectedSettingMock.defaultExpectation.paramPtrs

		mm_got := SettingsComponentMockSelectedSettingParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedSetting.t.Errorf("SettingsComponentMock.SelectedSetting got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedSetting.SelectedSettingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSelectedSetting.t.Errorf("SettingsComponentMock.SelectedSetting got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedSetting.SelectedSettingMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedSetting.t.Errorf("SettingsComponentMock.SelectedSetting got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedSetting.SelectedSettingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedSetting.SelectedSettingMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedSetting.t.Fatal("No results are set for the SettingsComponentMock.SelectedSetting")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmSelectedSetting.funcSelectedSetting != nil {
		return mmSelectedSetting.funcSelectedSetting(ctx, key)
	}
	mmSelectedSetting.t.Fatalf("Unexpected call to SettingsComponentMock.SelectedSetting. %v %v", ctx, key)
	return
}

// SelectedSettingAfterCounter returns a count of finished SettingsComponentMock.SelectedSetting invocations
func (mmSelectedSetting *SettingsComponentMock) SelectedSettingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedSetting.afterSelectedSettingCounter)
}

// SelectedSettingBeforeCounter returns a count of SettingsComponentMock.SelectedSetting invocations
func (mmSelectedSetting *SettingsComponentMock) SelectedSettingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedSetting.beforeSelectedSettingCounter)
}

// Calls returns a list of arguments used in each call to SettingsComponentMock.SelectedSetting.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedSetting *mSettingsComponentMockSelectedSetting) Calls() []*SettingsComponentMockSelectedSettingParams {
	mmSelectedSetting.mutex.RLock()

	argCopy := make([]*SettingsComponentMockSelectedSettingParams, len(mmSelectedSetting.callArgs))
	copy(argCopy, mmSelectedSetting.callArgs)

	mmSelectedSetting.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedSettingDone returns true if the count of the SelectedSetting invocations corresponds
// the number of defined expectations
func (m *SettingsComponentMock) MinimockSelectedSettingDone() bool {
	if m.SelectedSettingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedSettingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedSettingMock.invocationsDone()
}

// MinimockSelectedSettingInspect logs each unmet expectation
func (m *SettingsComponentMock) MinimockSelectedSettingInspect() {
	for _, e := range m.SelectedSettingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SettingsComponentMock.SelectedSetting at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedSettingCounter := mm_atomic.LoadUint64(&m.afterSelectedSettingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedSettingMock.defaultExpectation != nil && afterSelectedSettingCounter < 1 {
		if m.SelectedSettingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SettingsComponentMock.SelectedSetting at\n%s", m.SelectedSettingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SettingsComponentMock.SelectedSetting at\n%s with params: %#v", m.SelectedSettingMock.defaultExpectation.expectationOrigins.origin, *m.SelectedSettingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedSetting != nil && afterSelectedSettingCounter < 1 {
		m.t.Errorf("Expected call to SettingsComponentMock.SelectedSetting at\n%s", m.funcSelectedSettingOrigin)
	}

	if !m.SelectedSettingMock.invocationsDone() && afterSelectedSettingCounter > 0 {
		m.t.Errorf("Expected %d calls to SettingsComponentMock.SelectedSetting at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedSettingMock.expectedInvocations), m.SelectedSettingMock.expectedInvocationsOrigin, afterSelectedSettingCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SettingsComponentMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockSelectSettingsInspect()

			m.MinimockSelectedSettingInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SettingsComponentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SettingsComponentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockSelectSettingsDone() &&
		m.MinimockSelectedSettingDone()
}
