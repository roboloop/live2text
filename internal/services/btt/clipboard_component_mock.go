// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package btt

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClipboardComponentMock implements ClipboardComponent
type ClipboardComponentMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcHideClipboard          func(ctx context.Context) (err error)
	funcHideClipboardOrigin    string
	inspectFuncHideClipboard   func(ctx context.Context)
	afterHideClipboardCounter  uint64
	beforeHideClipboardCounter uint64
	HideClipboardMock          mClipboardComponentMockHideClipboard

	funcSelectClipboard          func(ctx context.Context, clipboard Clipboard) (err error)
	funcSelectClipboardOrigin    string
	inspectFuncSelectClipboard   func(ctx context.Context, clipboard Clipboard)
	afterSelectClipboardCounter  uint64
	beforeSelectClipboardCounter uint64
	SelectClipboardMock          mClipboardComponentMockSelectClipboard

	funcSelectedClipboard          func(ctx context.Context) (c2 Clipboard, err error)
	funcSelectedClipboardOrigin    string
	inspectFuncSelectedClipboard   func(ctx context.Context)
	afterSelectedClipboardCounter  uint64
	beforeSelectedClipboardCounter uint64
	SelectedClipboardMock          mClipboardComponentMockSelectedClipboard

	funcShowClipboard          func(ctx context.Context) (err error)
	funcShowClipboardOrigin    string
	inspectFuncShowClipboard   func(ctx context.Context)
	afterShowClipboardCounter  uint64
	beforeShowClipboardCounter uint64
	ShowClipboardMock          mClipboardComponentMockShowClipboard
}

// NewClipboardComponentMock returns a mock for ClipboardComponent
func NewClipboardComponentMock(t minimock.Tester) *ClipboardComponentMock {
	m := &ClipboardComponentMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.HideClipboardMock = mClipboardComponentMockHideClipboard{mock: m}
	m.HideClipboardMock.callArgs = []*ClipboardComponentMockHideClipboardParams{}

	m.SelectClipboardMock = mClipboardComponentMockSelectClipboard{mock: m}
	m.SelectClipboardMock.callArgs = []*ClipboardComponentMockSelectClipboardParams{}

	m.SelectedClipboardMock = mClipboardComponentMockSelectedClipboard{mock: m}
	m.SelectedClipboardMock.callArgs = []*ClipboardComponentMockSelectedClipboardParams{}

	m.ShowClipboardMock = mClipboardComponentMockShowClipboard{mock: m}
	m.ShowClipboardMock.callArgs = []*ClipboardComponentMockShowClipboardParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClipboardComponentMockHideClipboard struct {
	optional           bool
	mock               *ClipboardComponentMock
	defaultExpectation *ClipboardComponentMockHideClipboardExpectation
	expectations       []*ClipboardComponentMockHideClipboardExpectation

	callArgs []*ClipboardComponentMockHideClipboardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClipboardComponentMockHideClipboardExpectation specifies expectation struct of the ClipboardComponent.HideClipboard
type ClipboardComponentMockHideClipboardExpectation struct {
	mock               *ClipboardComponentMock
	params             *ClipboardComponentMockHideClipboardParams
	paramPtrs          *ClipboardComponentMockHideClipboardParamPtrs
	expectationOrigins ClipboardComponentMockHideClipboardExpectationOrigins
	results            *ClipboardComponentMockHideClipboardResults
	returnOrigin       string
	Counter            uint64
}

// ClipboardComponentMockHideClipboardParams contains parameters of the ClipboardComponent.HideClipboard
type ClipboardComponentMockHideClipboardParams struct {
	ctx context.Context
}

// ClipboardComponentMockHideClipboardParamPtrs contains pointers to parameters of the ClipboardComponent.HideClipboard
type ClipboardComponentMockHideClipboardParamPtrs struct {
	ctx *context.Context
}

// ClipboardComponentMockHideClipboardResults contains results of the ClipboardComponent.HideClipboard
type ClipboardComponentMockHideClipboardResults struct {
	err error
}

// ClipboardComponentMockHideClipboardOrigins contains origins of expectations of the ClipboardComponent.HideClipboard
type ClipboardComponentMockHideClipboardExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHideClipboard *mClipboardComponentMockHideClipboard) Optional() *mClipboardComponentMockHideClipboard {
	mmHideClipboard.optional = true
	return mmHideClipboard
}

// Expect sets up expected params for ClipboardComponent.HideClipboard
func (mmHideClipboard *mClipboardComponentMockHideClipboard) Expect(ctx context.Context) *mClipboardComponentMockHideClipboard {
	if mmHideClipboard.mock.funcHideClipboard != nil {
		mmHideClipboard.mock.t.Fatalf("ClipboardComponentMock.HideClipboard mock is already set by Set")
	}

	if mmHideClipboard.defaultExpectation == nil {
		mmHideClipboard.defaultExpectation = &ClipboardComponentMockHideClipboardExpectation{}
	}

	if mmHideClipboard.defaultExpectation.paramPtrs != nil {
		mmHideClipboard.mock.t.Fatalf("ClipboardComponentMock.HideClipboard mock is already set by ExpectParams functions")
	}

	mmHideClipboard.defaultExpectation.params = &ClipboardComponentMockHideClipboardParams{ctx}
	mmHideClipboard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHideClipboard.expectations {
		if minimock.Equal(e.params, mmHideClipboard.defaultExpectation.params) {
			mmHideClipboard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHideClipboard.defaultExpectation.params)
		}
	}

	return mmHideClipboard
}

// ExpectCtxParam1 sets up expected param ctx for ClipboardComponent.HideClipboard
func (mmHideClipboard *mClipboardComponentMockHideClipboard) ExpectCtxParam1(ctx context.Context) *mClipboardComponentMockHideClipboard {
	if mmHideClipboard.mock.funcHideClipboard != nil {
		mmHideClipboard.mock.t.Fatalf("ClipboardComponentMock.HideClipboard mock is already set by Set")
	}

	if mmHideClipboard.defaultExpectation == nil {
		mmHideClipboard.defaultExpectation = &ClipboardComponentMockHideClipboardExpectation{}
	}

	if mmHideClipboard.defaultExpectation.params != nil {
		mmHideClipboard.mock.t.Fatalf("ClipboardComponentMock.HideClipboard mock is already set by Expect")
	}

	if mmHideClipboard.defaultExpectation.paramPtrs == nil {
		mmHideClipboard.defaultExpectation.paramPtrs = &ClipboardComponentMockHideClipboardParamPtrs{}
	}
	mmHideClipboard.defaultExpectation.paramPtrs.ctx = &ctx
	mmHideClipboard.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHideClipboard
}

// Inspect accepts an inspector function that has same arguments as the ClipboardComponent.HideClipboard
func (mmHideClipboard *mClipboardComponentMockHideClipboard) Inspect(f func(ctx context.Context)) *mClipboardComponentMockHideClipboard {
	if mmHideClipboard.mock.inspectFuncHideClipboard != nil {
		mmHideClipboard.mock.t.Fatalf("Inspect function is already set for ClipboardComponentMock.HideClipboard")
	}

	mmHideClipboard.mock.inspectFuncHideClipboard = f

	return mmHideClipboard
}

// Return sets up results that will be returned by ClipboardComponent.HideClipboard
func (mmHideClipboard *mClipboardComponentMockHideClipboard) Return(err error) *ClipboardComponentMock {
	if mmHideClipboard.mock.funcHideClipboard != nil {
		mmHideClipboard.mock.t.Fatalf("ClipboardComponentMock.HideClipboard mock is already set by Set")
	}

	if mmHideClipboard.defaultExpectation == nil {
		mmHideClipboard.defaultExpectation = &ClipboardComponentMockHideClipboardExpectation{mock: mmHideClipboard.mock}
	}
	mmHideClipboard.defaultExpectation.results = &ClipboardComponentMockHideClipboardResults{err}
	mmHideClipboard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHideClipboard.mock
}

// Set uses given function f to mock the ClipboardComponent.HideClipboard method
func (mmHideClipboard *mClipboardComponentMockHideClipboard) Set(f func(ctx context.Context) (err error)) *ClipboardComponentMock {
	if mmHideClipboard.defaultExpectation != nil {
		mmHideClipboard.mock.t.Fatalf("Default expectation is already set for the ClipboardComponent.HideClipboard method")
	}

	if len(mmHideClipboard.expectations) > 0 {
		mmHideClipboard.mock.t.Fatalf("Some expectations are already set for the ClipboardComponent.HideClipboard method")
	}

	mmHideClipboard.mock.funcHideClipboard = f
	mmHideClipboard.mock.funcHideClipboardOrigin = minimock.CallerInfo(1)
	return mmHideClipboard.mock
}

// When sets expectation for the ClipboardComponent.HideClipboard which will trigger the result defined by the following
// Then helper
func (mmHideClipboard *mClipboardComponentMockHideClipboard) When(ctx context.Context) *ClipboardComponentMockHideClipboardExpectation {
	if mmHideClipboard.mock.funcHideClipboard != nil {
		mmHideClipboard.mock.t.Fatalf("ClipboardComponentMock.HideClipboard mock is already set by Set")
	}

	expectation := &ClipboardComponentMockHideClipboardExpectation{
		mock:               mmHideClipboard.mock,
		params:             &ClipboardComponentMockHideClipboardParams{ctx},
		expectationOrigins: ClipboardComponentMockHideClipboardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHideClipboard.expectations = append(mmHideClipboard.expectations, expectation)
	return expectation
}

// Then sets up ClipboardComponent.HideClipboard return parameters for the expectation previously defined by the When method
func (e *ClipboardComponentMockHideClipboardExpectation) Then(err error) *ClipboardComponentMock {
	e.results = &ClipboardComponentMockHideClipboardResults{err}
	return e.mock
}

// Times sets number of times ClipboardComponent.HideClipboard should be invoked
func (mmHideClipboard *mClipboardComponentMockHideClipboard) Times(n uint64) *mClipboardComponentMockHideClipboard {
	if n == 0 {
		mmHideClipboard.mock.t.Fatalf("Times of ClipboardComponentMock.HideClipboard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHideClipboard.expectedInvocations, n)
	mmHideClipboard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHideClipboard
}

func (mmHideClipboard *mClipboardComponentMockHideClipboard) invocationsDone() bool {
	if len(mmHideClipboard.expectations) == 0 && mmHideClipboard.defaultExpectation == nil && mmHideClipboard.mock.funcHideClipboard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHideClipboard.mock.afterHideClipboardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHideClipboard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HideClipboard implements ClipboardComponent
func (mmHideClipboard *ClipboardComponentMock) HideClipboard(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmHideClipboard.beforeHideClipboardCounter, 1)
	defer mm_atomic.AddUint64(&mmHideClipboard.afterHideClipboardCounter, 1)

	mmHideClipboard.t.Helper()

	if mmHideClipboard.inspectFuncHideClipboard != nil {
		mmHideClipboard.inspectFuncHideClipboard(ctx)
	}

	mm_params := ClipboardComponentMockHideClipboardParams{ctx}

	// Record call args
	mmHideClipboard.HideClipboardMock.mutex.Lock()
	mmHideClipboard.HideClipboardMock.callArgs = append(mmHideClipboard.HideClipboardMock.callArgs, &mm_params)
	mmHideClipboard.HideClipboardMock.mutex.Unlock()

	for _, e := range mmHideClipboard.HideClipboardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHideClipboard.HideClipboardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHideClipboard.HideClipboardMock.defaultExpectation.Counter, 1)
		mm_want := mmHideClipboard.HideClipboardMock.defaultExpectation.params
		mm_want_ptrs := mmHideClipboard.HideClipboardMock.defaultExpectation.paramPtrs

		mm_got := ClipboardComponentMockHideClipboardParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHideClipboard.t.Errorf("ClipboardComponentMock.HideClipboard got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHideClipboard.HideClipboardMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHideClipboard.t.Errorf("ClipboardComponentMock.HideClipboard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHideClipboard.HideClipboardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHideClipboard.HideClipboardMock.defaultExpectation.results
		if mm_results == nil {
			mmHideClipboard.t.Fatal("No results are set for the ClipboardComponentMock.HideClipboard")
		}
		return (*mm_results).err
	}
	if mmHideClipboard.funcHideClipboard != nil {
		return mmHideClipboard.funcHideClipboard(ctx)
	}
	mmHideClipboard.t.Fatalf("Unexpected call to ClipboardComponentMock.HideClipboard. %v", ctx)
	return
}

// HideClipboardAfterCounter returns a count of finished ClipboardComponentMock.HideClipboard invocations
func (mmHideClipboard *ClipboardComponentMock) HideClipboardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHideClipboard.afterHideClipboardCounter)
}

// HideClipboardBeforeCounter returns a count of ClipboardComponentMock.HideClipboard invocations
func (mmHideClipboard *ClipboardComponentMock) HideClipboardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHideClipboard.beforeHideClipboardCounter)
}

// Calls returns a list of arguments used in each call to ClipboardComponentMock.HideClipboard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHideClipboard *mClipboardComponentMockHideClipboard) Calls() []*ClipboardComponentMockHideClipboardParams {
	mmHideClipboard.mutex.RLock()

	argCopy := make([]*ClipboardComponentMockHideClipboardParams, len(mmHideClipboard.callArgs))
	copy(argCopy, mmHideClipboard.callArgs)

	mmHideClipboard.mutex.RUnlock()

	return argCopy
}

// MinimockHideClipboardDone returns true if the count of the HideClipboard invocations corresponds
// the number of defined expectations
func (m *ClipboardComponentMock) MinimockHideClipboardDone() bool {
	if m.HideClipboardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HideClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HideClipboardMock.invocationsDone()
}

// MinimockHideClipboardInspect logs each unmet expectation
func (m *ClipboardComponentMock) MinimockHideClipboardInspect() {
	for _, e := range m.HideClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClipboardComponentMock.HideClipboard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHideClipboardCounter := mm_atomic.LoadUint64(&m.afterHideClipboardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HideClipboardMock.defaultExpectation != nil && afterHideClipboardCounter < 1 {
		if m.HideClipboardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClipboardComponentMock.HideClipboard at\n%s", m.HideClipboardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClipboardComponentMock.HideClipboard at\n%s with params: %#v", m.HideClipboardMock.defaultExpectation.expectationOrigins.origin, *m.HideClipboardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHideClipboard != nil && afterHideClipboardCounter < 1 {
		m.t.Errorf("Expected call to ClipboardComponentMock.HideClipboard at\n%s", m.funcHideClipboardOrigin)
	}

	if !m.HideClipboardMock.invocationsDone() && afterHideClipboardCounter > 0 {
		m.t.Errorf("Expected %d calls to ClipboardComponentMock.HideClipboard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HideClipboardMock.expectedInvocations), m.HideClipboardMock.expectedInvocationsOrigin, afterHideClipboardCounter)
	}
}

type mClipboardComponentMockSelectClipboard struct {
	optional           bool
	mock               *ClipboardComponentMock
	defaultExpectation *ClipboardComponentMockSelectClipboardExpectation
	expectations       []*ClipboardComponentMockSelectClipboardExpectation

	callArgs []*ClipboardComponentMockSelectClipboardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClipboardComponentMockSelectClipboardExpectation specifies expectation struct of the ClipboardComponent.SelectClipboard
type ClipboardComponentMockSelectClipboardExpectation struct {
	mock               *ClipboardComponentMock
	params             *ClipboardComponentMockSelectClipboardParams
	paramPtrs          *ClipboardComponentMockSelectClipboardParamPtrs
	expectationOrigins ClipboardComponentMockSelectClipboardExpectationOrigins
	results            *ClipboardComponentMockSelectClipboardResults
	returnOrigin       string
	Counter            uint64
}

// ClipboardComponentMockSelectClipboardParams contains parameters of the ClipboardComponent.SelectClipboard
type ClipboardComponentMockSelectClipboardParams struct {
	ctx       context.Context
	clipboard Clipboard
}

// ClipboardComponentMockSelectClipboardParamPtrs contains pointers to parameters of the ClipboardComponent.SelectClipboard
type ClipboardComponentMockSelectClipboardParamPtrs struct {
	ctx       *context.Context
	clipboard *Clipboard
}

// ClipboardComponentMockSelectClipboardResults contains results of the ClipboardComponent.SelectClipboard
type ClipboardComponentMockSelectClipboardResults struct {
	err error
}

// ClipboardComponentMockSelectClipboardOrigins contains origins of expectations of the ClipboardComponent.SelectClipboard
type ClipboardComponentMockSelectClipboardExpectationOrigins struct {
	origin          string
	originCtx       string
	originClipboard string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectClipboard *mClipboardComponentMockSelectClipboard) Optional() *mClipboardComponentMockSelectClipboard {
	mmSelectClipboard.optional = true
	return mmSelectClipboard
}

// Expect sets up expected params for ClipboardComponent.SelectClipboard
func (mmSelectClipboard *mClipboardComponentMockSelectClipboard) Expect(ctx context.Context, clipboard Clipboard) *mClipboardComponentMockSelectClipboard {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectClipboard mock is already set by Set")
	}

	if mmSelectClipboard.defaultExpectation == nil {
		mmSelectClipboard.defaultExpectation = &ClipboardComponentMockSelectClipboardExpectation{}
	}

	if mmSelectClipboard.defaultExpectation.paramPtrs != nil {
		mmSelectClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectClipboard mock is already set by ExpectParams functions")
	}

	mmSelectClipboard.defaultExpectation.params = &ClipboardComponentMockSelectClipboardParams{ctx, clipboard}
	mmSelectClipboard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectClipboard.expectations {
		if minimock.Equal(e.params, mmSelectClipboard.defaultExpectation.params) {
			mmSelectClipboard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectClipboard.defaultExpectation.params)
		}
	}

	return mmSelectClipboard
}

// ExpectCtxParam1 sets up expected param ctx for ClipboardComponent.SelectClipboard
func (mmSelectClipboard *mClipboardComponentMockSelectClipboard) ExpectCtxParam1(ctx context.Context) *mClipboardComponentMockSelectClipboard {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectClipboard mock is already set by Set")
	}

	if mmSelectClipboard.defaultExpectation == nil {
		mmSelectClipboard.defaultExpectation = &ClipboardComponentMockSelectClipboardExpectation{}
	}

	if mmSelectClipboard.defaultExpectation.params != nil {
		mmSelectClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectClipboard mock is already set by Expect")
	}

	if mmSelectClipboard.defaultExpectation.paramPtrs == nil {
		mmSelectClipboard.defaultExpectation.paramPtrs = &ClipboardComponentMockSelectClipboardParamPtrs{}
	}
	mmSelectClipboard.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectClipboard.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectClipboard
}

// ExpectClipboardParam2 sets up expected param clipboard for ClipboardComponent.SelectClipboard
func (mmSelectClipboard *mClipboardComponentMockSelectClipboard) ExpectClipboardParam2(clipboard Clipboard) *mClipboardComponentMockSelectClipboard {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectClipboard mock is already set by Set")
	}

	if mmSelectClipboard.defaultExpectation == nil {
		mmSelectClipboard.defaultExpectation = &ClipboardComponentMockSelectClipboardExpectation{}
	}

	if mmSelectClipboard.defaultExpectation.params != nil {
		mmSelectClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectClipboard mock is already set by Expect")
	}

	if mmSelectClipboard.defaultExpectation.paramPtrs == nil {
		mmSelectClipboard.defaultExpectation.paramPtrs = &ClipboardComponentMockSelectClipboardParamPtrs{}
	}
	mmSelectClipboard.defaultExpectation.paramPtrs.clipboard = &clipboard
	mmSelectClipboard.defaultExpectation.expectationOrigins.originClipboard = minimock.CallerInfo(1)

	return mmSelectClipboard
}

// Inspect accepts an inspector function that has same arguments as the ClipboardComponent.SelectClipboard
func (mmSelectClipboard *mClipboardComponentMockSelectClipboard) Inspect(f func(ctx context.Context, clipboard Clipboard)) *mClipboardComponentMockSelectClipboard {
	if mmSelectClipboard.mock.inspectFuncSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("Inspect function is already set for ClipboardComponentMock.SelectClipboard")
	}

	mmSelectClipboard.mock.inspectFuncSelectClipboard = f

	return mmSelectClipboard
}

// Return sets up results that will be returned by ClipboardComponent.SelectClipboard
func (mmSelectClipboard *mClipboardComponentMockSelectClipboard) Return(err error) *ClipboardComponentMock {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectClipboard mock is already set by Set")
	}

	if mmSelectClipboard.defaultExpectation == nil {
		mmSelectClipboard.defaultExpectation = &ClipboardComponentMockSelectClipboardExpectation{mock: mmSelectClipboard.mock}
	}
	mmSelectClipboard.defaultExpectation.results = &ClipboardComponentMockSelectClipboardResults{err}
	mmSelectClipboard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectClipboard.mock
}

// Set uses given function f to mock the ClipboardComponent.SelectClipboard method
func (mmSelectClipboard *mClipboardComponentMockSelectClipboard) Set(f func(ctx context.Context, clipboard Clipboard) (err error)) *ClipboardComponentMock {
	if mmSelectClipboard.defaultExpectation != nil {
		mmSelectClipboard.mock.t.Fatalf("Default expectation is already set for the ClipboardComponent.SelectClipboard method")
	}

	if len(mmSelectClipboard.expectations) > 0 {
		mmSelectClipboard.mock.t.Fatalf("Some expectations are already set for the ClipboardComponent.SelectClipboard method")
	}

	mmSelectClipboard.mock.funcSelectClipboard = f
	mmSelectClipboard.mock.funcSelectClipboardOrigin = minimock.CallerInfo(1)
	return mmSelectClipboard.mock
}

// When sets expectation for the ClipboardComponent.SelectClipboard which will trigger the result defined by the following
// Then helper
func (mmSelectClipboard *mClipboardComponentMockSelectClipboard) When(ctx context.Context, clipboard Clipboard) *ClipboardComponentMockSelectClipboardExpectation {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectClipboard mock is already set by Set")
	}

	expectation := &ClipboardComponentMockSelectClipboardExpectation{
		mock:               mmSelectClipboard.mock,
		params:             &ClipboardComponentMockSelectClipboardParams{ctx, clipboard},
		expectationOrigins: ClipboardComponentMockSelectClipboardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectClipboard.expectations = append(mmSelectClipboard.expectations, expectation)
	return expectation
}

// Then sets up ClipboardComponent.SelectClipboard return parameters for the expectation previously defined by the When method
func (e *ClipboardComponentMockSelectClipboardExpectation) Then(err error) *ClipboardComponentMock {
	e.results = &ClipboardComponentMockSelectClipboardResults{err}
	return e.mock
}

// Times sets number of times ClipboardComponent.SelectClipboard should be invoked
func (mmSelectClipboard *mClipboardComponentMockSelectClipboard) Times(n uint64) *mClipboardComponentMockSelectClipboard {
	if n == 0 {
		mmSelectClipboard.mock.t.Fatalf("Times of ClipboardComponentMock.SelectClipboard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectClipboard.expectedInvocations, n)
	mmSelectClipboard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectClipboard
}

func (mmSelectClipboard *mClipboardComponentMockSelectClipboard) invocationsDone() bool {
	if len(mmSelectClipboard.expectations) == 0 && mmSelectClipboard.defaultExpectation == nil && mmSelectClipboard.mock.funcSelectClipboard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectClipboard.mock.afterSelectClipboardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectClipboard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectClipboard implements ClipboardComponent
func (mmSelectClipboard *ClipboardComponentMock) SelectClipboard(ctx context.Context, clipboard Clipboard) (err error) {
	mm_atomic.AddUint64(&mmSelectClipboard.beforeSelectClipboardCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectClipboard.afterSelectClipboardCounter, 1)

	mmSelectClipboard.t.Helper()

	if mmSelectClipboard.inspectFuncSelectClipboard != nil {
		mmSelectClipboard.inspectFuncSelectClipboard(ctx, clipboard)
	}

	mm_params := ClipboardComponentMockSelectClipboardParams{ctx, clipboard}

	// Record call args
	mmSelectClipboard.SelectClipboardMock.mutex.Lock()
	mmSelectClipboard.SelectClipboardMock.callArgs = append(mmSelectClipboard.SelectClipboardMock.callArgs, &mm_params)
	mmSelectClipboard.SelectClipboardMock.mutex.Unlock()

	for _, e := range mmSelectClipboard.SelectClipboardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectClipboard.SelectClipboardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectClipboard.SelectClipboardMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectClipboard.SelectClipboardMock.defaultExpectation.params
		mm_want_ptrs := mmSelectClipboard.SelectClipboardMock.defaultExpectation.paramPtrs

		mm_got := ClipboardComponentMockSelectClipboardParams{ctx, clipboard}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectClipboard.t.Errorf("ClipboardComponentMock.SelectClipboard got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectClipboard.SelectClipboardMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.clipboard != nil && !minimock.Equal(*mm_want_ptrs.clipboard, mm_got.clipboard) {
				mmSelectClipboard.t.Errorf("ClipboardComponentMock.SelectClipboard got unexpected parameter clipboard, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectClipboard.SelectClipboardMock.defaultExpectation.expectationOrigins.originClipboard, *mm_want_ptrs.clipboard, mm_got.clipboard, minimock.Diff(*mm_want_ptrs.clipboard, mm_got.clipboard))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectClipboard.t.Errorf("ClipboardComponentMock.SelectClipboard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectClipboard.SelectClipboardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectClipboard.SelectClipboardMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectClipboard.t.Fatal("No results are set for the ClipboardComponentMock.SelectClipboard")
		}
		return (*mm_results).err
	}
	if mmSelectClipboard.funcSelectClipboard != nil {
		return mmSelectClipboard.funcSelectClipboard(ctx, clipboard)
	}
	mmSelectClipboard.t.Fatalf("Unexpected call to ClipboardComponentMock.SelectClipboard. %v %v", ctx, clipboard)
	return
}

// SelectClipboardAfterCounter returns a count of finished ClipboardComponentMock.SelectClipboard invocations
func (mmSelectClipboard *ClipboardComponentMock) SelectClipboardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectClipboard.afterSelectClipboardCounter)
}

// SelectClipboardBeforeCounter returns a count of ClipboardComponentMock.SelectClipboard invocations
func (mmSelectClipboard *ClipboardComponentMock) SelectClipboardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectClipboard.beforeSelectClipboardCounter)
}

// Calls returns a list of arguments used in each call to ClipboardComponentMock.SelectClipboard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectClipboard *mClipboardComponentMockSelectClipboard) Calls() []*ClipboardComponentMockSelectClipboardParams {
	mmSelectClipboard.mutex.RLock()

	argCopy := make([]*ClipboardComponentMockSelectClipboardParams, len(mmSelectClipboard.callArgs))
	copy(argCopy, mmSelectClipboard.callArgs)

	mmSelectClipboard.mutex.RUnlock()

	return argCopy
}

// MinimockSelectClipboardDone returns true if the count of the SelectClipboard invocations corresponds
// the number of defined expectations
func (m *ClipboardComponentMock) MinimockSelectClipboardDone() bool {
	if m.SelectClipboardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectClipboardMock.invocationsDone()
}

// MinimockSelectClipboardInspect logs each unmet expectation
func (m *ClipboardComponentMock) MinimockSelectClipboardInspect() {
	for _, e := range m.SelectClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClipboardComponentMock.SelectClipboard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectClipboardCounter := mm_atomic.LoadUint64(&m.afterSelectClipboardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectClipboardMock.defaultExpectation != nil && afterSelectClipboardCounter < 1 {
		if m.SelectClipboardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClipboardComponentMock.SelectClipboard at\n%s", m.SelectClipboardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClipboardComponentMock.SelectClipboard at\n%s with params: %#v", m.SelectClipboardMock.defaultExpectation.expectationOrigins.origin, *m.SelectClipboardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectClipboard != nil && afterSelectClipboardCounter < 1 {
		m.t.Errorf("Expected call to ClipboardComponentMock.SelectClipboard at\n%s", m.funcSelectClipboardOrigin)
	}

	if !m.SelectClipboardMock.invocationsDone() && afterSelectClipboardCounter > 0 {
		m.t.Errorf("Expected %d calls to ClipboardComponentMock.SelectClipboard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectClipboardMock.expectedInvocations), m.SelectClipboardMock.expectedInvocationsOrigin, afterSelectClipboardCounter)
	}
}

type mClipboardComponentMockSelectedClipboard struct {
	optional           bool
	mock               *ClipboardComponentMock
	defaultExpectation *ClipboardComponentMockSelectedClipboardExpectation
	expectations       []*ClipboardComponentMockSelectedClipboardExpectation

	callArgs []*ClipboardComponentMockSelectedClipboardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClipboardComponentMockSelectedClipboardExpectation specifies expectation struct of the ClipboardComponent.SelectedClipboard
type ClipboardComponentMockSelectedClipboardExpectation struct {
	mock               *ClipboardComponentMock
	params             *ClipboardComponentMockSelectedClipboardParams
	paramPtrs          *ClipboardComponentMockSelectedClipboardParamPtrs
	expectationOrigins ClipboardComponentMockSelectedClipboardExpectationOrigins
	results            *ClipboardComponentMockSelectedClipboardResults
	returnOrigin       string
	Counter            uint64
}

// ClipboardComponentMockSelectedClipboardParams contains parameters of the ClipboardComponent.SelectedClipboard
type ClipboardComponentMockSelectedClipboardParams struct {
	ctx context.Context
}

// ClipboardComponentMockSelectedClipboardParamPtrs contains pointers to parameters of the ClipboardComponent.SelectedClipboard
type ClipboardComponentMockSelectedClipboardParamPtrs struct {
	ctx *context.Context
}

// ClipboardComponentMockSelectedClipboardResults contains results of the ClipboardComponent.SelectedClipboard
type ClipboardComponentMockSelectedClipboardResults struct {
	c2  Clipboard
	err error
}

// ClipboardComponentMockSelectedClipboardOrigins contains origins of expectations of the ClipboardComponent.SelectedClipboard
type ClipboardComponentMockSelectedClipboardExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedClipboard *mClipboardComponentMockSelectedClipboard) Optional() *mClipboardComponentMockSelectedClipboard {
	mmSelectedClipboard.optional = true
	return mmSelectedClipboard
}

// Expect sets up expected params for ClipboardComponent.SelectedClipboard
func (mmSelectedClipboard *mClipboardComponentMockSelectedClipboard) Expect(ctx context.Context) *mClipboardComponentMockSelectedClipboard {
	if mmSelectedClipboard.mock.funcSelectedClipboard != nil {
		mmSelectedClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectedClipboard mock is already set by Set")
	}

	if mmSelectedClipboard.defaultExpectation == nil {
		mmSelectedClipboard.defaultExpectation = &ClipboardComponentMockSelectedClipboardExpectation{}
	}

	if mmSelectedClipboard.defaultExpectation.paramPtrs != nil {
		mmSelectedClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectedClipboard mock is already set by ExpectParams functions")
	}

	mmSelectedClipboard.defaultExpectation.params = &ClipboardComponentMockSelectedClipboardParams{ctx}
	mmSelectedClipboard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedClipboard.expectations {
		if minimock.Equal(e.params, mmSelectedClipboard.defaultExpectation.params) {
			mmSelectedClipboard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedClipboard.defaultExpectation.params)
		}
	}

	return mmSelectedClipboard
}

// ExpectCtxParam1 sets up expected param ctx for ClipboardComponent.SelectedClipboard
func (mmSelectedClipboard *mClipboardComponentMockSelectedClipboard) ExpectCtxParam1(ctx context.Context) *mClipboardComponentMockSelectedClipboard {
	if mmSelectedClipboard.mock.funcSelectedClipboard != nil {
		mmSelectedClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectedClipboard mock is already set by Set")
	}

	if mmSelectedClipboard.defaultExpectation == nil {
		mmSelectedClipboard.defaultExpectation = &ClipboardComponentMockSelectedClipboardExpectation{}
	}

	if mmSelectedClipboard.defaultExpectation.params != nil {
		mmSelectedClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectedClipboard mock is already set by Expect")
	}

	if mmSelectedClipboard.defaultExpectation.paramPtrs == nil {
		mmSelectedClipboard.defaultExpectation.paramPtrs = &ClipboardComponentMockSelectedClipboardParamPtrs{}
	}
	mmSelectedClipboard.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedClipboard.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedClipboard
}

// Inspect accepts an inspector function that has same arguments as the ClipboardComponent.SelectedClipboard
func (mmSelectedClipboard *mClipboardComponentMockSelectedClipboard) Inspect(f func(ctx context.Context)) *mClipboardComponentMockSelectedClipboard {
	if mmSelectedClipboard.mock.inspectFuncSelectedClipboard != nil {
		mmSelectedClipboard.mock.t.Fatalf("Inspect function is already set for ClipboardComponentMock.SelectedClipboard")
	}

	mmSelectedClipboard.mock.inspectFuncSelectedClipboard = f

	return mmSelectedClipboard
}

// Return sets up results that will be returned by ClipboardComponent.SelectedClipboard
func (mmSelectedClipboard *mClipboardComponentMockSelectedClipboard) Return(c2 Clipboard, err error) *ClipboardComponentMock {
	if mmSelectedClipboard.mock.funcSelectedClipboard != nil {
		mmSelectedClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectedClipboard mock is already set by Set")
	}

	if mmSelectedClipboard.defaultExpectation == nil {
		mmSelectedClipboard.defaultExpectation = &ClipboardComponentMockSelectedClipboardExpectation{mock: mmSelectedClipboard.mock}
	}
	mmSelectedClipboard.defaultExpectation.results = &ClipboardComponentMockSelectedClipboardResults{c2, err}
	mmSelectedClipboard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedClipboard.mock
}

// Set uses given function f to mock the ClipboardComponent.SelectedClipboard method
func (mmSelectedClipboard *mClipboardComponentMockSelectedClipboard) Set(f func(ctx context.Context) (c2 Clipboard, err error)) *ClipboardComponentMock {
	if mmSelectedClipboard.defaultExpectation != nil {
		mmSelectedClipboard.mock.t.Fatalf("Default expectation is already set for the ClipboardComponent.SelectedClipboard method")
	}

	if len(mmSelectedClipboard.expectations) > 0 {
		mmSelectedClipboard.mock.t.Fatalf("Some expectations are already set for the ClipboardComponent.SelectedClipboard method")
	}

	mmSelectedClipboard.mock.funcSelectedClipboard = f
	mmSelectedClipboard.mock.funcSelectedClipboardOrigin = minimock.CallerInfo(1)
	return mmSelectedClipboard.mock
}

// When sets expectation for the ClipboardComponent.SelectedClipboard which will trigger the result defined by the following
// Then helper
func (mmSelectedClipboard *mClipboardComponentMockSelectedClipboard) When(ctx context.Context) *ClipboardComponentMockSelectedClipboardExpectation {
	if mmSelectedClipboard.mock.funcSelectedClipboard != nil {
		mmSelectedClipboard.mock.t.Fatalf("ClipboardComponentMock.SelectedClipboard mock is already set by Set")
	}

	expectation := &ClipboardComponentMockSelectedClipboardExpectation{
		mock:               mmSelectedClipboard.mock,
		params:             &ClipboardComponentMockSelectedClipboardParams{ctx},
		expectationOrigins: ClipboardComponentMockSelectedClipboardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedClipboard.expectations = append(mmSelectedClipboard.expectations, expectation)
	return expectation
}

// Then sets up ClipboardComponent.SelectedClipboard return parameters for the expectation previously defined by the When method
func (e *ClipboardComponentMockSelectedClipboardExpectation) Then(c2 Clipboard, err error) *ClipboardComponentMock {
	e.results = &ClipboardComponentMockSelectedClipboardResults{c2, err}
	return e.mock
}

// Times sets number of times ClipboardComponent.SelectedClipboard should be invoked
func (mmSelectedClipboard *mClipboardComponentMockSelectedClipboard) Times(n uint64) *mClipboardComponentMockSelectedClipboard {
	if n == 0 {
		mmSelectedClipboard.mock.t.Fatalf("Times of ClipboardComponentMock.SelectedClipboard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedClipboard.expectedInvocations, n)
	mmSelectedClipboard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedClipboard
}

func (mmSelectedClipboard *mClipboardComponentMockSelectedClipboard) invocationsDone() bool {
	if len(mmSelectedClipboard.expectations) == 0 && mmSelectedClipboard.defaultExpectation == nil && mmSelectedClipboard.mock.funcSelectedClipboard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedClipboard.mock.afterSelectedClipboardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedClipboard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedClipboard implements ClipboardComponent
func (mmSelectedClipboard *ClipboardComponentMock) SelectedClipboard(ctx context.Context) (c2 Clipboard, err error) {
	mm_atomic.AddUint64(&mmSelectedClipboard.beforeSelectedClipboardCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedClipboard.afterSelectedClipboardCounter, 1)

	mmSelectedClipboard.t.Helper()

	if mmSelectedClipboard.inspectFuncSelectedClipboard != nil {
		mmSelectedClipboard.inspectFuncSelectedClipboard(ctx)
	}

	mm_params := ClipboardComponentMockSelectedClipboardParams{ctx}

	// Record call args
	mmSelectedClipboard.SelectedClipboardMock.mutex.Lock()
	mmSelectedClipboard.SelectedClipboardMock.callArgs = append(mmSelectedClipboard.SelectedClipboardMock.callArgs, &mm_params)
	mmSelectedClipboard.SelectedClipboardMock.mutex.Unlock()

	for _, e := range mmSelectedClipboard.SelectedClipboardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmSelectedClipboard.SelectedClipboardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedClipboard.SelectedClipboardMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedClipboard.SelectedClipboardMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedClipboard.SelectedClipboardMock.defaultExpectation.paramPtrs

		mm_got := ClipboardComponentMockSelectedClipboardParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedClipboard.t.Errorf("ClipboardComponentMock.SelectedClipboard got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedClipboard.SelectedClipboardMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedClipboard.t.Errorf("ClipboardComponentMock.SelectedClipboard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedClipboard.SelectedClipboardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedClipboard.SelectedClipboardMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedClipboard.t.Fatal("No results are set for the ClipboardComponentMock.SelectedClipboard")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmSelectedClipboard.funcSelectedClipboard != nil {
		return mmSelectedClipboard.funcSelectedClipboard(ctx)
	}
	mmSelectedClipboard.t.Fatalf("Unexpected call to ClipboardComponentMock.SelectedClipboard. %v", ctx)
	return
}

// SelectedClipboardAfterCounter returns a count of finished ClipboardComponentMock.SelectedClipboard invocations
func (mmSelectedClipboard *ClipboardComponentMock) SelectedClipboardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedClipboard.afterSelectedClipboardCounter)
}

// SelectedClipboardBeforeCounter returns a count of ClipboardComponentMock.SelectedClipboard invocations
func (mmSelectedClipboard *ClipboardComponentMock) SelectedClipboardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedClipboard.beforeSelectedClipboardCounter)
}

// Calls returns a list of arguments used in each call to ClipboardComponentMock.SelectedClipboard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedClipboard *mClipboardComponentMockSelectedClipboard) Calls() []*ClipboardComponentMockSelectedClipboardParams {
	mmSelectedClipboard.mutex.RLock()

	argCopy := make([]*ClipboardComponentMockSelectedClipboardParams, len(mmSelectedClipboard.callArgs))
	copy(argCopy, mmSelectedClipboard.callArgs)

	mmSelectedClipboard.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedClipboardDone returns true if the count of the SelectedClipboard invocations corresponds
// the number of defined expectations
func (m *ClipboardComponentMock) MinimockSelectedClipboardDone() bool {
	if m.SelectedClipboardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedClipboardMock.invocationsDone()
}

// MinimockSelectedClipboardInspect logs each unmet expectation
func (m *ClipboardComponentMock) MinimockSelectedClipboardInspect() {
	for _, e := range m.SelectedClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClipboardComponentMock.SelectedClipboard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedClipboardCounter := mm_atomic.LoadUint64(&m.afterSelectedClipboardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedClipboardMock.defaultExpectation != nil && afterSelectedClipboardCounter < 1 {
		if m.SelectedClipboardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClipboardComponentMock.SelectedClipboard at\n%s", m.SelectedClipboardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClipboardComponentMock.SelectedClipboard at\n%s with params: %#v", m.SelectedClipboardMock.defaultExpectation.expectationOrigins.origin, *m.SelectedClipboardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedClipboard != nil && afterSelectedClipboardCounter < 1 {
		m.t.Errorf("Expected call to ClipboardComponentMock.SelectedClipboard at\n%s", m.funcSelectedClipboardOrigin)
	}

	if !m.SelectedClipboardMock.invocationsDone() && afterSelectedClipboardCounter > 0 {
		m.t.Errorf("Expected %d calls to ClipboardComponentMock.SelectedClipboard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedClipboardMock.expectedInvocations), m.SelectedClipboardMock.expectedInvocationsOrigin, afterSelectedClipboardCounter)
	}
}

type mClipboardComponentMockShowClipboard struct {
	optional           bool
	mock               *ClipboardComponentMock
	defaultExpectation *ClipboardComponentMockShowClipboardExpectation
	expectations       []*ClipboardComponentMockShowClipboardExpectation

	callArgs []*ClipboardComponentMockShowClipboardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClipboardComponentMockShowClipboardExpectation specifies expectation struct of the ClipboardComponent.ShowClipboard
type ClipboardComponentMockShowClipboardExpectation struct {
	mock               *ClipboardComponentMock
	params             *ClipboardComponentMockShowClipboardParams
	paramPtrs          *ClipboardComponentMockShowClipboardParamPtrs
	expectationOrigins ClipboardComponentMockShowClipboardExpectationOrigins
	results            *ClipboardComponentMockShowClipboardResults
	returnOrigin       string
	Counter            uint64
}

// ClipboardComponentMockShowClipboardParams contains parameters of the ClipboardComponent.ShowClipboard
type ClipboardComponentMockShowClipboardParams struct {
	ctx context.Context
}

// ClipboardComponentMockShowClipboardParamPtrs contains pointers to parameters of the ClipboardComponent.ShowClipboard
type ClipboardComponentMockShowClipboardParamPtrs struct {
	ctx *context.Context
}

// ClipboardComponentMockShowClipboardResults contains results of the ClipboardComponent.ShowClipboard
type ClipboardComponentMockShowClipboardResults struct {
	err error
}

// ClipboardComponentMockShowClipboardOrigins contains origins of expectations of the ClipboardComponent.ShowClipboard
type ClipboardComponentMockShowClipboardExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmShowClipboard *mClipboardComponentMockShowClipboard) Optional() *mClipboardComponentMockShowClipboard {
	mmShowClipboard.optional = true
	return mmShowClipboard
}

// Expect sets up expected params for ClipboardComponent.ShowClipboard
func (mmShowClipboard *mClipboardComponentMockShowClipboard) Expect(ctx context.Context) *mClipboardComponentMockShowClipboard {
	if mmShowClipboard.mock.funcShowClipboard != nil {
		mmShowClipboard.mock.t.Fatalf("ClipboardComponentMock.ShowClipboard mock is already set by Set")
	}

	if mmShowClipboard.defaultExpectation == nil {
		mmShowClipboard.defaultExpectation = &ClipboardComponentMockShowClipboardExpectation{}
	}

	if mmShowClipboard.defaultExpectation.paramPtrs != nil {
		mmShowClipboard.mock.t.Fatalf("ClipboardComponentMock.ShowClipboard mock is already set by ExpectParams functions")
	}

	mmShowClipboard.defaultExpectation.params = &ClipboardComponentMockShowClipboardParams{ctx}
	mmShowClipboard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmShowClipboard.expectations {
		if minimock.Equal(e.params, mmShowClipboard.defaultExpectation.params) {
			mmShowClipboard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmShowClipboard.defaultExpectation.params)
		}
	}

	return mmShowClipboard
}

// ExpectCtxParam1 sets up expected param ctx for ClipboardComponent.ShowClipboard
func (mmShowClipboard *mClipboardComponentMockShowClipboard) ExpectCtxParam1(ctx context.Context) *mClipboardComponentMockShowClipboard {
	if mmShowClipboard.mock.funcShowClipboard != nil {
		mmShowClipboard.mock.t.Fatalf("ClipboardComponentMock.ShowClipboard mock is already set by Set")
	}

	if mmShowClipboard.defaultExpectation == nil {
		mmShowClipboard.defaultExpectation = &ClipboardComponentMockShowClipboardExpectation{}
	}

	if mmShowClipboard.defaultExpectation.params != nil {
		mmShowClipboard.mock.t.Fatalf("ClipboardComponentMock.ShowClipboard mock is already set by Expect")
	}

	if mmShowClipboard.defaultExpectation.paramPtrs == nil {
		mmShowClipboard.defaultExpectation.paramPtrs = &ClipboardComponentMockShowClipboardParamPtrs{}
	}
	mmShowClipboard.defaultExpectation.paramPtrs.ctx = &ctx
	mmShowClipboard.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmShowClipboard
}

// Inspect accepts an inspector function that has same arguments as the ClipboardComponent.ShowClipboard
func (mmShowClipboard *mClipboardComponentMockShowClipboard) Inspect(f func(ctx context.Context)) *mClipboardComponentMockShowClipboard {
	if mmShowClipboard.mock.inspectFuncShowClipboard != nil {
		mmShowClipboard.mock.t.Fatalf("Inspect function is already set for ClipboardComponentMock.ShowClipboard")
	}

	mmShowClipboard.mock.inspectFuncShowClipboard = f

	return mmShowClipboard
}

// Return sets up results that will be returned by ClipboardComponent.ShowClipboard
func (mmShowClipboard *mClipboardComponentMockShowClipboard) Return(err error) *ClipboardComponentMock {
	if mmShowClipboard.mock.funcShowClipboard != nil {
		mmShowClipboard.mock.t.Fatalf("ClipboardComponentMock.ShowClipboard mock is already set by Set")
	}

	if mmShowClipboard.defaultExpectation == nil {
		mmShowClipboard.defaultExpectation = &ClipboardComponentMockShowClipboardExpectation{mock: mmShowClipboard.mock}
	}
	mmShowClipboard.defaultExpectation.results = &ClipboardComponentMockShowClipboardResults{err}
	mmShowClipboard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmShowClipboard.mock
}

// Set uses given function f to mock the ClipboardComponent.ShowClipboard method
func (mmShowClipboard *mClipboardComponentMockShowClipboard) Set(f func(ctx context.Context) (err error)) *ClipboardComponentMock {
	if mmShowClipboard.defaultExpectation != nil {
		mmShowClipboard.mock.t.Fatalf("Default expectation is already set for the ClipboardComponent.ShowClipboard method")
	}

	if len(mmShowClipboard.expectations) > 0 {
		mmShowClipboard.mock.t.Fatalf("Some expectations are already set for the ClipboardComponent.ShowClipboard method")
	}

	mmShowClipboard.mock.funcShowClipboard = f
	mmShowClipboard.mock.funcShowClipboardOrigin = minimock.CallerInfo(1)
	return mmShowClipboard.mock
}

// When sets expectation for the ClipboardComponent.ShowClipboard which will trigger the result defined by the following
// Then helper
func (mmShowClipboard *mClipboardComponentMockShowClipboard) When(ctx context.Context) *ClipboardComponentMockShowClipboardExpectation {
	if mmShowClipboard.mock.funcShowClipboard != nil {
		mmShowClipboard.mock.t.Fatalf("ClipboardComponentMock.ShowClipboard mock is already set by Set")
	}

	expectation := &ClipboardComponentMockShowClipboardExpectation{
		mock:               mmShowClipboard.mock,
		params:             &ClipboardComponentMockShowClipboardParams{ctx},
		expectationOrigins: ClipboardComponentMockShowClipboardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmShowClipboard.expectations = append(mmShowClipboard.expectations, expectation)
	return expectation
}

// Then sets up ClipboardComponent.ShowClipboard return parameters for the expectation previously defined by the When method
func (e *ClipboardComponentMockShowClipboardExpectation) Then(err error) *ClipboardComponentMock {
	e.results = &ClipboardComponentMockShowClipboardResults{err}
	return e.mock
}

// Times sets number of times ClipboardComponent.ShowClipboard should be invoked
func (mmShowClipboard *mClipboardComponentMockShowClipboard) Times(n uint64) *mClipboardComponentMockShowClipboard {
	if n == 0 {
		mmShowClipboard.mock.t.Fatalf("Times of ClipboardComponentMock.ShowClipboard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmShowClipboard.expectedInvocations, n)
	mmShowClipboard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmShowClipboard
}

func (mmShowClipboard *mClipboardComponentMockShowClipboard) invocationsDone() bool {
	if len(mmShowClipboard.expectations) == 0 && mmShowClipboard.defaultExpectation == nil && mmShowClipboard.mock.funcShowClipboard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmShowClipboard.mock.afterShowClipboardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmShowClipboard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ShowClipboard implements ClipboardComponent
func (mmShowClipboard *ClipboardComponentMock) ShowClipboard(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmShowClipboard.beforeShowClipboardCounter, 1)
	defer mm_atomic.AddUint64(&mmShowClipboard.afterShowClipboardCounter, 1)

	mmShowClipboard.t.Helper()

	if mmShowClipboard.inspectFuncShowClipboard != nil {
		mmShowClipboard.inspectFuncShowClipboard(ctx)
	}

	mm_params := ClipboardComponentMockShowClipboardParams{ctx}

	// Record call args
	mmShowClipboard.ShowClipboardMock.mutex.Lock()
	mmShowClipboard.ShowClipboardMock.callArgs = append(mmShowClipboard.ShowClipboardMock.callArgs, &mm_params)
	mmShowClipboard.ShowClipboardMock.mutex.Unlock()

	for _, e := range mmShowClipboard.ShowClipboardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmShowClipboard.ShowClipboardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShowClipboard.ShowClipboardMock.defaultExpectation.Counter, 1)
		mm_want := mmShowClipboard.ShowClipboardMock.defaultExpectation.params
		mm_want_ptrs := mmShowClipboard.ShowClipboardMock.defaultExpectation.paramPtrs

		mm_got := ClipboardComponentMockShowClipboardParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmShowClipboard.t.Errorf("ClipboardComponentMock.ShowClipboard got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmShowClipboard.ShowClipboardMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmShowClipboard.t.Errorf("ClipboardComponentMock.ShowClipboard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmShowClipboard.ShowClipboardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmShowClipboard.ShowClipboardMock.defaultExpectation.results
		if mm_results == nil {
			mmShowClipboard.t.Fatal("No results are set for the ClipboardComponentMock.ShowClipboard")
		}
		return (*mm_results).err
	}
	if mmShowClipboard.funcShowClipboard != nil {
		return mmShowClipboard.funcShowClipboard(ctx)
	}
	mmShowClipboard.t.Fatalf("Unexpected call to ClipboardComponentMock.ShowClipboard. %v", ctx)
	return
}

// ShowClipboardAfterCounter returns a count of finished ClipboardComponentMock.ShowClipboard invocations
func (mmShowClipboard *ClipboardComponentMock) ShowClipboardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShowClipboard.afterShowClipboardCounter)
}

// ShowClipboardBeforeCounter returns a count of ClipboardComponentMock.ShowClipboard invocations
func (mmShowClipboard *ClipboardComponentMock) ShowClipboardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShowClipboard.beforeShowClipboardCounter)
}

// Calls returns a list of arguments used in each call to ClipboardComponentMock.ShowClipboard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmShowClipboard *mClipboardComponentMockShowClipboard) Calls() []*ClipboardComponentMockShowClipboardParams {
	mmShowClipboard.mutex.RLock()

	argCopy := make([]*ClipboardComponentMockShowClipboardParams, len(mmShowClipboard.callArgs))
	copy(argCopy, mmShowClipboard.callArgs)

	mmShowClipboard.mutex.RUnlock()

	return argCopy
}

// MinimockShowClipboardDone returns true if the count of the ShowClipboard invocations corresponds
// the number of defined expectations
func (m *ClipboardComponentMock) MinimockShowClipboardDone() bool {
	if m.ShowClipboardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ShowClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ShowClipboardMock.invocationsDone()
}

// MinimockShowClipboardInspect logs each unmet expectation
func (m *ClipboardComponentMock) MinimockShowClipboardInspect() {
	for _, e := range m.ShowClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClipboardComponentMock.ShowClipboard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterShowClipboardCounter := mm_atomic.LoadUint64(&m.afterShowClipboardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ShowClipboardMock.defaultExpectation != nil && afterShowClipboardCounter < 1 {
		if m.ShowClipboardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClipboardComponentMock.ShowClipboard at\n%s", m.ShowClipboardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClipboardComponentMock.ShowClipboard at\n%s with params: %#v", m.ShowClipboardMock.defaultExpectation.expectationOrigins.origin, *m.ShowClipboardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShowClipboard != nil && afterShowClipboardCounter < 1 {
		m.t.Errorf("Expected call to ClipboardComponentMock.ShowClipboard at\n%s", m.funcShowClipboardOrigin)
	}

	if !m.ShowClipboardMock.invocationsDone() && afterShowClipboardCounter > 0 {
		m.t.Errorf("Expected %d calls to ClipboardComponentMock.ShowClipboard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ShowClipboardMock.expectedInvocations), m.ShowClipboardMock.expectedInvocationsOrigin, afterShowClipboardCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClipboardComponentMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockHideClipboardInspect()

			m.MinimockSelectClipboardInspect()

			m.MinimockSelectedClipboardInspect()

			m.MinimockShowClipboardInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClipboardComponentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClipboardComponentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockHideClipboardDone() &&
		m.MinimockSelectClipboardDone() &&
		m.MinimockSelectedClipboardDone() &&
		m.MinimockShowClipboardDone()
}
