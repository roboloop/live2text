// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package tmpl

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RendererMock implements Renderer
type RendererMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAppPlaceholder          func() (s1 string)
	funcAppPlaceholderOrigin    string
	inspectFuncAppPlaceholder   func()
	afterAppPlaceholderCounter  uint64
	beforeAppPlaceholderCounter uint64
	AppPlaceholderMock          mRendererMockAppPlaceholder

	funcCloseSettings          func(cleanViewMode string, closeAction map[string]any, openCleanViewAction map[string]any, appUUID string, refreshAppPayload map[string]any) (s1 string)
	funcCloseSettingsOrigin    string
	inspectFuncCloseSettings   func(cleanViewMode string, closeAction map[string]any, openCleanViewAction map[string]any, appUUID string, refreshAppPayload map[string]any)
	afterCloseSettingsCounter  uint64
	beforeCloseSettingsCounter uint64
	CloseSettingsMock          mRendererMockCloseSettings

	funcCopyText          func() (s1 string)
	funcCopyTextOrigin    string
	inspectFuncCopyText   func()
	afterCopyTextCounter  uint64
	beforeCopyTextCounter uint64
	CopyTextMock          mRendererMockCopyText

	funcFloatingPage          func() (s1 string)
	funcFloatingPageOrigin    string
	inspectFuncFloatingPage   func()
	afterFloatingPageCounter  uint64
	beforeFloatingPageCounter uint64
	FloatingPageMock          mRendererMockFloatingPage

	funcListenSocket          func(socketPath string) (s1 string)
	funcListenSocketOrigin    string
	inspectFuncListenSocket   func(socketPath string)
	afterListenSocketCounter  uint64
	beforeListenSocketCounter uint64
	ListenSocketMock          mRendererMockListenSocket

	funcOpenSettings          func(action map[string]any) (s1 string)
	funcOpenSettingsOrigin    string
	inspectFuncOpenSettings   func(action map[string]any)
	afterOpenSettingsCounter  uint64
	beforeOpenSettingsCounter uint64
	OpenSettingsMock          mRendererMockOpenSettings

	funcPrintMetric          func(template MetricTemplate, metric string, title string) (s1 string)
	funcPrintMetricOrigin    string
	inspectFuncPrintMetric   func(template MetricTemplate, metric string, title string)
	afterPrintMetricCounter  uint64
	beforePrintMetricCounter uint64
	PrintMetricMock          mRendererMockPrintMetric

	funcPrintSelectedClipboard          func() (s1 string)
	funcPrintSelectedClipboardOrigin    string
	inspectFuncPrintSelectedClipboard   func()
	afterPrintSelectedClipboardCounter  uint64
	beforePrintSelectedClipboardCounter uint64
	PrintSelectedClipboardMock          mRendererMockPrintSelectedClipboard

	funcPrintSelectedDevice          func() (s1 string)
	funcPrintSelectedDeviceOrigin    string
	inspectFuncPrintSelectedDevice   func()
	afterPrintSelectedDeviceCounter  uint64
	beforePrintSelectedDeviceCounter uint64
	PrintSelectedDeviceMock          mRendererMockPrintSelectedDevice

	funcPrintSelectedFloating          func() (s1 string)
	funcPrintSelectedFloatingOrigin    string
	inspectFuncPrintSelectedFloating   func()
	afterPrintSelectedFloatingCounter  uint64
	beforePrintSelectedFloatingCounter uint64
	PrintSelectedFloatingMock          mRendererMockPrintSelectedFloating

	funcPrintSelectedLanguage          func() (s1 string)
	funcPrintSelectedLanguageOrigin    string
	inspectFuncPrintSelectedLanguage   func()
	afterPrintSelectedLanguageCounter  uint64
	beforePrintSelectedLanguageCounter uint64
	PrintSelectedLanguageMock          mRendererMockPrintSelectedLanguage

	funcPrintSelectedViewMode          func() (s1 string)
	funcPrintSelectedViewModeOrigin    string
	inspectFuncPrintSelectedViewMode   func()
	afterPrintSelectedViewModeCounter  uint64
	beforePrintSelectedViewModeCounter uint64
	PrintSelectedViewModeMock          mRendererMockPrintSelectedViewMode

	funcPrintStatus          func() (s1 string)
	funcPrintStatusOrigin    string
	inspectFuncPrintStatus   func()
	afterPrintStatusCounter  uint64
	beforePrintStatusCounter uint64
	PrintStatusMock          mRendererMockPrintStatus

	funcSelectClipboard          func(clipboard string) (s1 string)
	funcSelectClipboardOrigin    string
	inspectFuncSelectClipboard   func(clipboard string)
	afterSelectClipboardCounter  uint64
	beforeSelectClipboardCounter uint64
	SelectClipboardMock          mRendererMockSelectClipboard

	funcSelectDevice          func(device string) (s1 string)
	funcSelectDeviceOrigin    string
	inspectFuncSelectDevice   func(device string)
	afterSelectDeviceCounter  uint64
	beforeSelectDeviceCounter uint64
	SelectDeviceMock          mRendererMockSelectDevice

	funcSelectFloating          func(floatingState string) (s1 string)
	funcSelectFloatingOrigin    string
	inspectFuncSelectFloating   func(floatingState string)
	afterSelectFloatingCounter  uint64
	beforeSelectFloatingCounter uint64
	SelectFloatingMock          mRendererMockSelectFloating

	funcSelectLanguage          func(language string) (s1 string)
	funcSelectLanguageOrigin    string
	inspectFuncSelectLanguage   func(language string)
	afterSelectLanguageCounter  uint64
	beforeSelectLanguageCounter uint64
	SelectLanguageMock          mRendererMockSelectLanguage

	funcSelectViewMode          func(viewMode string) (s1 string)
	funcSelectViewModeOrigin    string
	inspectFuncSelectViewMode   func(viewMode string)
	afterSelectViewModeCounter  uint64
	beforeSelectViewModeCounter uint64
	SelectViewModeMock          mRendererMockSelectViewMode

	funcToggle          func() (s1 string)
	funcToggleOrigin    string
	inspectFuncToggle   func()
	afterToggleCounter  uint64
	beforeToggleCounter uint64
	ToggleMock          mRendererMockToggle
}

// NewRendererMock returns a mock for Renderer
func NewRendererMock(t minimock.Tester) *RendererMock {
	m := &RendererMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AppPlaceholderMock = mRendererMockAppPlaceholder{mock: m}

	m.CloseSettingsMock = mRendererMockCloseSettings{mock: m}
	m.CloseSettingsMock.callArgs = []*RendererMockCloseSettingsParams{}

	m.CopyTextMock = mRendererMockCopyText{mock: m}

	m.FloatingPageMock = mRendererMockFloatingPage{mock: m}

	m.ListenSocketMock = mRendererMockListenSocket{mock: m}
	m.ListenSocketMock.callArgs = []*RendererMockListenSocketParams{}

	m.OpenSettingsMock = mRendererMockOpenSettings{mock: m}
	m.OpenSettingsMock.callArgs = []*RendererMockOpenSettingsParams{}

	m.PrintMetricMock = mRendererMockPrintMetric{mock: m}
	m.PrintMetricMock.callArgs = []*RendererMockPrintMetricParams{}

	m.PrintSelectedClipboardMock = mRendererMockPrintSelectedClipboard{mock: m}

	m.PrintSelectedDeviceMock = mRendererMockPrintSelectedDevice{mock: m}

	m.PrintSelectedFloatingMock = mRendererMockPrintSelectedFloating{mock: m}

	m.PrintSelectedLanguageMock = mRendererMockPrintSelectedLanguage{mock: m}

	m.PrintSelectedViewModeMock = mRendererMockPrintSelectedViewMode{mock: m}

	m.PrintStatusMock = mRendererMockPrintStatus{mock: m}

	m.SelectClipboardMock = mRendererMockSelectClipboard{mock: m}
	m.SelectClipboardMock.callArgs = []*RendererMockSelectClipboardParams{}

	m.SelectDeviceMock = mRendererMockSelectDevice{mock: m}
	m.SelectDeviceMock.callArgs = []*RendererMockSelectDeviceParams{}

	m.SelectFloatingMock = mRendererMockSelectFloating{mock: m}
	m.SelectFloatingMock.callArgs = []*RendererMockSelectFloatingParams{}

	m.SelectLanguageMock = mRendererMockSelectLanguage{mock: m}
	m.SelectLanguageMock.callArgs = []*RendererMockSelectLanguageParams{}

	m.SelectViewModeMock = mRendererMockSelectViewMode{mock: m}
	m.SelectViewModeMock.callArgs = []*RendererMockSelectViewModeParams{}

	m.ToggleMock = mRendererMockToggle{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRendererMockAppPlaceholder struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockAppPlaceholderExpectation
	expectations       []*RendererMockAppPlaceholderExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockAppPlaceholderExpectation specifies expectation struct of the Renderer.AppPlaceholder
type RendererMockAppPlaceholderExpectation struct {
	mock *RendererMock

	results      *RendererMockAppPlaceholderResults
	returnOrigin string
	Counter      uint64
}

// RendererMockAppPlaceholderResults contains results of the Renderer.AppPlaceholder
type RendererMockAppPlaceholderResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAppPlaceholder *mRendererMockAppPlaceholder) Optional() *mRendererMockAppPlaceholder {
	mmAppPlaceholder.optional = true
	return mmAppPlaceholder
}

// Expect sets up expected params for Renderer.AppPlaceholder
func (mmAppPlaceholder *mRendererMockAppPlaceholder) Expect() *mRendererMockAppPlaceholder {
	if mmAppPlaceholder.mock.funcAppPlaceholder != nil {
		mmAppPlaceholder.mock.t.Fatalf("RendererMock.AppPlaceholder mock is already set by Set")
	}

	if mmAppPlaceholder.defaultExpectation == nil {
		mmAppPlaceholder.defaultExpectation = &RendererMockAppPlaceholderExpectation{}
	}

	return mmAppPlaceholder
}

// Inspect accepts an inspector function that has same arguments as the Renderer.AppPlaceholder
func (mmAppPlaceholder *mRendererMockAppPlaceholder) Inspect(f func()) *mRendererMockAppPlaceholder {
	if mmAppPlaceholder.mock.inspectFuncAppPlaceholder != nil {
		mmAppPlaceholder.mock.t.Fatalf("Inspect function is already set for RendererMock.AppPlaceholder")
	}

	mmAppPlaceholder.mock.inspectFuncAppPlaceholder = f

	return mmAppPlaceholder
}

// Return sets up results that will be returned by Renderer.AppPlaceholder
func (mmAppPlaceholder *mRendererMockAppPlaceholder) Return(s1 string) *RendererMock {
	if mmAppPlaceholder.mock.funcAppPlaceholder != nil {
		mmAppPlaceholder.mock.t.Fatalf("RendererMock.AppPlaceholder mock is already set by Set")
	}

	if mmAppPlaceholder.defaultExpectation == nil {
		mmAppPlaceholder.defaultExpectation = &RendererMockAppPlaceholderExpectation{mock: mmAppPlaceholder.mock}
	}
	mmAppPlaceholder.defaultExpectation.results = &RendererMockAppPlaceholderResults{s1}
	mmAppPlaceholder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAppPlaceholder.mock
}

// Set uses given function f to mock the Renderer.AppPlaceholder method
func (mmAppPlaceholder *mRendererMockAppPlaceholder) Set(f func() (s1 string)) *RendererMock {
	if mmAppPlaceholder.defaultExpectation != nil {
		mmAppPlaceholder.mock.t.Fatalf("Default expectation is already set for the Renderer.AppPlaceholder method")
	}

	if len(mmAppPlaceholder.expectations) > 0 {
		mmAppPlaceholder.mock.t.Fatalf("Some expectations are already set for the Renderer.AppPlaceholder method")
	}

	mmAppPlaceholder.mock.funcAppPlaceholder = f
	mmAppPlaceholder.mock.funcAppPlaceholderOrigin = minimock.CallerInfo(1)
	return mmAppPlaceholder.mock
}

// Times sets number of times Renderer.AppPlaceholder should be invoked
func (mmAppPlaceholder *mRendererMockAppPlaceholder) Times(n uint64) *mRendererMockAppPlaceholder {
	if n == 0 {
		mmAppPlaceholder.mock.t.Fatalf("Times of RendererMock.AppPlaceholder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAppPlaceholder.expectedInvocations, n)
	mmAppPlaceholder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAppPlaceholder
}

func (mmAppPlaceholder *mRendererMockAppPlaceholder) invocationsDone() bool {
	if len(mmAppPlaceholder.expectations) == 0 && mmAppPlaceholder.defaultExpectation == nil && mmAppPlaceholder.mock.funcAppPlaceholder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAppPlaceholder.mock.afterAppPlaceholderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAppPlaceholder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AppPlaceholder implements Renderer
func (mmAppPlaceholder *RendererMock) AppPlaceholder() (s1 string) {
	mm_atomic.AddUint64(&mmAppPlaceholder.beforeAppPlaceholderCounter, 1)
	defer mm_atomic.AddUint64(&mmAppPlaceholder.afterAppPlaceholderCounter, 1)

	mmAppPlaceholder.t.Helper()

	if mmAppPlaceholder.inspectFuncAppPlaceholder != nil {
		mmAppPlaceholder.inspectFuncAppPlaceholder()
	}

	if mmAppPlaceholder.AppPlaceholderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAppPlaceholder.AppPlaceholderMock.defaultExpectation.Counter, 1)

		mm_results := mmAppPlaceholder.AppPlaceholderMock.defaultExpectation.results
		if mm_results == nil {
			mmAppPlaceholder.t.Fatal("No results are set for the RendererMock.AppPlaceholder")
		}
		return (*mm_results).s1
	}
	if mmAppPlaceholder.funcAppPlaceholder != nil {
		return mmAppPlaceholder.funcAppPlaceholder()
	}
	mmAppPlaceholder.t.Fatalf("Unexpected call to RendererMock.AppPlaceholder.")
	return
}

// AppPlaceholderAfterCounter returns a count of finished RendererMock.AppPlaceholder invocations
func (mmAppPlaceholder *RendererMock) AppPlaceholderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAppPlaceholder.afterAppPlaceholderCounter)
}

// AppPlaceholderBeforeCounter returns a count of RendererMock.AppPlaceholder invocations
func (mmAppPlaceholder *RendererMock) AppPlaceholderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAppPlaceholder.beforeAppPlaceholderCounter)
}

// MinimockAppPlaceholderDone returns true if the count of the AppPlaceholder invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockAppPlaceholderDone() bool {
	if m.AppPlaceholderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AppPlaceholderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AppPlaceholderMock.invocationsDone()
}

// MinimockAppPlaceholderInspect logs each unmet expectation
func (m *RendererMock) MinimockAppPlaceholderInspect() {
	for _, e := range m.AppPlaceholderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RendererMock.AppPlaceholder")
		}
	}

	afterAppPlaceholderCounter := mm_atomic.LoadUint64(&m.afterAppPlaceholderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AppPlaceholderMock.defaultExpectation != nil && afterAppPlaceholderCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.AppPlaceholder at\n%s", m.AppPlaceholderMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAppPlaceholder != nil && afterAppPlaceholderCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.AppPlaceholder at\n%s", m.funcAppPlaceholderOrigin)
	}

	if !m.AppPlaceholderMock.invocationsDone() && afterAppPlaceholderCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.AppPlaceholder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AppPlaceholderMock.expectedInvocations), m.AppPlaceholderMock.expectedInvocationsOrigin, afterAppPlaceholderCounter)
	}
}

type mRendererMockCloseSettings struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockCloseSettingsExpectation
	expectations       []*RendererMockCloseSettingsExpectation

	callArgs []*RendererMockCloseSettingsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockCloseSettingsExpectation specifies expectation struct of the Renderer.CloseSettings
type RendererMockCloseSettingsExpectation struct {
	mock               *RendererMock
	params             *RendererMockCloseSettingsParams
	paramPtrs          *RendererMockCloseSettingsParamPtrs
	expectationOrigins RendererMockCloseSettingsExpectationOrigins
	results            *RendererMockCloseSettingsResults
	returnOrigin       string
	Counter            uint64
}

// RendererMockCloseSettingsParams contains parameters of the Renderer.CloseSettings
type RendererMockCloseSettingsParams struct {
	cleanViewMode       string
	closeAction         map[string]any
	openCleanViewAction map[string]any
	appUUID             string
	refreshAppPayload   map[string]any
}

// RendererMockCloseSettingsParamPtrs contains pointers to parameters of the Renderer.CloseSettings
type RendererMockCloseSettingsParamPtrs struct {
	cleanViewMode       *string
	closeAction         *map[string]any
	openCleanViewAction *map[string]any
	appUUID             *string
	refreshAppPayload   *map[string]any
}

// RendererMockCloseSettingsResults contains results of the Renderer.CloseSettings
type RendererMockCloseSettingsResults struct {
	s1 string
}

// RendererMockCloseSettingsOrigins contains origins of expectations of the Renderer.CloseSettings
type RendererMockCloseSettingsExpectationOrigins struct {
	origin                    string
	originCleanViewMode       string
	originCloseAction         string
	originOpenCleanViewAction string
	originAppUUID             string
	originRefreshAppPayload   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCloseSettings *mRendererMockCloseSettings) Optional() *mRendererMockCloseSettings {
	mmCloseSettings.optional = true
	return mmCloseSettings
}

// Expect sets up expected params for Renderer.CloseSettings
func (mmCloseSettings *mRendererMockCloseSettings) Expect(cleanViewMode string, closeAction map[string]any, openCleanViewAction map[string]any, appUUID string, refreshAppPayload map[string]any) *mRendererMockCloseSettings {
	if mmCloseSettings.mock.funcCloseSettings != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by Set")
	}

	if mmCloseSettings.defaultExpectation == nil {
		mmCloseSettings.defaultExpectation = &RendererMockCloseSettingsExpectation{}
	}

	if mmCloseSettings.defaultExpectation.paramPtrs != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by ExpectParams functions")
	}

	mmCloseSettings.defaultExpectation.params = &RendererMockCloseSettingsParams{cleanViewMode, closeAction, openCleanViewAction, appUUID, refreshAppPayload}
	mmCloseSettings.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCloseSettings.expectations {
		if minimock.Equal(e.params, mmCloseSettings.defaultExpectation.params) {
			mmCloseSettings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCloseSettings.defaultExpectation.params)
		}
	}

	return mmCloseSettings
}

// ExpectCleanViewModeParam1 sets up expected param cleanViewMode for Renderer.CloseSettings
func (mmCloseSettings *mRendererMockCloseSettings) ExpectCleanViewModeParam1(cleanViewMode string) *mRendererMockCloseSettings {
	if mmCloseSettings.mock.funcCloseSettings != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by Set")
	}

	if mmCloseSettings.defaultExpectation == nil {
		mmCloseSettings.defaultExpectation = &RendererMockCloseSettingsExpectation{}
	}

	if mmCloseSettings.defaultExpectation.params != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by Expect")
	}

	if mmCloseSettings.defaultExpectation.paramPtrs == nil {
		mmCloseSettings.defaultExpectation.paramPtrs = &RendererMockCloseSettingsParamPtrs{}
	}
	mmCloseSettings.defaultExpectation.paramPtrs.cleanViewMode = &cleanViewMode
	mmCloseSettings.defaultExpectation.expectationOrigins.originCleanViewMode = minimock.CallerInfo(1)

	return mmCloseSettings
}

// ExpectCloseActionParam2 sets up expected param closeAction for Renderer.CloseSettings
func (mmCloseSettings *mRendererMockCloseSettings) ExpectCloseActionParam2(closeAction map[string]any) *mRendererMockCloseSettings {
	if mmCloseSettings.mock.funcCloseSettings != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by Set")
	}

	if mmCloseSettings.defaultExpectation == nil {
		mmCloseSettings.defaultExpectation = &RendererMockCloseSettingsExpectation{}
	}

	if mmCloseSettings.defaultExpectation.params != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by Expect")
	}

	if mmCloseSettings.defaultExpectation.paramPtrs == nil {
		mmCloseSettings.defaultExpectation.paramPtrs = &RendererMockCloseSettingsParamPtrs{}
	}
	mmCloseSettings.defaultExpectation.paramPtrs.closeAction = &closeAction
	mmCloseSettings.defaultExpectation.expectationOrigins.originCloseAction = minimock.CallerInfo(1)

	return mmCloseSettings
}

// ExpectOpenCleanViewActionParam3 sets up expected param openCleanViewAction for Renderer.CloseSettings
func (mmCloseSettings *mRendererMockCloseSettings) ExpectOpenCleanViewActionParam3(openCleanViewAction map[string]any) *mRendererMockCloseSettings {
	if mmCloseSettings.mock.funcCloseSettings != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by Set")
	}

	if mmCloseSettings.defaultExpectation == nil {
		mmCloseSettings.defaultExpectation = &RendererMockCloseSettingsExpectation{}
	}

	if mmCloseSettings.defaultExpectation.params != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by Expect")
	}

	if mmCloseSettings.defaultExpectation.paramPtrs == nil {
		mmCloseSettings.defaultExpectation.paramPtrs = &RendererMockCloseSettingsParamPtrs{}
	}
	mmCloseSettings.defaultExpectation.paramPtrs.openCleanViewAction = &openCleanViewAction
	mmCloseSettings.defaultExpectation.expectationOrigins.originOpenCleanViewAction = minimock.CallerInfo(1)

	return mmCloseSettings
}

// ExpectAppUUIDParam4 sets up expected param appUUID for Renderer.CloseSettings
func (mmCloseSettings *mRendererMockCloseSettings) ExpectAppUUIDParam4(appUUID string) *mRendererMockCloseSettings {
	if mmCloseSettings.mock.funcCloseSettings != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by Set")
	}

	if mmCloseSettings.defaultExpectation == nil {
		mmCloseSettings.defaultExpectation = &RendererMockCloseSettingsExpectation{}
	}

	if mmCloseSettings.defaultExpectation.params != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by Expect")
	}

	if mmCloseSettings.defaultExpectation.paramPtrs == nil {
		mmCloseSettings.defaultExpectation.paramPtrs = &RendererMockCloseSettingsParamPtrs{}
	}
	mmCloseSettings.defaultExpectation.paramPtrs.appUUID = &appUUID
	mmCloseSettings.defaultExpectation.expectationOrigins.originAppUUID = minimock.CallerInfo(1)

	return mmCloseSettings
}

// ExpectRefreshAppPayloadParam5 sets up expected param refreshAppPayload for Renderer.CloseSettings
func (mmCloseSettings *mRendererMockCloseSettings) ExpectRefreshAppPayloadParam5(refreshAppPayload map[string]any) *mRendererMockCloseSettings {
	if mmCloseSettings.mock.funcCloseSettings != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by Set")
	}

	if mmCloseSettings.defaultExpectation == nil {
		mmCloseSettings.defaultExpectation = &RendererMockCloseSettingsExpectation{}
	}

	if mmCloseSettings.defaultExpectation.params != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by Expect")
	}

	if mmCloseSettings.defaultExpectation.paramPtrs == nil {
		mmCloseSettings.defaultExpectation.paramPtrs = &RendererMockCloseSettingsParamPtrs{}
	}
	mmCloseSettings.defaultExpectation.paramPtrs.refreshAppPayload = &refreshAppPayload
	mmCloseSettings.defaultExpectation.expectationOrigins.originRefreshAppPayload = minimock.CallerInfo(1)

	return mmCloseSettings
}

// Inspect accepts an inspector function that has same arguments as the Renderer.CloseSettings
func (mmCloseSettings *mRendererMockCloseSettings) Inspect(f func(cleanViewMode string, closeAction map[string]any, openCleanViewAction map[string]any, appUUID string, refreshAppPayload map[string]any)) *mRendererMockCloseSettings {
	if mmCloseSettings.mock.inspectFuncCloseSettings != nil {
		mmCloseSettings.mock.t.Fatalf("Inspect function is already set for RendererMock.CloseSettings")
	}

	mmCloseSettings.mock.inspectFuncCloseSettings = f

	return mmCloseSettings
}

// Return sets up results that will be returned by Renderer.CloseSettings
func (mmCloseSettings *mRendererMockCloseSettings) Return(s1 string) *RendererMock {
	if mmCloseSettings.mock.funcCloseSettings != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by Set")
	}

	if mmCloseSettings.defaultExpectation == nil {
		mmCloseSettings.defaultExpectation = &RendererMockCloseSettingsExpectation{mock: mmCloseSettings.mock}
	}
	mmCloseSettings.defaultExpectation.results = &RendererMockCloseSettingsResults{s1}
	mmCloseSettings.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCloseSettings.mock
}

// Set uses given function f to mock the Renderer.CloseSettings method
func (mmCloseSettings *mRendererMockCloseSettings) Set(f func(cleanViewMode string, closeAction map[string]any, openCleanViewAction map[string]any, appUUID string, refreshAppPayload map[string]any) (s1 string)) *RendererMock {
	if mmCloseSettings.defaultExpectation != nil {
		mmCloseSettings.mock.t.Fatalf("Default expectation is already set for the Renderer.CloseSettings method")
	}

	if len(mmCloseSettings.expectations) > 0 {
		mmCloseSettings.mock.t.Fatalf("Some expectations are already set for the Renderer.CloseSettings method")
	}

	mmCloseSettings.mock.funcCloseSettings = f
	mmCloseSettings.mock.funcCloseSettingsOrigin = minimock.CallerInfo(1)
	return mmCloseSettings.mock
}

// When sets expectation for the Renderer.CloseSettings which will trigger the result defined by the following
// Then helper
func (mmCloseSettings *mRendererMockCloseSettings) When(cleanViewMode string, closeAction map[string]any, openCleanViewAction map[string]any, appUUID string, refreshAppPayload map[string]any) *RendererMockCloseSettingsExpectation {
	if mmCloseSettings.mock.funcCloseSettings != nil {
		mmCloseSettings.mock.t.Fatalf("RendererMock.CloseSettings mock is already set by Set")
	}

	expectation := &RendererMockCloseSettingsExpectation{
		mock:               mmCloseSettings.mock,
		params:             &RendererMockCloseSettingsParams{cleanViewMode, closeAction, openCleanViewAction, appUUID, refreshAppPayload},
		expectationOrigins: RendererMockCloseSettingsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCloseSettings.expectations = append(mmCloseSettings.expectations, expectation)
	return expectation
}

// Then sets up Renderer.CloseSettings return parameters for the expectation previously defined by the When method
func (e *RendererMockCloseSettingsExpectation) Then(s1 string) *RendererMock {
	e.results = &RendererMockCloseSettingsResults{s1}
	return e.mock
}

// Times sets number of times Renderer.CloseSettings should be invoked
func (mmCloseSettings *mRendererMockCloseSettings) Times(n uint64) *mRendererMockCloseSettings {
	if n == 0 {
		mmCloseSettings.mock.t.Fatalf("Times of RendererMock.CloseSettings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCloseSettings.expectedInvocations, n)
	mmCloseSettings.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCloseSettings
}

func (mmCloseSettings *mRendererMockCloseSettings) invocationsDone() bool {
	if len(mmCloseSettings.expectations) == 0 && mmCloseSettings.defaultExpectation == nil && mmCloseSettings.mock.funcCloseSettings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCloseSettings.mock.afterCloseSettingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCloseSettings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CloseSettings implements Renderer
func (mmCloseSettings *RendererMock) CloseSettings(cleanViewMode string, closeAction map[string]any, openCleanViewAction map[string]any, appUUID string, refreshAppPayload map[string]any) (s1 string) {
	mm_atomic.AddUint64(&mmCloseSettings.beforeCloseSettingsCounter, 1)
	defer mm_atomic.AddUint64(&mmCloseSettings.afterCloseSettingsCounter, 1)

	mmCloseSettings.t.Helper()

	if mmCloseSettings.inspectFuncCloseSettings != nil {
		mmCloseSettings.inspectFuncCloseSettings(cleanViewMode, closeAction, openCleanViewAction, appUUID, refreshAppPayload)
	}

	mm_params := RendererMockCloseSettingsParams{cleanViewMode, closeAction, openCleanViewAction, appUUID, refreshAppPayload}

	// Record call args
	mmCloseSettings.CloseSettingsMock.mutex.Lock()
	mmCloseSettings.CloseSettingsMock.callArgs = append(mmCloseSettings.CloseSettingsMock.callArgs, &mm_params)
	mmCloseSettings.CloseSettingsMock.mutex.Unlock()

	for _, e := range mmCloseSettings.CloseSettingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmCloseSettings.CloseSettingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCloseSettings.CloseSettingsMock.defaultExpectation.Counter, 1)
		mm_want := mmCloseSettings.CloseSettingsMock.defaultExpectation.params
		mm_want_ptrs := mmCloseSettings.CloseSettingsMock.defaultExpectation.paramPtrs

		mm_got := RendererMockCloseSettingsParams{cleanViewMode, closeAction, openCleanViewAction, appUUID, refreshAppPayload}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.cleanViewMode != nil && !minimock.Equal(*mm_want_ptrs.cleanViewMode, mm_got.cleanViewMode) {
				mmCloseSettings.t.Errorf("RendererMock.CloseSettings got unexpected parameter cleanViewMode, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCloseSettings.CloseSettingsMock.defaultExpectation.expectationOrigins.originCleanViewMode, *mm_want_ptrs.cleanViewMode, mm_got.cleanViewMode, minimock.Diff(*mm_want_ptrs.cleanViewMode, mm_got.cleanViewMode))
			}

			if mm_want_ptrs.closeAction != nil && !minimock.Equal(*mm_want_ptrs.closeAction, mm_got.closeAction) {
				mmCloseSettings.t.Errorf("RendererMock.CloseSettings got unexpected parameter closeAction, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCloseSettings.CloseSettingsMock.defaultExpectation.expectationOrigins.originCloseAction, *mm_want_ptrs.closeAction, mm_got.closeAction, minimock.Diff(*mm_want_ptrs.closeAction, mm_got.closeAction))
			}

			if mm_want_ptrs.openCleanViewAction != nil && !minimock.Equal(*mm_want_ptrs.openCleanViewAction, mm_got.openCleanViewAction) {
				mmCloseSettings.t.Errorf("RendererMock.CloseSettings got unexpected parameter openCleanViewAction, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCloseSettings.CloseSettingsMock.defaultExpectation.expectationOrigins.originOpenCleanViewAction, *mm_want_ptrs.openCleanViewAction, mm_got.openCleanViewAction, minimock.Diff(*mm_want_ptrs.openCleanViewAction, mm_got.openCleanViewAction))
			}

			if mm_want_ptrs.appUUID != nil && !minimock.Equal(*mm_want_ptrs.appUUID, mm_got.appUUID) {
				mmCloseSettings.t.Errorf("RendererMock.CloseSettings got unexpected parameter appUUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCloseSettings.CloseSettingsMock.defaultExpectation.expectationOrigins.originAppUUID, *mm_want_ptrs.appUUID, mm_got.appUUID, minimock.Diff(*mm_want_ptrs.appUUID, mm_got.appUUID))
			}

			if mm_want_ptrs.refreshAppPayload != nil && !minimock.Equal(*mm_want_ptrs.refreshAppPayload, mm_got.refreshAppPayload) {
				mmCloseSettings.t.Errorf("RendererMock.CloseSettings got unexpected parameter refreshAppPayload, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCloseSettings.CloseSettingsMock.defaultExpectation.expectationOrigins.originRefreshAppPayload, *mm_want_ptrs.refreshAppPayload, mm_got.refreshAppPayload, minimock.Diff(*mm_want_ptrs.refreshAppPayload, mm_got.refreshAppPayload))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCloseSettings.t.Errorf("RendererMock.CloseSettings got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCloseSettings.CloseSettingsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCloseSettings.CloseSettingsMock.defaultExpectation.results
		if mm_results == nil {
			mmCloseSettings.t.Fatal("No results are set for the RendererMock.CloseSettings")
		}
		return (*mm_results).s1
	}
	if mmCloseSettings.funcCloseSettings != nil {
		return mmCloseSettings.funcCloseSettings(cleanViewMode, closeAction, openCleanViewAction, appUUID, refreshAppPayload)
	}
	mmCloseSettings.t.Fatalf("Unexpected call to RendererMock.CloseSettings. %v %v %v %v %v", cleanViewMode, closeAction, openCleanViewAction, appUUID, refreshAppPayload)
	return
}

// CloseSettingsAfterCounter returns a count of finished RendererMock.CloseSettings invocations
func (mmCloseSettings *RendererMock) CloseSettingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseSettings.afterCloseSettingsCounter)
}

// CloseSettingsBeforeCounter returns a count of RendererMock.CloseSettings invocations
func (mmCloseSettings *RendererMock) CloseSettingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseSettings.beforeCloseSettingsCounter)
}

// Calls returns a list of arguments used in each call to RendererMock.CloseSettings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCloseSettings *mRendererMockCloseSettings) Calls() []*RendererMockCloseSettingsParams {
	mmCloseSettings.mutex.RLock()

	argCopy := make([]*RendererMockCloseSettingsParams, len(mmCloseSettings.callArgs))
	copy(argCopy, mmCloseSettings.callArgs)

	mmCloseSettings.mutex.RUnlock()

	return argCopy
}

// MinimockCloseSettingsDone returns true if the count of the CloseSettings invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockCloseSettingsDone() bool {
	if m.CloseSettingsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseSettingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseSettingsMock.invocationsDone()
}

// MinimockCloseSettingsInspect logs each unmet expectation
func (m *RendererMock) MinimockCloseSettingsInspect() {
	for _, e := range m.CloseSettingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RendererMock.CloseSettings at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCloseSettingsCounter := mm_atomic.LoadUint64(&m.afterCloseSettingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseSettingsMock.defaultExpectation != nil && afterCloseSettingsCounter < 1 {
		if m.CloseSettingsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RendererMock.CloseSettings at\n%s", m.CloseSettingsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RendererMock.CloseSettings at\n%s with params: %#v", m.CloseSettingsMock.defaultExpectation.expectationOrigins.origin, *m.CloseSettingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCloseSettings != nil && afterCloseSettingsCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.CloseSettings at\n%s", m.funcCloseSettingsOrigin)
	}

	if !m.CloseSettingsMock.invocationsDone() && afterCloseSettingsCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.CloseSettings at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseSettingsMock.expectedInvocations), m.CloseSettingsMock.expectedInvocationsOrigin, afterCloseSettingsCounter)
	}
}

type mRendererMockCopyText struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockCopyTextExpectation
	expectations       []*RendererMockCopyTextExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockCopyTextExpectation specifies expectation struct of the Renderer.CopyText
type RendererMockCopyTextExpectation struct {
	mock *RendererMock

	results      *RendererMockCopyTextResults
	returnOrigin string
	Counter      uint64
}

// RendererMockCopyTextResults contains results of the Renderer.CopyText
type RendererMockCopyTextResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCopyText *mRendererMockCopyText) Optional() *mRendererMockCopyText {
	mmCopyText.optional = true
	return mmCopyText
}

// Expect sets up expected params for Renderer.CopyText
func (mmCopyText *mRendererMockCopyText) Expect() *mRendererMockCopyText {
	if mmCopyText.mock.funcCopyText != nil {
		mmCopyText.mock.t.Fatalf("RendererMock.CopyText mock is already set by Set")
	}

	if mmCopyText.defaultExpectation == nil {
		mmCopyText.defaultExpectation = &RendererMockCopyTextExpectation{}
	}

	return mmCopyText
}

// Inspect accepts an inspector function that has same arguments as the Renderer.CopyText
func (mmCopyText *mRendererMockCopyText) Inspect(f func()) *mRendererMockCopyText {
	if mmCopyText.mock.inspectFuncCopyText != nil {
		mmCopyText.mock.t.Fatalf("Inspect function is already set for RendererMock.CopyText")
	}

	mmCopyText.mock.inspectFuncCopyText = f

	return mmCopyText
}

// Return sets up results that will be returned by Renderer.CopyText
func (mmCopyText *mRendererMockCopyText) Return(s1 string) *RendererMock {
	if mmCopyText.mock.funcCopyText != nil {
		mmCopyText.mock.t.Fatalf("RendererMock.CopyText mock is already set by Set")
	}

	if mmCopyText.defaultExpectation == nil {
		mmCopyText.defaultExpectation = &RendererMockCopyTextExpectation{mock: mmCopyText.mock}
	}
	mmCopyText.defaultExpectation.results = &RendererMockCopyTextResults{s1}
	mmCopyText.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCopyText.mock
}

// Set uses given function f to mock the Renderer.CopyText method
func (mmCopyText *mRendererMockCopyText) Set(f func() (s1 string)) *RendererMock {
	if mmCopyText.defaultExpectation != nil {
		mmCopyText.mock.t.Fatalf("Default expectation is already set for the Renderer.CopyText method")
	}

	if len(mmCopyText.expectations) > 0 {
		mmCopyText.mock.t.Fatalf("Some expectations are already set for the Renderer.CopyText method")
	}

	mmCopyText.mock.funcCopyText = f
	mmCopyText.mock.funcCopyTextOrigin = minimock.CallerInfo(1)
	return mmCopyText.mock
}

// Times sets number of times Renderer.CopyText should be invoked
func (mmCopyText *mRendererMockCopyText) Times(n uint64) *mRendererMockCopyText {
	if n == 0 {
		mmCopyText.mock.t.Fatalf("Times of RendererMock.CopyText mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCopyText.expectedInvocations, n)
	mmCopyText.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCopyText
}

func (mmCopyText *mRendererMockCopyText) invocationsDone() bool {
	if len(mmCopyText.expectations) == 0 && mmCopyText.defaultExpectation == nil && mmCopyText.mock.funcCopyText == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCopyText.mock.afterCopyTextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCopyText.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CopyText implements Renderer
func (mmCopyText *RendererMock) CopyText() (s1 string) {
	mm_atomic.AddUint64(&mmCopyText.beforeCopyTextCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyText.afterCopyTextCounter, 1)

	mmCopyText.t.Helper()

	if mmCopyText.inspectFuncCopyText != nil {
		mmCopyText.inspectFuncCopyText()
	}

	if mmCopyText.CopyTextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyText.CopyTextMock.defaultExpectation.Counter, 1)

		mm_results := mmCopyText.CopyTextMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyText.t.Fatal("No results are set for the RendererMock.CopyText")
		}
		return (*mm_results).s1
	}
	if mmCopyText.funcCopyText != nil {
		return mmCopyText.funcCopyText()
	}
	mmCopyText.t.Fatalf("Unexpected call to RendererMock.CopyText.")
	return
}

// CopyTextAfterCounter returns a count of finished RendererMock.CopyText invocations
func (mmCopyText *RendererMock) CopyTextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyText.afterCopyTextCounter)
}

// CopyTextBeforeCounter returns a count of RendererMock.CopyText invocations
func (mmCopyText *RendererMock) CopyTextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyText.beforeCopyTextCounter)
}

// MinimockCopyTextDone returns true if the count of the CopyText invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockCopyTextDone() bool {
	if m.CopyTextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CopyTextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CopyTextMock.invocationsDone()
}

// MinimockCopyTextInspect logs each unmet expectation
func (m *RendererMock) MinimockCopyTextInspect() {
	for _, e := range m.CopyTextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RendererMock.CopyText")
		}
	}

	afterCopyTextCounter := mm_atomic.LoadUint64(&m.afterCopyTextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CopyTextMock.defaultExpectation != nil && afterCopyTextCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.CopyText at\n%s", m.CopyTextMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyText != nil && afterCopyTextCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.CopyText at\n%s", m.funcCopyTextOrigin)
	}

	if !m.CopyTextMock.invocationsDone() && afterCopyTextCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.CopyText at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CopyTextMock.expectedInvocations), m.CopyTextMock.expectedInvocationsOrigin, afterCopyTextCounter)
	}
}

type mRendererMockFloatingPage struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockFloatingPageExpectation
	expectations       []*RendererMockFloatingPageExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockFloatingPageExpectation specifies expectation struct of the Renderer.FloatingPage
type RendererMockFloatingPageExpectation struct {
	mock *RendererMock

	results      *RendererMockFloatingPageResults
	returnOrigin string
	Counter      uint64
}

// RendererMockFloatingPageResults contains results of the Renderer.FloatingPage
type RendererMockFloatingPageResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFloatingPage *mRendererMockFloatingPage) Optional() *mRendererMockFloatingPage {
	mmFloatingPage.optional = true
	return mmFloatingPage
}

// Expect sets up expected params for Renderer.FloatingPage
func (mmFloatingPage *mRendererMockFloatingPage) Expect() *mRendererMockFloatingPage {
	if mmFloatingPage.mock.funcFloatingPage != nil {
		mmFloatingPage.mock.t.Fatalf("RendererMock.FloatingPage mock is already set by Set")
	}

	if mmFloatingPage.defaultExpectation == nil {
		mmFloatingPage.defaultExpectation = &RendererMockFloatingPageExpectation{}
	}

	return mmFloatingPage
}

// Inspect accepts an inspector function that has same arguments as the Renderer.FloatingPage
func (mmFloatingPage *mRendererMockFloatingPage) Inspect(f func()) *mRendererMockFloatingPage {
	if mmFloatingPage.mock.inspectFuncFloatingPage != nil {
		mmFloatingPage.mock.t.Fatalf("Inspect function is already set for RendererMock.FloatingPage")
	}

	mmFloatingPage.mock.inspectFuncFloatingPage = f

	return mmFloatingPage
}

// Return sets up results that will be returned by Renderer.FloatingPage
func (mmFloatingPage *mRendererMockFloatingPage) Return(s1 string) *RendererMock {
	if mmFloatingPage.mock.funcFloatingPage != nil {
		mmFloatingPage.mock.t.Fatalf("RendererMock.FloatingPage mock is already set by Set")
	}

	if mmFloatingPage.defaultExpectation == nil {
		mmFloatingPage.defaultExpectation = &RendererMockFloatingPageExpectation{mock: mmFloatingPage.mock}
	}
	mmFloatingPage.defaultExpectation.results = &RendererMockFloatingPageResults{s1}
	mmFloatingPage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFloatingPage.mock
}

// Set uses given function f to mock the Renderer.FloatingPage method
func (mmFloatingPage *mRendererMockFloatingPage) Set(f func() (s1 string)) *RendererMock {
	if mmFloatingPage.defaultExpectation != nil {
		mmFloatingPage.mock.t.Fatalf("Default expectation is already set for the Renderer.FloatingPage method")
	}

	if len(mmFloatingPage.expectations) > 0 {
		mmFloatingPage.mock.t.Fatalf("Some expectations are already set for the Renderer.FloatingPage method")
	}

	mmFloatingPage.mock.funcFloatingPage = f
	mmFloatingPage.mock.funcFloatingPageOrigin = minimock.CallerInfo(1)
	return mmFloatingPage.mock
}

// Times sets number of times Renderer.FloatingPage should be invoked
func (mmFloatingPage *mRendererMockFloatingPage) Times(n uint64) *mRendererMockFloatingPage {
	if n == 0 {
		mmFloatingPage.mock.t.Fatalf("Times of RendererMock.FloatingPage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFloatingPage.expectedInvocations, n)
	mmFloatingPage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFloatingPage
}

func (mmFloatingPage *mRendererMockFloatingPage) invocationsDone() bool {
	if len(mmFloatingPage.expectations) == 0 && mmFloatingPage.defaultExpectation == nil && mmFloatingPage.mock.funcFloatingPage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFloatingPage.mock.afterFloatingPageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFloatingPage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FloatingPage implements Renderer
func (mmFloatingPage *RendererMock) FloatingPage() (s1 string) {
	mm_atomic.AddUint64(&mmFloatingPage.beforeFloatingPageCounter, 1)
	defer mm_atomic.AddUint64(&mmFloatingPage.afterFloatingPageCounter, 1)

	mmFloatingPage.t.Helper()

	if mmFloatingPage.inspectFuncFloatingPage != nil {
		mmFloatingPage.inspectFuncFloatingPage()
	}

	if mmFloatingPage.FloatingPageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFloatingPage.FloatingPageMock.defaultExpectation.Counter, 1)

		mm_results := mmFloatingPage.FloatingPageMock.defaultExpectation.results
		if mm_results == nil {
			mmFloatingPage.t.Fatal("No results are set for the RendererMock.FloatingPage")
		}
		return (*mm_results).s1
	}
	if mmFloatingPage.funcFloatingPage != nil {
		return mmFloatingPage.funcFloatingPage()
	}
	mmFloatingPage.t.Fatalf("Unexpected call to RendererMock.FloatingPage.")
	return
}

// FloatingPageAfterCounter returns a count of finished RendererMock.FloatingPage invocations
func (mmFloatingPage *RendererMock) FloatingPageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFloatingPage.afterFloatingPageCounter)
}

// FloatingPageBeforeCounter returns a count of RendererMock.FloatingPage invocations
func (mmFloatingPage *RendererMock) FloatingPageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFloatingPage.beforeFloatingPageCounter)
}

// MinimockFloatingPageDone returns true if the count of the FloatingPage invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockFloatingPageDone() bool {
	if m.FloatingPageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FloatingPageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FloatingPageMock.invocationsDone()
}

// MinimockFloatingPageInspect logs each unmet expectation
func (m *RendererMock) MinimockFloatingPageInspect() {
	for _, e := range m.FloatingPageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RendererMock.FloatingPage")
		}
	}

	afterFloatingPageCounter := mm_atomic.LoadUint64(&m.afterFloatingPageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FloatingPageMock.defaultExpectation != nil && afterFloatingPageCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.FloatingPage at\n%s", m.FloatingPageMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFloatingPage != nil && afterFloatingPageCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.FloatingPage at\n%s", m.funcFloatingPageOrigin)
	}

	if !m.FloatingPageMock.invocationsDone() && afterFloatingPageCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.FloatingPage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FloatingPageMock.expectedInvocations), m.FloatingPageMock.expectedInvocationsOrigin, afterFloatingPageCounter)
	}
}

type mRendererMockListenSocket struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockListenSocketExpectation
	expectations       []*RendererMockListenSocketExpectation

	callArgs []*RendererMockListenSocketParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockListenSocketExpectation specifies expectation struct of the Renderer.ListenSocket
type RendererMockListenSocketExpectation struct {
	mock               *RendererMock
	params             *RendererMockListenSocketParams
	paramPtrs          *RendererMockListenSocketParamPtrs
	expectationOrigins RendererMockListenSocketExpectationOrigins
	results            *RendererMockListenSocketResults
	returnOrigin       string
	Counter            uint64
}

// RendererMockListenSocketParams contains parameters of the Renderer.ListenSocket
type RendererMockListenSocketParams struct {
	socketPath string
}

// RendererMockListenSocketParamPtrs contains pointers to parameters of the Renderer.ListenSocket
type RendererMockListenSocketParamPtrs struct {
	socketPath *string
}

// RendererMockListenSocketResults contains results of the Renderer.ListenSocket
type RendererMockListenSocketResults struct {
	s1 string
}

// RendererMockListenSocketOrigins contains origins of expectations of the Renderer.ListenSocket
type RendererMockListenSocketExpectationOrigins struct {
	origin           string
	originSocketPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListenSocket *mRendererMockListenSocket) Optional() *mRendererMockListenSocket {
	mmListenSocket.optional = true
	return mmListenSocket
}

// Expect sets up expected params for Renderer.ListenSocket
func (mmListenSocket *mRendererMockListenSocket) Expect(socketPath string) *mRendererMockListenSocket {
	if mmListenSocket.mock.funcListenSocket != nil {
		mmListenSocket.mock.t.Fatalf("RendererMock.ListenSocket mock is already set by Set")
	}

	if mmListenSocket.defaultExpectation == nil {
		mmListenSocket.defaultExpectation = &RendererMockListenSocketExpectation{}
	}

	if mmListenSocket.defaultExpectation.paramPtrs != nil {
		mmListenSocket.mock.t.Fatalf("RendererMock.ListenSocket mock is already set by ExpectParams functions")
	}

	mmListenSocket.defaultExpectation.params = &RendererMockListenSocketParams{socketPath}
	mmListenSocket.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListenSocket.expectations {
		if minimock.Equal(e.params, mmListenSocket.defaultExpectation.params) {
			mmListenSocket.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListenSocket.defaultExpectation.params)
		}
	}

	return mmListenSocket
}

// ExpectSocketPathParam1 sets up expected param socketPath for Renderer.ListenSocket
func (mmListenSocket *mRendererMockListenSocket) ExpectSocketPathParam1(socketPath string) *mRendererMockListenSocket {
	if mmListenSocket.mock.funcListenSocket != nil {
		mmListenSocket.mock.t.Fatalf("RendererMock.ListenSocket mock is already set by Set")
	}

	if mmListenSocket.defaultExpectation == nil {
		mmListenSocket.defaultExpectation = &RendererMockListenSocketExpectation{}
	}

	if mmListenSocket.defaultExpectation.params != nil {
		mmListenSocket.mock.t.Fatalf("RendererMock.ListenSocket mock is already set by Expect")
	}

	if mmListenSocket.defaultExpectation.paramPtrs == nil {
		mmListenSocket.defaultExpectation.paramPtrs = &RendererMockListenSocketParamPtrs{}
	}
	mmListenSocket.defaultExpectation.paramPtrs.socketPath = &socketPath
	mmListenSocket.defaultExpectation.expectationOrigins.originSocketPath = minimock.CallerInfo(1)

	return mmListenSocket
}

// Inspect accepts an inspector function that has same arguments as the Renderer.ListenSocket
func (mmListenSocket *mRendererMockListenSocket) Inspect(f func(socketPath string)) *mRendererMockListenSocket {
	if mmListenSocket.mock.inspectFuncListenSocket != nil {
		mmListenSocket.mock.t.Fatalf("Inspect function is already set for RendererMock.ListenSocket")
	}

	mmListenSocket.mock.inspectFuncListenSocket = f

	return mmListenSocket
}

// Return sets up results that will be returned by Renderer.ListenSocket
func (mmListenSocket *mRendererMockListenSocket) Return(s1 string) *RendererMock {
	if mmListenSocket.mock.funcListenSocket != nil {
		mmListenSocket.mock.t.Fatalf("RendererMock.ListenSocket mock is already set by Set")
	}

	if mmListenSocket.defaultExpectation == nil {
		mmListenSocket.defaultExpectation = &RendererMockListenSocketExpectation{mock: mmListenSocket.mock}
	}
	mmListenSocket.defaultExpectation.results = &RendererMockListenSocketResults{s1}
	mmListenSocket.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListenSocket.mock
}

// Set uses given function f to mock the Renderer.ListenSocket method
func (mmListenSocket *mRendererMockListenSocket) Set(f func(socketPath string) (s1 string)) *RendererMock {
	if mmListenSocket.defaultExpectation != nil {
		mmListenSocket.mock.t.Fatalf("Default expectation is already set for the Renderer.ListenSocket method")
	}

	if len(mmListenSocket.expectations) > 0 {
		mmListenSocket.mock.t.Fatalf("Some expectations are already set for the Renderer.ListenSocket method")
	}

	mmListenSocket.mock.funcListenSocket = f
	mmListenSocket.mock.funcListenSocketOrigin = minimock.CallerInfo(1)
	return mmListenSocket.mock
}

// When sets expectation for the Renderer.ListenSocket which will trigger the result defined by the following
// Then helper
func (mmListenSocket *mRendererMockListenSocket) When(socketPath string) *RendererMockListenSocketExpectation {
	if mmListenSocket.mock.funcListenSocket != nil {
		mmListenSocket.mock.t.Fatalf("RendererMock.ListenSocket mock is already set by Set")
	}

	expectation := &RendererMockListenSocketExpectation{
		mock:               mmListenSocket.mock,
		params:             &RendererMockListenSocketParams{socketPath},
		expectationOrigins: RendererMockListenSocketExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListenSocket.expectations = append(mmListenSocket.expectations, expectation)
	return expectation
}

// Then sets up Renderer.ListenSocket return parameters for the expectation previously defined by the When method
func (e *RendererMockListenSocketExpectation) Then(s1 string) *RendererMock {
	e.results = &RendererMockListenSocketResults{s1}
	return e.mock
}

// Times sets number of times Renderer.ListenSocket should be invoked
func (mmListenSocket *mRendererMockListenSocket) Times(n uint64) *mRendererMockListenSocket {
	if n == 0 {
		mmListenSocket.mock.t.Fatalf("Times of RendererMock.ListenSocket mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListenSocket.expectedInvocations, n)
	mmListenSocket.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListenSocket
}

func (mmListenSocket *mRendererMockListenSocket) invocationsDone() bool {
	if len(mmListenSocket.expectations) == 0 && mmListenSocket.defaultExpectation == nil && mmListenSocket.mock.funcListenSocket == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListenSocket.mock.afterListenSocketCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListenSocket.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListenSocket implements Renderer
func (mmListenSocket *RendererMock) ListenSocket(socketPath string) (s1 string) {
	mm_atomic.AddUint64(&mmListenSocket.beforeListenSocketCounter, 1)
	defer mm_atomic.AddUint64(&mmListenSocket.afterListenSocketCounter, 1)

	mmListenSocket.t.Helper()

	if mmListenSocket.inspectFuncListenSocket != nil {
		mmListenSocket.inspectFuncListenSocket(socketPath)
	}

	mm_params := RendererMockListenSocketParams{socketPath}

	// Record call args
	mmListenSocket.ListenSocketMock.mutex.Lock()
	mmListenSocket.ListenSocketMock.callArgs = append(mmListenSocket.ListenSocketMock.callArgs, &mm_params)
	mmListenSocket.ListenSocketMock.mutex.Unlock()

	for _, e := range mmListenSocket.ListenSocketMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmListenSocket.ListenSocketMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListenSocket.ListenSocketMock.defaultExpectation.Counter, 1)
		mm_want := mmListenSocket.ListenSocketMock.defaultExpectation.params
		mm_want_ptrs := mmListenSocket.ListenSocketMock.defaultExpectation.paramPtrs

		mm_got := RendererMockListenSocketParams{socketPath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.socketPath != nil && !minimock.Equal(*mm_want_ptrs.socketPath, mm_got.socketPath) {
				mmListenSocket.t.Errorf("RendererMock.ListenSocket got unexpected parameter socketPath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListenSocket.ListenSocketMock.defaultExpectation.expectationOrigins.originSocketPath, *mm_want_ptrs.socketPath, mm_got.socketPath, minimock.Diff(*mm_want_ptrs.socketPath, mm_got.socketPath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListenSocket.t.Errorf("RendererMock.ListenSocket got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListenSocket.ListenSocketMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListenSocket.ListenSocketMock.defaultExpectation.results
		if mm_results == nil {
			mmListenSocket.t.Fatal("No results are set for the RendererMock.ListenSocket")
		}
		return (*mm_results).s1
	}
	if mmListenSocket.funcListenSocket != nil {
		return mmListenSocket.funcListenSocket(socketPath)
	}
	mmListenSocket.t.Fatalf("Unexpected call to RendererMock.ListenSocket. %v", socketPath)
	return
}

// ListenSocketAfterCounter returns a count of finished RendererMock.ListenSocket invocations
func (mmListenSocket *RendererMock) ListenSocketAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListenSocket.afterListenSocketCounter)
}

// ListenSocketBeforeCounter returns a count of RendererMock.ListenSocket invocations
func (mmListenSocket *RendererMock) ListenSocketBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListenSocket.beforeListenSocketCounter)
}

// Calls returns a list of arguments used in each call to RendererMock.ListenSocket.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListenSocket *mRendererMockListenSocket) Calls() []*RendererMockListenSocketParams {
	mmListenSocket.mutex.RLock()

	argCopy := make([]*RendererMockListenSocketParams, len(mmListenSocket.callArgs))
	copy(argCopy, mmListenSocket.callArgs)

	mmListenSocket.mutex.RUnlock()

	return argCopy
}

// MinimockListenSocketDone returns true if the count of the ListenSocket invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockListenSocketDone() bool {
	if m.ListenSocketMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListenSocketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListenSocketMock.invocationsDone()
}

// MinimockListenSocketInspect logs each unmet expectation
func (m *RendererMock) MinimockListenSocketInspect() {
	for _, e := range m.ListenSocketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RendererMock.ListenSocket at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListenSocketCounter := mm_atomic.LoadUint64(&m.afterListenSocketCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListenSocketMock.defaultExpectation != nil && afterListenSocketCounter < 1 {
		if m.ListenSocketMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RendererMock.ListenSocket at\n%s", m.ListenSocketMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RendererMock.ListenSocket at\n%s with params: %#v", m.ListenSocketMock.defaultExpectation.expectationOrigins.origin, *m.ListenSocketMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListenSocket != nil && afterListenSocketCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.ListenSocket at\n%s", m.funcListenSocketOrigin)
	}

	if !m.ListenSocketMock.invocationsDone() && afterListenSocketCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.ListenSocket at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListenSocketMock.expectedInvocations), m.ListenSocketMock.expectedInvocationsOrigin, afterListenSocketCounter)
	}
}

type mRendererMockOpenSettings struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockOpenSettingsExpectation
	expectations       []*RendererMockOpenSettingsExpectation

	callArgs []*RendererMockOpenSettingsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockOpenSettingsExpectation specifies expectation struct of the Renderer.OpenSettings
type RendererMockOpenSettingsExpectation struct {
	mock               *RendererMock
	params             *RendererMockOpenSettingsParams
	paramPtrs          *RendererMockOpenSettingsParamPtrs
	expectationOrigins RendererMockOpenSettingsExpectationOrigins
	results            *RendererMockOpenSettingsResults
	returnOrigin       string
	Counter            uint64
}

// RendererMockOpenSettingsParams contains parameters of the Renderer.OpenSettings
type RendererMockOpenSettingsParams struct {
	action map[string]any
}

// RendererMockOpenSettingsParamPtrs contains pointers to parameters of the Renderer.OpenSettings
type RendererMockOpenSettingsParamPtrs struct {
	action *map[string]any
}

// RendererMockOpenSettingsResults contains results of the Renderer.OpenSettings
type RendererMockOpenSettingsResults struct {
	s1 string
}

// RendererMockOpenSettingsOrigins contains origins of expectations of the Renderer.OpenSettings
type RendererMockOpenSettingsExpectationOrigins struct {
	origin       string
	originAction string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOpenSettings *mRendererMockOpenSettings) Optional() *mRendererMockOpenSettings {
	mmOpenSettings.optional = true
	return mmOpenSettings
}

// Expect sets up expected params for Renderer.OpenSettings
func (mmOpenSettings *mRendererMockOpenSettings) Expect(action map[string]any) *mRendererMockOpenSettings {
	if mmOpenSettings.mock.funcOpenSettings != nil {
		mmOpenSettings.mock.t.Fatalf("RendererMock.OpenSettings mock is already set by Set")
	}

	if mmOpenSettings.defaultExpectation == nil {
		mmOpenSettings.defaultExpectation = &RendererMockOpenSettingsExpectation{}
	}

	if mmOpenSettings.defaultExpectation.paramPtrs != nil {
		mmOpenSettings.mock.t.Fatalf("RendererMock.OpenSettings mock is already set by ExpectParams functions")
	}

	mmOpenSettings.defaultExpectation.params = &RendererMockOpenSettingsParams{action}
	mmOpenSettings.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOpenSettings.expectations {
		if minimock.Equal(e.params, mmOpenSettings.defaultExpectation.params) {
			mmOpenSettings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOpenSettings.defaultExpectation.params)
		}
	}

	return mmOpenSettings
}

// ExpectActionParam1 sets up expected param action for Renderer.OpenSettings
func (mmOpenSettings *mRendererMockOpenSettings) ExpectActionParam1(action map[string]any) *mRendererMockOpenSettings {
	if mmOpenSettings.mock.funcOpenSettings != nil {
		mmOpenSettings.mock.t.Fatalf("RendererMock.OpenSettings mock is already set by Set")
	}

	if mmOpenSettings.defaultExpectation == nil {
		mmOpenSettings.defaultExpectation = &RendererMockOpenSettingsExpectation{}
	}

	if mmOpenSettings.defaultExpectation.params != nil {
		mmOpenSettings.mock.t.Fatalf("RendererMock.OpenSettings mock is already set by Expect")
	}

	if mmOpenSettings.defaultExpectation.paramPtrs == nil {
		mmOpenSettings.defaultExpectation.paramPtrs = &RendererMockOpenSettingsParamPtrs{}
	}
	mmOpenSettings.defaultExpectation.paramPtrs.action = &action
	mmOpenSettings.defaultExpectation.expectationOrigins.originAction = minimock.CallerInfo(1)

	return mmOpenSettings
}

// Inspect accepts an inspector function that has same arguments as the Renderer.OpenSettings
func (mmOpenSettings *mRendererMockOpenSettings) Inspect(f func(action map[string]any)) *mRendererMockOpenSettings {
	if mmOpenSettings.mock.inspectFuncOpenSettings != nil {
		mmOpenSettings.mock.t.Fatalf("Inspect function is already set for RendererMock.OpenSettings")
	}

	mmOpenSettings.mock.inspectFuncOpenSettings = f

	return mmOpenSettings
}

// Return sets up results that will be returned by Renderer.OpenSettings
func (mmOpenSettings *mRendererMockOpenSettings) Return(s1 string) *RendererMock {
	if mmOpenSettings.mock.funcOpenSettings != nil {
		mmOpenSettings.mock.t.Fatalf("RendererMock.OpenSettings mock is already set by Set")
	}

	if mmOpenSettings.defaultExpectation == nil {
		mmOpenSettings.defaultExpectation = &RendererMockOpenSettingsExpectation{mock: mmOpenSettings.mock}
	}
	mmOpenSettings.defaultExpectation.results = &RendererMockOpenSettingsResults{s1}
	mmOpenSettings.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOpenSettings.mock
}

// Set uses given function f to mock the Renderer.OpenSettings method
func (mmOpenSettings *mRendererMockOpenSettings) Set(f func(action map[string]any) (s1 string)) *RendererMock {
	if mmOpenSettings.defaultExpectation != nil {
		mmOpenSettings.mock.t.Fatalf("Default expectation is already set for the Renderer.OpenSettings method")
	}

	if len(mmOpenSettings.expectations) > 0 {
		mmOpenSettings.mock.t.Fatalf("Some expectations are already set for the Renderer.OpenSettings method")
	}

	mmOpenSettings.mock.funcOpenSettings = f
	mmOpenSettings.mock.funcOpenSettingsOrigin = minimock.CallerInfo(1)
	return mmOpenSettings.mock
}

// When sets expectation for the Renderer.OpenSettings which will trigger the result defined by the following
// Then helper
func (mmOpenSettings *mRendererMockOpenSettings) When(action map[string]any) *RendererMockOpenSettingsExpectation {
	if mmOpenSettings.mock.funcOpenSettings != nil {
		mmOpenSettings.mock.t.Fatalf("RendererMock.OpenSettings mock is already set by Set")
	}

	expectation := &RendererMockOpenSettingsExpectation{
		mock:               mmOpenSettings.mock,
		params:             &RendererMockOpenSettingsParams{action},
		expectationOrigins: RendererMockOpenSettingsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOpenSettings.expectations = append(mmOpenSettings.expectations, expectation)
	return expectation
}

// Then sets up Renderer.OpenSettings return parameters for the expectation previously defined by the When method
func (e *RendererMockOpenSettingsExpectation) Then(s1 string) *RendererMock {
	e.results = &RendererMockOpenSettingsResults{s1}
	return e.mock
}

// Times sets number of times Renderer.OpenSettings should be invoked
func (mmOpenSettings *mRendererMockOpenSettings) Times(n uint64) *mRendererMockOpenSettings {
	if n == 0 {
		mmOpenSettings.mock.t.Fatalf("Times of RendererMock.OpenSettings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOpenSettings.expectedInvocations, n)
	mmOpenSettings.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOpenSettings
}

func (mmOpenSettings *mRendererMockOpenSettings) invocationsDone() bool {
	if len(mmOpenSettings.expectations) == 0 && mmOpenSettings.defaultExpectation == nil && mmOpenSettings.mock.funcOpenSettings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOpenSettings.mock.afterOpenSettingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOpenSettings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OpenSettings implements Renderer
func (mmOpenSettings *RendererMock) OpenSettings(action map[string]any) (s1 string) {
	mm_atomic.AddUint64(&mmOpenSettings.beforeOpenSettingsCounter, 1)
	defer mm_atomic.AddUint64(&mmOpenSettings.afterOpenSettingsCounter, 1)

	mmOpenSettings.t.Helper()

	if mmOpenSettings.inspectFuncOpenSettings != nil {
		mmOpenSettings.inspectFuncOpenSettings(action)
	}

	mm_params := RendererMockOpenSettingsParams{action}

	// Record call args
	mmOpenSettings.OpenSettingsMock.mutex.Lock()
	mmOpenSettings.OpenSettingsMock.callArgs = append(mmOpenSettings.OpenSettingsMock.callArgs, &mm_params)
	mmOpenSettings.OpenSettingsMock.mutex.Unlock()

	for _, e := range mmOpenSettings.OpenSettingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmOpenSettings.OpenSettingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpenSettings.OpenSettingsMock.defaultExpectation.Counter, 1)
		mm_want := mmOpenSettings.OpenSettingsMock.defaultExpectation.params
		mm_want_ptrs := mmOpenSettings.OpenSettingsMock.defaultExpectation.paramPtrs

		mm_got := RendererMockOpenSettingsParams{action}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.action != nil && !minimock.Equal(*mm_want_ptrs.action, mm_got.action) {
				mmOpenSettings.t.Errorf("RendererMock.OpenSettings got unexpected parameter action, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOpenSettings.OpenSettingsMock.defaultExpectation.expectationOrigins.originAction, *mm_want_ptrs.action, mm_got.action, minimock.Diff(*mm_want_ptrs.action, mm_got.action))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOpenSettings.t.Errorf("RendererMock.OpenSettings got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOpenSettings.OpenSettingsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOpenSettings.OpenSettingsMock.defaultExpectation.results
		if mm_results == nil {
			mmOpenSettings.t.Fatal("No results are set for the RendererMock.OpenSettings")
		}
		return (*mm_results).s1
	}
	if mmOpenSettings.funcOpenSettings != nil {
		return mmOpenSettings.funcOpenSettings(action)
	}
	mmOpenSettings.t.Fatalf("Unexpected call to RendererMock.OpenSettings. %v", action)
	return
}

// OpenSettingsAfterCounter returns a count of finished RendererMock.OpenSettings invocations
func (mmOpenSettings *RendererMock) OpenSettingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpenSettings.afterOpenSettingsCounter)
}

// OpenSettingsBeforeCounter returns a count of RendererMock.OpenSettings invocations
func (mmOpenSettings *RendererMock) OpenSettingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpenSettings.beforeOpenSettingsCounter)
}

// Calls returns a list of arguments used in each call to RendererMock.OpenSettings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOpenSettings *mRendererMockOpenSettings) Calls() []*RendererMockOpenSettingsParams {
	mmOpenSettings.mutex.RLock()

	argCopy := make([]*RendererMockOpenSettingsParams, len(mmOpenSettings.callArgs))
	copy(argCopy, mmOpenSettings.callArgs)

	mmOpenSettings.mutex.RUnlock()

	return argCopy
}

// MinimockOpenSettingsDone returns true if the count of the OpenSettings invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockOpenSettingsDone() bool {
	if m.OpenSettingsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OpenSettingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OpenSettingsMock.invocationsDone()
}

// MinimockOpenSettingsInspect logs each unmet expectation
func (m *RendererMock) MinimockOpenSettingsInspect() {
	for _, e := range m.OpenSettingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RendererMock.OpenSettings at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOpenSettingsCounter := mm_atomic.LoadUint64(&m.afterOpenSettingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OpenSettingsMock.defaultExpectation != nil && afterOpenSettingsCounter < 1 {
		if m.OpenSettingsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RendererMock.OpenSettings at\n%s", m.OpenSettingsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RendererMock.OpenSettings at\n%s with params: %#v", m.OpenSettingsMock.defaultExpectation.expectationOrigins.origin, *m.OpenSettingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpenSettings != nil && afterOpenSettingsCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.OpenSettings at\n%s", m.funcOpenSettingsOrigin)
	}

	if !m.OpenSettingsMock.invocationsDone() && afterOpenSettingsCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.OpenSettings at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OpenSettingsMock.expectedInvocations), m.OpenSettingsMock.expectedInvocationsOrigin, afterOpenSettingsCounter)
	}
}

type mRendererMockPrintMetric struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockPrintMetricExpectation
	expectations       []*RendererMockPrintMetricExpectation

	callArgs []*RendererMockPrintMetricParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockPrintMetricExpectation specifies expectation struct of the Renderer.PrintMetric
type RendererMockPrintMetricExpectation struct {
	mock               *RendererMock
	params             *RendererMockPrintMetricParams
	paramPtrs          *RendererMockPrintMetricParamPtrs
	expectationOrigins RendererMockPrintMetricExpectationOrigins
	results            *RendererMockPrintMetricResults
	returnOrigin       string
	Counter            uint64
}

// RendererMockPrintMetricParams contains parameters of the Renderer.PrintMetric
type RendererMockPrintMetricParams struct {
	template MetricTemplate
	metric   string
	title    string
}

// RendererMockPrintMetricParamPtrs contains pointers to parameters of the Renderer.PrintMetric
type RendererMockPrintMetricParamPtrs struct {
	template *MetricTemplate
	metric   *string
	title    *string
}

// RendererMockPrintMetricResults contains results of the Renderer.PrintMetric
type RendererMockPrintMetricResults struct {
	s1 string
}

// RendererMockPrintMetricOrigins contains origins of expectations of the Renderer.PrintMetric
type RendererMockPrintMetricExpectationOrigins struct {
	origin         string
	originTemplate string
	originMetric   string
	originTitle    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrintMetric *mRendererMockPrintMetric) Optional() *mRendererMockPrintMetric {
	mmPrintMetric.optional = true
	return mmPrintMetric
}

// Expect sets up expected params for Renderer.PrintMetric
func (mmPrintMetric *mRendererMockPrintMetric) Expect(template MetricTemplate, metric string, title string) *mRendererMockPrintMetric {
	if mmPrintMetric.mock.funcPrintMetric != nil {
		mmPrintMetric.mock.t.Fatalf("RendererMock.PrintMetric mock is already set by Set")
	}

	if mmPrintMetric.defaultExpectation == nil {
		mmPrintMetric.defaultExpectation = &RendererMockPrintMetricExpectation{}
	}

	if mmPrintMetric.defaultExpectation.paramPtrs != nil {
		mmPrintMetric.mock.t.Fatalf("RendererMock.PrintMetric mock is already set by ExpectParams functions")
	}

	mmPrintMetric.defaultExpectation.params = &RendererMockPrintMetricParams{template, metric, title}
	mmPrintMetric.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPrintMetric.expectations {
		if minimock.Equal(e.params, mmPrintMetric.defaultExpectation.params) {
			mmPrintMetric.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrintMetric.defaultExpectation.params)
		}
	}

	return mmPrintMetric
}

// ExpectTemplateParam1 sets up expected param template for Renderer.PrintMetric
func (mmPrintMetric *mRendererMockPrintMetric) ExpectTemplateParam1(template MetricTemplate) *mRendererMockPrintMetric {
	if mmPrintMetric.mock.funcPrintMetric != nil {
		mmPrintMetric.mock.t.Fatalf("RendererMock.PrintMetric mock is already set by Set")
	}

	if mmPrintMetric.defaultExpectation == nil {
		mmPrintMetric.defaultExpectation = &RendererMockPrintMetricExpectation{}
	}

	if mmPrintMetric.defaultExpectation.params != nil {
		mmPrintMetric.mock.t.Fatalf("RendererMock.PrintMetric mock is already set by Expect")
	}

	if mmPrintMetric.defaultExpectation.paramPtrs == nil {
		mmPrintMetric.defaultExpectation.paramPtrs = &RendererMockPrintMetricParamPtrs{}
	}
	mmPrintMetric.defaultExpectation.paramPtrs.template = &template
	mmPrintMetric.defaultExpectation.expectationOrigins.originTemplate = minimock.CallerInfo(1)

	return mmPrintMetric
}

// ExpectMetricParam2 sets up expected param metric for Renderer.PrintMetric
func (mmPrintMetric *mRendererMockPrintMetric) ExpectMetricParam2(metric string) *mRendererMockPrintMetric {
	if mmPrintMetric.mock.funcPrintMetric != nil {
		mmPrintMetric.mock.t.Fatalf("RendererMock.PrintMetric mock is already set by Set")
	}

	if mmPrintMetric.defaultExpectation == nil {
		mmPrintMetric.defaultExpectation = &RendererMockPrintMetricExpectation{}
	}

	if mmPrintMetric.defaultExpectation.params != nil {
		mmPrintMetric.mock.t.Fatalf("RendererMock.PrintMetric mock is already set by Expect")
	}

	if mmPrintMetric.defaultExpectation.paramPtrs == nil {
		mmPrintMetric.defaultExpectation.paramPtrs = &RendererMockPrintMetricParamPtrs{}
	}
	mmPrintMetric.defaultExpectation.paramPtrs.metric = &metric
	mmPrintMetric.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmPrintMetric
}

// ExpectTitleParam3 sets up expected param title for Renderer.PrintMetric
func (mmPrintMetric *mRendererMockPrintMetric) ExpectTitleParam3(title string) *mRendererMockPrintMetric {
	if mmPrintMetric.mock.funcPrintMetric != nil {
		mmPrintMetric.mock.t.Fatalf("RendererMock.PrintMetric mock is already set by Set")
	}

	if mmPrintMetric.defaultExpectation == nil {
		mmPrintMetric.defaultExpectation = &RendererMockPrintMetricExpectation{}
	}

	if mmPrintMetric.defaultExpectation.params != nil {
		mmPrintMetric.mock.t.Fatalf("RendererMock.PrintMetric mock is already set by Expect")
	}

	if mmPrintMetric.defaultExpectation.paramPtrs == nil {
		mmPrintMetric.defaultExpectation.paramPtrs = &RendererMockPrintMetricParamPtrs{}
	}
	mmPrintMetric.defaultExpectation.paramPtrs.title = &title
	mmPrintMetric.defaultExpectation.expectationOrigins.originTitle = minimock.CallerInfo(1)

	return mmPrintMetric
}

// Inspect accepts an inspector function that has same arguments as the Renderer.PrintMetric
func (mmPrintMetric *mRendererMockPrintMetric) Inspect(f func(template MetricTemplate, metric string, title string)) *mRendererMockPrintMetric {
	if mmPrintMetric.mock.inspectFuncPrintMetric != nil {
		mmPrintMetric.mock.t.Fatalf("Inspect function is already set for RendererMock.PrintMetric")
	}

	mmPrintMetric.mock.inspectFuncPrintMetric = f

	return mmPrintMetric
}

// Return sets up results that will be returned by Renderer.PrintMetric
func (mmPrintMetric *mRendererMockPrintMetric) Return(s1 string) *RendererMock {
	if mmPrintMetric.mock.funcPrintMetric != nil {
		mmPrintMetric.mock.t.Fatalf("RendererMock.PrintMetric mock is already set by Set")
	}

	if mmPrintMetric.defaultExpectation == nil {
		mmPrintMetric.defaultExpectation = &RendererMockPrintMetricExpectation{mock: mmPrintMetric.mock}
	}
	mmPrintMetric.defaultExpectation.results = &RendererMockPrintMetricResults{s1}
	mmPrintMetric.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrintMetric.mock
}

// Set uses given function f to mock the Renderer.PrintMetric method
func (mmPrintMetric *mRendererMockPrintMetric) Set(f func(template MetricTemplate, metric string, title string) (s1 string)) *RendererMock {
	if mmPrintMetric.defaultExpectation != nil {
		mmPrintMetric.mock.t.Fatalf("Default expectation is already set for the Renderer.PrintMetric method")
	}

	if len(mmPrintMetric.expectations) > 0 {
		mmPrintMetric.mock.t.Fatalf("Some expectations are already set for the Renderer.PrintMetric method")
	}

	mmPrintMetric.mock.funcPrintMetric = f
	mmPrintMetric.mock.funcPrintMetricOrigin = minimock.CallerInfo(1)
	return mmPrintMetric.mock
}

// When sets expectation for the Renderer.PrintMetric which will trigger the result defined by the following
// Then helper
func (mmPrintMetric *mRendererMockPrintMetric) When(template MetricTemplate, metric string, title string) *RendererMockPrintMetricExpectation {
	if mmPrintMetric.mock.funcPrintMetric != nil {
		mmPrintMetric.mock.t.Fatalf("RendererMock.PrintMetric mock is already set by Set")
	}

	expectation := &RendererMockPrintMetricExpectation{
		mock:               mmPrintMetric.mock,
		params:             &RendererMockPrintMetricParams{template, metric, title},
		expectationOrigins: RendererMockPrintMetricExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPrintMetric.expectations = append(mmPrintMetric.expectations, expectation)
	return expectation
}

// Then sets up Renderer.PrintMetric return parameters for the expectation previously defined by the When method
func (e *RendererMockPrintMetricExpectation) Then(s1 string) *RendererMock {
	e.results = &RendererMockPrintMetricResults{s1}
	return e.mock
}

// Times sets number of times Renderer.PrintMetric should be invoked
func (mmPrintMetric *mRendererMockPrintMetric) Times(n uint64) *mRendererMockPrintMetric {
	if n == 0 {
		mmPrintMetric.mock.t.Fatalf("Times of RendererMock.PrintMetric mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrintMetric.expectedInvocations, n)
	mmPrintMetric.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrintMetric
}

func (mmPrintMetric *mRendererMockPrintMetric) invocationsDone() bool {
	if len(mmPrintMetric.expectations) == 0 && mmPrintMetric.defaultExpectation == nil && mmPrintMetric.mock.funcPrintMetric == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrintMetric.mock.afterPrintMetricCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrintMetric.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PrintMetric implements Renderer
func (mmPrintMetric *RendererMock) PrintMetric(template MetricTemplate, metric string, title string) (s1 string) {
	mm_atomic.AddUint64(&mmPrintMetric.beforePrintMetricCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintMetric.afterPrintMetricCounter, 1)

	mmPrintMetric.t.Helper()

	if mmPrintMetric.inspectFuncPrintMetric != nil {
		mmPrintMetric.inspectFuncPrintMetric(template, metric, title)
	}

	mm_params := RendererMockPrintMetricParams{template, metric, title}

	// Record call args
	mmPrintMetric.PrintMetricMock.mutex.Lock()
	mmPrintMetric.PrintMetricMock.callArgs = append(mmPrintMetric.PrintMetricMock.callArgs, &mm_params)
	mmPrintMetric.PrintMetricMock.mutex.Unlock()

	for _, e := range mmPrintMetric.PrintMetricMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmPrintMetric.PrintMetricMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintMetric.PrintMetricMock.defaultExpectation.Counter, 1)
		mm_want := mmPrintMetric.PrintMetricMock.defaultExpectation.params
		mm_want_ptrs := mmPrintMetric.PrintMetricMock.defaultExpectation.paramPtrs

		mm_got := RendererMockPrintMetricParams{template, metric, title}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.template != nil && !minimock.Equal(*mm_want_ptrs.template, mm_got.template) {
				mmPrintMetric.t.Errorf("RendererMock.PrintMetric got unexpected parameter template, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrintMetric.PrintMetricMock.defaultExpectation.expectationOrigins.originTemplate, *mm_want_ptrs.template, mm_got.template, minimock.Diff(*mm_want_ptrs.template, mm_got.template))
			}

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmPrintMetric.t.Errorf("RendererMock.PrintMetric got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrintMetric.PrintMetricMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.title != nil && !minimock.Equal(*mm_want_ptrs.title, mm_got.title) {
				mmPrintMetric.t.Errorf("RendererMock.PrintMetric got unexpected parameter title, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrintMetric.PrintMetricMock.defaultExpectation.expectationOrigins.originTitle, *mm_want_ptrs.title, mm_got.title, minimock.Diff(*mm_want_ptrs.title, mm_got.title))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrintMetric.t.Errorf("RendererMock.PrintMetric got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPrintMetric.PrintMetricMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrintMetric.PrintMetricMock.defaultExpectation.results
		if mm_results == nil {
			mmPrintMetric.t.Fatal("No results are set for the RendererMock.PrintMetric")
		}
		return (*mm_results).s1
	}
	if mmPrintMetric.funcPrintMetric != nil {
		return mmPrintMetric.funcPrintMetric(template, metric, title)
	}
	mmPrintMetric.t.Fatalf("Unexpected call to RendererMock.PrintMetric. %v %v %v", template, metric, title)
	return
}

// PrintMetricAfterCounter returns a count of finished RendererMock.PrintMetric invocations
func (mmPrintMetric *RendererMock) PrintMetricAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintMetric.afterPrintMetricCounter)
}

// PrintMetricBeforeCounter returns a count of RendererMock.PrintMetric invocations
func (mmPrintMetric *RendererMock) PrintMetricBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintMetric.beforePrintMetricCounter)
}

// Calls returns a list of arguments used in each call to RendererMock.PrintMetric.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrintMetric *mRendererMockPrintMetric) Calls() []*RendererMockPrintMetricParams {
	mmPrintMetric.mutex.RLock()

	argCopy := make([]*RendererMockPrintMetricParams, len(mmPrintMetric.callArgs))
	copy(argCopy, mmPrintMetric.callArgs)

	mmPrintMetric.mutex.RUnlock()

	return argCopy
}

// MinimockPrintMetricDone returns true if the count of the PrintMetric invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockPrintMetricDone() bool {
	if m.PrintMetricMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintMetricMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintMetricMock.invocationsDone()
}

// MinimockPrintMetricInspect logs each unmet expectation
func (m *RendererMock) MinimockPrintMetricInspect() {
	for _, e := range m.PrintMetricMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RendererMock.PrintMetric at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPrintMetricCounter := mm_atomic.LoadUint64(&m.afterPrintMetricCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintMetricMock.defaultExpectation != nil && afterPrintMetricCounter < 1 {
		if m.PrintMetricMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RendererMock.PrintMetric at\n%s", m.PrintMetricMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RendererMock.PrintMetric at\n%s with params: %#v", m.PrintMetricMock.defaultExpectation.expectationOrigins.origin, *m.PrintMetricMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintMetric != nil && afterPrintMetricCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.PrintMetric at\n%s", m.funcPrintMetricOrigin)
	}

	if !m.PrintMetricMock.invocationsDone() && afterPrintMetricCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.PrintMetric at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrintMetricMock.expectedInvocations), m.PrintMetricMock.expectedInvocationsOrigin, afterPrintMetricCounter)
	}
}

type mRendererMockPrintSelectedClipboard struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockPrintSelectedClipboardExpectation
	expectations       []*RendererMockPrintSelectedClipboardExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockPrintSelectedClipboardExpectation specifies expectation struct of the Renderer.PrintSelectedClipboard
type RendererMockPrintSelectedClipboardExpectation struct {
	mock *RendererMock

	results      *RendererMockPrintSelectedClipboardResults
	returnOrigin string
	Counter      uint64
}

// RendererMockPrintSelectedClipboardResults contains results of the Renderer.PrintSelectedClipboard
type RendererMockPrintSelectedClipboardResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrintSelectedClipboard *mRendererMockPrintSelectedClipboard) Optional() *mRendererMockPrintSelectedClipboard {
	mmPrintSelectedClipboard.optional = true
	return mmPrintSelectedClipboard
}

// Expect sets up expected params for Renderer.PrintSelectedClipboard
func (mmPrintSelectedClipboard *mRendererMockPrintSelectedClipboard) Expect() *mRendererMockPrintSelectedClipboard {
	if mmPrintSelectedClipboard.mock.funcPrintSelectedClipboard != nil {
		mmPrintSelectedClipboard.mock.t.Fatalf("RendererMock.PrintSelectedClipboard mock is already set by Set")
	}

	if mmPrintSelectedClipboard.defaultExpectation == nil {
		mmPrintSelectedClipboard.defaultExpectation = &RendererMockPrintSelectedClipboardExpectation{}
	}

	return mmPrintSelectedClipboard
}

// Inspect accepts an inspector function that has same arguments as the Renderer.PrintSelectedClipboard
func (mmPrintSelectedClipboard *mRendererMockPrintSelectedClipboard) Inspect(f func()) *mRendererMockPrintSelectedClipboard {
	if mmPrintSelectedClipboard.mock.inspectFuncPrintSelectedClipboard != nil {
		mmPrintSelectedClipboard.mock.t.Fatalf("Inspect function is already set for RendererMock.PrintSelectedClipboard")
	}

	mmPrintSelectedClipboard.mock.inspectFuncPrintSelectedClipboard = f

	return mmPrintSelectedClipboard
}

// Return sets up results that will be returned by Renderer.PrintSelectedClipboard
func (mmPrintSelectedClipboard *mRendererMockPrintSelectedClipboard) Return(s1 string) *RendererMock {
	if mmPrintSelectedClipboard.mock.funcPrintSelectedClipboard != nil {
		mmPrintSelectedClipboard.mock.t.Fatalf("RendererMock.PrintSelectedClipboard mock is already set by Set")
	}

	if mmPrintSelectedClipboard.defaultExpectation == nil {
		mmPrintSelectedClipboard.defaultExpectation = &RendererMockPrintSelectedClipboardExpectation{mock: mmPrintSelectedClipboard.mock}
	}
	mmPrintSelectedClipboard.defaultExpectation.results = &RendererMockPrintSelectedClipboardResults{s1}
	mmPrintSelectedClipboard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedClipboard.mock
}

// Set uses given function f to mock the Renderer.PrintSelectedClipboard method
func (mmPrintSelectedClipboard *mRendererMockPrintSelectedClipboard) Set(f func() (s1 string)) *RendererMock {
	if mmPrintSelectedClipboard.defaultExpectation != nil {
		mmPrintSelectedClipboard.mock.t.Fatalf("Default expectation is already set for the Renderer.PrintSelectedClipboard method")
	}

	if len(mmPrintSelectedClipboard.expectations) > 0 {
		mmPrintSelectedClipboard.mock.t.Fatalf("Some expectations are already set for the Renderer.PrintSelectedClipboard method")
	}

	mmPrintSelectedClipboard.mock.funcPrintSelectedClipboard = f
	mmPrintSelectedClipboard.mock.funcPrintSelectedClipboardOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedClipboard.mock
}

// Times sets number of times Renderer.PrintSelectedClipboard should be invoked
func (mmPrintSelectedClipboard *mRendererMockPrintSelectedClipboard) Times(n uint64) *mRendererMockPrintSelectedClipboard {
	if n == 0 {
		mmPrintSelectedClipboard.mock.t.Fatalf("Times of RendererMock.PrintSelectedClipboard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrintSelectedClipboard.expectedInvocations, n)
	mmPrintSelectedClipboard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedClipboard
}

func (mmPrintSelectedClipboard *mRendererMockPrintSelectedClipboard) invocationsDone() bool {
	if len(mmPrintSelectedClipboard.expectations) == 0 && mmPrintSelectedClipboard.defaultExpectation == nil && mmPrintSelectedClipboard.mock.funcPrintSelectedClipboard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrintSelectedClipboard.mock.afterPrintSelectedClipboardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrintSelectedClipboard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PrintSelectedClipboard implements Renderer
func (mmPrintSelectedClipboard *RendererMock) PrintSelectedClipboard() (s1 string) {
	mm_atomic.AddUint64(&mmPrintSelectedClipboard.beforePrintSelectedClipboardCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintSelectedClipboard.afterPrintSelectedClipboardCounter, 1)

	mmPrintSelectedClipboard.t.Helper()

	if mmPrintSelectedClipboard.inspectFuncPrintSelectedClipboard != nil {
		mmPrintSelectedClipboard.inspectFuncPrintSelectedClipboard()
	}

	if mmPrintSelectedClipboard.PrintSelectedClipboardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintSelectedClipboard.PrintSelectedClipboardMock.defaultExpectation.Counter, 1)

		mm_results := mmPrintSelectedClipboard.PrintSelectedClipboardMock.defaultExpectation.results
		if mm_results == nil {
			mmPrintSelectedClipboard.t.Fatal("No results are set for the RendererMock.PrintSelectedClipboard")
		}
		return (*mm_results).s1
	}
	if mmPrintSelectedClipboard.funcPrintSelectedClipboard != nil {
		return mmPrintSelectedClipboard.funcPrintSelectedClipboard()
	}
	mmPrintSelectedClipboard.t.Fatalf("Unexpected call to RendererMock.PrintSelectedClipboard.")
	return
}

// PrintSelectedClipboardAfterCounter returns a count of finished RendererMock.PrintSelectedClipboard invocations
func (mmPrintSelectedClipboard *RendererMock) PrintSelectedClipboardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintSelectedClipboard.afterPrintSelectedClipboardCounter)
}

// PrintSelectedClipboardBeforeCounter returns a count of RendererMock.PrintSelectedClipboard invocations
func (mmPrintSelectedClipboard *RendererMock) PrintSelectedClipboardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintSelectedClipboard.beforePrintSelectedClipboardCounter)
}

// MinimockPrintSelectedClipboardDone returns true if the count of the PrintSelectedClipboard invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockPrintSelectedClipboardDone() bool {
	if m.PrintSelectedClipboardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintSelectedClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintSelectedClipboardMock.invocationsDone()
}

// MinimockPrintSelectedClipboardInspect logs each unmet expectation
func (m *RendererMock) MinimockPrintSelectedClipboardInspect() {
	for _, e := range m.PrintSelectedClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RendererMock.PrintSelectedClipboard")
		}
	}

	afterPrintSelectedClipboardCounter := mm_atomic.LoadUint64(&m.afterPrintSelectedClipboardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintSelectedClipboardMock.defaultExpectation != nil && afterPrintSelectedClipboardCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.PrintSelectedClipboard at\n%s", m.PrintSelectedClipboardMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintSelectedClipboard != nil && afterPrintSelectedClipboardCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.PrintSelectedClipboard at\n%s", m.funcPrintSelectedClipboardOrigin)
	}

	if !m.PrintSelectedClipboardMock.invocationsDone() && afterPrintSelectedClipboardCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.PrintSelectedClipboard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrintSelectedClipboardMock.expectedInvocations), m.PrintSelectedClipboardMock.expectedInvocationsOrigin, afterPrintSelectedClipboardCounter)
	}
}

type mRendererMockPrintSelectedDevice struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockPrintSelectedDeviceExpectation
	expectations       []*RendererMockPrintSelectedDeviceExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockPrintSelectedDeviceExpectation specifies expectation struct of the Renderer.PrintSelectedDevice
type RendererMockPrintSelectedDeviceExpectation struct {
	mock *RendererMock

	results      *RendererMockPrintSelectedDeviceResults
	returnOrigin string
	Counter      uint64
}

// RendererMockPrintSelectedDeviceResults contains results of the Renderer.PrintSelectedDevice
type RendererMockPrintSelectedDeviceResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrintSelectedDevice *mRendererMockPrintSelectedDevice) Optional() *mRendererMockPrintSelectedDevice {
	mmPrintSelectedDevice.optional = true
	return mmPrintSelectedDevice
}

// Expect sets up expected params for Renderer.PrintSelectedDevice
func (mmPrintSelectedDevice *mRendererMockPrintSelectedDevice) Expect() *mRendererMockPrintSelectedDevice {
	if mmPrintSelectedDevice.mock.funcPrintSelectedDevice != nil {
		mmPrintSelectedDevice.mock.t.Fatalf("RendererMock.PrintSelectedDevice mock is already set by Set")
	}

	if mmPrintSelectedDevice.defaultExpectation == nil {
		mmPrintSelectedDevice.defaultExpectation = &RendererMockPrintSelectedDeviceExpectation{}
	}

	return mmPrintSelectedDevice
}

// Inspect accepts an inspector function that has same arguments as the Renderer.PrintSelectedDevice
func (mmPrintSelectedDevice *mRendererMockPrintSelectedDevice) Inspect(f func()) *mRendererMockPrintSelectedDevice {
	if mmPrintSelectedDevice.mock.inspectFuncPrintSelectedDevice != nil {
		mmPrintSelectedDevice.mock.t.Fatalf("Inspect function is already set for RendererMock.PrintSelectedDevice")
	}

	mmPrintSelectedDevice.mock.inspectFuncPrintSelectedDevice = f

	return mmPrintSelectedDevice
}

// Return sets up results that will be returned by Renderer.PrintSelectedDevice
func (mmPrintSelectedDevice *mRendererMockPrintSelectedDevice) Return(s1 string) *RendererMock {
	if mmPrintSelectedDevice.mock.funcPrintSelectedDevice != nil {
		mmPrintSelectedDevice.mock.t.Fatalf("RendererMock.PrintSelectedDevice mock is already set by Set")
	}

	if mmPrintSelectedDevice.defaultExpectation == nil {
		mmPrintSelectedDevice.defaultExpectation = &RendererMockPrintSelectedDeviceExpectation{mock: mmPrintSelectedDevice.mock}
	}
	mmPrintSelectedDevice.defaultExpectation.results = &RendererMockPrintSelectedDeviceResults{s1}
	mmPrintSelectedDevice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedDevice.mock
}

// Set uses given function f to mock the Renderer.PrintSelectedDevice method
func (mmPrintSelectedDevice *mRendererMockPrintSelectedDevice) Set(f func() (s1 string)) *RendererMock {
	if mmPrintSelectedDevice.defaultExpectation != nil {
		mmPrintSelectedDevice.mock.t.Fatalf("Default expectation is already set for the Renderer.PrintSelectedDevice method")
	}

	if len(mmPrintSelectedDevice.expectations) > 0 {
		mmPrintSelectedDevice.mock.t.Fatalf("Some expectations are already set for the Renderer.PrintSelectedDevice method")
	}

	mmPrintSelectedDevice.mock.funcPrintSelectedDevice = f
	mmPrintSelectedDevice.mock.funcPrintSelectedDeviceOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedDevice.mock
}

// Times sets number of times Renderer.PrintSelectedDevice should be invoked
func (mmPrintSelectedDevice *mRendererMockPrintSelectedDevice) Times(n uint64) *mRendererMockPrintSelectedDevice {
	if n == 0 {
		mmPrintSelectedDevice.mock.t.Fatalf("Times of RendererMock.PrintSelectedDevice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrintSelectedDevice.expectedInvocations, n)
	mmPrintSelectedDevice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedDevice
}

func (mmPrintSelectedDevice *mRendererMockPrintSelectedDevice) invocationsDone() bool {
	if len(mmPrintSelectedDevice.expectations) == 0 && mmPrintSelectedDevice.defaultExpectation == nil && mmPrintSelectedDevice.mock.funcPrintSelectedDevice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrintSelectedDevice.mock.afterPrintSelectedDeviceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrintSelectedDevice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PrintSelectedDevice implements Renderer
func (mmPrintSelectedDevice *RendererMock) PrintSelectedDevice() (s1 string) {
	mm_atomic.AddUint64(&mmPrintSelectedDevice.beforePrintSelectedDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintSelectedDevice.afterPrintSelectedDeviceCounter, 1)

	mmPrintSelectedDevice.t.Helper()

	if mmPrintSelectedDevice.inspectFuncPrintSelectedDevice != nil {
		mmPrintSelectedDevice.inspectFuncPrintSelectedDevice()
	}

	if mmPrintSelectedDevice.PrintSelectedDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintSelectedDevice.PrintSelectedDeviceMock.defaultExpectation.Counter, 1)

		mm_results := mmPrintSelectedDevice.PrintSelectedDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmPrintSelectedDevice.t.Fatal("No results are set for the RendererMock.PrintSelectedDevice")
		}
		return (*mm_results).s1
	}
	if mmPrintSelectedDevice.funcPrintSelectedDevice != nil {
		return mmPrintSelectedDevice.funcPrintSelectedDevice()
	}
	mmPrintSelectedDevice.t.Fatalf("Unexpected call to RendererMock.PrintSelectedDevice.")
	return
}

// PrintSelectedDeviceAfterCounter returns a count of finished RendererMock.PrintSelectedDevice invocations
func (mmPrintSelectedDevice *RendererMock) PrintSelectedDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintSelectedDevice.afterPrintSelectedDeviceCounter)
}

// PrintSelectedDeviceBeforeCounter returns a count of RendererMock.PrintSelectedDevice invocations
func (mmPrintSelectedDevice *RendererMock) PrintSelectedDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintSelectedDevice.beforePrintSelectedDeviceCounter)
}

// MinimockPrintSelectedDeviceDone returns true if the count of the PrintSelectedDevice invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockPrintSelectedDeviceDone() bool {
	if m.PrintSelectedDeviceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintSelectedDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintSelectedDeviceMock.invocationsDone()
}

// MinimockPrintSelectedDeviceInspect logs each unmet expectation
func (m *RendererMock) MinimockPrintSelectedDeviceInspect() {
	for _, e := range m.PrintSelectedDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RendererMock.PrintSelectedDevice")
		}
	}

	afterPrintSelectedDeviceCounter := mm_atomic.LoadUint64(&m.afterPrintSelectedDeviceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintSelectedDeviceMock.defaultExpectation != nil && afterPrintSelectedDeviceCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.PrintSelectedDevice at\n%s", m.PrintSelectedDeviceMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintSelectedDevice != nil && afterPrintSelectedDeviceCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.PrintSelectedDevice at\n%s", m.funcPrintSelectedDeviceOrigin)
	}

	if !m.PrintSelectedDeviceMock.invocationsDone() && afterPrintSelectedDeviceCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.PrintSelectedDevice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrintSelectedDeviceMock.expectedInvocations), m.PrintSelectedDeviceMock.expectedInvocationsOrigin, afterPrintSelectedDeviceCounter)
	}
}

type mRendererMockPrintSelectedFloating struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockPrintSelectedFloatingExpectation
	expectations       []*RendererMockPrintSelectedFloatingExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockPrintSelectedFloatingExpectation specifies expectation struct of the Renderer.PrintSelectedFloating
type RendererMockPrintSelectedFloatingExpectation struct {
	mock *RendererMock

	results      *RendererMockPrintSelectedFloatingResults
	returnOrigin string
	Counter      uint64
}

// RendererMockPrintSelectedFloatingResults contains results of the Renderer.PrintSelectedFloating
type RendererMockPrintSelectedFloatingResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrintSelectedFloating *mRendererMockPrintSelectedFloating) Optional() *mRendererMockPrintSelectedFloating {
	mmPrintSelectedFloating.optional = true
	return mmPrintSelectedFloating
}

// Expect sets up expected params for Renderer.PrintSelectedFloating
func (mmPrintSelectedFloating *mRendererMockPrintSelectedFloating) Expect() *mRendererMockPrintSelectedFloating {
	if mmPrintSelectedFloating.mock.funcPrintSelectedFloating != nil {
		mmPrintSelectedFloating.mock.t.Fatalf("RendererMock.PrintSelectedFloating mock is already set by Set")
	}

	if mmPrintSelectedFloating.defaultExpectation == nil {
		mmPrintSelectedFloating.defaultExpectation = &RendererMockPrintSelectedFloatingExpectation{}
	}

	return mmPrintSelectedFloating
}

// Inspect accepts an inspector function that has same arguments as the Renderer.PrintSelectedFloating
func (mmPrintSelectedFloating *mRendererMockPrintSelectedFloating) Inspect(f func()) *mRendererMockPrintSelectedFloating {
	if mmPrintSelectedFloating.mock.inspectFuncPrintSelectedFloating != nil {
		mmPrintSelectedFloating.mock.t.Fatalf("Inspect function is already set for RendererMock.PrintSelectedFloating")
	}

	mmPrintSelectedFloating.mock.inspectFuncPrintSelectedFloating = f

	return mmPrintSelectedFloating
}

// Return sets up results that will be returned by Renderer.PrintSelectedFloating
func (mmPrintSelectedFloating *mRendererMockPrintSelectedFloating) Return(s1 string) *RendererMock {
	if mmPrintSelectedFloating.mock.funcPrintSelectedFloating != nil {
		mmPrintSelectedFloating.mock.t.Fatalf("RendererMock.PrintSelectedFloating mock is already set by Set")
	}

	if mmPrintSelectedFloating.defaultExpectation == nil {
		mmPrintSelectedFloating.defaultExpectation = &RendererMockPrintSelectedFloatingExpectation{mock: mmPrintSelectedFloating.mock}
	}
	mmPrintSelectedFloating.defaultExpectation.results = &RendererMockPrintSelectedFloatingResults{s1}
	mmPrintSelectedFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedFloating.mock
}

// Set uses given function f to mock the Renderer.PrintSelectedFloating method
func (mmPrintSelectedFloating *mRendererMockPrintSelectedFloating) Set(f func() (s1 string)) *RendererMock {
	if mmPrintSelectedFloating.defaultExpectation != nil {
		mmPrintSelectedFloating.mock.t.Fatalf("Default expectation is already set for the Renderer.PrintSelectedFloating method")
	}

	if len(mmPrintSelectedFloating.expectations) > 0 {
		mmPrintSelectedFloating.mock.t.Fatalf("Some expectations are already set for the Renderer.PrintSelectedFloating method")
	}

	mmPrintSelectedFloating.mock.funcPrintSelectedFloating = f
	mmPrintSelectedFloating.mock.funcPrintSelectedFloatingOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedFloating.mock
}

// Times sets number of times Renderer.PrintSelectedFloating should be invoked
func (mmPrintSelectedFloating *mRendererMockPrintSelectedFloating) Times(n uint64) *mRendererMockPrintSelectedFloating {
	if n == 0 {
		mmPrintSelectedFloating.mock.t.Fatalf("Times of RendererMock.PrintSelectedFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrintSelectedFloating.expectedInvocations, n)
	mmPrintSelectedFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedFloating
}

func (mmPrintSelectedFloating *mRendererMockPrintSelectedFloating) invocationsDone() bool {
	if len(mmPrintSelectedFloating.expectations) == 0 && mmPrintSelectedFloating.defaultExpectation == nil && mmPrintSelectedFloating.mock.funcPrintSelectedFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrintSelectedFloating.mock.afterPrintSelectedFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrintSelectedFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PrintSelectedFloating implements Renderer
func (mmPrintSelectedFloating *RendererMock) PrintSelectedFloating() (s1 string) {
	mm_atomic.AddUint64(&mmPrintSelectedFloating.beforePrintSelectedFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintSelectedFloating.afterPrintSelectedFloatingCounter, 1)

	mmPrintSelectedFloating.t.Helper()

	if mmPrintSelectedFloating.inspectFuncPrintSelectedFloating != nil {
		mmPrintSelectedFloating.inspectFuncPrintSelectedFloating()
	}

	if mmPrintSelectedFloating.PrintSelectedFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintSelectedFloating.PrintSelectedFloatingMock.defaultExpectation.Counter, 1)

		mm_results := mmPrintSelectedFloating.PrintSelectedFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmPrintSelectedFloating.t.Fatal("No results are set for the RendererMock.PrintSelectedFloating")
		}
		return (*mm_results).s1
	}
	if mmPrintSelectedFloating.funcPrintSelectedFloating != nil {
		return mmPrintSelectedFloating.funcPrintSelectedFloating()
	}
	mmPrintSelectedFloating.t.Fatalf("Unexpected call to RendererMock.PrintSelectedFloating.")
	return
}

// PrintSelectedFloatingAfterCounter returns a count of finished RendererMock.PrintSelectedFloating invocations
func (mmPrintSelectedFloating *RendererMock) PrintSelectedFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintSelectedFloating.afterPrintSelectedFloatingCounter)
}

// PrintSelectedFloatingBeforeCounter returns a count of RendererMock.PrintSelectedFloating invocations
func (mmPrintSelectedFloating *RendererMock) PrintSelectedFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintSelectedFloating.beforePrintSelectedFloatingCounter)
}

// MinimockPrintSelectedFloatingDone returns true if the count of the PrintSelectedFloating invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockPrintSelectedFloatingDone() bool {
	if m.PrintSelectedFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintSelectedFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintSelectedFloatingMock.invocationsDone()
}

// MinimockPrintSelectedFloatingInspect logs each unmet expectation
func (m *RendererMock) MinimockPrintSelectedFloatingInspect() {
	for _, e := range m.PrintSelectedFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RendererMock.PrintSelectedFloating")
		}
	}

	afterPrintSelectedFloatingCounter := mm_atomic.LoadUint64(&m.afterPrintSelectedFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintSelectedFloatingMock.defaultExpectation != nil && afterPrintSelectedFloatingCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.PrintSelectedFloating at\n%s", m.PrintSelectedFloatingMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintSelectedFloating != nil && afterPrintSelectedFloatingCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.PrintSelectedFloating at\n%s", m.funcPrintSelectedFloatingOrigin)
	}

	if !m.PrintSelectedFloatingMock.invocationsDone() && afterPrintSelectedFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.PrintSelectedFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrintSelectedFloatingMock.expectedInvocations), m.PrintSelectedFloatingMock.expectedInvocationsOrigin, afterPrintSelectedFloatingCounter)
	}
}

type mRendererMockPrintSelectedLanguage struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockPrintSelectedLanguageExpectation
	expectations       []*RendererMockPrintSelectedLanguageExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockPrintSelectedLanguageExpectation specifies expectation struct of the Renderer.PrintSelectedLanguage
type RendererMockPrintSelectedLanguageExpectation struct {
	mock *RendererMock

	results      *RendererMockPrintSelectedLanguageResults
	returnOrigin string
	Counter      uint64
}

// RendererMockPrintSelectedLanguageResults contains results of the Renderer.PrintSelectedLanguage
type RendererMockPrintSelectedLanguageResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrintSelectedLanguage *mRendererMockPrintSelectedLanguage) Optional() *mRendererMockPrintSelectedLanguage {
	mmPrintSelectedLanguage.optional = true
	return mmPrintSelectedLanguage
}

// Expect sets up expected params for Renderer.PrintSelectedLanguage
func (mmPrintSelectedLanguage *mRendererMockPrintSelectedLanguage) Expect() *mRendererMockPrintSelectedLanguage {
	if mmPrintSelectedLanguage.mock.funcPrintSelectedLanguage != nil {
		mmPrintSelectedLanguage.mock.t.Fatalf("RendererMock.PrintSelectedLanguage mock is already set by Set")
	}

	if mmPrintSelectedLanguage.defaultExpectation == nil {
		mmPrintSelectedLanguage.defaultExpectation = &RendererMockPrintSelectedLanguageExpectation{}
	}

	return mmPrintSelectedLanguage
}

// Inspect accepts an inspector function that has same arguments as the Renderer.PrintSelectedLanguage
func (mmPrintSelectedLanguage *mRendererMockPrintSelectedLanguage) Inspect(f func()) *mRendererMockPrintSelectedLanguage {
	if mmPrintSelectedLanguage.mock.inspectFuncPrintSelectedLanguage != nil {
		mmPrintSelectedLanguage.mock.t.Fatalf("Inspect function is already set for RendererMock.PrintSelectedLanguage")
	}

	mmPrintSelectedLanguage.mock.inspectFuncPrintSelectedLanguage = f

	return mmPrintSelectedLanguage
}

// Return sets up results that will be returned by Renderer.PrintSelectedLanguage
func (mmPrintSelectedLanguage *mRendererMockPrintSelectedLanguage) Return(s1 string) *RendererMock {
	if mmPrintSelectedLanguage.mock.funcPrintSelectedLanguage != nil {
		mmPrintSelectedLanguage.mock.t.Fatalf("RendererMock.PrintSelectedLanguage mock is already set by Set")
	}

	if mmPrintSelectedLanguage.defaultExpectation == nil {
		mmPrintSelectedLanguage.defaultExpectation = &RendererMockPrintSelectedLanguageExpectation{mock: mmPrintSelectedLanguage.mock}
	}
	mmPrintSelectedLanguage.defaultExpectation.results = &RendererMockPrintSelectedLanguageResults{s1}
	mmPrintSelectedLanguage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedLanguage.mock
}

// Set uses given function f to mock the Renderer.PrintSelectedLanguage method
func (mmPrintSelectedLanguage *mRendererMockPrintSelectedLanguage) Set(f func() (s1 string)) *RendererMock {
	if mmPrintSelectedLanguage.defaultExpectation != nil {
		mmPrintSelectedLanguage.mock.t.Fatalf("Default expectation is already set for the Renderer.PrintSelectedLanguage method")
	}

	if len(mmPrintSelectedLanguage.expectations) > 0 {
		mmPrintSelectedLanguage.mock.t.Fatalf("Some expectations are already set for the Renderer.PrintSelectedLanguage method")
	}

	mmPrintSelectedLanguage.mock.funcPrintSelectedLanguage = f
	mmPrintSelectedLanguage.mock.funcPrintSelectedLanguageOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedLanguage.mock
}

// Times sets number of times Renderer.PrintSelectedLanguage should be invoked
func (mmPrintSelectedLanguage *mRendererMockPrintSelectedLanguage) Times(n uint64) *mRendererMockPrintSelectedLanguage {
	if n == 0 {
		mmPrintSelectedLanguage.mock.t.Fatalf("Times of RendererMock.PrintSelectedLanguage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrintSelectedLanguage.expectedInvocations, n)
	mmPrintSelectedLanguage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedLanguage
}

func (mmPrintSelectedLanguage *mRendererMockPrintSelectedLanguage) invocationsDone() bool {
	if len(mmPrintSelectedLanguage.expectations) == 0 && mmPrintSelectedLanguage.defaultExpectation == nil && mmPrintSelectedLanguage.mock.funcPrintSelectedLanguage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrintSelectedLanguage.mock.afterPrintSelectedLanguageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrintSelectedLanguage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PrintSelectedLanguage implements Renderer
func (mmPrintSelectedLanguage *RendererMock) PrintSelectedLanguage() (s1 string) {
	mm_atomic.AddUint64(&mmPrintSelectedLanguage.beforePrintSelectedLanguageCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintSelectedLanguage.afterPrintSelectedLanguageCounter, 1)

	mmPrintSelectedLanguage.t.Helper()

	if mmPrintSelectedLanguage.inspectFuncPrintSelectedLanguage != nil {
		mmPrintSelectedLanguage.inspectFuncPrintSelectedLanguage()
	}

	if mmPrintSelectedLanguage.PrintSelectedLanguageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintSelectedLanguage.PrintSelectedLanguageMock.defaultExpectation.Counter, 1)

		mm_results := mmPrintSelectedLanguage.PrintSelectedLanguageMock.defaultExpectation.results
		if mm_results == nil {
			mmPrintSelectedLanguage.t.Fatal("No results are set for the RendererMock.PrintSelectedLanguage")
		}
		return (*mm_results).s1
	}
	if mmPrintSelectedLanguage.funcPrintSelectedLanguage != nil {
		return mmPrintSelectedLanguage.funcPrintSelectedLanguage()
	}
	mmPrintSelectedLanguage.t.Fatalf("Unexpected call to RendererMock.PrintSelectedLanguage.")
	return
}

// PrintSelectedLanguageAfterCounter returns a count of finished RendererMock.PrintSelectedLanguage invocations
func (mmPrintSelectedLanguage *RendererMock) PrintSelectedLanguageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintSelectedLanguage.afterPrintSelectedLanguageCounter)
}

// PrintSelectedLanguageBeforeCounter returns a count of RendererMock.PrintSelectedLanguage invocations
func (mmPrintSelectedLanguage *RendererMock) PrintSelectedLanguageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintSelectedLanguage.beforePrintSelectedLanguageCounter)
}

// MinimockPrintSelectedLanguageDone returns true if the count of the PrintSelectedLanguage invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockPrintSelectedLanguageDone() bool {
	if m.PrintSelectedLanguageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintSelectedLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintSelectedLanguageMock.invocationsDone()
}

// MinimockPrintSelectedLanguageInspect logs each unmet expectation
func (m *RendererMock) MinimockPrintSelectedLanguageInspect() {
	for _, e := range m.PrintSelectedLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RendererMock.PrintSelectedLanguage")
		}
	}

	afterPrintSelectedLanguageCounter := mm_atomic.LoadUint64(&m.afterPrintSelectedLanguageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintSelectedLanguageMock.defaultExpectation != nil && afterPrintSelectedLanguageCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.PrintSelectedLanguage at\n%s", m.PrintSelectedLanguageMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintSelectedLanguage != nil && afterPrintSelectedLanguageCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.PrintSelectedLanguage at\n%s", m.funcPrintSelectedLanguageOrigin)
	}

	if !m.PrintSelectedLanguageMock.invocationsDone() && afterPrintSelectedLanguageCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.PrintSelectedLanguage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrintSelectedLanguageMock.expectedInvocations), m.PrintSelectedLanguageMock.expectedInvocationsOrigin, afterPrintSelectedLanguageCounter)
	}
}

type mRendererMockPrintSelectedViewMode struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockPrintSelectedViewModeExpectation
	expectations       []*RendererMockPrintSelectedViewModeExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockPrintSelectedViewModeExpectation specifies expectation struct of the Renderer.PrintSelectedViewMode
type RendererMockPrintSelectedViewModeExpectation struct {
	mock *RendererMock

	results      *RendererMockPrintSelectedViewModeResults
	returnOrigin string
	Counter      uint64
}

// RendererMockPrintSelectedViewModeResults contains results of the Renderer.PrintSelectedViewMode
type RendererMockPrintSelectedViewModeResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrintSelectedViewMode *mRendererMockPrintSelectedViewMode) Optional() *mRendererMockPrintSelectedViewMode {
	mmPrintSelectedViewMode.optional = true
	return mmPrintSelectedViewMode
}

// Expect sets up expected params for Renderer.PrintSelectedViewMode
func (mmPrintSelectedViewMode *mRendererMockPrintSelectedViewMode) Expect() *mRendererMockPrintSelectedViewMode {
	if mmPrintSelectedViewMode.mock.funcPrintSelectedViewMode != nil {
		mmPrintSelectedViewMode.mock.t.Fatalf("RendererMock.PrintSelectedViewMode mock is already set by Set")
	}

	if mmPrintSelectedViewMode.defaultExpectation == nil {
		mmPrintSelectedViewMode.defaultExpectation = &RendererMockPrintSelectedViewModeExpectation{}
	}

	return mmPrintSelectedViewMode
}

// Inspect accepts an inspector function that has same arguments as the Renderer.PrintSelectedViewMode
func (mmPrintSelectedViewMode *mRendererMockPrintSelectedViewMode) Inspect(f func()) *mRendererMockPrintSelectedViewMode {
	if mmPrintSelectedViewMode.mock.inspectFuncPrintSelectedViewMode != nil {
		mmPrintSelectedViewMode.mock.t.Fatalf("Inspect function is already set for RendererMock.PrintSelectedViewMode")
	}

	mmPrintSelectedViewMode.mock.inspectFuncPrintSelectedViewMode = f

	return mmPrintSelectedViewMode
}

// Return sets up results that will be returned by Renderer.PrintSelectedViewMode
func (mmPrintSelectedViewMode *mRendererMockPrintSelectedViewMode) Return(s1 string) *RendererMock {
	if mmPrintSelectedViewMode.mock.funcPrintSelectedViewMode != nil {
		mmPrintSelectedViewMode.mock.t.Fatalf("RendererMock.PrintSelectedViewMode mock is already set by Set")
	}

	if mmPrintSelectedViewMode.defaultExpectation == nil {
		mmPrintSelectedViewMode.defaultExpectation = &RendererMockPrintSelectedViewModeExpectation{mock: mmPrintSelectedViewMode.mock}
	}
	mmPrintSelectedViewMode.defaultExpectation.results = &RendererMockPrintSelectedViewModeResults{s1}
	mmPrintSelectedViewMode.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedViewMode.mock
}

// Set uses given function f to mock the Renderer.PrintSelectedViewMode method
func (mmPrintSelectedViewMode *mRendererMockPrintSelectedViewMode) Set(f func() (s1 string)) *RendererMock {
	if mmPrintSelectedViewMode.defaultExpectation != nil {
		mmPrintSelectedViewMode.mock.t.Fatalf("Default expectation is already set for the Renderer.PrintSelectedViewMode method")
	}

	if len(mmPrintSelectedViewMode.expectations) > 0 {
		mmPrintSelectedViewMode.mock.t.Fatalf("Some expectations are already set for the Renderer.PrintSelectedViewMode method")
	}

	mmPrintSelectedViewMode.mock.funcPrintSelectedViewMode = f
	mmPrintSelectedViewMode.mock.funcPrintSelectedViewModeOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedViewMode.mock
}

// Times sets number of times Renderer.PrintSelectedViewMode should be invoked
func (mmPrintSelectedViewMode *mRendererMockPrintSelectedViewMode) Times(n uint64) *mRendererMockPrintSelectedViewMode {
	if n == 0 {
		mmPrintSelectedViewMode.mock.t.Fatalf("Times of RendererMock.PrintSelectedViewMode mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrintSelectedViewMode.expectedInvocations, n)
	mmPrintSelectedViewMode.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrintSelectedViewMode
}

func (mmPrintSelectedViewMode *mRendererMockPrintSelectedViewMode) invocationsDone() bool {
	if len(mmPrintSelectedViewMode.expectations) == 0 && mmPrintSelectedViewMode.defaultExpectation == nil && mmPrintSelectedViewMode.mock.funcPrintSelectedViewMode == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrintSelectedViewMode.mock.afterPrintSelectedViewModeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrintSelectedViewMode.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PrintSelectedViewMode implements Renderer
func (mmPrintSelectedViewMode *RendererMock) PrintSelectedViewMode() (s1 string) {
	mm_atomic.AddUint64(&mmPrintSelectedViewMode.beforePrintSelectedViewModeCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintSelectedViewMode.afterPrintSelectedViewModeCounter, 1)

	mmPrintSelectedViewMode.t.Helper()

	if mmPrintSelectedViewMode.inspectFuncPrintSelectedViewMode != nil {
		mmPrintSelectedViewMode.inspectFuncPrintSelectedViewMode()
	}

	if mmPrintSelectedViewMode.PrintSelectedViewModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintSelectedViewMode.PrintSelectedViewModeMock.defaultExpectation.Counter, 1)

		mm_results := mmPrintSelectedViewMode.PrintSelectedViewModeMock.defaultExpectation.results
		if mm_results == nil {
			mmPrintSelectedViewMode.t.Fatal("No results are set for the RendererMock.PrintSelectedViewMode")
		}
		return (*mm_results).s1
	}
	if mmPrintSelectedViewMode.funcPrintSelectedViewMode != nil {
		return mmPrintSelectedViewMode.funcPrintSelectedViewMode()
	}
	mmPrintSelectedViewMode.t.Fatalf("Unexpected call to RendererMock.PrintSelectedViewMode.")
	return
}

// PrintSelectedViewModeAfterCounter returns a count of finished RendererMock.PrintSelectedViewMode invocations
func (mmPrintSelectedViewMode *RendererMock) PrintSelectedViewModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintSelectedViewMode.afterPrintSelectedViewModeCounter)
}

// PrintSelectedViewModeBeforeCounter returns a count of RendererMock.PrintSelectedViewMode invocations
func (mmPrintSelectedViewMode *RendererMock) PrintSelectedViewModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintSelectedViewMode.beforePrintSelectedViewModeCounter)
}

// MinimockPrintSelectedViewModeDone returns true if the count of the PrintSelectedViewMode invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockPrintSelectedViewModeDone() bool {
	if m.PrintSelectedViewModeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintSelectedViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintSelectedViewModeMock.invocationsDone()
}

// MinimockPrintSelectedViewModeInspect logs each unmet expectation
func (m *RendererMock) MinimockPrintSelectedViewModeInspect() {
	for _, e := range m.PrintSelectedViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RendererMock.PrintSelectedViewMode")
		}
	}

	afterPrintSelectedViewModeCounter := mm_atomic.LoadUint64(&m.afterPrintSelectedViewModeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintSelectedViewModeMock.defaultExpectation != nil && afterPrintSelectedViewModeCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.PrintSelectedViewMode at\n%s", m.PrintSelectedViewModeMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintSelectedViewMode != nil && afterPrintSelectedViewModeCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.PrintSelectedViewMode at\n%s", m.funcPrintSelectedViewModeOrigin)
	}

	if !m.PrintSelectedViewModeMock.invocationsDone() && afterPrintSelectedViewModeCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.PrintSelectedViewMode at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrintSelectedViewModeMock.expectedInvocations), m.PrintSelectedViewModeMock.expectedInvocationsOrigin, afterPrintSelectedViewModeCounter)
	}
}

type mRendererMockPrintStatus struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockPrintStatusExpectation
	expectations       []*RendererMockPrintStatusExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockPrintStatusExpectation specifies expectation struct of the Renderer.PrintStatus
type RendererMockPrintStatusExpectation struct {
	mock *RendererMock

	results      *RendererMockPrintStatusResults
	returnOrigin string
	Counter      uint64
}

// RendererMockPrintStatusResults contains results of the Renderer.PrintStatus
type RendererMockPrintStatusResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrintStatus *mRendererMockPrintStatus) Optional() *mRendererMockPrintStatus {
	mmPrintStatus.optional = true
	return mmPrintStatus
}

// Expect sets up expected params for Renderer.PrintStatus
func (mmPrintStatus *mRendererMockPrintStatus) Expect() *mRendererMockPrintStatus {
	if mmPrintStatus.mock.funcPrintStatus != nil {
		mmPrintStatus.mock.t.Fatalf("RendererMock.PrintStatus mock is already set by Set")
	}

	if mmPrintStatus.defaultExpectation == nil {
		mmPrintStatus.defaultExpectation = &RendererMockPrintStatusExpectation{}
	}

	return mmPrintStatus
}

// Inspect accepts an inspector function that has same arguments as the Renderer.PrintStatus
func (mmPrintStatus *mRendererMockPrintStatus) Inspect(f func()) *mRendererMockPrintStatus {
	if mmPrintStatus.mock.inspectFuncPrintStatus != nil {
		mmPrintStatus.mock.t.Fatalf("Inspect function is already set for RendererMock.PrintStatus")
	}

	mmPrintStatus.mock.inspectFuncPrintStatus = f

	return mmPrintStatus
}

// Return sets up results that will be returned by Renderer.PrintStatus
func (mmPrintStatus *mRendererMockPrintStatus) Return(s1 string) *RendererMock {
	if mmPrintStatus.mock.funcPrintStatus != nil {
		mmPrintStatus.mock.t.Fatalf("RendererMock.PrintStatus mock is already set by Set")
	}

	if mmPrintStatus.defaultExpectation == nil {
		mmPrintStatus.defaultExpectation = &RendererMockPrintStatusExpectation{mock: mmPrintStatus.mock}
	}
	mmPrintStatus.defaultExpectation.results = &RendererMockPrintStatusResults{s1}
	mmPrintStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrintStatus.mock
}

// Set uses given function f to mock the Renderer.PrintStatus method
func (mmPrintStatus *mRendererMockPrintStatus) Set(f func() (s1 string)) *RendererMock {
	if mmPrintStatus.defaultExpectation != nil {
		mmPrintStatus.mock.t.Fatalf("Default expectation is already set for the Renderer.PrintStatus method")
	}

	if len(mmPrintStatus.expectations) > 0 {
		mmPrintStatus.mock.t.Fatalf("Some expectations are already set for the Renderer.PrintStatus method")
	}

	mmPrintStatus.mock.funcPrintStatus = f
	mmPrintStatus.mock.funcPrintStatusOrigin = minimock.CallerInfo(1)
	return mmPrintStatus.mock
}

// Times sets number of times Renderer.PrintStatus should be invoked
func (mmPrintStatus *mRendererMockPrintStatus) Times(n uint64) *mRendererMockPrintStatus {
	if n == 0 {
		mmPrintStatus.mock.t.Fatalf("Times of RendererMock.PrintStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrintStatus.expectedInvocations, n)
	mmPrintStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrintStatus
}

func (mmPrintStatus *mRendererMockPrintStatus) invocationsDone() bool {
	if len(mmPrintStatus.expectations) == 0 && mmPrintStatus.defaultExpectation == nil && mmPrintStatus.mock.funcPrintStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrintStatus.mock.afterPrintStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrintStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PrintStatus implements Renderer
func (mmPrintStatus *RendererMock) PrintStatus() (s1 string) {
	mm_atomic.AddUint64(&mmPrintStatus.beforePrintStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintStatus.afterPrintStatusCounter, 1)

	mmPrintStatus.t.Helper()

	if mmPrintStatus.inspectFuncPrintStatus != nil {
		mmPrintStatus.inspectFuncPrintStatus()
	}

	if mmPrintStatus.PrintStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintStatus.PrintStatusMock.defaultExpectation.Counter, 1)

		mm_results := mmPrintStatus.PrintStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmPrintStatus.t.Fatal("No results are set for the RendererMock.PrintStatus")
		}
		return (*mm_results).s1
	}
	if mmPrintStatus.funcPrintStatus != nil {
		return mmPrintStatus.funcPrintStatus()
	}
	mmPrintStatus.t.Fatalf("Unexpected call to RendererMock.PrintStatus.")
	return
}

// PrintStatusAfterCounter returns a count of finished RendererMock.PrintStatus invocations
func (mmPrintStatus *RendererMock) PrintStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintStatus.afterPrintStatusCounter)
}

// PrintStatusBeforeCounter returns a count of RendererMock.PrintStatus invocations
func (mmPrintStatus *RendererMock) PrintStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintStatus.beforePrintStatusCounter)
}

// MinimockPrintStatusDone returns true if the count of the PrintStatus invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockPrintStatusDone() bool {
	if m.PrintStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintStatusMock.invocationsDone()
}

// MinimockPrintStatusInspect logs each unmet expectation
func (m *RendererMock) MinimockPrintStatusInspect() {
	for _, e := range m.PrintStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RendererMock.PrintStatus")
		}
	}

	afterPrintStatusCounter := mm_atomic.LoadUint64(&m.afterPrintStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintStatusMock.defaultExpectation != nil && afterPrintStatusCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.PrintStatus at\n%s", m.PrintStatusMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintStatus != nil && afterPrintStatusCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.PrintStatus at\n%s", m.funcPrintStatusOrigin)
	}

	if !m.PrintStatusMock.invocationsDone() && afterPrintStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.PrintStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrintStatusMock.expectedInvocations), m.PrintStatusMock.expectedInvocationsOrigin, afterPrintStatusCounter)
	}
}

type mRendererMockSelectClipboard struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockSelectClipboardExpectation
	expectations       []*RendererMockSelectClipboardExpectation

	callArgs []*RendererMockSelectClipboardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockSelectClipboardExpectation specifies expectation struct of the Renderer.SelectClipboard
type RendererMockSelectClipboardExpectation struct {
	mock               *RendererMock
	params             *RendererMockSelectClipboardParams
	paramPtrs          *RendererMockSelectClipboardParamPtrs
	expectationOrigins RendererMockSelectClipboardExpectationOrigins
	results            *RendererMockSelectClipboardResults
	returnOrigin       string
	Counter            uint64
}

// RendererMockSelectClipboardParams contains parameters of the Renderer.SelectClipboard
type RendererMockSelectClipboardParams struct {
	clipboard string
}

// RendererMockSelectClipboardParamPtrs contains pointers to parameters of the Renderer.SelectClipboard
type RendererMockSelectClipboardParamPtrs struct {
	clipboard *string
}

// RendererMockSelectClipboardResults contains results of the Renderer.SelectClipboard
type RendererMockSelectClipboardResults struct {
	s1 string
}

// RendererMockSelectClipboardOrigins contains origins of expectations of the Renderer.SelectClipboard
type RendererMockSelectClipboardExpectationOrigins struct {
	origin          string
	originClipboard string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectClipboard *mRendererMockSelectClipboard) Optional() *mRendererMockSelectClipboard {
	mmSelectClipboard.optional = true
	return mmSelectClipboard
}

// Expect sets up expected params for Renderer.SelectClipboard
func (mmSelectClipboard *mRendererMockSelectClipboard) Expect(clipboard string) *mRendererMockSelectClipboard {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("RendererMock.SelectClipboard mock is already set by Set")
	}

	if mmSelectClipboard.defaultExpectation == nil {
		mmSelectClipboard.defaultExpectation = &RendererMockSelectClipboardExpectation{}
	}

	if mmSelectClipboard.defaultExpectation.paramPtrs != nil {
		mmSelectClipboard.mock.t.Fatalf("RendererMock.SelectClipboard mock is already set by ExpectParams functions")
	}

	mmSelectClipboard.defaultExpectation.params = &RendererMockSelectClipboardParams{clipboard}
	mmSelectClipboard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectClipboard.expectations {
		if minimock.Equal(e.params, mmSelectClipboard.defaultExpectation.params) {
			mmSelectClipboard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectClipboard.defaultExpectation.params)
		}
	}

	return mmSelectClipboard
}

// ExpectClipboardParam1 sets up expected param clipboard for Renderer.SelectClipboard
func (mmSelectClipboard *mRendererMockSelectClipboard) ExpectClipboardParam1(clipboard string) *mRendererMockSelectClipboard {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("RendererMock.SelectClipboard mock is already set by Set")
	}

	if mmSelectClipboard.defaultExpectation == nil {
		mmSelectClipboard.defaultExpectation = &RendererMockSelectClipboardExpectation{}
	}

	if mmSelectClipboard.defaultExpectation.params != nil {
		mmSelectClipboard.mock.t.Fatalf("RendererMock.SelectClipboard mock is already set by Expect")
	}

	if mmSelectClipboard.defaultExpectation.paramPtrs == nil {
		mmSelectClipboard.defaultExpectation.paramPtrs = &RendererMockSelectClipboardParamPtrs{}
	}
	mmSelectClipboard.defaultExpectation.paramPtrs.clipboard = &clipboard
	mmSelectClipboard.defaultExpectation.expectationOrigins.originClipboard = minimock.CallerInfo(1)

	return mmSelectClipboard
}

// Inspect accepts an inspector function that has same arguments as the Renderer.SelectClipboard
func (mmSelectClipboard *mRendererMockSelectClipboard) Inspect(f func(clipboard string)) *mRendererMockSelectClipboard {
	if mmSelectClipboard.mock.inspectFuncSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("Inspect function is already set for RendererMock.SelectClipboard")
	}

	mmSelectClipboard.mock.inspectFuncSelectClipboard = f

	return mmSelectClipboard
}

// Return sets up results that will be returned by Renderer.SelectClipboard
func (mmSelectClipboard *mRendererMockSelectClipboard) Return(s1 string) *RendererMock {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("RendererMock.SelectClipboard mock is already set by Set")
	}

	if mmSelectClipboard.defaultExpectation == nil {
		mmSelectClipboard.defaultExpectation = &RendererMockSelectClipboardExpectation{mock: mmSelectClipboard.mock}
	}
	mmSelectClipboard.defaultExpectation.results = &RendererMockSelectClipboardResults{s1}
	mmSelectClipboard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectClipboard.mock
}

// Set uses given function f to mock the Renderer.SelectClipboard method
func (mmSelectClipboard *mRendererMockSelectClipboard) Set(f func(clipboard string) (s1 string)) *RendererMock {
	if mmSelectClipboard.defaultExpectation != nil {
		mmSelectClipboard.mock.t.Fatalf("Default expectation is already set for the Renderer.SelectClipboard method")
	}

	if len(mmSelectClipboard.expectations) > 0 {
		mmSelectClipboard.mock.t.Fatalf("Some expectations are already set for the Renderer.SelectClipboard method")
	}

	mmSelectClipboard.mock.funcSelectClipboard = f
	mmSelectClipboard.mock.funcSelectClipboardOrigin = minimock.CallerInfo(1)
	return mmSelectClipboard.mock
}

// When sets expectation for the Renderer.SelectClipboard which will trigger the result defined by the following
// Then helper
func (mmSelectClipboard *mRendererMockSelectClipboard) When(clipboard string) *RendererMockSelectClipboardExpectation {
	if mmSelectClipboard.mock.funcSelectClipboard != nil {
		mmSelectClipboard.mock.t.Fatalf("RendererMock.SelectClipboard mock is already set by Set")
	}

	expectation := &RendererMockSelectClipboardExpectation{
		mock:               mmSelectClipboard.mock,
		params:             &RendererMockSelectClipboardParams{clipboard},
		expectationOrigins: RendererMockSelectClipboardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectClipboard.expectations = append(mmSelectClipboard.expectations, expectation)
	return expectation
}

// Then sets up Renderer.SelectClipboard return parameters for the expectation previously defined by the When method
func (e *RendererMockSelectClipboardExpectation) Then(s1 string) *RendererMock {
	e.results = &RendererMockSelectClipboardResults{s1}
	return e.mock
}

// Times sets number of times Renderer.SelectClipboard should be invoked
func (mmSelectClipboard *mRendererMockSelectClipboard) Times(n uint64) *mRendererMockSelectClipboard {
	if n == 0 {
		mmSelectClipboard.mock.t.Fatalf("Times of RendererMock.SelectClipboard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectClipboard.expectedInvocations, n)
	mmSelectClipboard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectClipboard
}

func (mmSelectClipboard *mRendererMockSelectClipboard) invocationsDone() bool {
	if len(mmSelectClipboard.expectations) == 0 && mmSelectClipboard.defaultExpectation == nil && mmSelectClipboard.mock.funcSelectClipboard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectClipboard.mock.afterSelectClipboardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectClipboard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectClipboard implements Renderer
func (mmSelectClipboard *RendererMock) SelectClipboard(clipboard string) (s1 string) {
	mm_atomic.AddUint64(&mmSelectClipboard.beforeSelectClipboardCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectClipboard.afterSelectClipboardCounter, 1)

	mmSelectClipboard.t.Helper()

	if mmSelectClipboard.inspectFuncSelectClipboard != nil {
		mmSelectClipboard.inspectFuncSelectClipboard(clipboard)
	}

	mm_params := RendererMockSelectClipboardParams{clipboard}

	// Record call args
	mmSelectClipboard.SelectClipboardMock.mutex.Lock()
	mmSelectClipboard.SelectClipboardMock.callArgs = append(mmSelectClipboard.SelectClipboardMock.callArgs, &mm_params)
	mmSelectClipboard.SelectClipboardMock.mutex.Unlock()

	for _, e := range mmSelectClipboard.SelectClipboardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSelectClipboard.SelectClipboardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectClipboard.SelectClipboardMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectClipboard.SelectClipboardMock.defaultExpectation.params
		mm_want_ptrs := mmSelectClipboard.SelectClipboardMock.defaultExpectation.paramPtrs

		mm_got := RendererMockSelectClipboardParams{clipboard}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.clipboard != nil && !minimock.Equal(*mm_want_ptrs.clipboard, mm_got.clipboard) {
				mmSelectClipboard.t.Errorf("RendererMock.SelectClipboard got unexpected parameter clipboard, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectClipboard.SelectClipboardMock.defaultExpectation.expectationOrigins.originClipboard, *mm_want_ptrs.clipboard, mm_got.clipboard, minimock.Diff(*mm_want_ptrs.clipboard, mm_got.clipboard))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectClipboard.t.Errorf("RendererMock.SelectClipboard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectClipboard.SelectClipboardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectClipboard.SelectClipboardMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectClipboard.t.Fatal("No results are set for the RendererMock.SelectClipboard")
		}
		return (*mm_results).s1
	}
	if mmSelectClipboard.funcSelectClipboard != nil {
		return mmSelectClipboard.funcSelectClipboard(clipboard)
	}
	mmSelectClipboard.t.Fatalf("Unexpected call to RendererMock.SelectClipboard. %v", clipboard)
	return
}

// SelectClipboardAfterCounter returns a count of finished RendererMock.SelectClipboard invocations
func (mmSelectClipboard *RendererMock) SelectClipboardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectClipboard.afterSelectClipboardCounter)
}

// SelectClipboardBeforeCounter returns a count of RendererMock.SelectClipboard invocations
func (mmSelectClipboard *RendererMock) SelectClipboardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectClipboard.beforeSelectClipboardCounter)
}

// Calls returns a list of arguments used in each call to RendererMock.SelectClipboard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectClipboard *mRendererMockSelectClipboard) Calls() []*RendererMockSelectClipboardParams {
	mmSelectClipboard.mutex.RLock()

	argCopy := make([]*RendererMockSelectClipboardParams, len(mmSelectClipboard.callArgs))
	copy(argCopy, mmSelectClipboard.callArgs)

	mmSelectClipboard.mutex.RUnlock()

	return argCopy
}

// MinimockSelectClipboardDone returns true if the count of the SelectClipboard invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockSelectClipboardDone() bool {
	if m.SelectClipboardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectClipboardMock.invocationsDone()
}

// MinimockSelectClipboardInspect logs each unmet expectation
func (m *RendererMock) MinimockSelectClipboardInspect() {
	for _, e := range m.SelectClipboardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RendererMock.SelectClipboard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectClipboardCounter := mm_atomic.LoadUint64(&m.afterSelectClipboardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectClipboardMock.defaultExpectation != nil && afterSelectClipboardCounter < 1 {
		if m.SelectClipboardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RendererMock.SelectClipboard at\n%s", m.SelectClipboardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RendererMock.SelectClipboard at\n%s with params: %#v", m.SelectClipboardMock.defaultExpectation.expectationOrigins.origin, *m.SelectClipboardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectClipboard != nil && afterSelectClipboardCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.SelectClipboard at\n%s", m.funcSelectClipboardOrigin)
	}

	if !m.SelectClipboardMock.invocationsDone() && afterSelectClipboardCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.SelectClipboard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectClipboardMock.expectedInvocations), m.SelectClipboardMock.expectedInvocationsOrigin, afterSelectClipboardCounter)
	}
}

type mRendererMockSelectDevice struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockSelectDeviceExpectation
	expectations       []*RendererMockSelectDeviceExpectation

	callArgs []*RendererMockSelectDeviceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockSelectDeviceExpectation specifies expectation struct of the Renderer.SelectDevice
type RendererMockSelectDeviceExpectation struct {
	mock               *RendererMock
	params             *RendererMockSelectDeviceParams
	paramPtrs          *RendererMockSelectDeviceParamPtrs
	expectationOrigins RendererMockSelectDeviceExpectationOrigins
	results            *RendererMockSelectDeviceResults
	returnOrigin       string
	Counter            uint64
}

// RendererMockSelectDeviceParams contains parameters of the Renderer.SelectDevice
type RendererMockSelectDeviceParams struct {
	device string
}

// RendererMockSelectDeviceParamPtrs contains pointers to parameters of the Renderer.SelectDevice
type RendererMockSelectDeviceParamPtrs struct {
	device *string
}

// RendererMockSelectDeviceResults contains results of the Renderer.SelectDevice
type RendererMockSelectDeviceResults struct {
	s1 string
}

// RendererMockSelectDeviceOrigins contains origins of expectations of the Renderer.SelectDevice
type RendererMockSelectDeviceExpectationOrigins struct {
	origin       string
	originDevice string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectDevice *mRendererMockSelectDevice) Optional() *mRendererMockSelectDevice {
	mmSelectDevice.optional = true
	return mmSelectDevice
}

// Expect sets up expected params for Renderer.SelectDevice
func (mmSelectDevice *mRendererMockSelectDevice) Expect(device string) *mRendererMockSelectDevice {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("RendererMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &RendererMockSelectDeviceExpectation{}
	}

	if mmSelectDevice.defaultExpectation.paramPtrs != nil {
		mmSelectDevice.mock.t.Fatalf("RendererMock.SelectDevice mock is already set by ExpectParams functions")
	}

	mmSelectDevice.defaultExpectation.params = &RendererMockSelectDeviceParams{device}
	mmSelectDevice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectDevice.expectations {
		if minimock.Equal(e.params, mmSelectDevice.defaultExpectation.params) {
			mmSelectDevice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectDevice.defaultExpectation.params)
		}
	}

	return mmSelectDevice
}

// ExpectDeviceParam1 sets up expected param device for Renderer.SelectDevice
func (mmSelectDevice *mRendererMockSelectDevice) ExpectDeviceParam1(device string) *mRendererMockSelectDevice {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("RendererMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &RendererMockSelectDeviceExpectation{}
	}

	if mmSelectDevice.defaultExpectation.params != nil {
		mmSelectDevice.mock.t.Fatalf("RendererMock.SelectDevice mock is already set by Expect")
	}

	if mmSelectDevice.defaultExpectation.paramPtrs == nil {
		mmSelectDevice.defaultExpectation.paramPtrs = &RendererMockSelectDeviceParamPtrs{}
	}
	mmSelectDevice.defaultExpectation.paramPtrs.device = &device
	mmSelectDevice.defaultExpectation.expectationOrigins.originDevice = minimock.CallerInfo(1)

	return mmSelectDevice
}

// Inspect accepts an inspector function that has same arguments as the Renderer.SelectDevice
func (mmSelectDevice *mRendererMockSelectDevice) Inspect(f func(device string)) *mRendererMockSelectDevice {
	if mmSelectDevice.mock.inspectFuncSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("Inspect function is already set for RendererMock.SelectDevice")
	}

	mmSelectDevice.mock.inspectFuncSelectDevice = f

	return mmSelectDevice
}

// Return sets up results that will be returned by Renderer.SelectDevice
func (mmSelectDevice *mRendererMockSelectDevice) Return(s1 string) *RendererMock {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("RendererMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &RendererMockSelectDeviceExpectation{mock: mmSelectDevice.mock}
	}
	mmSelectDevice.defaultExpectation.results = &RendererMockSelectDeviceResults{s1}
	mmSelectDevice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectDevice.mock
}

// Set uses given function f to mock the Renderer.SelectDevice method
func (mmSelectDevice *mRendererMockSelectDevice) Set(f func(device string) (s1 string)) *RendererMock {
	if mmSelectDevice.defaultExpectation != nil {
		mmSelectDevice.mock.t.Fatalf("Default expectation is already set for the Renderer.SelectDevice method")
	}

	if len(mmSelectDevice.expectations) > 0 {
		mmSelectDevice.mock.t.Fatalf("Some expectations are already set for the Renderer.SelectDevice method")
	}

	mmSelectDevice.mock.funcSelectDevice = f
	mmSelectDevice.mock.funcSelectDeviceOrigin = minimock.CallerInfo(1)
	return mmSelectDevice.mock
}

// When sets expectation for the Renderer.SelectDevice which will trigger the result defined by the following
// Then helper
func (mmSelectDevice *mRendererMockSelectDevice) When(device string) *RendererMockSelectDeviceExpectation {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("RendererMock.SelectDevice mock is already set by Set")
	}

	expectation := &RendererMockSelectDeviceExpectation{
		mock:               mmSelectDevice.mock,
		params:             &RendererMockSelectDeviceParams{device},
		expectationOrigins: RendererMockSelectDeviceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectDevice.expectations = append(mmSelectDevice.expectations, expectation)
	return expectation
}

// Then sets up Renderer.SelectDevice return parameters for the expectation previously defined by the When method
func (e *RendererMockSelectDeviceExpectation) Then(s1 string) *RendererMock {
	e.results = &RendererMockSelectDeviceResults{s1}
	return e.mock
}

// Times sets number of times Renderer.SelectDevice should be invoked
func (mmSelectDevice *mRendererMockSelectDevice) Times(n uint64) *mRendererMockSelectDevice {
	if n == 0 {
		mmSelectDevice.mock.t.Fatalf("Times of RendererMock.SelectDevice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectDevice.expectedInvocations, n)
	mmSelectDevice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectDevice
}

func (mmSelectDevice *mRendererMockSelectDevice) invocationsDone() bool {
	if len(mmSelectDevice.expectations) == 0 && mmSelectDevice.defaultExpectation == nil && mmSelectDevice.mock.funcSelectDevice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectDevice.mock.afterSelectDeviceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectDevice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectDevice implements Renderer
func (mmSelectDevice *RendererMock) SelectDevice(device string) (s1 string) {
	mm_atomic.AddUint64(&mmSelectDevice.beforeSelectDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectDevice.afterSelectDeviceCounter, 1)

	mmSelectDevice.t.Helper()

	if mmSelectDevice.inspectFuncSelectDevice != nil {
		mmSelectDevice.inspectFuncSelectDevice(device)
	}

	mm_params := RendererMockSelectDeviceParams{device}

	// Record call args
	mmSelectDevice.SelectDeviceMock.mutex.Lock()
	mmSelectDevice.SelectDeviceMock.callArgs = append(mmSelectDevice.SelectDeviceMock.callArgs, &mm_params)
	mmSelectDevice.SelectDeviceMock.mutex.Unlock()

	for _, e := range mmSelectDevice.SelectDeviceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSelectDevice.SelectDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectDevice.SelectDeviceMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectDevice.SelectDeviceMock.defaultExpectation.params
		mm_want_ptrs := mmSelectDevice.SelectDeviceMock.defaultExpectation.paramPtrs

		mm_got := RendererMockSelectDeviceParams{device}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.device != nil && !minimock.Equal(*mm_want_ptrs.device, mm_got.device) {
				mmSelectDevice.t.Errorf("RendererMock.SelectDevice got unexpected parameter device, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectDevice.SelectDeviceMock.defaultExpectation.expectationOrigins.originDevice, *mm_want_ptrs.device, mm_got.device, minimock.Diff(*mm_want_ptrs.device, mm_got.device))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectDevice.t.Errorf("RendererMock.SelectDevice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectDevice.SelectDeviceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectDevice.SelectDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectDevice.t.Fatal("No results are set for the RendererMock.SelectDevice")
		}
		return (*mm_results).s1
	}
	if mmSelectDevice.funcSelectDevice != nil {
		return mmSelectDevice.funcSelectDevice(device)
	}
	mmSelectDevice.t.Fatalf("Unexpected call to RendererMock.SelectDevice. %v", device)
	return
}

// SelectDeviceAfterCounter returns a count of finished RendererMock.SelectDevice invocations
func (mmSelectDevice *RendererMock) SelectDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectDevice.afterSelectDeviceCounter)
}

// SelectDeviceBeforeCounter returns a count of RendererMock.SelectDevice invocations
func (mmSelectDevice *RendererMock) SelectDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectDevice.beforeSelectDeviceCounter)
}

// Calls returns a list of arguments used in each call to RendererMock.SelectDevice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectDevice *mRendererMockSelectDevice) Calls() []*RendererMockSelectDeviceParams {
	mmSelectDevice.mutex.RLock()

	argCopy := make([]*RendererMockSelectDeviceParams, len(mmSelectDevice.callArgs))
	copy(argCopy, mmSelectDevice.callArgs)

	mmSelectDevice.mutex.RUnlock()

	return argCopy
}

// MinimockSelectDeviceDone returns true if the count of the SelectDevice invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockSelectDeviceDone() bool {
	if m.SelectDeviceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectDeviceMock.invocationsDone()
}

// MinimockSelectDeviceInspect logs each unmet expectation
func (m *RendererMock) MinimockSelectDeviceInspect() {
	for _, e := range m.SelectDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RendererMock.SelectDevice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectDeviceCounter := mm_atomic.LoadUint64(&m.afterSelectDeviceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectDeviceMock.defaultExpectation != nil && afterSelectDeviceCounter < 1 {
		if m.SelectDeviceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RendererMock.SelectDevice at\n%s", m.SelectDeviceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RendererMock.SelectDevice at\n%s with params: %#v", m.SelectDeviceMock.defaultExpectation.expectationOrigins.origin, *m.SelectDeviceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectDevice != nil && afterSelectDeviceCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.SelectDevice at\n%s", m.funcSelectDeviceOrigin)
	}

	if !m.SelectDeviceMock.invocationsDone() && afterSelectDeviceCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.SelectDevice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectDeviceMock.expectedInvocations), m.SelectDeviceMock.expectedInvocationsOrigin, afterSelectDeviceCounter)
	}
}

type mRendererMockSelectFloating struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockSelectFloatingExpectation
	expectations       []*RendererMockSelectFloatingExpectation

	callArgs []*RendererMockSelectFloatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockSelectFloatingExpectation specifies expectation struct of the Renderer.SelectFloating
type RendererMockSelectFloatingExpectation struct {
	mock               *RendererMock
	params             *RendererMockSelectFloatingParams
	paramPtrs          *RendererMockSelectFloatingParamPtrs
	expectationOrigins RendererMockSelectFloatingExpectationOrigins
	results            *RendererMockSelectFloatingResults
	returnOrigin       string
	Counter            uint64
}

// RendererMockSelectFloatingParams contains parameters of the Renderer.SelectFloating
type RendererMockSelectFloatingParams struct {
	floatingState string
}

// RendererMockSelectFloatingParamPtrs contains pointers to parameters of the Renderer.SelectFloating
type RendererMockSelectFloatingParamPtrs struct {
	floatingState *string
}

// RendererMockSelectFloatingResults contains results of the Renderer.SelectFloating
type RendererMockSelectFloatingResults struct {
	s1 string
}

// RendererMockSelectFloatingOrigins contains origins of expectations of the Renderer.SelectFloating
type RendererMockSelectFloatingExpectationOrigins struct {
	origin              string
	originFloatingState string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectFloating *mRendererMockSelectFloating) Optional() *mRendererMockSelectFloating {
	mmSelectFloating.optional = true
	return mmSelectFloating
}

// Expect sets up expected params for Renderer.SelectFloating
func (mmSelectFloating *mRendererMockSelectFloating) Expect(floatingState string) *mRendererMockSelectFloating {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("RendererMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &RendererMockSelectFloatingExpectation{}
	}

	if mmSelectFloating.defaultExpectation.paramPtrs != nil {
		mmSelectFloating.mock.t.Fatalf("RendererMock.SelectFloating mock is already set by ExpectParams functions")
	}

	mmSelectFloating.defaultExpectation.params = &RendererMockSelectFloatingParams{floatingState}
	mmSelectFloating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectFloating.expectations {
		if minimock.Equal(e.params, mmSelectFloating.defaultExpectation.params) {
			mmSelectFloating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectFloating.defaultExpectation.params)
		}
	}

	return mmSelectFloating
}

// ExpectFloatingStateParam1 sets up expected param floatingState for Renderer.SelectFloating
func (mmSelectFloating *mRendererMockSelectFloating) ExpectFloatingStateParam1(floatingState string) *mRendererMockSelectFloating {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("RendererMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &RendererMockSelectFloatingExpectation{}
	}

	if mmSelectFloating.defaultExpectation.params != nil {
		mmSelectFloating.mock.t.Fatalf("RendererMock.SelectFloating mock is already set by Expect")
	}

	if mmSelectFloating.defaultExpectation.paramPtrs == nil {
		mmSelectFloating.defaultExpectation.paramPtrs = &RendererMockSelectFloatingParamPtrs{}
	}
	mmSelectFloating.defaultExpectation.paramPtrs.floatingState = &floatingState
	mmSelectFloating.defaultExpectation.expectationOrigins.originFloatingState = minimock.CallerInfo(1)

	return mmSelectFloating
}

// Inspect accepts an inspector function that has same arguments as the Renderer.SelectFloating
func (mmSelectFloating *mRendererMockSelectFloating) Inspect(f func(floatingState string)) *mRendererMockSelectFloating {
	if mmSelectFloating.mock.inspectFuncSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("Inspect function is already set for RendererMock.SelectFloating")
	}

	mmSelectFloating.mock.inspectFuncSelectFloating = f

	return mmSelectFloating
}

// Return sets up results that will be returned by Renderer.SelectFloating
func (mmSelectFloating *mRendererMockSelectFloating) Return(s1 string) *RendererMock {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("RendererMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &RendererMockSelectFloatingExpectation{mock: mmSelectFloating.mock}
	}
	mmSelectFloating.defaultExpectation.results = &RendererMockSelectFloatingResults{s1}
	mmSelectFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectFloating.mock
}

// Set uses given function f to mock the Renderer.SelectFloating method
func (mmSelectFloating *mRendererMockSelectFloating) Set(f func(floatingState string) (s1 string)) *RendererMock {
	if mmSelectFloating.defaultExpectation != nil {
		mmSelectFloating.mock.t.Fatalf("Default expectation is already set for the Renderer.SelectFloating method")
	}

	if len(mmSelectFloating.expectations) > 0 {
		mmSelectFloating.mock.t.Fatalf("Some expectations are already set for the Renderer.SelectFloating method")
	}

	mmSelectFloating.mock.funcSelectFloating = f
	mmSelectFloating.mock.funcSelectFloatingOrigin = minimock.CallerInfo(1)
	return mmSelectFloating.mock
}

// When sets expectation for the Renderer.SelectFloating which will trigger the result defined by the following
// Then helper
func (mmSelectFloating *mRendererMockSelectFloating) When(floatingState string) *RendererMockSelectFloatingExpectation {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("RendererMock.SelectFloating mock is already set by Set")
	}

	expectation := &RendererMockSelectFloatingExpectation{
		mock:               mmSelectFloating.mock,
		params:             &RendererMockSelectFloatingParams{floatingState},
		expectationOrigins: RendererMockSelectFloatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectFloating.expectations = append(mmSelectFloating.expectations, expectation)
	return expectation
}

// Then sets up Renderer.SelectFloating return parameters for the expectation previously defined by the When method
func (e *RendererMockSelectFloatingExpectation) Then(s1 string) *RendererMock {
	e.results = &RendererMockSelectFloatingResults{s1}
	return e.mock
}

// Times sets number of times Renderer.SelectFloating should be invoked
func (mmSelectFloating *mRendererMockSelectFloating) Times(n uint64) *mRendererMockSelectFloating {
	if n == 0 {
		mmSelectFloating.mock.t.Fatalf("Times of RendererMock.SelectFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectFloating.expectedInvocations, n)
	mmSelectFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectFloating
}

func (mmSelectFloating *mRendererMockSelectFloating) invocationsDone() bool {
	if len(mmSelectFloating.expectations) == 0 && mmSelectFloating.defaultExpectation == nil && mmSelectFloating.mock.funcSelectFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectFloating.mock.afterSelectFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectFloating implements Renderer
func (mmSelectFloating *RendererMock) SelectFloating(floatingState string) (s1 string) {
	mm_atomic.AddUint64(&mmSelectFloating.beforeSelectFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectFloating.afterSelectFloatingCounter, 1)

	mmSelectFloating.t.Helper()

	if mmSelectFloating.inspectFuncSelectFloating != nil {
		mmSelectFloating.inspectFuncSelectFloating(floatingState)
	}

	mm_params := RendererMockSelectFloatingParams{floatingState}

	// Record call args
	mmSelectFloating.SelectFloatingMock.mutex.Lock()
	mmSelectFloating.SelectFloatingMock.callArgs = append(mmSelectFloating.SelectFloatingMock.callArgs, &mm_params)
	mmSelectFloating.SelectFloatingMock.mutex.Unlock()

	for _, e := range mmSelectFloating.SelectFloatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSelectFloating.SelectFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectFloating.SelectFloatingMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectFloating.SelectFloatingMock.defaultExpectation.params
		mm_want_ptrs := mmSelectFloating.SelectFloatingMock.defaultExpectation.paramPtrs

		mm_got := RendererMockSelectFloatingParams{floatingState}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.floatingState != nil && !minimock.Equal(*mm_want_ptrs.floatingState, mm_got.floatingState) {
				mmSelectFloating.t.Errorf("RendererMock.SelectFloating got unexpected parameter floatingState, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectFloating.SelectFloatingMock.defaultExpectation.expectationOrigins.originFloatingState, *mm_want_ptrs.floatingState, mm_got.floatingState, minimock.Diff(*mm_want_ptrs.floatingState, mm_got.floatingState))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectFloating.t.Errorf("RendererMock.SelectFloating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectFloating.SelectFloatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectFloating.SelectFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectFloating.t.Fatal("No results are set for the RendererMock.SelectFloating")
		}
		return (*mm_results).s1
	}
	if mmSelectFloating.funcSelectFloating != nil {
		return mmSelectFloating.funcSelectFloating(floatingState)
	}
	mmSelectFloating.t.Fatalf("Unexpected call to RendererMock.SelectFloating. %v", floatingState)
	return
}

// SelectFloatingAfterCounter returns a count of finished RendererMock.SelectFloating invocations
func (mmSelectFloating *RendererMock) SelectFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectFloating.afterSelectFloatingCounter)
}

// SelectFloatingBeforeCounter returns a count of RendererMock.SelectFloating invocations
func (mmSelectFloating *RendererMock) SelectFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectFloating.beforeSelectFloatingCounter)
}

// Calls returns a list of arguments used in each call to RendererMock.SelectFloating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectFloating *mRendererMockSelectFloating) Calls() []*RendererMockSelectFloatingParams {
	mmSelectFloating.mutex.RLock()

	argCopy := make([]*RendererMockSelectFloatingParams, len(mmSelectFloating.callArgs))
	copy(argCopy, mmSelectFloating.callArgs)

	mmSelectFloating.mutex.RUnlock()

	return argCopy
}

// MinimockSelectFloatingDone returns true if the count of the SelectFloating invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockSelectFloatingDone() bool {
	if m.SelectFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectFloatingMock.invocationsDone()
}

// MinimockSelectFloatingInspect logs each unmet expectation
func (m *RendererMock) MinimockSelectFloatingInspect() {
	for _, e := range m.SelectFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RendererMock.SelectFloating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectFloatingCounter := mm_atomic.LoadUint64(&m.afterSelectFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectFloatingMock.defaultExpectation != nil && afterSelectFloatingCounter < 1 {
		if m.SelectFloatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RendererMock.SelectFloating at\n%s", m.SelectFloatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RendererMock.SelectFloating at\n%s with params: %#v", m.SelectFloatingMock.defaultExpectation.expectationOrigins.origin, *m.SelectFloatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectFloating != nil && afterSelectFloatingCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.SelectFloating at\n%s", m.funcSelectFloatingOrigin)
	}

	if !m.SelectFloatingMock.invocationsDone() && afterSelectFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.SelectFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectFloatingMock.expectedInvocations), m.SelectFloatingMock.expectedInvocationsOrigin, afterSelectFloatingCounter)
	}
}

type mRendererMockSelectLanguage struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockSelectLanguageExpectation
	expectations       []*RendererMockSelectLanguageExpectation

	callArgs []*RendererMockSelectLanguageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockSelectLanguageExpectation specifies expectation struct of the Renderer.SelectLanguage
type RendererMockSelectLanguageExpectation struct {
	mock               *RendererMock
	params             *RendererMockSelectLanguageParams
	paramPtrs          *RendererMockSelectLanguageParamPtrs
	expectationOrigins RendererMockSelectLanguageExpectationOrigins
	results            *RendererMockSelectLanguageResults
	returnOrigin       string
	Counter            uint64
}

// RendererMockSelectLanguageParams contains parameters of the Renderer.SelectLanguage
type RendererMockSelectLanguageParams struct {
	language string
}

// RendererMockSelectLanguageParamPtrs contains pointers to parameters of the Renderer.SelectLanguage
type RendererMockSelectLanguageParamPtrs struct {
	language *string
}

// RendererMockSelectLanguageResults contains results of the Renderer.SelectLanguage
type RendererMockSelectLanguageResults struct {
	s1 string
}

// RendererMockSelectLanguageOrigins contains origins of expectations of the Renderer.SelectLanguage
type RendererMockSelectLanguageExpectationOrigins struct {
	origin         string
	originLanguage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectLanguage *mRendererMockSelectLanguage) Optional() *mRendererMockSelectLanguage {
	mmSelectLanguage.optional = true
	return mmSelectLanguage
}

// Expect sets up expected params for Renderer.SelectLanguage
func (mmSelectLanguage *mRendererMockSelectLanguage) Expect(language string) *mRendererMockSelectLanguage {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("RendererMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &RendererMockSelectLanguageExpectation{}
	}

	if mmSelectLanguage.defaultExpectation.paramPtrs != nil {
		mmSelectLanguage.mock.t.Fatalf("RendererMock.SelectLanguage mock is already set by ExpectParams functions")
	}

	mmSelectLanguage.defaultExpectation.params = &RendererMockSelectLanguageParams{language}
	mmSelectLanguage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectLanguage.expectations {
		if minimock.Equal(e.params, mmSelectLanguage.defaultExpectation.params) {
			mmSelectLanguage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectLanguage.defaultExpectation.params)
		}
	}

	return mmSelectLanguage
}

// ExpectLanguageParam1 sets up expected param language for Renderer.SelectLanguage
func (mmSelectLanguage *mRendererMockSelectLanguage) ExpectLanguageParam1(language string) *mRendererMockSelectLanguage {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("RendererMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &RendererMockSelectLanguageExpectation{}
	}

	if mmSelectLanguage.defaultExpectation.params != nil {
		mmSelectLanguage.mock.t.Fatalf("RendererMock.SelectLanguage mock is already set by Expect")
	}

	if mmSelectLanguage.defaultExpectation.paramPtrs == nil {
		mmSelectLanguage.defaultExpectation.paramPtrs = &RendererMockSelectLanguageParamPtrs{}
	}
	mmSelectLanguage.defaultExpectation.paramPtrs.language = &language
	mmSelectLanguage.defaultExpectation.expectationOrigins.originLanguage = minimock.CallerInfo(1)

	return mmSelectLanguage
}

// Inspect accepts an inspector function that has same arguments as the Renderer.SelectLanguage
func (mmSelectLanguage *mRendererMockSelectLanguage) Inspect(f func(language string)) *mRendererMockSelectLanguage {
	if mmSelectLanguage.mock.inspectFuncSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("Inspect function is already set for RendererMock.SelectLanguage")
	}

	mmSelectLanguage.mock.inspectFuncSelectLanguage = f

	return mmSelectLanguage
}

// Return sets up results that will be returned by Renderer.SelectLanguage
func (mmSelectLanguage *mRendererMockSelectLanguage) Return(s1 string) *RendererMock {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("RendererMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &RendererMockSelectLanguageExpectation{mock: mmSelectLanguage.mock}
	}
	mmSelectLanguage.defaultExpectation.results = &RendererMockSelectLanguageResults{s1}
	mmSelectLanguage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectLanguage.mock
}

// Set uses given function f to mock the Renderer.SelectLanguage method
func (mmSelectLanguage *mRendererMockSelectLanguage) Set(f func(language string) (s1 string)) *RendererMock {
	if mmSelectLanguage.defaultExpectation != nil {
		mmSelectLanguage.mock.t.Fatalf("Default expectation is already set for the Renderer.SelectLanguage method")
	}

	if len(mmSelectLanguage.expectations) > 0 {
		mmSelectLanguage.mock.t.Fatalf("Some expectations are already set for the Renderer.SelectLanguage method")
	}

	mmSelectLanguage.mock.funcSelectLanguage = f
	mmSelectLanguage.mock.funcSelectLanguageOrigin = minimock.CallerInfo(1)
	return mmSelectLanguage.mock
}

// When sets expectation for the Renderer.SelectLanguage which will trigger the result defined by the following
// Then helper
func (mmSelectLanguage *mRendererMockSelectLanguage) When(language string) *RendererMockSelectLanguageExpectation {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("RendererMock.SelectLanguage mock is already set by Set")
	}

	expectation := &RendererMockSelectLanguageExpectation{
		mock:               mmSelectLanguage.mock,
		params:             &RendererMockSelectLanguageParams{language},
		expectationOrigins: RendererMockSelectLanguageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectLanguage.expectations = append(mmSelectLanguage.expectations, expectation)
	return expectation
}

// Then sets up Renderer.SelectLanguage return parameters for the expectation previously defined by the When method
func (e *RendererMockSelectLanguageExpectation) Then(s1 string) *RendererMock {
	e.results = &RendererMockSelectLanguageResults{s1}
	return e.mock
}

// Times sets number of times Renderer.SelectLanguage should be invoked
func (mmSelectLanguage *mRendererMockSelectLanguage) Times(n uint64) *mRendererMockSelectLanguage {
	if n == 0 {
		mmSelectLanguage.mock.t.Fatalf("Times of RendererMock.SelectLanguage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectLanguage.expectedInvocations, n)
	mmSelectLanguage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectLanguage
}

func (mmSelectLanguage *mRendererMockSelectLanguage) invocationsDone() bool {
	if len(mmSelectLanguage.expectations) == 0 && mmSelectLanguage.defaultExpectation == nil && mmSelectLanguage.mock.funcSelectLanguage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectLanguage.mock.afterSelectLanguageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectLanguage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectLanguage implements Renderer
func (mmSelectLanguage *RendererMock) SelectLanguage(language string) (s1 string) {
	mm_atomic.AddUint64(&mmSelectLanguage.beforeSelectLanguageCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectLanguage.afterSelectLanguageCounter, 1)

	mmSelectLanguage.t.Helper()

	if mmSelectLanguage.inspectFuncSelectLanguage != nil {
		mmSelectLanguage.inspectFuncSelectLanguage(language)
	}

	mm_params := RendererMockSelectLanguageParams{language}

	// Record call args
	mmSelectLanguage.SelectLanguageMock.mutex.Lock()
	mmSelectLanguage.SelectLanguageMock.callArgs = append(mmSelectLanguage.SelectLanguageMock.callArgs, &mm_params)
	mmSelectLanguage.SelectLanguageMock.mutex.Unlock()

	for _, e := range mmSelectLanguage.SelectLanguageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSelectLanguage.SelectLanguageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectLanguage.SelectLanguageMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectLanguage.SelectLanguageMock.defaultExpectation.params
		mm_want_ptrs := mmSelectLanguage.SelectLanguageMock.defaultExpectation.paramPtrs

		mm_got := RendererMockSelectLanguageParams{language}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.language != nil && !minimock.Equal(*mm_want_ptrs.language, mm_got.language) {
				mmSelectLanguage.t.Errorf("RendererMock.SelectLanguage got unexpected parameter language, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectLanguage.SelectLanguageMock.defaultExpectation.expectationOrigins.originLanguage, *mm_want_ptrs.language, mm_got.language, minimock.Diff(*mm_want_ptrs.language, mm_got.language))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectLanguage.t.Errorf("RendererMock.SelectLanguage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectLanguage.SelectLanguageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectLanguage.SelectLanguageMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectLanguage.t.Fatal("No results are set for the RendererMock.SelectLanguage")
		}
		return (*mm_results).s1
	}
	if mmSelectLanguage.funcSelectLanguage != nil {
		return mmSelectLanguage.funcSelectLanguage(language)
	}
	mmSelectLanguage.t.Fatalf("Unexpected call to RendererMock.SelectLanguage. %v", language)
	return
}

// SelectLanguageAfterCounter returns a count of finished RendererMock.SelectLanguage invocations
func (mmSelectLanguage *RendererMock) SelectLanguageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectLanguage.afterSelectLanguageCounter)
}

// SelectLanguageBeforeCounter returns a count of RendererMock.SelectLanguage invocations
func (mmSelectLanguage *RendererMock) SelectLanguageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectLanguage.beforeSelectLanguageCounter)
}

// Calls returns a list of arguments used in each call to RendererMock.SelectLanguage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectLanguage *mRendererMockSelectLanguage) Calls() []*RendererMockSelectLanguageParams {
	mmSelectLanguage.mutex.RLock()

	argCopy := make([]*RendererMockSelectLanguageParams, len(mmSelectLanguage.callArgs))
	copy(argCopy, mmSelectLanguage.callArgs)

	mmSelectLanguage.mutex.RUnlock()

	return argCopy
}

// MinimockSelectLanguageDone returns true if the count of the SelectLanguage invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockSelectLanguageDone() bool {
	if m.SelectLanguageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectLanguageMock.invocationsDone()
}

// MinimockSelectLanguageInspect logs each unmet expectation
func (m *RendererMock) MinimockSelectLanguageInspect() {
	for _, e := range m.SelectLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RendererMock.SelectLanguage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectLanguageCounter := mm_atomic.LoadUint64(&m.afterSelectLanguageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectLanguageMock.defaultExpectation != nil && afterSelectLanguageCounter < 1 {
		if m.SelectLanguageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RendererMock.SelectLanguage at\n%s", m.SelectLanguageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RendererMock.SelectLanguage at\n%s with params: %#v", m.SelectLanguageMock.defaultExpectation.expectationOrigins.origin, *m.SelectLanguageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectLanguage != nil && afterSelectLanguageCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.SelectLanguage at\n%s", m.funcSelectLanguageOrigin)
	}

	if !m.SelectLanguageMock.invocationsDone() && afterSelectLanguageCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.SelectLanguage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectLanguageMock.expectedInvocations), m.SelectLanguageMock.expectedInvocationsOrigin, afterSelectLanguageCounter)
	}
}

type mRendererMockSelectViewMode struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockSelectViewModeExpectation
	expectations       []*RendererMockSelectViewModeExpectation

	callArgs []*RendererMockSelectViewModeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockSelectViewModeExpectation specifies expectation struct of the Renderer.SelectViewMode
type RendererMockSelectViewModeExpectation struct {
	mock               *RendererMock
	params             *RendererMockSelectViewModeParams
	paramPtrs          *RendererMockSelectViewModeParamPtrs
	expectationOrigins RendererMockSelectViewModeExpectationOrigins
	results            *RendererMockSelectViewModeResults
	returnOrigin       string
	Counter            uint64
}

// RendererMockSelectViewModeParams contains parameters of the Renderer.SelectViewMode
type RendererMockSelectViewModeParams struct {
	viewMode string
}

// RendererMockSelectViewModeParamPtrs contains pointers to parameters of the Renderer.SelectViewMode
type RendererMockSelectViewModeParamPtrs struct {
	viewMode *string
}

// RendererMockSelectViewModeResults contains results of the Renderer.SelectViewMode
type RendererMockSelectViewModeResults struct {
	s1 string
}

// RendererMockSelectViewModeOrigins contains origins of expectations of the Renderer.SelectViewMode
type RendererMockSelectViewModeExpectationOrigins struct {
	origin         string
	originViewMode string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectViewMode *mRendererMockSelectViewMode) Optional() *mRendererMockSelectViewMode {
	mmSelectViewMode.optional = true
	return mmSelectViewMode
}

// Expect sets up expected params for Renderer.SelectViewMode
func (mmSelectViewMode *mRendererMockSelectViewMode) Expect(viewMode string) *mRendererMockSelectViewMode {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("RendererMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &RendererMockSelectViewModeExpectation{}
	}

	if mmSelectViewMode.defaultExpectation.paramPtrs != nil {
		mmSelectViewMode.mock.t.Fatalf("RendererMock.SelectViewMode mock is already set by ExpectParams functions")
	}

	mmSelectViewMode.defaultExpectation.params = &RendererMockSelectViewModeParams{viewMode}
	mmSelectViewMode.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectViewMode.expectations {
		if minimock.Equal(e.params, mmSelectViewMode.defaultExpectation.params) {
			mmSelectViewMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectViewMode.defaultExpectation.params)
		}
	}

	return mmSelectViewMode
}

// ExpectViewModeParam1 sets up expected param viewMode for Renderer.SelectViewMode
func (mmSelectViewMode *mRendererMockSelectViewMode) ExpectViewModeParam1(viewMode string) *mRendererMockSelectViewMode {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("RendererMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &RendererMockSelectViewModeExpectation{}
	}

	if mmSelectViewMode.defaultExpectation.params != nil {
		mmSelectViewMode.mock.t.Fatalf("RendererMock.SelectViewMode mock is already set by Expect")
	}

	if mmSelectViewMode.defaultExpectation.paramPtrs == nil {
		mmSelectViewMode.defaultExpectation.paramPtrs = &RendererMockSelectViewModeParamPtrs{}
	}
	mmSelectViewMode.defaultExpectation.paramPtrs.viewMode = &viewMode
	mmSelectViewMode.defaultExpectation.expectationOrigins.originViewMode = minimock.CallerInfo(1)

	return mmSelectViewMode
}

// Inspect accepts an inspector function that has same arguments as the Renderer.SelectViewMode
func (mmSelectViewMode *mRendererMockSelectViewMode) Inspect(f func(viewMode string)) *mRendererMockSelectViewMode {
	if mmSelectViewMode.mock.inspectFuncSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("Inspect function is already set for RendererMock.SelectViewMode")
	}

	mmSelectViewMode.mock.inspectFuncSelectViewMode = f

	return mmSelectViewMode
}

// Return sets up results that will be returned by Renderer.SelectViewMode
func (mmSelectViewMode *mRendererMockSelectViewMode) Return(s1 string) *RendererMock {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("RendererMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &RendererMockSelectViewModeExpectation{mock: mmSelectViewMode.mock}
	}
	mmSelectViewMode.defaultExpectation.results = &RendererMockSelectViewModeResults{s1}
	mmSelectViewMode.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectViewMode.mock
}

// Set uses given function f to mock the Renderer.SelectViewMode method
func (mmSelectViewMode *mRendererMockSelectViewMode) Set(f func(viewMode string) (s1 string)) *RendererMock {
	if mmSelectViewMode.defaultExpectation != nil {
		mmSelectViewMode.mock.t.Fatalf("Default expectation is already set for the Renderer.SelectViewMode method")
	}

	if len(mmSelectViewMode.expectations) > 0 {
		mmSelectViewMode.mock.t.Fatalf("Some expectations are already set for the Renderer.SelectViewMode method")
	}

	mmSelectViewMode.mock.funcSelectViewMode = f
	mmSelectViewMode.mock.funcSelectViewModeOrigin = minimock.CallerInfo(1)
	return mmSelectViewMode.mock
}

// When sets expectation for the Renderer.SelectViewMode which will trigger the result defined by the following
// Then helper
func (mmSelectViewMode *mRendererMockSelectViewMode) When(viewMode string) *RendererMockSelectViewModeExpectation {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("RendererMock.SelectViewMode mock is already set by Set")
	}

	expectation := &RendererMockSelectViewModeExpectation{
		mock:               mmSelectViewMode.mock,
		params:             &RendererMockSelectViewModeParams{viewMode},
		expectationOrigins: RendererMockSelectViewModeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectViewMode.expectations = append(mmSelectViewMode.expectations, expectation)
	return expectation
}

// Then sets up Renderer.SelectViewMode return parameters for the expectation previously defined by the When method
func (e *RendererMockSelectViewModeExpectation) Then(s1 string) *RendererMock {
	e.results = &RendererMockSelectViewModeResults{s1}
	return e.mock
}

// Times sets number of times Renderer.SelectViewMode should be invoked
func (mmSelectViewMode *mRendererMockSelectViewMode) Times(n uint64) *mRendererMockSelectViewMode {
	if n == 0 {
		mmSelectViewMode.mock.t.Fatalf("Times of RendererMock.SelectViewMode mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectViewMode.expectedInvocations, n)
	mmSelectViewMode.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectViewMode
}

func (mmSelectViewMode *mRendererMockSelectViewMode) invocationsDone() bool {
	if len(mmSelectViewMode.expectations) == 0 && mmSelectViewMode.defaultExpectation == nil && mmSelectViewMode.mock.funcSelectViewMode == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectViewMode.mock.afterSelectViewModeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectViewMode.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectViewMode implements Renderer
func (mmSelectViewMode *RendererMock) SelectViewMode(viewMode string) (s1 string) {
	mm_atomic.AddUint64(&mmSelectViewMode.beforeSelectViewModeCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectViewMode.afterSelectViewModeCounter, 1)

	mmSelectViewMode.t.Helper()

	if mmSelectViewMode.inspectFuncSelectViewMode != nil {
		mmSelectViewMode.inspectFuncSelectViewMode(viewMode)
	}

	mm_params := RendererMockSelectViewModeParams{viewMode}

	// Record call args
	mmSelectViewMode.SelectViewModeMock.mutex.Lock()
	mmSelectViewMode.SelectViewModeMock.callArgs = append(mmSelectViewMode.SelectViewModeMock.callArgs, &mm_params)
	mmSelectViewMode.SelectViewModeMock.mutex.Unlock()

	for _, e := range mmSelectViewMode.SelectViewModeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSelectViewMode.SelectViewModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectViewMode.SelectViewModeMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectViewMode.SelectViewModeMock.defaultExpectation.params
		mm_want_ptrs := mmSelectViewMode.SelectViewModeMock.defaultExpectation.paramPtrs

		mm_got := RendererMockSelectViewModeParams{viewMode}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.viewMode != nil && !minimock.Equal(*mm_want_ptrs.viewMode, mm_got.viewMode) {
				mmSelectViewMode.t.Errorf("RendererMock.SelectViewMode got unexpected parameter viewMode, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectViewMode.SelectViewModeMock.defaultExpectation.expectationOrigins.originViewMode, *mm_want_ptrs.viewMode, mm_got.viewMode, minimock.Diff(*mm_want_ptrs.viewMode, mm_got.viewMode))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectViewMode.t.Errorf("RendererMock.SelectViewMode got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectViewMode.SelectViewModeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectViewMode.SelectViewModeMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectViewMode.t.Fatal("No results are set for the RendererMock.SelectViewMode")
		}
		return (*mm_results).s1
	}
	if mmSelectViewMode.funcSelectViewMode != nil {
		return mmSelectViewMode.funcSelectViewMode(viewMode)
	}
	mmSelectViewMode.t.Fatalf("Unexpected call to RendererMock.SelectViewMode. %v", viewMode)
	return
}

// SelectViewModeAfterCounter returns a count of finished RendererMock.SelectViewMode invocations
func (mmSelectViewMode *RendererMock) SelectViewModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectViewMode.afterSelectViewModeCounter)
}

// SelectViewModeBeforeCounter returns a count of RendererMock.SelectViewMode invocations
func (mmSelectViewMode *RendererMock) SelectViewModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectViewMode.beforeSelectViewModeCounter)
}

// Calls returns a list of arguments used in each call to RendererMock.SelectViewMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectViewMode *mRendererMockSelectViewMode) Calls() []*RendererMockSelectViewModeParams {
	mmSelectViewMode.mutex.RLock()

	argCopy := make([]*RendererMockSelectViewModeParams, len(mmSelectViewMode.callArgs))
	copy(argCopy, mmSelectViewMode.callArgs)

	mmSelectViewMode.mutex.RUnlock()

	return argCopy
}

// MinimockSelectViewModeDone returns true if the count of the SelectViewMode invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockSelectViewModeDone() bool {
	if m.SelectViewModeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectViewModeMock.invocationsDone()
}

// MinimockSelectViewModeInspect logs each unmet expectation
func (m *RendererMock) MinimockSelectViewModeInspect() {
	for _, e := range m.SelectViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RendererMock.SelectViewMode at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectViewModeCounter := mm_atomic.LoadUint64(&m.afterSelectViewModeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectViewModeMock.defaultExpectation != nil && afterSelectViewModeCounter < 1 {
		if m.SelectViewModeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RendererMock.SelectViewMode at\n%s", m.SelectViewModeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RendererMock.SelectViewMode at\n%s with params: %#v", m.SelectViewModeMock.defaultExpectation.expectationOrigins.origin, *m.SelectViewModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectViewMode != nil && afterSelectViewModeCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.SelectViewMode at\n%s", m.funcSelectViewModeOrigin)
	}

	if !m.SelectViewModeMock.invocationsDone() && afterSelectViewModeCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.SelectViewMode at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectViewModeMock.expectedInvocations), m.SelectViewModeMock.expectedInvocationsOrigin, afterSelectViewModeCounter)
	}
}

type mRendererMockToggle struct {
	optional           bool
	mock               *RendererMock
	defaultExpectation *RendererMockToggleExpectation
	expectations       []*RendererMockToggleExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RendererMockToggleExpectation specifies expectation struct of the Renderer.Toggle
type RendererMockToggleExpectation struct {
	mock *RendererMock

	results      *RendererMockToggleResults
	returnOrigin string
	Counter      uint64
}

// RendererMockToggleResults contains results of the Renderer.Toggle
type RendererMockToggleResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToggle *mRendererMockToggle) Optional() *mRendererMockToggle {
	mmToggle.optional = true
	return mmToggle
}

// Expect sets up expected params for Renderer.Toggle
func (mmToggle *mRendererMockToggle) Expect() *mRendererMockToggle {
	if mmToggle.mock.funcToggle != nil {
		mmToggle.mock.t.Fatalf("RendererMock.Toggle mock is already set by Set")
	}

	if mmToggle.defaultExpectation == nil {
		mmToggle.defaultExpectation = &RendererMockToggleExpectation{}
	}

	return mmToggle
}

// Inspect accepts an inspector function that has same arguments as the Renderer.Toggle
func (mmToggle *mRendererMockToggle) Inspect(f func()) *mRendererMockToggle {
	if mmToggle.mock.inspectFuncToggle != nil {
		mmToggle.mock.t.Fatalf("Inspect function is already set for RendererMock.Toggle")
	}

	mmToggle.mock.inspectFuncToggle = f

	return mmToggle
}

// Return sets up results that will be returned by Renderer.Toggle
func (mmToggle *mRendererMockToggle) Return(s1 string) *RendererMock {
	if mmToggle.mock.funcToggle != nil {
		mmToggle.mock.t.Fatalf("RendererMock.Toggle mock is already set by Set")
	}

	if mmToggle.defaultExpectation == nil {
		mmToggle.defaultExpectation = &RendererMockToggleExpectation{mock: mmToggle.mock}
	}
	mmToggle.defaultExpectation.results = &RendererMockToggleResults{s1}
	mmToggle.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToggle.mock
}

// Set uses given function f to mock the Renderer.Toggle method
func (mmToggle *mRendererMockToggle) Set(f func() (s1 string)) *RendererMock {
	if mmToggle.defaultExpectation != nil {
		mmToggle.mock.t.Fatalf("Default expectation is already set for the Renderer.Toggle method")
	}

	if len(mmToggle.expectations) > 0 {
		mmToggle.mock.t.Fatalf("Some expectations are already set for the Renderer.Toggle method")
	}

	mmToggle.mock.funcToggle = f
	mmToggle.mock.funcToggleOrigin = minimock.CallerInfo(1)
	return mmToggle.mock
}

// Times sets number of times Renderer.Toggle should be invoked
func (mmToggle *mRendererMockToggle) Times(n uint64) *mRendererMockToggle {
	if n == 0 {
		mmToggle.mock.t.Fatalf("Times of RendererMock.Toggle mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToggle.expectedInvocations, n)
	mmToggle.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToggle
}

func (mmToggle *mRendererMockToggle) invocationsDone() bool {
	if len(mmToggle.expectations) == 0 && mmToggle.defaultExpectation == nil && mmToggle.mock.funcToggle == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToggle.mock.afterToggleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToggle.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Toggle implements Renderer
func (mmToggle *RendererMock) Toggle() (s1 string) {
	mm_atomic.AddUint64(&mmToggle.beforeToggleCounter, 1)
	defer mm_atomic.AddUint64(&mmToggle.afterToggleCounter, 1)

	mmToggle.t.Helper()

	if mmToggle.inspectFuncToggle != nil {
		mmToggle.inspectFuncToggle()
	}

	if mmToggle.ToggleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToggle.ToggleMock.defaultExpectation.Counter, 1)

		mm_results := mmToggle.ToggleMock.defaultExpectation.results
		if mm_results == nil {
			mmToggle.t.Fatal("No results are set for the RendererMock.Toggle")
		}
		return (*mm_results).s1
	}
	if mmToggle.funcToggle != nil {
		return mmToggle.funcToggle()
	}
	mmToggle.t.Fatalf("Unexpected call to RendererMock.Toggle.")
	return
}

// ToggleAfterCounter returns a count of finished RendererMock.Toggle invocations
func (mmToggle *RendererMock) ToggleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToggle.afterToggleCounter)
}

// ToggleBeforeCounter returns a count of RendererMock.Toggle invocations
func (mmToggle *RendererMock) ToggleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToggle.beforeToggleCounter)
}

// MinimockToggleDone returns true if the count of the Toggle invocations corresponds
// the number of defined expectations
func (m *RendererMock) MinimockToggleDone() bool {
	if m.ToggleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToggleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToggleMock.invocationsDone()
}

// MinimockToggleInspect logs each unmet expectation
func (m *RendererMock) MinimockToggleInspect() {
	for _, e := range m.ToggleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RendererMock.Toggle")
		}
	}

	afterToggleCounter := mm_atomic.LoadUint64(&m.afterToggleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToggleMock.defaultExpectation != nil && afterToggleCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.Toggle at\n%s", m.ToggleMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToggle != nil && afterToggleCounter < 1 {
		m.t.Errorf("Expected call to RendererMock.Toggle at\n%s", m.funcToggleOrigin)
	}

	if !m.ToggleMock.invocationsDone() && afterToggleCounter > 0 {
		m.t.Errorf("Expected %d calls to RendererMock.Toggle at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToggleMock.expectedInvocations), m.ToggleMock.expectedInvocationsOrigin, afterToggleCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RendererMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAppPlaceholderInspect()

			m.MinimockCloseSettingsInspect()

			m.MinimockCopyTextInspect()

			m.MinimockFloatingPageInspect()

			m.MinimockListenSocketInspect()

			m.MinimockOpenSettingsInspect()

			m.MinimockPrintMetricInspect()

			m.MinimockPrintSelectedClipboardInspect()

			m.MinimockPrintSelectedDeviceInspect()

			m.MinimockPrintSelectedFloatingInspect()

			m.MinimockPrintSelectedLanguageInspect()

			m.MinimockPrintSelectedViewModeInspect()

			m.MinimockPrintStatusInspect()

			m.MinimockSelectClipboardInspect()

			m.MinimockSelectDeviceInspect()

			m.MinimockSelectFloatingInspect()

			m.MinimockSelectLanguageInspect()

			m.MinimockSelectViewModeInspect()

			m.MinimockToggleInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RendererMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RendererMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAppPlaceholderDone() &&
		m.MinimockCloseSettingsDone() &&
		m.MinimockCopyTextDone() &&
		m.MinimockFloatingPageDone() &&
		m.MinimockListenSocketDone() &&
		m.MinimockOpenSettingsDone() &&
		m.MinimockPrintMetricDone() &&
		m.MinimockPrintSelectedClipboardDone() &&
		m.MinimockPrintSelectedDeviceDone() &&
		m.MinimockPrintSelectedFloatingDone() &&
		m.MinimockPrintSelectedLanguageDone() &&
		m.MinimockPrintSelectedViewModeDone() &&
		m.MinimockPrintStatusDone() &&
		m.MinimockSelectClipboardDone() &&
		m.MinimockSelectDeviceDone() &&
		m.MinimockSelectFloatingDone() &&
		m.MinimockSelectLanguageDone() &&
		m.MinimockSelectViewModeDone() &&
		m.MinimockToggleDone()
}
