// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package btt

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LanguageComponentMock implements LanguageComponent
type LanguageComponentMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcSelectLanguage          func(ctx context.Context, language string) (err error)
	funcSelectLanguageOrigin    string
	inspectFuncSelectLanguage   func(ctx context.Context, language string)
	afterSelectLanguageCounter  uint64
	beforeSelectLanguageCounter uint64
	SelectLanguageMock          mLanguageComponentMockSelectLanguage

	funcSelectedLanguage          func(ctx context.Context) (s1 string, err error)
	funcSelectedLanguageOrigin    string
	inspectFuncSelectedLanguage   func(ctx context.Context)
	afterSelectedLanguageCounter  uint64
	beforeSelectedLanguageCounter uint64
	SelectedLanguageMock          mLanguageComponentMockSelectedLanguage
}

// NewLanguageComponentMock returns a mock for LanguageComponent
func NewLanguageComponentMock(t minimock.Tester) *LanguageComponentMock {
	m := &LanguageComponentMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.SelectLanguageMock = mLanguageComponentMockSelectLanguage{mock: m}
	m.SelectLanguageMock.callArgs = []*LanguageComponentMockSelectLanguageParams{}

	m.SelectedLanguageMock = mLanguageComponentMockSelectedLanguage{mock: m}
	m.SelectedLanguageMock.callArgs = []*LanguageComponentMockSelectedLanguageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLanguageComponentMockSelectLanguage struct {
	optional           bool
	mock               *LanguageComponentMock
	defaultExpectation *LanguageComponentMockSelectLanguageExpectation
	expectations       []*LanguageComponentMockSelectLanguageExpectation

	callArgs []*LanguageComponentMockSelectLanguageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LanguageComponentMockSelectLanguageExpectation specifies expectation struct of the LanguageComponent.SelectLanguage
type LanguageComponentMockSelectLanguageExpectation struct {
	mock               *LanguageComponentMock
	params             *LanguageComponentMockSelectLanguageParams
	paramPtrs          *LanguageComponentMockSelectLanguageParamPtrs
	expectationOrigins LanguageComponentMockSelectLanguageExpectationOrigins
	results            *LanguageComponentMockSelectLanguageResults
	returnOrigin       string
	Counter            uint64
}

// LanguageComponentMockSelectLanguageParams contains parameters of the LanguageComponent.SelectLanguage
type LanguageComponentMockSelectLanguageParams struct {
	ctx      context.Context
	language string
}

// LanguageComponentMockSelectLanguageParamPtrs contains pointers to parameters of the LanguageComponent.SelectLanguage
type LanguageComponentMockSelectLanguageParamPtrs struct {
	ctx      *context.Context
	language *string
}

// LanguageComponentMockSelectLanguageResults contains results of the LanguageComponent.SelectLanguage
type LanguageComponentMockSelectLanguageResults struct {
	err error
}

// LanguageComponentMockSelectLanguageOrigins contains origins of expectations of the LanguageComponent.SelectLanguage
type LanguageComponentMockSelectLanguageExpectationOrigins struct {
	origin         string
	originCtx      string
	originLanguage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectLanguage *mLanguageComponentMockSelectLanguage) Optional() *mLanguageComponentMockSelectLanguage {
	mmSelectLanguage.optional = true
	return mmSelectLanguage
}

// Expect sets up expected params for LanguageComponent.SelectLanguage
func (mmSelectLanguage *mLanguageComponentMockSelectLanguage) Expect(ctx context.Context, language string) *mLanguageComponentMockSelectLanguage {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("LanguageComponentMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &LanguageComponentMockSelectLanguageExpectation{}
	}

	if mmSelectLanguage.defaultExpectation.paramPtrs != nil {
		mmSelectLanguage.mock.t.Fatalf("LanguageComponentMock.SelectLanguage mock is already set by ExpectParams functions")
	}

	mmSelectLanguage.defaultExpectation.params = &LanguageComponentMockSelectLanguageParams{ctx, language}
	mmSelectLanguage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectLanguage.expectations {
		if minimock.Equal(e.params, mmSelectLanguage.defaultExpectation.params) {
			mmSelectLanguage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectLanguage.defaultExpectation.params)
		}
	}

	return mmSelectLanguage
}

// ExpectCtxParam1 sets up expected param ctx for LanguageComponent.SelectLanguage
func (mmSelectLanguage *mLanguageComponentMockSelectLanguage) ExpectCtxParam1(ctx context.Context) *mLanguageComponentMockSelectLanguage {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("LanguageComponentMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &LanguageComponentMockSelectLanguageExpectation{}
	}

	if mmSelectLanguage.defaultExpectation.params != nil {
		mmSelectLanguage.mock.t.Fatalf("LanguageComponentMock.SelectLanguage mock is already set by Expect")
	}

	if mmSelectLanguage.defaultExpectation.paramPtrs == nil {
		mmSelectLanguage.defaultExpectation.paramPtrs = &LanguageComponentMockSelectLanguageParamPtrs{}
	}
	mmSelectLanguage.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectLanguage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectLanguage
}

// ExpectLanguageParam2 sets up expected param language for LanguageComponent.SelectLanguage
func (mmSelectLanguage *mLanguageComponentMockSelectLanguage) ExpectLanguageParam2(language string) *mLanguageComponentMockSelectLanguage {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("LanguageComponentMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &LanguageComponentMockSelectLanguageExpectation{}
	}

	if mmSelectLanguage.defaultExpectation.params != nil {
		mmSelectLanguage.mock.t.Fatalf("LanguageComponentMock.SelectLanguage mock is already set by Expect")
	}

	if mmSelectLanguage.defaultExpectation.paramPtrs == nil {
		mmSelectLanguage.defaultExpectation.paramPtrs = &LanguageComponentMockSelectLanguageParamPtrs{}
	}
	mmSelectLanguage.defaultExpectation.paramPtrs.language = &language
	mmSelectLanguage.defaultExpectation.expectationOrigins.originLanguage = minimock.CallerInfo(1)

	return mmSelectLanguage
}

// Inspect accepts an inspector function that has same arguments as the LanguageComponent.SelectLanguage
func (mmSelectLanguage *mLanguageComponentMockSelectLanguage) Inspect(f func(ctx context.Context, language string)) *mLanguageComponentMockSelectLanguage {
	if mmSelectLanguage.mock.inspectFuncSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("Inspect function is already set for LanguageComponentMock.SelectLanguage")
	}

	mmSelectLanguage.mock.inspectFuncSelectLanguage = f

	return mmSelectLanguage
}

// Return sets up results that will be returned by LanguageComponent.SelectLanguage
func (mmSelectLanguage *mLanguageComponentMockSelectLanguage) Return(err error) *LanguageComponentMock {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("LanguageComponentMock.SelectLanguage mock is already set by Set")
	}

	if mmSelectLanguage.defaultExpectation == nil {
		mmSelectLanguage.defaultExpectation = &LanguageComponentMockSelectLanguageExpectation{mock: mmSelectLanguage.mock}
	}
	mmSelectLanguage.defaultExpectation.results = &LanguageComponentMockSelectLanguageResults{err}
	mmSelectLanguage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectLanguage.mock
}

// Set uses given function f to mock the LanguageComponent.SelectLanguage method
func (mmSelectLanguage *mLanguageComponentMockSelectLanguage) Set(f func(ctx context.Context, language string) (err error)) *LanguageComponentMock {
	if mmSelectLanguage.defaultExpectation != nil {
		mmSelectLanguage.mock.t.Fatalf("Default expectation is already set for the LanguageComponent.SelectLanguage method")
	}

	if len(mmSelectLanguage.expectations) > 0 {
		mmSelectLanguage.mock.t.Fatalf("Some expectations are already set for the LanguageComponent.SelectLanguage method")
	}

	mmSelectLanguage.mock.funcSelectLanguage = f
	mmSelectLanguage.mock.funcSelectLanguageOrigin = minimock.CallerInfo(1)
	return mmSelectLanguage.mock
}

// When sets expectation for the LanguageComponent.SelectLanguage which will trigger the result defined by the following
// Then helper
func (mmSelectLanguage *mLanguageComponentMockSelectLanguage) When(ctx context.Context, language string) *LanguageComponentMockSelectLanguageExpectation {
	if mmSelectLanguage.mock.funcSelectLanguage != nil {
		mmSelectLanguage.mock.t.Fatalf("LanguageComponentMock.SelectLanguage mock is already set by Set")
	}

	expectation := &LanguageComponentMockSelectLanguageExpectation{
		mock:               mmSelectLanguage.mock,
		params:             &LanguageComponentMockSelectLanguageParams{ctx, language},
		expectationOrigins: LanguageComponentMockSelectLanguageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectLanguage.expectations = append(mmSelectLanguage.expectations, expectation)
	return expectation
}

// Then sets up LanguageComponent.SelectLanguage return parameters for the expectation previously defined by the When method
func (e *LanguageComponentMockSelectLanguageExpectation) Then(err error) *LanguageComponentMock {
	e.results = &LanguageComponentMockSelectLanguageResults{err}
	return e.mock
}

// Times sets number of times LanguageComponent.SelectLanguage should be invoked
func (mmSelectLanguage *mLanguageComponentMockSelectLanguage) Times(n uint64) *mLanguageComponentMockSelectLanguage {
	if n == 0 {
		mmSelectLanguage.mock.t.Fatalf("Times of LanguageComponentMock.SelectLanguage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectLanguage.expectedInvocations, n)
	mmSelectLanguage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectLanguage
}

func (mmSelectLanguage *mLanguageComponentMockSelectLanguage) invocationsDone() bool {
	if len(mmSelectLanguage.expectations) == 0 && mmSelectLanguage.defaultExpectation == nil && mmSelectLanguage.mock.funcSelectLanguage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectLanguage.mock.afterSelectLanguageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectLanguage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectLanguage implements LanguageComponent
func (mmSelectLanguage *LanguageComponentMock) SelectLanguage(ctx context.Context, language string) (err error) {
	mm_atomic.AddUint64(&mmSelectLanguage.beforeSelectLanguageCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectLanguage.afterSelectLanguageCounter, 1)

	mmSelectLanguage.t.Helper()

	if mmSelectLanguage.inspectFuncSelectLanguage != nil {
		mmSelectLanguage.inspectFuncSelectLanguage(ctx, language)
	}

	mm_params := LanguageComponentMockSelectLanguageParams{ctx, language}

	// Record call args
	mmSelectLanguage.SelectLanguageMock.mutex.Lock()
	mmSelectLanguage.SelectLanguageMock.callArgs = append(mmSelectLanguage.SelectLanguageMock.callArgs, &mm_params)
	mmSelectLanguage.SelectLanguageMock.mutex.Unlock()

	for _, e := range mmSelectLanguage.SelectLanguageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectLanguage.SelectLanguageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectLanguage.SelectLanguageMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectLanguage.SelectLanguageMock.defaultExpectation.params
		mm_want_ptrs := mmSelectLanguage.SelectLanguageMock.defaultExpectation.paramPtrs

		mm_got := LanguageComponentMockSelectLanguageParams{ctx, language}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectLanguage.t.Errorf("LanguageComponentMock.SelectLanguage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectLanguage.SelectLanguageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.language != nil && !minimock.Equal(*mm_want_ptrs.language, mm_got.language) {
				mmSelectLanguage.t.Errorf("LanguageComponentMock.SelectLanguage got unexpected parameter language, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectLanguage.SelectLanguageMock.defaultExpectation.expectationOrigins.originLanguage, *mm_want_ptrs.language, mm_got.language, minimock.Diff(*mm_want_ptrs.language, mm_got.language))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectLanguage.t.Errorf("LanguageComponentMock.SelectLanguage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectLanguage.SelectLanguageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectLanguage.SelectLanguageMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectLanguage.t.Fatal("No results are set for the LanguageComponentMock.SelectLanguage")
		}
		return (*mm_results).err
	}
	if mmSelectLanguage.funcSelectLanguage != nil {
		return mmSelectLanguage.funcSelectLanguage(ctx, language)
	}
	mmSelectLanguage.t.Fatalf("Unexpected call to LanguageComponentMock.SelectLanguage. %v %v", ctx, language)
	return
}

// SelectLanguageAfterCounter returns a count of finished LanguageComponentMock.SelectLanguage invocations
func (mmSelectLanguage *LanguageComponentMock) SelectLanguageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectLanguage.afterSelectLanguageCounter)
}

// SelectLanguageBeforeCounter returns a count of LanguageComponentMock.SelectLanguage invocations
func (mmSelectLanguage *LanguageComponentMock) SelectLanguageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectLanguage.beforeSelectLanguageCounter)
}

// Calls returns a list of arguments used in each call to LanguageComponentMock.SelectLanguage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectLanguage *mLanguageComponentMockSelectLanguage) Calls() []*LanguageComponentMockSelectLanguageParams {
	mmSelectLanguage.mutex.RLock()

	argCopy := make([]*LanguageComponentMockSelectLanguageParams, len(mmSelectLanguage.callArgs))
	copy(argCopy, mmSelectLanguage.callArgs)

	mmSelectLanguage.mutex.RUnlock()

	return argCopy
}

// MinimockSelectLanguageDone returns true if the count of the SelectLanguage invocations corresponds
// the number of defined expectations
func (m *LanguageComponentMock) MinimockSelectLanguageDone() bool {
	if m.SelectLanguageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectLanguageMock.invocationsDone()
}

// MinimockSelectLanguageInspect logs each unmet expectation
func (m *LanguageComponentMock) MinimockSelectLanguageInspect() {
	for _, e := range m.SelectLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LanguageComponentMock.SelectLanguage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectLanguageCounter := mm_atomic.LoadUint64(&m.afterSelectLanguageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectLanguageMock.defaultExpectation != nil && afterSelectLanguageCounter < 1 {
		if m.SelectLanguageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LanguageComponentMock.SelectLanguage at\n%s", m.SelectLanguageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LanguageComponentMock.SelectLanguage at\n%s with params: %#v", m.SelectLanguageMock.defaultExpectation.expectationOrigins.origin, *m.SelectLanguageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectLanguage != nil && afterSelectLanguageCounter < 1 {
		m.t.Errorf("Expected call to LanguageComponentMock.SelectLanguage at\n%s", m.funcSelectLanguageOrigin)
	}

	if !m.SelectLanguageMock.invocationsDone() && afterSelectLanguageCounter > 0 {
		m.t.Errorf("Expected %d calls to LanguageComponentMock.SelectLanguage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectLanguageMock.expectedInvocations), m.SelectLanguageMock.expectedInvocationsOrigin, afterSelectLanguageCounter)
	}
}

type mLanguageComponentMockSelectedLanguage struct {
	optional           bool
	mock               *LanguageComponentMock
	defaultExpectation *LanguageComponentMockSelectedLanguageExpectation
	expectations       []*LanguageComponentMockSelectedLanguageExpectation

	callArgs []*LanguageComponentMockSelectedLanguageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LanguageComponentMockSelectedLanguageExpectation specifies expectation struct of the LanguageComponent.SelectedLanguage
type LanguageComponentMockSelectedLanguageExpectation struct {
	mock               *LanguageComponentMock
	params             *LanguageComponentMockSelectedLanguageParams
	paramPtrs          *LanguageComponentMockSelectedLanguageParamPtrs
	expectationOrigins LanguageComponentMockSelectedLanguageExpectationOrigins
	results            *LanguageComponentMockSelectedLanguageResults
	returnOrigin       string
	Counter            uint64
}

// LanguageComponentMockSelectedLanguageParams contains parameters of the LanguageComponent.SelectedLanguage
type LanguageComponentMockSelectedLanguageParams struct {
	ctx context.Context
}

// LanguageComponentMockSelectedLanguageParamPtrs contains pointers to parameters of the LanguageComponent.SelectedLanguage
type LanguageComponentMockSelectedLanguageParamPtrs struct {
	ctx *context.Context
}

// LanguageComponentMockSelectedLanguageResults contains results of the LanguageComponent.SelectedLanguage
type LanguageComponentMockSelectedLanguageResults struct {
	s1  string
	err error
}

// LanguageComponentMockSelectedLanguageOrigins contains origins of expectations of the LanguageComponent.SelectedLanguage
type LanguageComponentMockSelectedLanguageExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedLanguage *mLanguageComponentMockSelectedLanguage) Optional() *mLanguageComponentMockSelectedLanguage {
	mmSelectedLanguage.optional = true
	return mmSelectedLanguage
}

// Expect sets up expected params for LanguageComponent.SelectedLanguage
func (mmSelectedLanguage *mLanguageComponentMockSelectedLanguage) Expect(ctx context.Context) *mLanguageComponentMockSelectedLanguage {
	if mmSelectedLanguage.mock.funcSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("LanguageComponentMock.SelectedLanguage mock is already set by Set")
	}

	if mmSelectedLanguage.defaultExpectation == nil {
		mmSelectedLanguage.defaultExpectation = &LanguageComponentMockSelectedLanguageExpectation{}
	}

	if mmSelectedLanguage.defaultExpectation.paramPtrs != nil {
		mmSelectedLanguage.mock.t.Fatalf("LanguageComponentMock.SelectedLanguage mock is already set by ExpectParams functions")
	}

	mmSelectedLanguage.defaultExpectation.params = &LanguageComponentMockSelectedLanguageParams{ctx}
	mmSelectedLanguage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedLanguage.expectations {
		if minimock.Equal(e.params, mmSelectedLanguage.defaultExpectation.params) {
			mmSelectedLanguage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedLanguage.defaultExpectation.params)
		}
	}

	return mmSelectedLanguage
}

// ExpectCtxParam1 sets up expected param ctx for LanguageComponent.SelectedLanguage
func (mmSelectedLanguage *mLanguageComponentMockSelectedLanguage) ExpectCtxParam1(ctx context.Context) *mLanguageComponentMockSelectedLanguage {
	if mmSelectedLanguage.mock.funcSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("LanguageComponentMock.SelectedLanguage mock is already set by Set")
	}

	if mmSelectedLanguage.defaultExpectation == nil {
		mmSelectedLanguage.defaultExpectation = &LanguageComponentMockSelectedLanguageExpectation{}
	}

	if mmSelectedLanguage.defaultExpectation.params != nil {
		mmSelectedLanguage.mock.t.Fatalf("LanguageComponentMock.SelectedLanguage mock is already set by Expect")
	}

	if mmSelectedLanguage.defaultExpectation.paramPtrs == nil {
		mmSelectedLanguage.defaultExpectation.paramPtrs = &LanguageComponentMockSelectedLanguageParamPtrs{}
	}
	mmSelectedLanguage.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedLanguage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedLanguage
}

// Inspect accepts an inspector function that has same arguments as the LanguageComponent.SelectedLanguage
func (mmSelectedLanguage *mLanguageComponentMockSelectedLanguage) Inspect(f func(ctx context.Context)) *mLanguageComponentMockSelectedLanguage {
	if mmSelectedLanguage.mock.inspectFuncSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("Inspect function is already set for LanguageComponentMock.SelectedLanguage")
	}

	mmSelectedLanguage.mock.inspectFuncSelectedLanguage = f

	return mmSelectedLanguage
}

// Return sets up results that will be returned by LanguageComponent.SelectedLanguage
func (mmSelectedLanguage *mLanguageComponentMockSelectedLanguage) Return(s1 string, err error) *LanguageComponentMock {
	if mmSelectedLanguage.mock.funcSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("LanguageComponentMock.SelectedLanguage mock is already set by Set")
	}

	if mmSelectedLanguage.defaultExpectation == nil {
		mmSelectedLanguage.defaultExpectation = &LanguageComponentMockSelectedLanguageExpectation{mock: mmSelectedLanguage.mock}
	}
	mmSelectedLanguage.defaultExpectation.results = &LanguageComponentMockSelectedLanguageResults{s1, err}
	mmSelectedLanguage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedLanguage.mock
}

// Set uses given function f to mock the LanguageComponent.SelectedLanguage method
func (mmSelectedLanguage *mLanguageComponentMockSelectedLanguage) Set(f func(ctx context.Context) (s1 string, err error)) *LanguageComponentMock {
	if mmSelectedLanguage.defaultExpectation != nil {
		mmSelectedLanguage.mock.t.Fatalf("Default expectation is already set for the LanguageComponent.SelectedLanguage method")
	}

	if len(mmSelectedLanguage.expectations) > 0 {
		mmSelectedLanguage.mock.t.Fatalf("Some expectations are already set for the LanguageComponent.SelectedLanguage method")
	}

	mmSelectedLanguage.mock.funcSelectedLanguage = f
	mmSelectedLanguage.mock.funcSelectedLanguageOrigin = minimock.CallerInfo(1)
	return mmSelectedLanguage.mock
}

// When sets expectation for the LanguageComponent.SelectedLanguage which will trigger the result defined by the following
// Then helper
func (mmSelectedLanguage *mLanguageComponentMockSelectedLanguage) When(ctx context.Context) *LanguageComponentMockSelectedLanguageExpectation {
	if mmSelectedLanguage.mock.funcSelectedLanguage != nil {
		mmSelectedLanguage.mock.t.Fatalf("LanguageComponentMock.SelectedLanguage mock is already set by Set")
	}

	expectation := &LanguageComponentMockSelectedLanguageExpectation{
		mock:               mmSelectedLanguage.mock,
		params:             &LanguageComponentMockSelectedLanguageParams{ctx},
		expectationOrigins: LanguageComponentMockSelectedLanguageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedLanguage.expectations = append(mmSelectedLanguage.expectations, expectation)
	return expectation
}

// Then sets up LanguageComponent.SelectedLanguage return parameters for the expectation previously defined by the When method
func (e *LanguageComponentMockSelectedLanguageExpectation) Then(s1 string, err error) *LanguageComponentMock {
	e.results = &LanguageComponentMockSelectedLanguageResults{s1, err}
	return e.mock
}

// Times sets number of times LanguageComponent.SelectedLanguage should be invoked
func (mmSelectedLanguage *mLanguageComponentMockSelectedLanguage) Times(n uint64) *mLanguageComponentMockSelectedLanguage {
	if n == 0 {
		mmSelectedLanguage.mock.t.Fatalf("Times of LanguageComponentMock.SelectedLanguage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedLanguage.expectedInvocations, n)
	mmSelectedLanguage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedLanguage
}

func (mmSelectedLanguage *mLanguageComponentMockSelectedLanguage) invocationsDone() bool {
	if len(mmSelectedLanguage.expectations) == 0 && mmSelectedLanguage.defaultExpectation == nil && mmSelectedLanguage.mock.funcSelectedLanguage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedLanguage.mock.afterSelectedLanguageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedLanguage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedLanguage implements LanguageComponent
func (mmSelectedLanguage *LanguageComponentMock) SelectedLanguage(ctx context.Context) (s1 string, err error) {
	mm_atomic.AddUint64(&mmSelectedLanguage.beforeSelectedLanguageCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedLanguage.afterSelectedLanguageCounter, 1)

	mmSelectedLanguage.t.Helper()

	if mmSelectedLanguage.inspectFuncSelectedLanguage != nil {
		mmSelectedLanguage.inspectFuncSelectedLanguage(ctx)
	}

	mm_params := LanguageComponentMockSelectedLanguageParams{ctx}

	// Record call args
	mmSelectedLanguage.SelectedLanguageMock.mutex.Lock()
	mmSelectedLanguage.SelectedLanguageMock.callArgs = append(mmSelectedLanguage.SelectedLanguageMock.callArgs, &mm_params)
	mmSelectedLanguage.SelectedLanguageMock.mutex.Unlock()

	for _, e := range mmSelectedLanguage.SelectedLanguageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmSelectedLanguage.SelectedLanguageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.paramPtrs

		mm_got := LanguageComponentMockSelectedLanguageParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedLanguage.t.Errorf("LanguageComponentMock.SelectedLanguage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedLanguage.t.Errorf("LanguageComponentMock.SelectedLanguage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedLanguage.SelectedLanguageMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedLanguage.t.Fatal("No results are set for the LanguageComponentMock.SelectedLanguage")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmSelectedLanguage.funcSelectedLanguage != nil {
		return mmSelectedLanguage.funcSelectedLanguage(ctx)
	}
	mmSelectedLanguage.t.Fatalf("Unexpected call to LanguageComponentMock.SelectedLanguage. %v", ctx)
	return
}

// SelectedLanguageAfterCounter returns a count of finished LanguageComponentMock.SelectedLanguage invocations
func (mmSelectedLanguage *LanguageComponentMock) SelectedLanguageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedLanguage.afterSelectedLanguageCounter)
}

// SelectedLanguageBeforeCounter returns a count of LanguageComponentMock.SelectedLanguage invocations
func (mmSelectedLanguage *LanguageComponentMock) SelectedLanguageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedLanguage.beforeSelectedLanguageCounter)
}

// Calls returns a list of arguments used in each call to LanguageComponentMock.SelectedLanguage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedLanguage *mLanguageComponentMockSelectedLanguage) Calls() []*LanguageComponentMockSelectedLanguageParams {
	mmSelectedLanguage.mutex.RLock()

	argCopy := make([]*LanguageComponentMockSelectedLanguageParams, len(mmSelectedLanguage.callArgs))
	copy(argCopy, mmSelectedLanguage.callArgs)

	mmSelectedLanguage.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedLanguageDone returns true if the count of the SelectedLanguage invocations corresponds
// the number of defined expectations
func (m *LanguageComponentMock) MinimockSelectedLanguageDone() bool {
	if m.SelectedLanguageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedLanguageMock.invocationsDone()
}

// MinimockSelectedLanguageInspect logs each unmet expectation
func (m *LanguageComponentMock) MinimockSelectedLanguageInspect() {
	for _, e := range m.SelectedLanguageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LanguageComponentMock.SelectedLanguage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedLanguageCounter := mm_atomic.LoadUint64(&m.afterSelectedLanguageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedLanguageMock.defaultExpectation != nil && afterSelectedLanguageCounter < 1 {
		if m.SelectedLanguageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LanguageComponentMock.SelectedLanguage at\n%s", m.SelectedLanguageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LanguageComponentMock.SelectedLanguage at\n%s with params: %#v", m.SelectedLanguageMock.defaultExpectation.expectationOrigins.origin, *m.SelectedLanguageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedLanguage != nil && afterSelectedLanguageCounter < 1 {
		m.t.Errorf("Expected call to LanguageComponentMock.SelectedLanguage at\n%s", m.funcSelectedLanguageOrigin)
	}

	if !m.SelectedLanguageMock.invocationsDone() && afterSelectedLanguageCounter > 0 {
		m.t.Errorf("Expected %d calls to LanguageComponentMock.SelectedLanguage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedLanguageMock.expectedInvocations), m.SelectedLanguageMock.expectedInvocationsOrigin, afterSelectedLanguageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LanguageComponentMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockSelectLanguageInspect()

			m.MinimockSelectedLanguageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LanguageComponentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LanguageComponentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockSelectLanguageDone() &&
		m.MinimockSelectedLanguageDone()
}
