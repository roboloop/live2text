// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package storage

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StorageMock implements Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetValue          func(ctx context.Context, key Key) (s1 string, err error)
	funcGetValueOrigin    string
	inspectFuncGetValue   func(ctx context.Context, key Key)
	afterGetValueCounter  uint64
	beforeGetValueCounter uint64
	GetValueMock          mStorageMockGetValue

	funcSetValue          func(ctx context.Context, key Key, value string) (err error)
	funcSetValueOrigin    string
	inspectFuncSetValue   func(ctx context.Context, key Key, value string)
	afterSetValueCounter  uint64
	beforeSetValueCounter uint64
	SetValueMock          mStorageMockSetValue
}

// NewStorageMock returns a mock for Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetValueMock = mStorageMockGetValue{mock: m}
	m.GetValueMock.callArgs = []*StorageMockGetValueParams{}

	m.SetValueMock = mStorageMockSetValue{mock: m}
	m.SetValueMock.callArgs = []*StorageMockSetValueParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockGetValue struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetValueExpectation
	expectations       []*StorageMockGetValueExpectation

	callArgs []*StorageMockGetValueParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetValueExpectation specifies expectation struct of the Storage.GetValue
type StorageMockGetValueExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetValueParams
	paramPtrs          *StorageMockGetValueParamPtrs
	expectationOrigins StorageMockGetValueExpectationOrigins
	results            *StorageMockGetValueResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetValueParams contains parameters of the Storage.GetValue
type StorageMockGetValueParams struct {
	ctx context.Context
	key Key
}

// StorageMockGetValueParamPtrs contains pointers to parameters of the Storage.GetValue
type StorageMockGetValueParamPtrs struct {
	ctx *context.Context
	key *Key
}

// StorageMockGetValueResults contains results of the Storage.GetValue
type StorageMockGetValueResults struct {
	s1  string
	err error
}

// StorageMockGetValueOrigins contains origins of expectations of the Storage.GetValue
type StorageMockGetValueExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetValue *mStorageMockGetValue) Optional() *mStorageMockGetValue {
	mmGetValue.optional = true
	return mmGetValue
}

// Expect sets up expected params for Storage.GetValue
func (mmGetValue *mStorageMockGetValue) Expect(ctx context.Context, key Key) *mStorageMockGetValue {
	if mmGetValue.mock.funcGetValue != nil {
		mmGetValue.mock.t.Fatalf("StorageMock.GetValue mock is already set by Set")
	}

	if mmGetValue.defaultExpectation == nil {
		mmGetValue.defaultExpectation = &StorageMockGetValueExpectation{}
	}

	if mmGetValue.defaultExpectation.paramPtrs != nil {
		mmGetValue.mock.t.Fatalf("StorageMock.GetValue mock is already set by ExpectParams functions")
	}

	mmGetValue.defaultExpectation.params = &StorageMockGetValueParams{ctx, key}
	mmGetValue.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetValue.expectations {
		if minimock.Equal(e.params, mmGetValue.defaultExpectation.params) {
			mmGetValue.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetValue.defaultExpectation.params)
		}
	}

	return mmGetValue
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetValue
func (mmGetValue *mStorageMockGetValue) ExpectCtxParam1(ctx context.Context) *mStorageMockGetValue {
	if mmGetValue.mock.funcGetValue != nil {
		mmGetValue.mock.t.Fatalf("StorageMock.GetValue mock is already set by Set")
	}

	if mmGetValue.defaultExpectation == nil {
		mmGetValue.defaultExpectation = &StorageMockGetValueExpectation{}
	}

	if mmGetValue.defaultExpectation.params != nil {
		mmGetValue.mock.t.Fatalf("StorageMock.GetValue mock is already set by Expect")
	}

	if mmGetValue.defaultExpectation.paramPtrs == nil {
		mmGetValue.defaultExpectation.paramPtrs = &StorageMockGetValueParamPtrs{}
	}
	mmGetValue.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetValue.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetValue
}

// ExpectKeyParam2 sets up expected param key for Storage.GetValue
func (mmGetValue *mStorageMockGetValue) ExpectKeyParam2(key Key) *mStorageMockGetValue {
	if mmGetValue.mock.funcGetValue != nil {
		mmGetValue.mock.t.Fatalf("StorageMock.GetValue mock is already set by Set")
	}

	if mmGetValue.defaultExpectation == nil {
		mmGetValue.defaultExpectation = &StorageMockGetValueExpectation{}
	}

	if mmGetValue.defaultExpectation.params != nil {
		mmGetValue.mock.t.Fatalf("StorageMock.GetValue mock is already set by Expect")
	}

	if mmGetValue.defaultExpectation.paramPtrs == nil {
		mmGetValue.defaultExpectation.paramPtrs = &StorageMockGetValueParamPtrs{}
	}
	mmGetValue.defaultExpectation.paramPtrs.key = &key
	mmGetValue.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmGetValue
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetValue
func (mmGetValue *mStorageMockGetValue) Inspect(f func(ctx context.Context, key Key)) *mStorageMockGetValue {
	if mmGetValue.mock.inspectFuncGetValue != nil {
		mmGetValue.mock.t.Fatalf("Inspect function is already set for StorageMock.GetValue")
	}

	mmGetValue.mock.inspectFuncGetValue = f

	return mmGetValue
}

// Return sets up results that will be returned by Storage.GetValue
func (mmGetValue *mStorageMockGetValue) Return(s1 string, err error) *StorageMock {
	if mmGetValue.mock.funcGetValue != nil {
		mmGetValue.mock.t.Fatalf("StorageMock.GetValue mock is already set by Set")
	}

	if mmGetValue.defaultExpectation == nil {
		mmGetValue.defaultExpectation = &StorageMockGetValueExpectation{mock: mmGetValue.mock}
	}
	mmGetValue.defaultExpectation.results = &StorageMockGetValueResults{s1, err}
	mmGetValue.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetValue.mock
}

// Set uses given function f to mock the Storage.GetValue method
func (mmGetValue *mStorageMockGetValue) Set(f func(ctx context.Context, key Key) (s1 string, err error)) *StorageMock {
	if mmGetValue.defaultExpectation != nil {
		mmGetValue.mock.t.Fatalf("Default expectation is already set for the Storage.GetValue method")
	}

	if len(mmGetValue.expectations) > 0 {
		mmGetValue.mock.t.Fatalf("Some expectations are already set for the Storage.GetValue method")
	}

	mmGetValue.mock.funcGetValue = f
	mmGetValue.mock.funcGetValueOrigin = minimock.CallerInfo(1)
	return mmGetValue.mock
}

// When sets expectation for the Storage.GetValue which will trigger the result defined by the following
// Then helper
func (mmGetValue *mStorageMockGetValue) When(ctx context.Context, key Key) *StorageMockGetValueExpectation {
	if mmGetValue.mock.funcGetValue != nil {
		mmGetValue.mock.t.Fatalf("StorageMock.GetValue mock is already set by Set")
	}

	expectation := &StorageMockGetValueExpectation{
		mock:               mmGetValue.mock,
		params:             &StorageMockGetValueParams{ctx, key},
		expectationOrigins: StorageMockGetValueExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetValue.expectations = append(mmGetValue.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetValue return parameters for the expectation previously defined by the When method
func (e *StorageMockGetValueExpectation) Then(s1 string, err error) *StorageMock {
	e.results = &StorageMockGetValueResults{s1, err}
	return e.mock
}

// Times sets number of times Storage.GetValue should be invoked
func (mmGetValue *mStorageMockGetValue) Times(n uint64) *mStorageMockGetValue {
	if n == 0 {
		mmGetValue.mock.t.Fatalf("Times of StorageMock.GetValue mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetValue.expectedInvocations, n)
	mmGetValue.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetValue
}

func (mmGetValue *mStorageMockGetValue) invocationsDone() bool {
	if len(mmGetValue.expectations) == 0 && mmGetValue.defaultExpectation == nil && mmGetValue.mock.funcGetValue == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetValue.mock.afterGetValueCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetValue.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetValue implements Storage
func (mmGetValue *StorageMock) GetValue(ctx context.Context, key Key) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetValue.beforeGetValueCounter, 1)
	defer mm_atomic.AddUint64(&mmGetValue.afterGetValueCounter, 1)

	mmGetValue.t.Helper()

	if mmGetValue.inspectFuncGetValue != nil {
		mmGetValue.inspectFuncGetValue(ctx, key)
	}

	mm_params := StorageMockGetValueParams{ctx, key}

	// Record call args
	mmGetValue.GetValueMock.mutex.Lock()
	mmGetValue.GetValueMock.callArgs = append(mmGetValue.GetValueMock.callArgs, &mm_params)
	mmGetValue.GetValueMock.mutex.Unlock()

	for _, e := range mmGetValue.GetValueMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetValue.GetValueMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetValue.GetValueMock.defaultExpectation.Counter, 1)
		mm_want := mmGetValue.GetValueMock.defaultExpectation.params
		mm_want_ptrs := mmGetValue.GetValueMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetValueParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetValue.t.Errorf("StorageMock.GetValue got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetValue.GetValueMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGetValue.t.Errorf("StorageMock.GetValue got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetValue.GetValueMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetValue.t.Errorf("StorageMock.GetValue got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetValue.GetValueMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetValue.GetValueMock.defaultExpectation.results
		if mm_results == nil {
			mmGetValue.t.Fatal("No results are set for the StorageMock.GetValue")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetValue.funcGetValue != nil {
		return mmGetValue.funcGetValue(ctx, key)
	}
	mmGetValue.t.Fatalf("Unexpected call to StorageMock.GetValue. %v %v", ctx, key)
	return
}

// GetValueAfterCounter returns a count of finished StorageMock.GetValue invocations
func (mmGetValue *StorageMock) GetValueAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetValue.afterGetValueCounter)
}

// GetValueBeforeCounter returns a count of StorageMock.GetValue invocations
func (mmGetValue *StorageMock) GetValueBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetValue.beforeGetValueCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetValue.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetValue *mStorageMockGetValue) Calls() []*StorageMockGetValueParams {
	mmGetValue.mutex.RLock()

	argCopy := make([]*StorageMockGetValueParams, len(mmGetValue.callArgs))
	copy(argCopy, mmGetValue.callArgs)

	mmGetValue.mutex.RUnlock()

	return argCopy
}

// MinimockGetValueDone returns true if the count of the GetValue invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetValueDone() bool {
	if m.GetValueMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetValueMock.invocationsDone()
}

// MinimockGetValueInspect logs each unmet expectation
func (m *StorageMock) MinimockGetValueInspect() {
	for _, e := range m.GetValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetValue at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetValueCounter := mm_atomic.LoadUint64(&m.afterGetValueCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetValueMock.defaultExpectation != nil && afterGetValueCounter < 1 {
		if m.GetValueMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetValue at\n%s", m.GetValueMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetValue at\n%s with params: %#v", m.GetValueMock.defaultExpectation.expectationOrigins.origin, *m.GetValueMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetValue != nil && afterGetValueCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetValue at\n%s", m.funcGetValueOrigin)
	}

	if !m.GetValueMock.invocationsDone() && afterGetValueCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetValue at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetValueMock.expectedInvocations), m.GetValueMock.expectedInvocationsOrigin, afterGetValueCounter)
	}
}

type mStorageMockSetValue struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockSetValueExpectation
	expectations       []*StorageMockSetValueExpectation

	callArgs []*StorageMockSetValueParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockSetValueExpectation specifies expectation struct of the Storage.SetValue
type StorageMockSetValueExpectation struct {
	mock               *StorageMock
	params             *StorageMockSetValueParams
	paramPtrs          *StorageMockSetValueParamPtrs
	expectationOrigins StorageMockSetValueExpectationOrigins
	results            *StorageMockSetValueResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockSetValueParams contains parameters of the Storage.SetValue
type StorageMockSetValueParams struct {
	ctx   context.Context
	key   Key
	value string
}

// StorageMockSetValueParamPtrs contains pointers to parameters of the Storage.SetValue
type StorageMockSetValueParamPtrs struct {
	ctx   *context.Context
	key   *Key
	value *string
}

// StorageMockSetValueResults contains results of the Storage.SetValue
type StorageMockSetValueResults struct {
	err error
}

// StorageMockSetValueOrigins contains origins of expectations of the Storage.SetValue
type StorageMockSetValueExpectationOrigins struct {
	origin      string
	originCtx   string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetValue *mStorageMockSetValue) Optional() *mStorageMockSetValue {
	mmSetValue.optional = true
	return mmSetValue
}

// Expect sets up expected params for Storage.SetValue
func (mmSetValue *mStorageMockSetValue) Expect(ctx context.Context, key Key, value string) *mStorageMockSetValue {
	if mmSetValue.mock.funcSetValue != nil {
		mmSetValue.mock.t.Fatalf("StorageMock.SetValue mock is already set by Set")
	}

	if mmSetValue.defaultExpectation == nil {
		mmSetValue.defaultExpectation = &StorageMockSetValueExpectation{}
	}

	if mmSetValue.defaultExpectation.paramPtrs != nil {
		mmSetValue.mock.t.Fatalf("StorageMock.SetValue mock is already set by ExpectParams functions")
	}

	mmSetValue.defaultExpectation.params = &StorageMockSetValueParams{ctx, key, value}
	mmSetValue.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetValue.expectations {
		if minimock.Equal(e.params, mmSetValue.defaultExpectation.params) {
			mmSetValue.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetValue.defaultExpectation.params)
		}
	}

	return mmSetValue
}

// ExpectCtxParam1 sets up expected param ctx for Storage.SetValue
func (mmSetValue *mStorageMockSetValue) ExpectCtxParam1(ctx context.Context) *mStorageMockSetValue {
	if mmSetValue.mock.funcSetValue != nil {
		mmSetValue.mock.t.Fatalf("StorageMock.SetValue mock is already set by Set")
	}

	if mmSetValue.defaultExpectation == nil {
		mmSetValue.defaultExpectation = &StorageMockSetValueExpectation{}
	}

	if mmSetValue.defaultExpectation.params != nil {
		mmSetValue.mock.t.Fatalf("StorageMock.SetValue mock is already set by Expect")
	}

	if mmSetValue.defaultExpectation.paramPtrs == nil {
		mmSetValue.defaultExpectation.paramPtrs = &StorageMockSetValueParamPtrs{}
	}
	mmSetValue.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetValue.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetValue
}

// ExpectKeyParam2 sets up expected param key for Storage.SetValue
func (mmSetValue *mStorageMockSetValue) ExpectKeyParam2(key Key) *mStorageMockSetValue {
	if mmSetValue.mock.funcSetValue != nil {
		mmSetValue.mock.t.Fatalf("StorageMock.SetValue mock is already set by Set")
	}

	if mmSetValue.defaultExpectation == nil {
		mmSetValue.defaultExpectation = &StorageMockSetValueExpectation{}
	}

	if mmSetValue.defaultExpectation.params != nil {
		mmSetValue.mock.t.Fatalf("StorageMock.SetValue mock is already set by Expect")
	}

	if mmSetValue.defaultExpectation.paramPtrs == nil {
		mmSetValue.defaultExpectation.paramPtrs = &StorageMockSetValueParamPtrs{}
	}
	mmSetValue.defaultExpectation.paramPtrs.key = &key
	mmSetValue.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSetValue
}

// ExpectValueParam3 sets up expected param value for Storage.SetValue
func (mmSetValue *mStorageMockSetValue) ExpectValueParam3(value string) *mStorageMockSetValue {
	if mmSetValue.mock.funcSetValue != nil {
		mmSetValue.mock.t.Fatalf("StorageMock.SetValue mock is already set by Set")
	}

	if mmSetValue.defaultExpectation == nil {
		mmSetValue.defaultExpectation = &StorageMockSetValueExpectation{}
	}

	if mmSetValue.defaultExpectation.params != nil {
		mmSetValue.mock.t.Fatalf("StorageMock.SetValue mock is already set by Expect")
	}

	if mmSetValue.defaultExpectation.paramPtrs == nil {
		mmSetValue.defaultExpectation.paramPtrs = &StorageMockSetValueParamPtrs{}
	}
	mmSetValue.defaultExpectation.paramPtrs.value = &value
	mmSetValue.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSetValue
}

// Inspect accepts an inspector function that has same arguments as the Storage.SetValue
func (mmSetValue *mStorageMockSetValue) Inspect(f func(ctx context.Context, key Key, value string)) *mStorageMockSetValue {
	if mmSetValue.mock.inspectFuncSetValue != nil {
		mmSetValue.mock.t.Fatalf("Inspect function is already set for StorageMock.SetValue")
	}

	mmSetValue.mock.inspectFuncSetValue = f

	return mmSetValue
}

// Return sets up results that will be returned by Storage.SetValue
func (mmSetValue *mStorageMockSetValue) Return(err error) *StorageMock {
	if mmSetValue.mock.funcSetValue != nil {
		mmSetValue.mock.t.Fatalf("StorageMock.SetValue mock is already set by Set")
	}

	if mmSetValue.defaultExpectation == nil {
		mmSetValue.defaultExpectation = &StorageMockSetValueExpectation{mock: mmSetValue.mock}
	}
	mmSetValue.defaultExpectation.results = &StorageMockSetValueResults{err}
	mmSetValue.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetValue.mock
}

// Set uses given function f to mock the Storage.SetValue method
func (mmSetValue *mStorageMockSetValue) Set(f func(ctx context.Context, key Key, value string) (err error)) *StorageMock {
	if mmSetValue.defaultExpectation != nil {
		mmSetValue.mock.t.Fatalf("Default expectation is already set for the Storage.SetValue method")
	}

	if len(mmSetValue.expectations) > 0 {
		mmSetValue.mock.t.Fatalf("Some expectations are already set for the Storage.SetValue method")
	}

	mmSetValue.mock.funcSetValue = f
	mmSetValue.mock.funcSetValueOrigin = minimock.CallerInfo(1)
	return mmSetValue.mock
}

// When sets expectation for the Storage.SetValue which will trigger the result defined by the following
// Then helper
func (mmSetValue *mStorageMockSetValue) When(ctx context.Context, key Key, value string) *StorageMockSetValueExpectation {
	if mmSetValue.mock.funcSetValue != nil {
		mmSetValue.mock.t.Fatalf("StorageMock.SetValue mock is already set by Set")
	}

	expectation := &StorageMockSetValueExpectation{
		mock:               mmSetValue.mock,
		params:             &StorageMockSetValueParams{ctx, key, value},
		expectationOrigins: StorageMockSetValueExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetValue.expectations = append(mmSetValue.expectations, expectation)
	return expectation
}

// Then sets up Storage.SetValue return parameters for the expectation previously defined by the When method
func (e *StorageMockSetValueExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockSetValueResults{err}
	return e.mock
}

// Times sets number of times Storage.SetValue should be invoked
func (mmSetValue *mStorageMockSetValue) Times(n uint64) *mStorageMockSetValue {
	if n == 0 {
		mmSetValue.mock.t.Fatalf("Times of StorageMock.SetValue mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetValue.expectedInvocations, n)
	mmSetValue.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetValue
}

func (mmSetValue *mStorageMockSetValue) invocationsDone() bool {
	if len(mmSetValue.expectations) == 0 && mmSetValue.defaultExpectation == nil && mmSetValue.mock.funcSetValue == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetValue.mock.afterSetValueCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetValue.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetValue implements Storage
func (mmSetValue *StorageMock) SetValue(ctx context.Context, key Key, value string) (err error) {
	mm_atomic.AddUint64(&mmSetValue.beforeSetValueCounter, 1)
	defer mm_atomic.AddUint64(&mmSetValue.afterSetValueCounter, 1)

	mmSetValue.t.Helper()

	if mmSetValue.inspectFuncSetValue != nil {
		mmSetValue.inspectFuncSetValue(ctx, key, value)
	}

	mm_params := StorageMockSetValueParams{ctx, key, value}

	// Record call args
	mmSetValue.SetValueMock.mutex.Lock()
	mmSetValue.SetValueMock.callArgs = append(mmSetValue.SetValueMock.callArgs, &mm_params)
	mmSetValue.SetValueMock.mutex.Unlock()

	for _, e := range mmSetValue.SetValueMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetValue.SetValueMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetValue.SetValueMock.defaultExpectation.Counter, 1)
		mm_want := mmSetValue.SetValueMock.defaultExpectation.params
		mm_want_ptrs := mmSetValue.SetValueMock.defaultExpectation.paramPtrs

		mm_got := StorageMockSetValueParams{ctx, key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetValue.t.Errorf("StorageMock.SetValue got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetValue.SetValueMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSetValue.t.Errorf("StorageMock.SetValue got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetValue.SetValueMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSetValue.t.Errorf("StorageMock.SetValue got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetValue.SetValueMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetValue.t.Errorf("StorageMock.SetValue got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetValue.SetValueMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetValue.SetValueMock.defaultExpectation.results
		if mm_results == nil {
			mmSetValue.t.Fatal("No results are set for the StorageMock.SetValue")
		}
		return (*mm_results).err
	}
	if mmSetValue.funcSetValue != nil {
		return mmSetValue.funcSetValue(ctx, key, value)
	}
	mmSetValue.t.Fatalf("Unexpected call to StorageMock.SetValue. %v %v %v", ctx, key, value)
	return
}

// SetValueAfterCounter returns a count of finished StorageMock.SetValue invocations
func (mmSetValue *StorageMock) SetValueAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetValue.afterSetValueCounter)
}

// SetValueBeforeCounter returns a count of StorageMock.SetValue invocations
func (mmSetValue *StorageMock) SetValueBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetValue.beforeSetValueCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SetValue.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetValue *mStorageMockSetValue) Calls() []*StorageMockSetValueParams {
	mmSetValue.mutex.RLock()

	argCopy := make([]*StorageMockSetValueParams, len(mmSetValue.callArgs))
	copy(argCopy, mmSetValue.callArgs)

	mmSetValue.mutex.RUnlock()

	return argCopy
}

// MinimockSetValueDone returns true if the count of the SetValue invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSetValueDone() bool {
	if m.SetValueMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetValueMock.invocationsDone()
}

// MinimockSetValueInspect logs each unmet expectation
func (m *StorageMock) MinimockSetValueInspect() {
	for _, e := range m.SetValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SetValue at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetValueCounter := mm_atomic.LoadUint64(&m.afterSetValueCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetValueMock.defaultExpectation != nil && afterSetValueCounter < 1 {
		if m.SetValueMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.SetValue at\n%s", m.SetValueMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.SetValue at\n%s with params: %#v", m.SetValueMock.defaultExpectation.expectationOrigins.origin, *m.SetValueMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetValue != nil && afterSetValueCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.SetValue at\n%s", m.funcSetValueOrigin)
	}

	if !m.SetValueMock.invocationsDone() && afterSetValueCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.SetValue at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetValueMock.expectedInvocations), m.SetValueMock.expectedInvocationsOrigin, afterSetValueCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetValueInspect()

			m.MinimockSetValueInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetValueDone() &&
		m.MinimockSetValueDone()
}
