// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package btt

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// InitializingComponentMock implements InitializingComponent
type InitializingComponentMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClear          func(ctx context.Context) (err error)
	funcClearOrigin    string
	inspectFuncClear   func(ctx context.Context)
	afterClearCounter  uint64
	beforeClearCounter uint64
	ClearMock          mInitializingComponentMockClear

	funcInitialize          func(ctx context.Context) (err error)
	funcInitializeOrigin    string
	inspectFuncInitialize   func(ctx context.Context)
	afterInitializeCounter  uint64
	beforeInitializeCounter uint64
	InitializeMock          mInitializingComponentMockInitialize
}

// NewInitializingComponentMock returns a mock for InitializingComponent
func NewInitializingComponentMock(t minimock.Tester) *InitializingComponentMock {
	m := &InitializingComponentMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ClearMock = mInitializingComponentMockClear{mock: m}
	m.ClearMock.callArgs = []*InitializingComponentMockClearParams{}

	m.InitializeMock = mInitializingComponentMockInitialize{mock: m}
	m.InitializeMock.callArgs = []*InitializingComponentMockInitializeParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mInitializingComponentMockClear struct {
	optional           bool
	mock               *InitializingComponentMock
	defaultExpectation *InitializingComponentMockClearExpectation
	expectations       []*InitializingComponentMockClearExpectation

	callArgs []*InitializingComponentMockClearParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// InitializingComponentMockClearExpectation specifies expectation struct of the InitializingComponent.Clear
type InitializingComponentMockClearExpectation struct {
	mock               *InitializingComponentMock
	params             *InitializingComponentMockClearParams
	paramPtrs          *InitializingComponentMockClearParamPtrs
	expectationOrigins InitializingComponentMockClearExpectationOrigins
	results            *InitializingComponentMockClearResults
	returnOrigin       string
	Counter            uint64
}

// InitializingComponentMockClearParams contains parameters of the InitializingComponent.Clear
type InitializingComponentMockClearParams struct {
	ctx context.Context
}

// InitializingComponentMockClearParamPtrs contains pointers to parameters of the InitializingComponent.Clear
type InitializingComponentMockClearParamPtrs struct {
	ctx *context.Context
}

// InitializingComponentMockClearResults contains results of the InitializingComponent.Clear
type InitializingComponentMockClearResults struct {
	err error
}

// InitializingComponentMockClearOrigins contains origins of expectations of the InitializingComponent.Clear
type InitializingComponentMockClearExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClear *mInitializingComponentMockClear) Optional() *mInitializingComponentMockClear {
	mmClear.optional = true
	return mmClear
}

// Expect sets up expected params for InitializingComponent.Clear
func (mmClear *mInitializingComponentMockClear) Expect(ctx context.Context) *mInitializingComponentMockClear {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("InitializingComponentMock.Clear mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &InitializingComponentMockClearExpectation{}
	}

	if mmClear.defaultExpectation.paramPtrs != nil {
		mmClear.mock.t.Fatalf("InitializingComponentMock.Clear mock is already set by ExpectParams functions")
	}

	mmClear.defaultExpectation.params = &InitializingComponentMockClearParams{ctx}
	mmClear.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClear.expectations {
		if minimock.Equal(e.params, mmClear.defaultExpectation.params) {
			mmClear.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClear.defaultExpectation.params)
		}
	}

	return mmClear
}

// ExpectCtxParam1 sets up expected param ctx for InitializingComponent.Clear
func (mmClear *mInitializingComponentMockClear) ExpectCtxParam1(ctx context.Context) *mInitializingComponentMockClear {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("InitializingComponentMock.Clear mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &InitializingComponentMockClearExpectation{}
	}

	if mmClear.defaultExpectation.params != nil {
		mmClear.mock.t.Fatalf("InitializingComponentMock.Clear mock is already set by Expect")
	}

	if mmClear.defaultExpectation.paramPtrs == nil {
		mmClear.defaultExpectation.paramPtrs = &InitializingComponentMockClearParamPtrs{}
	}
	mmClear.defaultExpectation.paramPtrs.ctx = &ctx
	mmClear.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmClear
}

// Inspect accepts an inspector function that has same arguments as the InitializingComponent.Clear
func (mmClear *mInitializingComponentMockClear) Inspect(f func(ctx context.Context)) *mInitializingComponentMockClear {
	if mmClear.mock.inspectFuncClear != nil {
		mmClear.mock.t.Fatalf("Inspect function is already set for InitializingComponentMock.Clear")
	}

	mmClear.mock.inspectFuncClear = f

	return mmClear
}

// Return sets up results that will be returned by InitializingComponent.Clear
func (mmClear *mInitializingComponentMockClear) Return(err error) *InitializingComponentMock {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("InitializingComponentMock.Clear mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &InitializingComponentMockClearExpectation{mock: mmClear.mock}
	}
	mmClear.defaultExpectation.results = &InitializingComponentMockClearResults{err}
	mmClear.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClear.mock
}

// Set uses given function f to mock the InitializingComponent.Clear method
func (mmClear *mInitializingComponentMockClear) Set(f func(ctx context.Context) (err error)) *InitializingComponentMock {
	if mmClear.defaultExpectation != nil {
		mmClear.mock.t.Fatalf("Default expectation is already set for the InitializingComponent.Clear method")
	}

	if len(mmClear.expectations) > 0 {
		mmClear.mock.t.Fatalf("Some expectations are already set for the InitializingComponent.Clear method")
	}

	mmClear.mock.funcClear = f
	mmClear.mock.funcClearOrigin = minimock.CallerInfo(1)
	return mmClear.mock
}

// When sets expectation for the InitializingComponent.Clear which will trigger the result defined by the following
// Then helper
func (mmClear *mInitializingComponentMockClear) When(ctx context.Context) *InitializingComponentMockClearExpectation {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("InitializingComponentMock.Clear mock is already set by Set")
	}

	expectation := &InitializingComponentMockClearExpectation{
		mock:               mmClear.mock,
		params:             &InitializingComponentMockClearParams{ctx},
		expectationOrigins: InitializingComponentMockClearExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClear.expectations = append(mmClear.expectations, expectation)
	return expectation
}

// Then sets up InitializingComponent.Clear return parameters for the expectation previously defined by the When method
func (e *InitializingComponentMockClearExpectation) Then(err error) *InitializingComponentMock {
	e.results = &InitializingComponentMockClearResults{err}
	return e.mock
}

// Times sets number of times InitializingComponent.Clear should be invoked
func (mmClear *mInitializingComponentMockClear) Times(n uint64) *mInitializingComponentMockClear {
	if n == 0 {
		mmClear.mock.t.Fatalf("Times of InitializingComponentMock.Clear mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClear.expectedInvocations, n)
	mmClear.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClear
}

func (mmClear *mInitializingComponentMockClear) invocationsDone() bool {
	if len(mmClear.expectations) == 0 && mmClear.defaultExpectation == nil && mmClear.mock.funcClear == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClear.mock.afterClearCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClear.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Clear implements InitializingComponent
func (mmClear *InitializingComponentMock) Clear(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmClear.beforeClearCounter, 1)
	defer mm_atomic.AddUint64(&mmClear.afterClearCounter, 1)

	mmClear.t.Helper()

	if mmClear.inspectFuncClear != nil {
		mmClear.inspectFuncClear(ctx)
	}

	mm_params := InitializingComponentMockClearParams{ctx}

	// Record call args
	mmClear.ClearMock.mutex.Lock()
	mmClear.ClearMock.callArgs = append(mmClear.ClearMock.callArgs, &mm_params)
	mmClear.ClearMock.mutex.Unlock()

	for _, e := range mmClear.ClearMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClear.ClearMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClear.ClearMock.defaultExpectation.Counter, 1)
		mm_want := mmClear.ClearMock.defaultExpectation.params
		mm_want_ptrs := mmClear.ClearMock.defaultExpectation.paramPtrs

		mm_got := InitializingComponentMockClearParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClear.t.Errorf("InitializingComponentMock.Clear got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClear.ClearMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClear.t.Errorf("InitializingComponentMock.Clear got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClear.ClearMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClear.ClearMock.defaultExpectation.results
		if mm_results == nil {
			mmClear.t.Fatal("No results are set for the InitializingComponentMock.Clear")
		}
		return (*mm_results).err
	}
	if mmClear.funcClear != nil {
		return mmClear.funcClear(ctx)
	}
	mmClear.t.Fatalf("Unexpected call to InitializingComponentMock.Clear. %v", ctx)
	return
}

// ClearAfterCounter returns a count of finished InitializingComponentMock.Clear invocations
func (mmClear *InitializingComponentMock) ClearAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClear.afterClearCounter)
}

// ClearBeforeCounter returns a count of InitializingComponentMock.Clear invocations
func (mmClear *InitializingComponentMock) ClearBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClear.beforeClearCounter)
}

// Calls returns a list of arguments used in each call to InitializingComponentMock.Clear.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClear *mInitializingComponentMockClear) Calls() []*InitializingComponentMockClearParams {
	mmClear.mutex.RLock()

	argCopy := make([]*InitializingComponentMockClearParams, len(mmClear.callArgs))
	copy(argCopy, mmClear.callArgs)

	mmClear.mutex.RUnlock()

	return argCopy
}

// MinimockClearDone returns true if the count of the Clear invocations corresponds
// the number of defined expectations
func (m *InitializingComponentMock) MinimockClearDone() bool {
	if m.ClearMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearMock.invocationsDone()
}

// MinimockClearInspect logs each unmet expectation
func (m *InitializingComponentMock) MinimockClearInspect() {
	for _, e := range m.ClearMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializingComponentMock.Clear at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClearCounter := mm_atomic.LoadUint64(&m.afterClearCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearMock.defaultExpectation != nil && afterClearCounter < 1 {
		if m.ClearMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to InitializingComponentMock.Clear at\n%s", m.ClearMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to InitializingComponentMock.Clear at\n%s with params: %#v", m.ClearMock.defaultExpectation.expectationOrigins.origin, *m.ClearMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClear != nil && afterClearCounter < 1 {
		m.t.Errorf("Expected call to InitializingComponentMock.Clear at\n%s", m.funcClearOrigin)
	}

	if !m.ClearMock.invocationsDone() && afterClearCounter > 0 {
		m.t.Errorf("Expected %d calls to InitializingComponentMock.Clear at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearMock.expectedInvocations), m.ClearMock.expectedInvocationsOrigin, afterClearCounter)
	}
}

type mInitializingComponentMockInitialize struct {
	optional           bool
	mock               *InitializingComponentMock
	defaultExpectation *InitializingComponentMockInitializeExpectation
	expectations       []*InitializingComponentMockInitializeExpectation

	callArgs []*InitializingComponentMockInitializeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// InitializingComponentMockInitializeExpectation specifies expectation struct of the InitializingComponent.Initialize
type InitializingComponentMockInitializeExpectation struct {
	mock               *InitializingComponentMock
	params             *InitializingComponentMockInitializeParams
	paramPtrs          *InitializingComponentMockInitializeParamPtrs
	expectationOrigins InitializingComponentMockInitializeExpectationOrigins
	results            *InitializingComponentMockInitializeResults
	returnOrigin       string
	Counter            uint64
}

// InitializingComponentMockInitializeParams contains parameters of the InitializingComponent.Initialize
type InitializingComponentMockInitializeParams struct {
	ctx context.Context
}

// InitializingComponentMockInitializeParamPtrs contains pointers to parameters of the InitializingComponent.Initialize
type InitializingComponentMockInitializeParamPtrs struct {
	ctx *context.Context
}

// InitializingComponentMockInitializeResults contains results of the InitializingComponent.Initialize
type InitializingComponentMockInitializeResults struct {
	err error
}

// InitializingComponentMockInitializeOrigins contains origins of expectations of the InitializingComponent.Initialize
type InitializingComponentMockInitializeExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInitialize *mInitializingComponentMockInitialize) Optional() *mInitializingComponentMockInitialize {
	mmInitialize.optional = true
	return mmInitialize
}

// Expect sets up expected params for InitializingComponent.Initialize
func (mmInitialize *mInitializingComponentMockInitialize) Expect(ctx context.Context) *mInitializingComponentMockInitialize {
	if mmInitialize.mock.funcInitialize != nil {
		mmInitialize.mock.t.Fatalf("InitializingComponentMock.Initialize mock is already set by Set")
	}

	if mmInitialize.defaultExpectation == nil {
		mmInitialize.defaultExpectation = &InitializingComponentMockInitializeExpectation{}
	}

	if mmInitialize.defaultExpectation.paramPtrs != nil {
		mmInitialize.mock.t.Fatalf("InitializingComponentMock.Initialize mock is already set by ExpectParams functions")
	}

	mmInitialize.defaultExpectation.params = &InitializingComponentMockInitializeParams{ctx}
	mmInitialize.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInitialize.expectations {
		if minimock.Equal(e.params, mmInitialize.defaultExpectation.params) {
			mmInitialize.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInitialize.defaultExpectation.params)
		}
	}

	return mmInitialize
}

// ExpectCtxParam1 sets up expected param ctx for InitializingComponent.Initialize
func (mmInitialize *mInitializingComponentMockInitialize) ExpectCtxParam1(ctx context.Context) *mInitializingComponentMockInitialize {
	if mmInitialize.mock.funcInitialize != nil {
		mmInitialize.mock.t.Fatalf("InitializingComponentMock.Initialize mock is already set by Set")
	}

	if mmInitialize.defaultExpectation == nil {
		mmInitialize.defaultExpectation = &InitializingComponentMockInitializeExpectation{}
	}

	if mmInitialize.defaultExpectation.params != nil {
		mmInitialize.mock.t.Fatalf("InitializingComponentMock.Initialize mock is already set by Expect")
	}

	if mmInitialize.defaultExpectation.paramPtrs == nil {
		mmInitialize.defaultExpectation.paramPtrs = &InitializingComponentMockInitializeParamPtrs{}
	}
	mmInitialize.defaultExpectation.paramPtrs.ctx = &ctx
	mmInitialize.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInitialize
}

// Inspect accepts an inspector function that has same arguments as the InitializingComponent.Initialize
func (mmInitialize *mInitializingComponentMockInitialize) Inspect(f func(ctx context.Context)) *mInitializingComponentMockInitialize {
	if mmInitialize.mock.inspectFuncInitialize != nil {
		mmInitialize.mock.t.Fatalf("Inspect function is already set for InitializingComponentMock.Initialize")
	}

	mmInitialize.mock.inspectFuncInitialize = f

	return mmInitialize
}

// Return sets up results that will be returned by InitializingComponent.Initialize
func (mmInitialize *mInitializingComponentMockInitialize) Return(err error) *InitializingComponentMock {
	if mmInitialize.mock.funcInitialize != nil {
		mmInitialize.mock.t.Fatalf("InitializingComponentMock.Initialize mock is already set by Set")
	}

	if mmInitialize.defaultExpectation == nil {
		mmInitialize.defaultExpectation = &InitializingComponentMockInitializeExpectation{mock: mmInitialize.mock}
	}
	mmInitialize.defaultExpectation.results = &InitializingComponentMockInitializeResults{err}
	mmInitialize.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInitialize.mock
}

// Set uses given function f to mock the InitializingComponent.Initialize method
func (mmInitialize *mInitializingComponentMockInitialize) Set(f func(ctx context.Context) (err error)) *InitializingComponentMock {
	if mmInitialize.defaultExpectation != nil {
		mmInitialize.mock.t.Fatalf("Default expectation is already set for the InitializingComponent.Initialize method")
	}

	if len(mmInitialize.expectations) > 0 {
		mmInitialize.mock.t.Fatalf("Some expectations are already set for the InitializingComponent.Initialize method")
	}

	mmInitialize.mock.funcInitialize = f
	mmInitialize.mock.funcInitializeOrigin = minimock.CallerInfo(1)
	return mmInitialize.mock
}

// When sets expectation for the InitializingComponent.Initialize which will trigger the result defined by the following
// Then helper
func (mmInitialize *mInitializingComponentMockInitialize) When(ctx context.Context) *InitializingComponentMockInitializeExpectation {
	if mmInitialize.mock.funcInitialize != nil {
		mmInitialize.mock.t.Fatalf("InitializingComponentMock.Initialize mock is already set by Set")
	}

	expectation := &InitializingComponentMockInitializeExpectation{
		mock:               mmInitialize.mock,
		params:             &InitializingComponentMockInitializeParams{ctx},
		expectationOrigins: InitializingComponentMockInitializeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInitialize.expectations = append(mmInitialize.expectations, expectation)
	return expectation
}

// Then sets up InitializingComponent.Initialize return parameters for the expectation previously defined by the When method
func (e *InitializingComponentMockInitializeExpectation) Then(err error) *InitializingComponentMock {
	e.results = &InitializingComponentMockInitializeResults{err}
	return e.mock
}

// Times sets number of times InitializingComponent.Initialize should be invoked
func (mmInitialize *mInitializingComponentMockInitialize) Times(n uint64) *mInitializingComponentMockInitialize {
	if n == 0 {
		mmInitialize.mock.t.Fatalf("Times of InitializingComponentMock.Initialize mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInitialize.expectedInvocations, n)
	mmInitialize.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInitialize
}

func (mmInitialize *mInitializingComponentMockInitialize) invocationsDone() bool {
	if len(mmInitialize.expectations) == 0 && mmInitialize.defaultExpectation == nil && mmInitialize.mock.funcInitialize == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInitialize.mock.afterInitializeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInitialize.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Initialize implements InitializingComponent
func (mmInitialize *InitializingComponentMock) Initialize(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmInitialize.beforeInitializeCounter, 1)
	defer mm_atomic.AddUint64(&mmInitialize.afterInitializeCounter, 1)

	mmInitialize.t.Helper()

	if mmInitialize.inspectFuncInitialize != nil {
		mmInitialize.inspectFuncInitialize(ctx)
	}

	mm_params := InitializingComponentMockInitializeParams{ctx}

	// Record call args
	mmInitialize.InitializeMock.mutex.Lock()
	mmInitialize.InitializeMock.callArgs = append(mmInitialize.InitializeMock.callArgs, &mm_params)
	mmInitialize.InitializeMock.mutex.Unlock()

	for _, e := range mmInitialize.InitializeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInitialize.InitializeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInitialize.InitializeMock.defaultExpectation.Counter, 1)
		mm_want := mmInitialize.InitializeMock.defaultExpectation.params
		mm_want_ptrs := mmInitialize.InitializeMock.defaultExpectation.paramPtrs

		mm_got := InitializingComponentMockInitializeParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInitialize.t.Errorf("InitializingComponentMock.Initialize got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInitialize.InitializeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInitialize.t.Errorf("InitializingComponentMock.Initialize got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInitialize.InitializeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInitialize.InitializeMock.defaultExpectation.results
		if mm_results == nil {
			mmInitialize.t.Fatal("No results are set for the InitializingComponentMock.Initialize")
		}
		return (*mm_results).err
	}
	if mmInitialize.funcInitialize != nil {
		return mmInitialize.funcInitialize(ctx)
	}
	mmInitialize.t.Fatalf("Unexpected call to InitializingComponentMock.Initialize. %v", ctx)
	return
}

// InitializeAfterCounter returns a count of finished InitializingComponentMock.Initialize invocations
func (mmInitialize *InitializingComponentMock) InitializeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitialize.afterInitializeCounter)
}

// InitializeBeforeCounter returns a count of InitializingComponentMock.Initialize invocations
func (mmInitialize *InitializingComponentMock) InitializeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitialize.beforeInitializeCounter)
}

// Calls returns a list of arguments used in each call to InitializingComponentMock.Initialize.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInitialize *mInitializingComponentMockInitialize) Calls() []*InitializingComponentMockInitializeParams {
	mmInitialize.mutex.RLock()

	argCopy := make([]*InitializingComponentMockInitializeParams, len(mmInitialize.callArgs))
	copy(argCopy, mmInitialize.callArgs)

	mmInitialize.mutex.RUnlock()

	return argCopy
}

// MinimockInitializeDone returns true if the count of the Initialize invocations corresponds
// the number of defined expectations
func (m *InitializingComponentMock) MinimockInitializeDone() bool {
	if m.InitializeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InitializeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InitializeMock.invocationsDone()
}

// MinimockInitializeInspect logs each unmet expectation
func (m *InitializingComponentMock) MinimockInitializeInspect() {
	for _, e := range m.InitializeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializingComponentMock.Initialize at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInitializeCounter := mm_atomic.LoadUint64(&m.afterInitializeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InitializeMock.defaultExpectation != nil && afterInitializeCounter < 1 {
		if m.InitializeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to InitializingComponentMock.Initialize at\n%s", m.InitializeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to InitializingComponentMock.Initialize at\n%s with params: %#v", m.InitializeMock.defaultExpectation.expectationOrigins.origin, *m.InitializeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitialize != nil && afterInitializeCounter < 1 {
		m.t.Errorf("Expected call to InitializingComponentMock.Initialize at\n%s", m.funcInitializeOrigin)
	}

	if !m.InitializeMock.invocationsDone() && afterInitializeCounter > 0 {
		m.t.Errorf("Expected %d calls to InitializingComponentMock.Initialize at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InitializeMock.expectedInvocations), m.InitializeMock.expectedInvocationsOrigin, afterInitializeCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *InitializingComponentMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockClearInspect()

			m.MinimockInitializeInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *InitializingComponentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *InitializingComponentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockClearDone() &&
		m.MinimockInitializeDone()
}
