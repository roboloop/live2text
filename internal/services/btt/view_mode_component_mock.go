// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package btt

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ViewModeComponentMock implements ViewModeComponent
type ViewModeComponentMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDisableCleanView          func(ctx context.Context) (err error)
	funcDisableCleanViewOrigin    string
	inspectFuncDisableCleanView   func(ctx context.Context)
	afterDisableCleanViewCounter  uint64
	beforeDisableCleanViewCounter uint64
	DisableCleanViewMock          mViewModeComponentMockDisableCleanView

	funcEnableCleanMode          func(ctx context.Context) (err error)
	funcEnableCleanModeOrigin    string
	inspectFuncEnableCleanMode   func(ctx context.Context)
	afterEnableCleanModeCounter  uint64
	beforeEnableCleanModeCounter uint64
	EnableCleanModeMock          mViewModeComponentMockEnableCleanMode

	funcSelectViewMode          func(ctx context.Context, viewMode ViewMode) (err error)
	funcSelectViewModeOrigin    string
	inspectFuncSelectViewMode   func(ctx context.Context, viewMode ViewMode)
	afterSelectViewModeCounter  uint64
	beforeSelectViewModeCounter uint64
	SelectViewModeMock          mViewModeComponentMockSelectViewMode

	funcSelectedViewMode          func(ctx context.Context) (v1 ViewMode, err error)
	funcSelectedViewModeOrigin    string
	inspectFuncSelectedViewMode   func(ctx context.Context)
	afterSelectedViewModeCounter  uint64
	beforeSelectedViewModeCounter uint64
	SelectedViewModeMock          mViewModeComponentMockSelectedViewMode
}

// NewViewModeComponentMock returns a mock for ViewModeComponent
func NewViewModeComponentMock(t minimock.Tester) *ViewModeComponentMock {
	m := &ViewModeComponentMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DisableCleanViewMock = mViewModeComponentMockDisableCleanView{mock: m}
	m.DisableCleanViewMock.callArgs = []*ViewModeComponentMockDisableCleanViewParams{}

	m.EnableCleanModeMock = mViewModeComponentMockEnableCleanMode{mock: m}
	m.EnableCleanModeMock.callArgs = []*ViewModeComponentMockEnableCleanModeParams{}

	m.SelectViewModeMock = mViewModeComponentMockSelectViewMode{mock: m}
	m.SelectViewModeMock.callArgs = []*ViewModeComponentMockSelectViewModeParams{}

	m.SelectedViewModeMock = mViewModeComponentMockSelectedViewMode{mock: m}
	m.SelectedViewModeMock.callArgs = []*ViewModeComponentMockSelectedViewModeParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mViewModeComponentMockDisableCleanView struct {
	optional           bool
	mock               *ViewModeComponentMock
	defaultExpectation *ViewModeComponentMockDisableCleanViewExpectation
	expectations       []*ViewModeComponentMockDisableCleanViewExpectation

	callArgs []*ViewModeComponentMockDisableCleanViewParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ViewModeComponentMockDisableCleanViewExpectation specifies expectation struct of the ViewModeComponent.DisableCleanView
type ViewModeComponentMockDisableCleanViewExpectation struct {
	mock               *ViewModeComponentMock
	params             *ViewModeComponentMockDisableCleanViewParams
	paramPtrs          *ViewModeComponentMockDisableCleanViewParamPtrs
	expectationOrigins ViewModeComponentMockDisableCleanViewExpectationOrigins
	results            *ViewModeComponentMockDisableCleanViewResults
	returnOrigin       string
	Counter            uint64
}

// ViewModeComponentMockDisableCleanViewParams contains parameters of the ViewModeComponent.DisableCleanView
type ViewModeComponentMockDisableCleanViewParams struct {
	ctx context.Context
}

// ViewModeComponentMockDisableCleanViewParamPtrs contains pointers to parameters of the ViewModeComponent.DisableCleanView
type ViewModeComponentMockDisableCleanViewParamPtrs struct {
	ctx *context.Context
}

// ViewModeComponentMockDisableCleanViewResults contains results of the ViewModeComponent.DisableCleanView
type ViewModeComponentMockDisableCleanViewResults struct {
	err error
}

// ViewModeComponentMockDisableCleanViewOrigins contains origins of expectations of the ViewModeComponent.DisableCleanView
type ViewModeComponentMockDisableCleanViewExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDisableCleanView *mViewModeComponentMockDisableCleanView) Optional() *mViewModeComponentMockDisableCleanView {
	mmDisableCleanView.optional = true
	return mmDisableCleanView
}

// Expect sets up expected params for ViewModeComponent.DisableCleanView
func (mmDisableCleanView *mViewModeComponentMockDisableCleanView) Expect(ctx context.Context) *mViewModeComponentMockDisableCleanView {
	if mmDisableCleanView.mock.funcDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("ViewModeComponentMock.DisableCleanView mock is already set by Set")
	}

	if mmDisableCleanView.defaultExpectation == nil {
		mmDisableCleanView.defaultExpectation = &ViewModeComponentMockDisableCleanViewExpectation{}
	}

	if mmDisableCleanView.defaultExpectation.paramPtrs != nil {
		mmDisableCleanView.mock.t.Fatalf("ViewModeComponentMock.DisableCleanView mock is already set by ExpectParams functions")
	}

	mmDisableCleanView.defaultExpectation.params = &ViewModeComponentMockDisableCleanViewParams{ctx}
	mmDisableCleanView.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDisableCleanView.expectations {
		if minimock.Equal(e.params, mmDisableCleanView.defaultExpectation.params) {
			mmDisableCleanView.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDisableCleanView.defaultExpectation.params)
		}
	}

	return mmDisableCleanView
}

// ExpectCtxParam1 sets up expected param ctx for ViewModeComponent.DisableCleanView
func (mmDisableCleanView *mViewModeComponentMockDisableCleanView) ExpectCtxParam1(ctx context.Context) *mViewModeComponentMockDisableCleanView {
	if mmDisableCleanView.mock.funcDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("ViewModeComponentMock.DisableCleanView mock is already set by Set")
	}

	if mmDisableCleanView.defaultExpectation == nil {
		mmDisableCleanView.defaultExpectation = &ViewModeComponentMockDisableCleanViewExpectation{}
	}

	if mmDisableCleanView.defaultExpectation.params != nil {
		mmDisableCleanView.mock.t.Fatalf("ViewModeComponentMock.DisableCleanView mock is already set by Expect")
	}

	if mmDisableCleanView.defaultExpectation.paramPtrs == nil {
		mmDisableCleanView.defaultExpectation.paramPtrs = &ViewModeComponentMockDisableCleanViewParamPtrs{}
	}
	mmDisableCleanView.defaultExpectation.paramPtrs.ctx = &ctx
	mmDisableCleanView.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDisableCleanView
}

// Inspect accepts an inspector function that has same arguments as the ViewModeComponent.DisableCleanView
func (mmDisableCleanView *mViewModeComponentMockDisableCleanView) Inspect(f func(ctx context.Context)) *mViewModeComponentMockDisableCleanView {
	if mmDisableCleanView.mock.inspectFuncDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("Inspect function is already set for ViewModeComponentMock.DisableCleanView")
	}

	mmDisableCleanView.mock.inspectFuncDisableCleanView = f

	return mmDisableCleanView
}

// Return sets up results that will be returned by ViewModeComponent.DisableCleanView
func (mmDisableCleanView *mViewModeComponentMockDisableCleanView) Return(err error) *ViewModeComponentMock {
	if mmDisableCleanView.mock.funcDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("ViewModeComponentMock.DisableCleanView mock is already set by Set")
	}

	if mmDisableCleanView.defaultExpectation == nil {
		mmDisableCleanView.defaultExpectation = &ViewModeComponentMockDisableCleanViewExpectation{mock: mmDisableCleanView.mock}
	}
	mmDisableCleanView.defaultExpectation.results = &ViewModeComponentMockDisableCleanViewResults{err}
	mmDisableCleanView.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDisableCleanView.mock
}

// Set uses given function f to mock the ViewModeComponent.DisableCleanView method
func (mmDisableCleanView *mViewModeComponentMockDisableCleanView) Set(f func(ctx context.Context) (err error)) *ViewModeComponentMock {
	if mmDisableCleanView.defaultExpectation != nil {
		mmDisableCleanView.mock.t.Fatalf("Default expectation is already set for the ViewModeComponent.DisableCleanView method")
	}

	if len(mmDisableCleanView.expectations) > 0 {
		mmDisableCleanView.mock.t.Fatalf("Some expectations are already set for the ViewModeComponent.DisableCleanView method")
	}

	mmDisableCleanView.mock.funcDisableCleanView = f
	mmDisableCleanView.mock.funcDisableCleanViewOrigin = minimock.CallerInfo(1)
	return mmDisableCleanView.mock
}

// When sets expectation for the ViewModeComponent.DisableCleanView which will trigger the result defined by the following
// Then helper
func (mmDisableCleanView *mViewModeComponentMockDisableCleanView) When(ctx context.Context) *ViewModeComponentMockDisableCleanViewExpectation {
	if mmDisableCleanView.mock.funcDisableCleanView != nil {
		mmDisableCleanView.mock.t.Fatalf("ViewModeComponentMock.DisableCleanView mock is already set by Set")
	}

	expectation := &ViewModeComponentMockDisableCleanViewExpectation{
		mock:               mmDisableCleanView.mock,
		params:             &ViewModeComponentMockDisableCleanViewParams{ctx},
		expectationOrigins: ViewModeComponentMockDisableCleanViewExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDisableCleanView.expectations = append(mmDisableCleanView.expectations, expectation)
	return expectation
}

// Then sets up ViewModeComponent.DisableCleanView return parameters for the expectation previously defined by the When method
func (e *ViewModeComponentMockDisableCleanViewExpectation) Then(err error) *ViewModeComponentMock {
	e.results = &ViewModeComponentMockDisableCleanViewResults{err}
	return e.mock
}

// Times sets number of times ViewModeComponent.DisableCleanView should be invoked
func (mmDisableCleanView *mViewModeComponentMockDisableCleanView) Times(n uint64) *mViewModeComponentMockDisableCleanView {
	if n == 0 {
		mmDisableCleanView.mock.t.Fatalf("Times of ViewModeComponentMock.DisableCleanView mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDisableCleanView.expectedInvocations, n)
	mmDisableCleanView.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDisableCleanView
}

func (mmDisableCleanView *mViewModeComponentMockDisableCleanView) invocationsDone() bool {
	if len(mmDisableCleanView.expectations) == 0 && mmDisableCleanView.defaultExpectation == nil && mmDisableCleanView.mock.funcDisableCleanView == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDisableCleanView.mock.afterDisableCleanViewCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDisableCleanView.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DisableCleanView implements ViewModeComponent
func (mmDisableCleanView *ViewModeComponentMock) DisableCleanView(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmDisableCleanView.beforeDisableCleanViewCounter, 1)
	defer mm_atomic.AddUint64(&mmDisableCleanView.afterDisableCleanViewCounter, 1)

	mmDisableCleanView.t.Helper()

	if mmDisableCleanView.inspectFuncDisableCleanView != nil {
		mmDisableCleanView.inspectFuncDisableCleanView(ctx)
	}

	mm_params := ViewModeComponentMockDisableCleanViewParams{ctx}

	// Record call args
	mmDisableCleanView.DisableCleanViewMock.mutex.Lock()
	mmDisableCleanView.DisableCleanViewMock.callArgs = append(mmDisableCleanView.DisableCleanViewMock.callArgs, &mm_params)
	mmDisableCleanView.DisableCleanViewMock.mutex.Unlock()

	for _, e := range mmDisableCleanView.DisableCleanViewMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDisableCleanView.DisableCleanViewMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDisableCleanView.DisableCleanViewMock.defaultExpectation.Counter, 1)
		mm_want := mmDisableCleanView.DisableCleanViewMock.defaultExpectation.params
		mm_want_ptrs := mmDisableCleanView.DisableCleanViewMock.defaultExpectation.paramPtrs

		mm_got := ViewModeComponentMockDisableCleanViewParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDisableCleanView.t.Errorf("ViewModeComponentMock.DisableCleanView got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDisableCleanView.DisableCleanViewMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDisableCleanView.t.Errorf("ViewModeComponentMock.DisableCleanView got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDisableCleanView.DisableCleanViewMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDisableCleanView.DisableCleanViewMock.defaultExpectation.results
		if mm_results == nil {
			mmDisableCleanView.t.Fatal("No results are set for the ViewModeComponentMock.DisableCleanView")
		}
		return (*mm_results).err
	}
	if mmDisableCleanView.funcDisableCleanView != nil {
		return mmDisableCleanView.funcDisableCleanView(ctx)
	}
	mmDisableCleanView.t.Fatalf("Unexpected call to ViewModeComponentMock.DisableCleanView. %v", ctx)
	return
}

// DisableCleanViewAfterCounter returns a count of finished ViewModeComponentMock.DisableCleanView invocations
func (mmDisableCleanView *ViewModeComponentMock) DisableCleanViewAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDisableCleanView.afterDisableCleanViewCounter)
}

// DisableCleanViewBeforeCounter returns a count of ViewModeComponentMock.DisableCleanView invocations
func (mmDisableCleanView *ViewModeComponentMock) DisableCleanViewBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDisableCleanView.beforeDisableCleanViewCounter)
}

// Calls returns a list of arguments used in each call to ViewModeComponentMock.DisableCleanView.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDisableCleanView *mViewModeComponentMockDisableCleanView) Calls() []*ViewModeComponentMockDisableCleanViewParams {
	mmDisableCleanView.mutex.RLock()

	argCopy := make([]*ViewModeComponentMockDisableCleanViewParams, len(mmDisableCleanView.callArgs))
	copy(argCopy, mmDisableCleanView.callArgs)

	mmDisableCleanView.mutex.RUnlock()

	return argCopy
}

// MinimockDisableCleanViewDone returns true if the count of the DisableCleanView invocations corresponds
// the number of defined expectations
func (m *ViewModeComponentMock) MinimockDisableCleanViewDone() bool {
	if m.DisableCleanViewMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DisableCleanViewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DisableCleanViewMock.invocationsDone()
}

// MinimockDisableCleanViewInspect logs each unmet expectation
func (m *ViewModeComponentMock) MinimockDisableCleanViewInspect() {
	for _, e := range m.DisableCleanViewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ViewModeComponentMock.DisableCleanView at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDisableCleanViewCounter := mm_atomic.LoadUint64(&m.afterDisableCleanViewCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DisableCleanViewMock.defaultExpectation != nil && afterDisableCleanViewCounter < 1 {
		if m.DisableCleanViewMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ViewModeComponentMock.DisableCleanView at\n%s", m.DisableCleanViewMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ViewModeComponentMock.DisableCleanView at\n%s with params: %#v", m.DisableCleanViewMock.defaultExpectation.expectationOrigins.origin, *m.DisableCleanViewMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDisableCleanView != nil && afterDisableCleanViewCounter < 1 {
		m.t.Errorf("Expected call to ViewModeComponentMock.DisableCleanView at\n%s", m.funcDisableCleanViewOrigin)
	}

	if !m.DisableCleanViewMock.invocationsDone() && afterDisableCleanViewCounter > 0 {
		m.t.Errorf("Expected %d calls to ViewModeComponentMock.DisableCleanView at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DisableCleanViewMock.expectedInvocations), m.DisableCleanViewMock.expectedInvocationsOrigin, afterDisableCleanViewCounter)
	}
}

type mViewModeComponentMockEnableCleanMode struct {
	optional           bool
	mock               *ViewModeComponentMock
	defaultExpectation *ViewModeComponentMockEnableCleanModeExpectation
	expectations       []*ViewModeComponentMockEnableCleanModeExpectation

	callArgs []*ViewModeComponentMockEnableCleanModeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ViewModeComponentMockEnableCleanModeExpectation specifies expectation struct of the ViewModeComponent.EnableCleanMode
type ViewModeComponentMockEnableCleanModeExpectation struct {
	mock               *ViewModeComponentMock
	params             *ViewModeComponentMockEnableCleanModeParams
	paramPtrs          *ViewModeComponentMockEnableCleanModeParamPtrs
	expectationOrigins ViewModeComponentMockEnableCleanModeExpectationOrigins
	results            *ViewModeComponentMockEnableCleanModeResults
	returnOrigin       string
	Counter            uint64
}

// ViewModeComponentMockEnableCleanModeParams contains parameters of the ViewModeComponent.EnableCleanMode
type ViewModeComponentMockEnableCleanModeParams struct {
	ctx context.Context
}

// ViewModeComponentMockEnableCleanModeParamPtrs contains pointers to parameters of the ViewModeComponent.EnableCleanMode
type ViewModeComponentMockEnableCleanModeParamPtrs struct {
	ctx *context.Context
}

// ViewModeComponentMockEnableCleanModeResults contains results of the ViewModeComponent.EnableCleanMode
type ViewModeComponentMockEnableCleanModeResults struct {
	err error
}

// ViewModeComponentMockEnableCleanModeOrigins contains origins of expectations of the ViewModeComponent.EnableCleanMode
type ViewModeComponentMockEnableCleanModeExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEnableCleanMode *mViewModeComponentMockEnableCleanMode) Optional() *mViewModeComponentMockEnableCleanMode {
	mmEnableCleanMode.optional = true
	return mmEnableCleanMode
}

// Expect sets up expected params for ViewModeComponent.EnableCleanMode
func (mmEnableCleanMode *mViewModeComponentMockEnableCleanMode) Expect(ctx context.Context) *mViewModeComponentMockEnableCleanMode {
	if mmEnableCleanMode.mock.funcEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("ViewModeComponentMock.EnableCleanMode mock is already set by Set")
	}

	if mmEnableCleanMode.defaultExpectation == nil {
		mmEnableCleanMode.defaultExpectation = &ViewModeComponentMockEnableCleanModeExpectation{}
	}

	if mmEnableCleanMode.defaultExpectation.paramPtrs != nil {
		mmEnableCleanMode.mock.t.Fatalf("ViewModeComponentMock.EnableCleanMode mock is already set by ExpectParams functions")
	}

	mmEnableCleanMode.defaultExpectation.params = &ViewModeComponentMockEnableCleanModeParams{ctx}
	mmEnableCleanMode.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEnableCleanMode.expectations {
		if minimock.Equal(e.params, mmEnableCleanMode.defaultExpectation.params) {
			mmEnableCleanMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEnableCleanMode.defaultExpectation.params)
		}
	}

	return mmEnableCleanMode
}

// ExpectCtxParam1 sets up expected param ctx for ViewModeComponent.EnableCleanMode
func (mmEnableCleanMode *mViewModeComponentMockEnableCleanMode) ExpectCtxParam1(ctx context.Context) *mViewModeComponentMockEnableCleanMode {
	if mmEnableCleanMode.mock.funcEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("ViewModeComponentMock.EnableCleanMode mock is already set by Set")
	}

	if mmEnableCleanMode.defaultExpectation == nil {
		mmEnableCleanMode.defaultExpectation = &ViewModeComponentMockEnableCleanModeExpectation{}
	}

	if mmEnableCleanMode.defaultExpectation.params != nil {
		mmEnableCleanMode.mock.t.Fatalf("ViewModeComponentMock.EnableCleanMode mock is already set by Expect")
	}

	if mmEnableCleanMode.defaultExpectation.paramPtrs == nil {
		mmEnableCleanMode.defaultExpectation.paramPtrs = &ViewModeComponentMockEnableCleanModeParamPtrs{}
	}
	mmEnableCleanMode.defaultExpectation.paramPtrs.ctx = &ctx
	mmEnableCleanMode.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEnableCleanMode
}

// Inspect accepts an inspector function that has same arguments as the ViewModeComponent.EnableCleanMode
func (mmEnableCleanMode *mViewModeComponentMockEnableCleanMode) Inspect(f func(ctx context.Context)) *mViewModeComponentMockEnableCleanMode {
	if mmEnableCleanMode.mock.inspectFuncEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("Inspect function is already set for ViewModeComponentMock.EnableCleanMode")
	}

	mmEnableCleanMode.mock.inspectFuncEnableCleanMode = f

	return mmEnableCleanMode
}

// Return sets up results that will be returned by ViewModeComponent.EnableCleanMode
func (mmEnableCleanMode *mViewModeComponentMockEnableCleanMode) Return(err error) *ViewModeComponentMock {
	if mmEnableCleanMode.mock.funcEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("ViewModeComponentMock.EnableCleanMode mock is already set by Set")
	}

	if mmEnableCleanMode.defaultExpectation == nil {
		mmEnableCleanMode.defaultExpectation = &ViewModeComponentMockEnableCleanModeExpectation{mock: mmEnableCleanMode.mock}
	}
	mmEnableCleanMode.defaultExpectation.results = &ViewModeComponentMockEnableCleanModeResults{err}
	mmEnableCleanMode.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEnableCleanMode.mock
}

// Set uses given function f to mock the ViewModeComponent.EnableCleanMode method
func (mmEnableCleanMode *mViewModeComponentMockEnableCleanMode) Set(f func(ctx context.Context) (err error)) *ViewModeComponentMock {
	if mmEnableCleanMode.defaultExpectation != nil {
		mmEnableCleanMode.mock.t.Fatalf("Default expectation is already set for the ViewModeComponent.EnableCleanMode method")
	}

	if len(mmEnableCleanMode.expectations) > 0 {
		mmEnableCleanMode.mock.t.Fatalf("Some expectations are already set for the ViewModeComponent.EnableCleanMode method")
	}

	mmEnableCleanMode.mock.funcEnableCleanMode = f
	mmEnableCleanMode.mock.funcEnableCleanModeOrigin = minimock.CallerInfo(1)
	return mmEnableCleanMode.mock
}

// When sets expectation for the ViewModeComponent.EnableCleanMode which will trigger the result defined by the following
// Then helper
func (mmEnableCleanMode *mViewModeComponentMockEnableCleanMode) When(ctx context.Context) *ViewModeComponentMockEnableCleanModeExpectation {
	if mmEnableCleanMode.mock.funcEnableCleanMode != nil {
		mmEnableCleanMode.mock.t.Fatalf("ViewModeComponentMock.EnableCleanMode mock is already set by Set")
	}

	expectation := &ViewModeComponentMockEnableCleanModeExpectation{
		mock:               mmEnableCleanMode.mock,
		params:             &ViewModeComponentMockEnableCleanModeParams{ctx},
		expectationOrigins: ViewModeComponentMockEnableCleanModeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEnableCleanMode.expectations = append(mmEnableCleanMode.expectations, expectation)
	return expectation
}

// Then sets up ViewModeComponent.EnableCleanMode return parameters for the expectation previously defined by the When method
func (e *ViewModeComponentMockEnableCleanModeExpectation) Then(err error) *ViewModeComponentMock {
	e.results = &ViewModeComponentMockEnableCleanModeResults{err}
	return e.mock
}

// Times sets number of times ViewModeComponent.EnableCleanMode should be invoked
func (mmEnableCleanMode *mViewModeComponentMockEnableCleanMode) Times(n uint64) *mViewModeComponentMockEnableCleanMode {
	if n == 0 {
		mmEnableCleanMode.mock.t.Fatalf("Times of ViewModeComponentMock.EnableCleanMode mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEnableCleanMode.expectedInvocations, n)
	mmEnableCleanMode.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEnableCleanMode
}

func (mmEnableCleanMode *mViewModeComponentMockEnableCleanMode) invocationsDone() bool {
	if len(mmEnableCleanMode.expectations) == 0 && mmEnableCleanMode.defaultExpectation == nil && mmEnableCleanMode.mock.funcEnableCleanMode == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEnableCleanMode.mock.afterEnableCleanModeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEnableCleanMode.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EnableCleanMode implements ViewModeComponent
func (mmEnableCleanMode *ViewModeComponentMock) EnableCleanMode(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmEnableCleanMode.beforeEnableCleanModeCounter, 1)
	defer mm_atomic.AddUint64(&mmEnableCleanMode.afterEnableCleanModeCounter, 1)

	mmEnableCleanMode.t.Helper()

	if mmEnableCleanMode.inspectFuncEnableCleanMode != nil {
		mmEnableCleanMode.inspectFuncEnableCleanMode(ctx)
	}

	mm_params := ViewModeComponentMockEnableCleanModeParams{ctx}

	// Record call args
	mmEnableCleanMode.EnableCleanModeMock.mutex.Lock()
	mmEnableCleanMode.EnableCleanModeMock.callArgs = append(mmEnableCleanMode.EnableCleanModeMock.callArgs, &mm_params)
	mmEnableCleanMode.EnableCleanModeMock.mutex.Unlock()

	for _, e := range mmEnableCleanMode.EnableCleanModeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEnableCleanMode.EnableCleanModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.Counter, 1)
		mm_want := mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.params
		mm_want_ptrs := mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.paramPtrs

		mm_got := ViewModeComponentMockEnableCleanModeParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEnableCleanMode.t.Errorf("ViewModeComponentMock.EnableCleanMode got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEnableCleanMode.t.Errorf("ViewModeComponentMock.EnableCleanMode got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEnableCleanMode.EnableCleanModeMock.defaultExpectation.results
		if mm_results == nil {
			mmEnableCleanMode.t.Fatal("No results are set for the ViewModeComponentMock.EnableCleanMode")
		}
		return (*mm_results).err
	}
	if mmEnableCleanMode.funcEnableCleanMode != nil {
		return mmEnableCleanMode.funcEnableCleanMode(ctx)
	}
	mmEnableCleanMode.t.Fatalf("Unexpected call to ViewModeComponentMock.EnableCleanMode. %v", ctx)
	return
}

// EnableCleanModeAfterCounter returns a count of finished ViewModeComponentMock.EnableCleanMode invocations
func (mmEnableCleanMode *ViewModeComponentMock) EnableCleanModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnableCleanMode.afterEnableCleanModeCounter)
}

// EnableCleanModeBeforeCounter returns a count of ViewModeComponentMock.EnableCleanMode invocations
func (mmEnableCleanMode *ViewModeComponentMock) EnableCleanModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnableCleanMode.beforeEnableCleanModeCounter)
}

// Calls returns a list of arguments used in each call to ViewModeComponentMock.EnableCleanMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEnableCleanMode *mViewModeComponentMockEnableCleanMode) Calls() []*ViewModeComponentMockEnableCleanModeParams {
	mmEnableCleanMode.mutex.RLock()

	argCopy := make([]*ViewModeComponentMockEnableCleanModeParams, len(mmEnableCleanMode.callArgs))
	copy(argCopy, mmEnableCleanMode.callArgs)

	mmEnableCleanMode.mutex.RUnlock()

	return argCopy
}

// MinimockEnableCleanModeDone returns true if the count of the EnableCleanMode invocations corresponds
// the number of defined expectations
func (m *ViewModeComponentMock) MinimockEnableCleanModeDone() bool {
	if m.EnableCleanModeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EnableCleanModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EnableCleanModeMock.invocationsDone()
}

// MinimockEnableCleanModeInspect logs each unmet expectation
func (m *ViewModeComponentMock) MinimockEnableCleanModeInspect() {
	for _, e := range m.EnableCleanModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ViewModeComponentMock.EnableCleanMode at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEnableCleanModeCounter := mm_atomic.LoadUint64(&m.afterEnableCleanModeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EnableCleanModeMock.defaultExpectation != nil && afterEnableCleanModeCounter < 1 {
		if m.EnableCleanModeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ViewModeComponentMock.EnableCleanMode at\n%s", m.EnableCleanModeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ViewModeComponentMock.EnableCleanMode at\n%s with params: %#v", m.EnableCleanModeMock.defaultExpectation.expectationOrigins.origin, *m.EnableCleanModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnableCleanMode != nil && afterEnableCleanModeCounter < 1 {
		m.t.Errorf("Expected call to ViewModeComponentMock.EnableCleanMode at\n%s", m.funcEnableCleanModeOrigin)
	}

	if !m.EnableCleanModeMock.invocationsDone() && afterEnableCleanModeCounter > 0 {
		m.t.Errorf("Expected %d calls to ViewModeComponentMock.EnableCleanMode at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EnableCleanModeMock.expectedInvocations), m.EnableCleanModeMock.expectedInvocationsOrigin, afterEnableCleanModeCounter)
	}
}

type mViewModeComponentMockSelectViewMode struct {
	optional           bool
	mock               *ViewModeComponentMock
	defaultExpectation *ViewModeComponentMockSelectViewModeExpectation
	expectations       []*ViewModeComponentMockSelectViewModeExpectation

	callArgs []*ViewModeComponentMockSelectViewModeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ViewModeComponentMockSelectViewModeExpectation specifies expectation struct of the ViewModeComponent.SelectViewMode
type ViewModeComponentMockSelectViewModeExpectation struct {
	mock               *ViewModeComponentMock
	params             *ViewModeComponentMockSelectViewModeParams
	paramPtrs          *ViewModeComponentMockSelectViewModeParamPtrs
	expectationOrigins ViewModeComponentMockSelectViewModeExpectationOrigins
	results            *ViewModeComponentMockSelectViewModeResults
	returnOrigin       string
	Counter            uint64
}

// ViewModeComponentMockSelectViewModeParams contains parameters of the ViewModeComponent.SelectViewMode
type ViewModeComponentMockSelectViewModeParams struct {
	ctx      context.Context
	viewMode ViewMode
}

// ViewModeComponentMockSelectViewModeParamPtrs contains pointers to parameters of the ViewModeComponent.SelectViewMode
type ViewModeComponentMockSelectViewModeParamPtrs struct {
	ctx      *context.Context
	viewMode *ViewMode
}

// ViewModeComponentMockSelectViewModeResults contains results of the ViewModeComponent.SelectViewMode
type ViewModeComponentMockSelectViewModeResults struct {
	err error
}

// ViewModeComponentMockSelectViewModeOrigins contains origins of expectations of the ViewModeComponent.SelectViewMode
type ViewModeComponentMockSelectViewModeExpectationOrigins struct {
	origin         string
	originCtx      string
	originViewMode string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectViewMode *mViewModeComponentMockSelectViewMode) Optional() *mViewModeComponentMockSelectViewMode {
	mmSelectViewMode.optional = true
	return mmSelectViewMode
}

// Expect sets up expected params for ViewModeComponent.SelectViewMode
func (mmSelectViewMode *mViewModeComponentMockSelectViewMode) Expect(ctx context.Context, viewMode ViewMode) *mViewModeComponentMockSelectViewMode {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &ViewModeComponentMockSelectViewModeExpectation{}
	}

	if mmSelectViewMode.defaultExpectation.paramPtrs != nil {
		mmSelectViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectViewMode mock is already set by ExpectParams functions")
	}

	mmSelectViewMode.defaultExpectation.params = &ViewModeComponentMockSelectViewModeParams{ctx, viewMode}
	mmSelectViewMode.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectViewMode.expectations {
		if minimock.Equal(e.params, mmSelectViewMode.defaultExpectation.params) {
			mmSelectViewMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectViewMode.defaultExpectation.params)
		}
	}

	return mmSelectViewMode
}

// ExpectCtxParam1 sets up expected param ctx for ViewModeComponent.SelectViewMode
func (mmSelectViewMode *mViewModeComponentMockSelectViewMode) ExpectCtxParam1(ctx context.Context) *mViewModeComponentMockSelectViewMode {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &ViewModeComponentMockSelectViewModeExpectation{}
	}

	if mmSelectViewMode.defaultExpectation.params != nil {
		mmSelectViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectViewMode mock is already set by Expect")
	}

	if mmSelectViewMode.defaultExpectation.paramPtrs == nil {
		mmSelectViewMode.defaultExpectation.paramPtrs = &ViewModeComponentMockSelectViewModeParamPtrs{}
	}
	mmSelectViewMode.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectViewMode.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectViewMode
}

// ExpectViewModeParam2 sets up expected param viewMode for ViewModeComponent.SelectViewMode
func (mmSelectViewMode *mViewModeComponentMockSelectViewMode) ExpectViewModeParam2(viewMode ViewMode) *mViewModeComponentMockSelectViewMode {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &ViewModeComponentMockSelectViewModeExpectation{}
	}

	if mmSelectViewMode.defaultExpectation.params != nil {
		mmSelectViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectViewMode mock is already set by Expect")
	}

	if mmSelectViewMode.defaultExpectation.paramPtrs == nil {
		mmSelectViewMode.defaultExpectation.paramPtrs = &ViewModeComponentMockSelectViewModeParamPtrs{}
	}
	mmSelectViewMode.defaultExpectation.paramPtrs.viewMode = &viewMode
	mmSelectViewMode.defaultExpectation.expectationOrigins.originViewMode = minimock.CallerInfo(1)

	return mmSelectViewMode
}

// Inspect accepts an inspector function that has same arguments as the ViewModeComponent.SelectViewMode
func (mmSelectViewMode *mViewModeComponentMockSelectViewMode) Inspect(f func(ctx context.Context, viewMode ViewMode)) *mViewModeComponentMockSelectViewMode {
	if mmSelectViewMode.mock.inspectFuncSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("Inspect function is already set for ViewModeComponentMock.SelectViewMode")
	}

	mmSelectViewMode.mock.inspectFuncSelectViewMode = f

	return mmSelectViewMode
}

// Return sets up results that will be returned by ViewModeComponent.SelectViewMode
func (mmSelectViewMode *mViewModeComponentMockSelectViewMode) Return(err error) *ViewModeComponentMock {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectViewMode mock is already set by Set")
	}

	if mmSelectViewMode.defaultExpectation == nil {
		mmSelectViewMode.defaultExpectation = &ViewModeComponentMockSelectViewModeExpectation{mock: mmSelectViewMode.mock}
	}
	mmSelectViewMode.defaultExpectation.results = &ViewModeComponentMockSelectViewModeResults{err}
	mmSelectViewMode.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectViewMode.mock
}

// Set uses given function f to mock the ViewModeComponent.SelectViewMode method
func (mmSelectViewMode *mViewModeComponentMockSelectViewMode) Set(f func(ctx context.Context, viewMode ViewMode) (err error)) *ViewModeComponentMock {
	if mmSelectViewMode.defaultExpectation != nil {
		mmSelectViewMode.mock.t.Fatalf("Default expectation is already set for the ViewModeComponent.SelectViewMode method")
	}

	if len(mmSelectViewMode.expectations) > 0 {
		mmSelectViewMode.mock.t.Fatalf("Some expectations are already set for the ViewModeComponent.SelectViewMode method")
	}

	mmSelectViewMode.mock.funcSelectViewMode = f
	mmSelectViewMode.mock.funcSelectViewModeOrigin = minimock.CallerInfo(1)
	return mmSelectViewMode.mock
}

// When sets expectation for the ViewModeComponent.SelectViewMode which will trigger the result defined by the following
// Then helper
func (mmSelectViewMode *mViewModeComponentMockSelectViewMode) When(ctx context.Context, viewMode ViewMode) *ViewModeComponentMockSelectViewModeExpectation {
	if mmSelectViewMode.mock.funcSelectViewMode != nil {
		mmSelectViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectViewMode mock is already set by Set")
	}

	expectation := &ViewModeComponentMockSelectViewModeExpectation{
		mock:               mmSelectViewMode.mock,
		params:             &ViewModeComponentMockSelectViewModeParams{ctx, viewMode},
		expectationOrigins: ViewModeComponentMockSelectViewModeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectViewMode.expectations = append(mmSelectViewMode.expectations, expectation)
	return expectation
}

// Then sets up ViewModeComponent.SelectViewMode return parameters for the expectation previously defined by the When method
func (e *ViewModeComponentMockSelectViewModeExpectation) Then(err error) *ViewModeComponentMock {
	e.results = &ViewModeComponentMockSelectViewModeResults{err}
	return e.mock
}

// Times sets number of times ViewModeComponent.SelectViewMode should be invoked
func (mmSelectViewMode *mViewModeComponentMockSelectViewMode) Times(n uint64) *mViewModeComponentMockSelectViewMode {
	if n == 0 {
		mmSelectViewMode.mock.t.Fatalf("Times of ViewModeComponentMock.SelectViewMode mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectViewMode.expectedInvocations, n)
	mmSelectViewMode.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectViewMode
}

func (mmSelectViewMode *mViewModeComponentMockSelectViewMode) invocationsDone() bool {
	if len(mmSelectViewMode.expectations) == 0 && mmSelectViewMode.defaultExpectation == nil && mmSelectViewMode.mock.funcSelectViewMode == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectViewMode.mock.afterSelectViewModeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectViewMode.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectViewMode implements ViewModeComponent
func (mmSelectViewMode *ViewModeComponentMock) SelectViewMode(ctx context.Context, viewMode ViewMode) (err error) {
	mm_atomic.AddUint64(&mmSelectViewMode.beforeSelectViewModeCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectViewMode.afterSelectViewModeCounter, 1)

	mmSelectViewMode.t.Helper()

	if mmSelectViewMode.inspectFuncSelectViewMode != nil {
		mmSelectViewMode.inspectFuncSelectViewMode(ctx, viewMode)
	}

	mm_params := ViewModeComponentMockSelectViewModeParams{ctx, viewMode}

	// Record call args
	mmSelectViewMode.SelectViewModeMock.mutex.Lock()
	mmSelectViewMode.SelectViewModeMock.callArgs = append(mmSelectViewMode.SelectViewModeMock.callArgs, &mm_params)
	mmSelectViewMode.SelectViewModeMock.mutex.Unlock()

	for _, e := range mmSelectViewMode.SelectViewModeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectViewMode.SelectViewModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectViewMode.SelectViewModeMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectViewMode.SelectViewModeMock.defaultExpectation.params
		mm_want_ptrs := mmSelectViewMode.SelectViewModeMock.defaultExpectation.paramPtrs

		mm_got := ViewModeComponentMockSelectViewModeParams{ctx, viewMode}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectViewMode.t.Errorf("ViewModeComponentMock.SelectViewMode got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectViewMode.SelectViewModeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.viewMode != nil && !minimock.Equal(*mm_want_ptrs.viewMode, mm_got.viewMode) {
				mmSelectViewMode.t.Errorf("ViewModeComponentMock.SelectViewMode got unexpected parameter viewMode, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectViewMode.SelectViewModeMock.defaultExpectation.expectationOrigins.originViewMode, *mm_want_ptrs.viewMode, mm_got.viewMode, minimock.Diff(*mm_want_ptrs.viewMode, mm_got.viewMode))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectViewMode.t.Errorf("ViewModeComponentMock.SelectViewMode got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectViewMode.SelectViewModeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectViewMode.SelectViewModeMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectViewMode.t.Fatal("No results are set for the ViewModeComponentMock.SelectViewMode")
		}
		return (*mm_results).err
	}
	if mmSelectViewMode.funcSelectViewMode != nil {
		return mmSelectViewMode.funcSelectViewMode(ctx, viewMode)
	}
	mmSelectViewMode.t.Fatalf("Unexpected call to ViewModeComponentMock.SelectViewMode. %v %v", ctx, viewMode)
	return
}

// SelectViewModeAfterCounter returns a count of finished ViewModeComponentMock.SelectViewMode invocations
func (mmSelectViewMode *ViewModeComponentMock) SelectViewModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectViewMode.afterSelectViewModeCounter)
}

// SelectViewModeBeforeCounter returns a count of ViewModeComponentMock.SelectViewMode invocations
func (mmSelectViewMode *ViewModeComponentMock) SelectViewModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectViewMode.beforeSelectViewModeCounter)
}

// Calls returns a list of arguments used in each call to ViewModeComponentMock.SelectViewMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectViewMode *mViewModeComponentMockSelectViewMode) Calls() []*ViewModeComponentMockSelectViewModeParams {
	mmSelectViewMode.mutex.RLock()

	argCopy := make([]*ViewModeComponentMockSelectViewModeParams, len(mmSelectViewMode.callArgs))
	copy(argCopy, mmSelectViewMode.callArgs)

	mmSelectViewMode.mutex.RUnlock()

	return argCopy
}

// MinimockSelectViewModeDone returns true if the count of the SelectViewMode invocations corresponds
// the number of defined expectations
func (m *ViewModeComponentMock) MinimockSelectViewModeDone() bool {
	if m.SelectViewModeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectViewModeMock.invocationsDone()
}

// MinimockSelectViewModeInspect logs each unmet expectation
func (m *ViewModeComponentMock) MinimockSelectViewModeInspect() {
	for _, e := range m.SelectViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ViewModeComponentMock.SelectViewMode at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectViewModeCounter := mm_atomic.LoadUint64(&m.afterSelectViewModeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectViewModeMock.defaultExpectation != nil && afterSelectViewModeCounter < 1 {
		if m.SelectViewModeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ViewModeComponentMock.SelectViewMode at\n%s", m.SelectViewModeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ViewModeComponentMock.SelectViewMode at\n%s with params: %#v", m.SelectViewModeMock.defaultExpectation.expectationOrigins.origin, *m.SelectViewModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectViewMode != nil && afterSelectViewModeCounter < 1 {
		m.t.Errorf("Expected call to ViewModeComponentMock.SelectViewMode at\n%s", m.funcSelectViewModeOrigin)
	}

	if !m.SelectViewModeMock.invocationsDone() && afterSelectViewModeCounter > 0 {
		m.t.Errorf("Expected %d calls to ViewModeComponentMock.SelectViewMode at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectViewModeMock.expectedInvocations), m.SelectViewModeMock.expectedInvocationsOrigin, afterSelectViewModeCounter)
	}
}

type mViewModeComponentMockSelectedViewMode struct {
	optional           bool
	mock               *ViewModeComponentMock
	defaultExpectation *ViewModeComponentMockSelectedViewModeExpectation
	expectations       []*ViewModeComponentMockSelectedViewModeExpectation

	callArgs []*ViewModeComponentMockSelectedViewModeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ViewModeComponentMockSelectedViewModeExpectation specifies expectation struct of the ViewModeComponent.SelectedViewMode
type ViewModeComponentMockSelectedViewModeExpectation struct {
	mock               *ViewModeComponentMock
	params             *ViewModeComponentMockSelectedViewModeParams
	paramPtrs          *ViewModeComponentMockSelectedViewModeParamPtrs
	expectationOrigins ViewModeComponentMockSelectedViewModeExpectationOrigins
	results            *ViewModeComponentMockSelectedViewModeResults
	returnOrigin       string
	Counter            uint64
}

// ViewModeComponentMockSelectedViewModeParams contains parameters of the ViewModeComponent.SelectedViewMode
type ViewModeComponentMockSelectedViewModeParams struct {
	ctx context.Context
}

// ViewModeComponentMockSelectedViewModeParamPtrs contains pointers to parameters of the ViewModeComponent.SelectedViewMode
type ViewModeComponentMockSelectedViewModeParamPtrs struct {
	ctx *context.Context
}

// ViewModeComponentMockSelectedViewModeResults contains results of the ViewModeComponent.SelectedViewMode
type ViewModeComponentMockSelectedViewModeResults struct {
	v1  ViewMode
	err error
}

// ViewModeComponentMockSelectedViewModeOrigins contains origins of expectations of the ViewModeComponent.SelectedViewMode
type ViewModeComponentMockSelectedViewModeExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedViewMode *mViewModeComponentMockSelectedViewMode) Optional() *mViewModeComponentMockSelectedViewMode {
	mmSelectedViewMode.optional = true
	return mmSelectedViewMode
}

// Expect sets up expected params for ViewModeComponent.SelectedViewMode
func (mmSelectedViewMode *mViewModeComponentMockSelectedViewMode) Expect(ctx context.Context) *mViewModeComponentMockSelectedViewMode {
	if mmSelectedViewMode.mock.funcSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectedViewMode mock is already set by Set")
	}

	if mmSelectedViewMode.defaultExpectation == nil {
		mmSelectedViewMode.defaultExpectation = &ViewModeComponentMockSelectedViewModeExpectation{}
	}

	if mmSelectedViewMode.defaultExpectation.paramPtrs != nil {
		mmSelectedViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectedViewMode mock is already set by ExpectParams functions")
	}

	mmSelectedViewMode.defaultExpectation.params = &ViewModeComponentMockSelectedViewModeParams{ctx}
	mmSelectedViewMode.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedViewMode.expectations {
		if minimock.Equal(e.params, mmSelectedViewMode.defaultExpectation.params) {
			mmSelectedViewMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedViewMode.defaultExpectation.params)
		}
	}

	return mmSelectedViewMode
}

// ExpectCtxParam1 sets up expected param ctx for ViewModeComponent.SelectedViewMode
func (mmSelectedViewMode *mViewModeComponentMockSelectedViewMode) ExpectCtxParam1(ctx context.Context) *mViewModeComponentMockSelectedViewMode {
	if mmSelectedViewMode.mock.funcSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectedViewMode mock is already set by Set")
	}

	if mmSelectedViewMode.defaultExpectation == nil {
		mmSelectedViewMode.defaultExpectation = &ViewModeComponentMockSelectedViewModeExpectation{}
	}

	if mmSelectedViewMode.defaultExpectation.params != nil {
		mmSelectedViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectedViewMode mock is already set by Expect")
	}

	if mmSelectedViewMode.defaultExpectation.paramPtrs == nil {
		mmSelectedViewMode.defaultExpectation.paramPtrs = &ViewModeComponentMockSelectedViewModeParamPtrs{}
	}
	mmSelectedViewMode.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedViewMode.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedViewMode
}

// Inspect accepts an inspector function that has same arguments as the ViewModeComponent.SelectedViewMode
func (mmSelectedViewMode *mViewModeComponentMockSelectedViewMode) Inspect(f func(ctx context.Context)) *mViewModeComponentMockSelectedViewMode {
	if mmSelectedViewMode.mock.inspectFuncSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("Inspect function is already set for ViewModeComponentMock.SelectedViewMode")
	}

	mmSelectedViewMode.mock.inspectFuncSelectedViewMode = f

	return mmSelectedViewMode
}

// Return sets up results that will be returned by ViewModeComponent.SelectedViewMode
func (mmSelectedViewMode *mViewModeComponentMockSelectedViewMode) Return(v1 ViewMode, err error) *ViewModeComponentMock {
	if mmSelectedViewMode.mock.funcSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectedViewMode mock is already set by Set")
	}

	if mmSelectedViewMode.defaultExpectation == nil {
		mmSelectedViewMode.defaultExpectation = &ViewModeComponentMockSelectedViewModeExpectation{mock: mmSelectedViewMode.mock}
	}
	mmSelectedViewMode.defaultExpectation.results = &ViewModeComponentMockSelectedViewModeResults{v1, err}
	mmSelectedViewMode.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedViewMode.mock
}

// Set uses given function f to mock the ViewModeComponent.SelectedViewMode method
func (mmSelectedViewMode *mViewModeComponentMockSelectedViewMode) Set(f func(ctx context.Context) (v1 ViewMode, err error)) *ViewModeComponentMock {
	if mmSelectedViewMode.defaultExpectation != nil {
		mmSelectedViewMode.mock.t.Fatalf("Default expectation is already set for the ViewModeComponent.SelectedViewMode method")
	}

	if len(mmSelectedViewMode.expectations) > 0 {
		mmSelectedViewMode.mock.t.Fatalf("Some expectations are already set for the ViewModeComponent.SelectedViewMode method")
	}

	mmSelectedViewMode.mock.funcSelectedViewMode = f
	mmSelectedViewMode.mock.funcSelectedViewModeOrigin = minimock.CallerInfo(1)
	return mmSelectedViewMode.mock
}

// When sets expectation for the ViewModeComponent.SelectedViewMode which will trigger the result defined by the following
// Then helper
func (mmSelectedViewMode *mViewModeComponentMockSelectedViewMode) When(ctx context.Context) *ViewModeComponentMockSelectedViewModeExpectation {
	if mmSelectedViewMode.mock.funcSelectedViewMode != nil {
		mmSelectedViewMode.mock.t.Fatalf("ViewModeComponentMock.SelectedViewMode mock is already set by Set")
	}

	expectation := &ViewModeComponentMockSelectedViewModeExpectation{
		mock:               mmSelectedViewMode.mock,
		params:             &ViewModeComponentMockSelectedViewModeParams{ctx},
		expectationOrigins: ViewModeComponentMockSelectedViewModeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedViewMode.expectations = append(mmSelectedViewMode.expectations, expectation)
	return expectation
}

// Then sets up ViewModeComponent.SelectedViewMode return parameters for the expectation previously defined by the When method
func (e *ViewModeComponentMockSelectedViewModeExpectation) Then(v1 ViewMode, err error) *ViewModeComponentMock {
	e.results = &ViewModeComponentMockSelectedViewModeResults{v1, err}
	return e.mock
}

// Times sets number of times ViewModeComponent.SelectedViewMode should be invoked
func (mmSelectedViewMode *mViewModeComponentMockSelectedViewMode) Times(n uint64) *mViewModeComponentMockSelectedViewMode {
	if n == 0 {
		mmSelectedViewMode.mock.t.Fatalf("Times of ViewModeComponentMock.SelectedViewMode mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedViewMode.expectedInvocations, n)
	mmSelectedViewMode.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedViewMode
}

func (mmSelectedViewMode *mViewModeComponentMockSelectedViewMode) invocationsDone() bool {
	if len(mmSelectedViewMode.expectations) == 0 && mmSelectedViewMode.defaultExpectation == nil && mmSelectedViewMode.mock.funcSelectedViewMode == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedViewMode.mock.afterSelectedViewModeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedViewMode.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedViewMode implements ViewModeComponent
func (mmSelectedViewMode *ViewModeComponentMock) SelectedViewMode(ctx context.Context) (v1 ViewMode, err error) {
	mm_atomic.AddUint64(&mmSelectedViewMode.beforeSelectedViewModeCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedViewMode.afterSelectedViewModeCounter, 1)

	mmSelectedViewMode.t.Helper()

	if mmSelectedViewMode.inspectFuncSelectedViewMode != nil {
		mmSelectedViewMode.inspectFuncSelectedViewMode(ctx)
	}

	mm_params := ViewModeComponentMockSelectedViewModeParams{ctx}

	// Record call args
	mmSelectedViewMode.SelectedViewModeMock.mutex.Lock()
	mmSelectedViewMode.SelectedViewModeMock.callArgs = append(mmSelectedViewMode.SelectedViewModeMock.callArgs, &mm_params)
	mmSelectedViewMode.SelectedViewModeMock.mutex.Unlock()

	for _, e := range mmSelectedViewMode.SelectedViewModeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.v1, e.results.err
		}
	}

	if mmSelectedViewMode.SelectedViewModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.paramPtrs

		mm_got := ViewModeComponentMockSelectedViewModeParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedViewMode.t.Errorf("ViewModeComponentMock.SelectedViewMode got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedViewMode.t.Errorf("ViewModeComponentMock.SelectedViewMode got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedViewMode.SelectedViewModeMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedViewMode.t.Fatal("No results are set for the ViewModeComponentMock.SelectedViewMode")
		}
		return (*mm_results).v1, (*mm_results).err
	}
	if mmSelectedViewMode.funcSelectedViewMode != nil {
		return mmSelectedViewMode.funcSelectedViewMode(ctx)
	}
	mmSelectedViewMode.t.Fatalf("Unexpected call to ViewModeComponentMock.SelectedViewMode. %v", ctx)
	return
}

// SelectedViewModeAfterCounter returns a count of finished ViewModeComponentMock.SelectedViewMode invocations
func (mmSelectedViewMode *ViewModeComponentMock) SelectedViewModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedViewMode.afterSelectedViewModeCounter)
}

// SelectedViewModeBeforeCounter returns a count of ViewModeComponentMock.SelectedViewMode invocations
func (mmSelectedViewMode *ViewModeComponentMock) SelectedViewModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedViewMode.beforeSelectedViewModeCounter)
}

// Calls returns a list of arguments used in each call to ViewModeComponentMock.SelectedViewMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedViewMode *mViewModeComponentMockSelectedViewMode) Calls() []*ViewModeComponentMockSelectedViewModeParams {
	mmSelectedViewMode.mutex.RLock()

	argCopy := make([]*ViewModeComponentMockSelectedViewModeParams, len(mmSelectedViewMode.callArgs))
	copy(argCopy, mmSelectedViewMode.callArgs)

	mmSelectedViewMode.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedViewModeDone returns true if the count of the SelectedViewMode invocations corresponds
// the number of defined expectations
func (m *ViewModeComponentMock) MinimockSelectedViewModeDone() bool {
	if m.SelectedViewModeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedViewModeMock.invocationsDone()
}

// MinimockSelectedViewModeInspect logs each unmet expectation
func (m *ViewModeComponentMock) MinimockSelectedViewModeInspect() {
	for _, e := range m.SelectedViewModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ViewModeComponentMock.SelectedViewMode at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedViewModeCounter := mm_atomic.LoadUint64(&m.afterSelectedViewModeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedViewModeMock.defaultExpectation != nil && afterSelectedViewModeCounter < 1 {
		if m.SelectedViewModeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ViewModeComponentMock.SelectedViewMode at\n%s", m.SelectedViewModeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ViewModeComponentMock.SelectedViewMode at\n%s with params: %#v", m.SelectedViewModeMock.defaultExpectation.expectationOrigins.origin, *m.SelectedViewModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedViewMode != nil && afterSelectedViewModeCounter < 1 {
		m.t.Errorf("Expected call to ViewModeComponentMock.SelectedViewMode at\n%s", m.funcSelectedViewModeOrigin)
	}

	if !m.SelectedViewModeMock.invocationsDone() && afterSelectedViewModeCounter > 0 {
		m.t.Errorf("Expected %d calls to ViewModeComponentMock.SelectedViewMode at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedViewModeMock.expectedInvocations), m.SelectedViewModeMock.expectedInvocationsOrigin, afterSelectedViewModeCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ViewModeComponentMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDisableCleanViewInspect()

			m.MinimockEnableCleanModeInspect()

			m.MinimockSelectViewModeInspect()

			m.MinimockSelectedViewModeInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ViewModeComponentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ViewModeComponentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDisableCleanViewDone() &&
		m.MinimockEnableCleanModeDone() &&
		m.MinimockSelectViewModeDone() &&
		m.MinimockSelectedViewModeDone()
}
