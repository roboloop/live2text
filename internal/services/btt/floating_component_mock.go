// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package btt

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// FloatingComponentMock implements FloatingComponent
type FloatingComponentMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcFloatingPage          func() (s1 string)
	funcFloatingPageOrigin    string
	inspectFuncFloatingPage   func()
	afterFloatingPageCounter  uint64
	beforeFloatingPageCounter uint64
	FloatingPageMock          mFloatingComponentMockFloatingPage

	funcHideFloating          func(ctx context.Context) (err error)
	funcHideFloatingOrigin    string
	inspectFuncHideFloating   func(ctx context.Context)
	afterHideFloatingCounter  uint64
	beforeHideFloatingCounter uint64
	HideFloatingMock          mFloatingComponentMockHideFloating

	funcSelectFloating          func(ctx context.Context, floating Floating) (err error)
	funcSelectFloatingOrigin    string
	inspectFuncSelectFloating   func(ctx context.Context, floating Floating)
	afterSelectFloatingCounter  uint64
	beforeSelectFloatingCounter uint64
	SelectFloatingMock          mFloatingComponentMockSelectFloating

	funcSelectedFloating          func(ctx context.Context) (f1 Floating, err error)
	funcSelectedFloatingOrigin    string
	inspectFuncSelectedFloating   func(ctx context.Context)
	afterSelectedFloatingCounter  uint64
	beforeSelectedFloatingCounter uint64
	SelectedFloatingMock          mFloatingComponentMockSelectedFloating

	funcShowFloating          func(ctx context.Context) (err error)
	funcShowFloatingOrigin    string
	inspectFuncShowFloating   func(ctx context.Context)
	afterShowFloatingCounter  uint64
	beforeShowFloatingCounter uint64
	ShowFloatingMock          mFloatingComponentMockShowFloating

	funcStreamText          func(ctx context.Context) (ch1 <-chan string, ch2 <-chan error, err error)
	funcStreamTextOrigin    string
	inspectFuncStreamText   func(ctx context.Context)
	afterStreamTextCounter  uint64
	beforeStreamTextCounter uint64
	StreamTextMock          mFloatingComponentMockStreamText
}

// NewFloatingComponentMock returns a mock for FloatingComponent
func NewFloatingComponentMock(t minimock.Tester) *FloatingComponentMock {
	m := &FloatingComponentMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.FloatingPageMock = mFloatingComponentMockFloatingPage{mock: m}

	m.HideFloatingMock = mFloatingComponentMockHideFloating{mock: m}
	m.HideFloatingMock.callArgs = []*FloatingComponentMockHideFloatingParams{}

	m.SelectFloatingMock = mFloatingComponentMockSelectFloating{mock: m}
	m.SelectFloatingMock.callArgs = []*FloatingComponentMockSelectFloatingParams{}

	m.SelectedFloatingMock = mFloatingComponentMockSelectedFloating{mock: m}
	m.SelectedFloatingMock.callArgs = []*FloatingComponentMockSelectedFloatingParams{}

	m.ShowFloatingMock = mFloatingComponentMockShowFloating{mock: m}
	m.ShowFloatingMock.callArgs = []*FloatingComponentMockShowFloatingParams{}

	m.StreamTextMock = mFloatingComponentMockStreamText{mock: m}
	m.StreamTextMock.callArgs = []*FloatingComponentMockStreamTextParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mFloatingComponentMockFloatingPage struct {
	optional           bool
	mock               *FloatingComponentMock
	defaultExpectation *FloatingComponentMockFloatingPageExpectation
	expectations       []*FloatingComponentMockFloatingPageExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FloatingComponentMockFloatingPageExpectation specifies expectation struct of the FloatingComponent.FloatingPage
type FloatingComponentMockFloatingPageExpectation struct {
	mock *FloatingComponentMock

	results      *FloatingComponentMockFloatingPageResults
	returnOrigin string
	Counter      uint64
}

// FloatingComponentMockFloatingPageResults contains results of the FloatingComponent.FloatingPage
type FloatingComponentMockFloatingPageResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFloatingPage *mFloatingComponentMockFloatingPage) Optional() *mFloatingComponentMockFloatingPage {
	mmFloatingPage.optional = true
	return mmFloatingPage
}

// Expect sets up expected params for FloatingComponent.FloatingPage
func (mmFloatingPage *mFloatingComponentMockFloatingPage) Expect() *mFloatingComponentMockFloatingPage {
	if mmFloatingPage.mock.funcFloatingPage != nil {
		mmFloatingPage.mock.t.Fatalf("FloatingComponentMock.FloatingPage mock is already set by Set")
	}

	if mmFloatingPage.defaultExpectation == nil {
		mmFloatingPage.defaultExpectation = &FloatingComponentMockFloatingPageExpectation{}
	}

	return mmFloatingPage
}

// Inspect accepts an inspector function that has same arguments as the FloatingComponent.FloatingPage
func (mmFloatingPage *mFloatingComponentMockFloatingPage) Inspect(f func()) *mFloatingComponentMockFloatingPage {
	if mmFloatingPage.mock.inspectFuncFloatingPage != nil {
		mmFloatingPage.mock.t.Fatalf("Inspect function is already set for FloatingComponentMock.FloatingPage")
	}

	mmFloatingPage.mock.inspectFuncFloatingPage = f

	return mmFloatingPage
}

// Return sets up results that will be returned by FloatingComponent.FloatingPage
func (mmFloatingPage *mFloatingComponentMockFloatingPage) Return(s1 string) *FloatingComponentMock {
	if mmFloatingPage.mock.funcFloatingPage != nil {
		mmFloatingPage.mock.t.Fatalf("FloatingComponentMock.FloatingPage mock is already set by Set")
	}

	if mmFloatingPage.defaultExpectation == nil {
		mmFloatingPage.defaultExpectation = &FloatingComponentMockFloatingPageExpectation{mock: mmFloatingPage.mock}
	}
	mmFloatingPage.defaultExpectation.results = &FloatingComponentMockFloatingPageResults{s1}
	mmFloatingPage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFloatingPage.mock
}

// Set uses given function f to mock the FloatingComponent.FloatingPage method
func (mmFloatingPage *mFloatingComponentMockFloatingPage) Set(f func() (s1 string)) *FloatingComponentMock {
	if mmFloatingPage.defaultExpectation != nil {
		mmFloatingPage.mock.t.Fatalf("Default expectation is already set for the FloatingComponent.FloatingPage method")
	}

	if len(mmFloatingPage.expectations) > 0 {
		mmFloatingPage.mock.t.Fatalf("Some expectations are already set for the FloatingComponent.FloatingPage method")
	}

	mmFloatingPage.mock.funcFloatingPage = f
	mmFloatingPage.mock.funcFloatingPageOrigin = minimock.CallerInfo(1)
	return mmFloatingPage.mock
}

// Times sets number of times FloatingComponent.FloatingPage should be invoked
func (mmFloatingPage *mFloatingComponentMockFloatingPage) Times(n uint64) *mFloatingComponentMockFloatingPage {
	if n == 0 {
		mmFloatingPage.mock.t.Fatalf("Times of FloatingComponentMock.FloatingPage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFloatingPage.expectedInvocations, n)
	mmFloatingPage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFloatingPage
}

func (mmFloatingPage *mFloatingComponentMockFloatingPage) invocationsDone() bool {
	if len(mmFloatingPage.expectations) == 0 && mmFloatingPage.defaultExpectation == nil && mmFloatingPage.mock.funcFloatingPage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFloatingPage.mock.afterFloatingPageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFloatingPage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FloatingPage implements FloatingComponent
func (mmFloatingPage *FloatingComponentMock) FloatingPage() (s1 string) {
	mm_atomic.AddUint64(&mmFloatingPage.beforeFloatingPageCounter, 1)
	defer mm_atomic.AddUint64(&mmFloatingPage.afterFloatingPageCounter, 1)

	mmFloatingPage.t.Helper()

	if mmFloatingPage.inspectFuncFloatingPage != nil {
		mmFloatingPage.inspectFuncFloatingPage()
	}

	if mmFloatingPage.FloatingPageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFloatingPage.FloatingPageMock.defaultExpectation.Counter, 1)

		mm_results := mmFloatingPage.FloatingPageMock.defaultExpectation.results
		if mm_results == nil {
			mmFloatingPage.t.Fatal("No results are set for the FloatingComponentMock.FloatingPage")
		}
		return (*mm_results).s1
	}
	if mmFloatingPage.funcFloatingPage != nil {
		return mmFloatingPage.funcFloatingPage()
	}
	mmFloatingPage.t.Fatalf("Unexpected call to FloatingComponentMock.FloatingPage.")
	return
}

// FloatingPageAfterCounter returns a count of finished FloatingComponentMock.FloatingPage invocations
func (mmFloatingPage *FloatingComponentMock) FloatingPageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFloatingPage.afterFloatingPageCounter)
}

// FloatingPageBeforeCounter returns a count of FloatingComponentMock.FloatingPage invocations
func (mmFloatingPage *FloatingComponentMock) FloatingPageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFloatingPage.beforeFloatingPageCounter)
}

// MinimockFloatingPageDone returns true if the count of the FloatingPage invocations corresponds
// the number of defined expectations
func (m *FloatingComponentMock) MinimockFloatingPageDone() bool {
	if m.FloatingPageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FloatingPageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FloatingPageMock.invocationsDone()
}

// MinimockFloatingPageInspect logs each unmet expectation
func (m *FloatingComponentMock) MinimockFloatingPageInspect() {
	for _, e := range m.FloatingPageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FloatingComponentMock.FloatingPage")
		}
	}

	afterFloatingPageCounter := mm_atomic.LoadUint64(&m.afterFloatingPageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FloatingPageMock.defaultExpectation != nil && afterFloatingPageCounter < 1 {
		m.t.Errorf("Expected call to FloatingComponentMock.FloatingPage at\n%s", m.FloatingPageMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFloatingPage != nil && afterFloatingPageCounter < 1 {
		m.t.Errorf("Expected call to FloatingComponentMock.FloatingPage at\n%s", m.funcFloatingPageOrigin)
	}

	if !m.FloatingPageMock.invocationsDone() && afterFloatingPageCounter > 0 {
		m.t.Errorf("Expected %d calls to FloatingComponentMock.FloatingPage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FloatingPageMock.expectedInvocations), m.FloatingPageMock.expectedInvocationsOrigin, afterFloatingPageCounter)
	}
}

type mFloatingComponentMockHideFloating struct {
	optional           bool
	mock               *FloatingComponentMock
	defaultExpectation *FloatingComponentMockHideFloatingExpectation
	expectations       []*FloatingComponentMockHideFloatingExpectation

	callArgs []*FloatingComponentMockHideFloatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FloatingComponentMockHideFloatingExpectation specifies expectation struct of the FloatingComponent.HideFloating
type FloatingComponentMockHideFloatingExpectation struct {
	mock               *FloatingComponentMock
	params             *FloatingComponentMockHideFloatingParams
	paramPtrs          *FloatingComponentMockHideFloatingParamPtrs
	expectationOrigins FloatingComponentMockHideFloatingExpectationOrigins
	results            *FloatingComponentMockHideFloatingResults
	returnOrigin       string
	Counter            uint64
}

// FloatingComponentMockHideFloatingParams contains parameters of the FloatingComponent.HideFloating
type FloatingComponentMockHideFloatingParams struct {
	ctx context.Context
}

// FloatingComponentMockHideFloatingParamPtrs contains pointers to parameters of the FloatingComponent.HideFloating
type FloatingComponentMockHideFloatingParamPtrs struct {
	ctx *context.Context
}

// FloatingComponentMockHideFloatingResults contains results of the FloatingComponent.HideFloating
type FloatingComponentMockHideFloatingResults struct {
	err error
}

// FloatingComponentMockHideFloatingOrigins contains origins of expectations of the FloatingComponent.HideFloating
type FloatingComponentMockHideFloatingExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHideFloating *mFloatingComponentMockHideFloating) Optional() *mFloatingComponentMockHideFloating {
	mmHideFloating.optional = true
	return mmHideFloating
}

// Expect sets up expected params for FloatingComponent.HideFloating
func (mmHideFloating *mFloatingComponentMockHideFloating) Expect(ctx context.Context) *mFloatingComponentMockHideFloating {
	if mmHideFloating.mock.funcHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("FloatingComponentMock.HideFloating mock is already set by Set")
	}

	if mmHideFloating.defaultExpectation == nil {
		mmHideFloating.defaultExpectation = &FloatingComponentMockHideFloatingExpectation{}
	}

	if mmHideFloating.defaultExpectation.paramPtrs != nil {
		mmHideFloating.mock.t.Fatalf("FloatingComponentMock.HideFloating mock is already set by ExpectParams functions")
	}

	mmHideFloating.defaultExpectation.params = &FloatingComponentMockHideFloatingParams{ctx}
	mmHideFloating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHideFloating.expectations {
		if minimock.Equal(e.params, mmHideFloating.defaultExpectation.params) {
			mmHideFloating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHideFloating.defaultExpectation.params)
		}
	}

	return mmHideFloating
}

// ExpectCtxParam1 sets up expected param ctx for FloatingComponent.HideFloating
func (mmHideFloating *mFloatingComponentMockHideFloating) ExpectCtxParam1(ctx context.Context) *mFloatingComponentMockHideFloating {
	if mmHideFloating.mock.funcHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("FloatingComponentMock.HideFloating mock is already set by Set")
	}

	if mmHideFloating.defaultExpectation == nil {
		mmHideFloating.defaultExpectation = &FloatingComponentMockHideFloatingExpectation{}
	}

	if mmHideFloating.defaultExpectation.params != nil {
		mmHideFloating.mock.t.Fatalf("FloatingComponentMock.HideFloating mock is already set by Expect")
	}

	if mmHideFloating.defaultExpectation.paramPtrs == nil {
		mmHideFloating.defaultExpectation.paramPtrs = &FloatingComponentMockHideFloatingParamPtrs{}
	}
	mmHideFloating.defaultExpectation.paramPtrs.ctx = &ctx
	mmHideFloating.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHideFloating
}

// Inspect accepts an inspector function that has same arguments as the FloatingComponent.HideFloating
func (mmHideFloating *mFloatingComponentMockHideFloating) Inspect(f func(ctx context.Context)) *mFloatingComponentMockHideFloating {
	if mmHideFloating.mock.inspectFuncHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("Inspect function is already set for FloatingComponentMock.HideFloating")
	}

	mmHideFloating.mock.inspectFuncHideFloating = f

	return mmHideFloating
}

// Return sets up results that will be returned by FloatingComponent.HideFloating
func (mmHideFloating *mFloatingComponentMockHideFloating) Return(err error) *FloatingComponentMock {
	if mmHideFloating.mock.funcHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("FloatingComponentMock.HideFloating mock is already set by Set")
	}

	if mmHideFloating.defaultExpectation == nil {
		mmHideFloating.defaultExpectation = &FloatingComponentMockHideFloatingExpectation{mock: mmHideFloating.mock}
	}
	mmHideFloating.defaultExpectation.results = &FloatingComponentMockHideFloatingResults{err}
	mmHideFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHideFloating.mock
}

// Set uses given function f to mock the FloatingComponent.HideFloating method
func (mmHideFloating *mFloatingComponentMockHideFloating) Set(f func(ctx context.Context) (err error)) *FloatingComponentMock {
	if mmHideFloating.defaultExpectation != nil {
		mmHideFloating.mock.t.Fatalf("Default expectation is already set for the FloatingComponent.HideFloating method")
	}

	if len(mmHideFloating.expectations) > 0 {
		mmHideFloating.mock.t.Fatalf("Some expectations are already set for the FloatingComponent.HideFloating method")
	}

	mmHideFloating.mock.funcHideFloating = f
	mmHideFloating.mock.funcHideFloatingOrigin = minimock.CallerInfo(1)
	return mmHideFloating.mock
}

// When sets expectation for the FloatingComponent.HideFloating which will trigger the result defined by the following
// Then helper
func (mmHideFloating *mFloatingComponentMockHideFloating) When(ctx context.Context) *FloatingComponentMockHideFloatingExpectation {
	if mmHideFloating.mock.funcHideFloating != nil {
		mmHideFloating.mock.t.Fatalf("FloatingComponentMock.HideFloating mock is already set by Set")
	}

	expectation := &FloatingComponentMockHideFloatingExpectation{
		mock:               mmHideFloating.mock,
		params:             &FloatingComponentMockHideFloatingParams{ctx},
		expectationOrigins: FloatingComponentMockHideFloatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHideFloating.expectations = append(mmHideFloating.expectations, expectation)
	return expectation
}

// Then sets up FloatingComponent.HideFloating return parameters for the expectation previously defined by the When method
func (e *FloatingComponentMockHideFloatingExpectation) Then(err error) *FloatingComponentMock {
	e.results = &FloatingComponentMockHideFloatingResults{err}
	return e.mock
}

// Times sets number of times FloatingComponent.HideFloating should be invoked
func (mmHideFloating *mFloatingComponentMockHideFloating) Times(n uint64) *mFloatingComponentMockHideFloating {
	if n == 0 {
		mmHideFloating.mock.t.Fatalf("Times of FloatingComponentMock.HideFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHideFloating.expectedInvocations, n)
	mmHideFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHideFloating
}

func (mmHideFloating *mFloatingComponentMockHideFloating) invocationsDone() bool {
	if len(mmHideFloating.expectations) == 0 && mmHideFloating.defaultExpectation == nil && mmHideFloating.mock.funcHideFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHideFloating.mock.afterHideFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHideFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HideFloating implements FloatingComponent
func (mmHideFloating *FloatingComponentMock) HideFloating(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmHideFloating.beforeHideFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmHideFloating.afterHideFloatingCounter, 1)

	mmHideFloating.t.Helper()

	if mmHideFloating.inspectFuncHideFloating != nil {
		mmHideFloating.inspectFuncHideFloating(ctx)
	}

	mm_params := FloatingComponentMockHideFloatingParams{ctx}

	// Record call args
	mmHideFloating.HideFloatingMock.mutex.Lock()
	mmHideFloating.HideFloatingMock.callArgs = append(mmHideFloating.HideFloatingMock.callArgs, &mm_params)
	mmHideFloating.HideFloatingMock.mutex.Unlock()

	for _, e := range mmHideFloating.HideFloatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHideFloating.HideFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHideFloating.HideFloatingMock.defaultExpectation.Counter, 1)
		mm_want := mmHideFloating.HideFloatingMock.defaultExpectation.params
		mm_want_ptrs := mmHideFloating.HideFloatingMock.defaultExpectation.paramPtrs

		mm_got := FloatingComponentMockHideFloatingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHideFloating.t.Errorf("FloatingComponentMock.HideFloating got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHideFloating.HideFloatingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHideFloating.t.Errorf("FloatingComponentMock.HideFloating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHideFloating.HideFloatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHideFloating.HideFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmHideFloating.t.Fatal("No results are set for the FloatingComponentMock.HideFloating")
		}
		return (*mm_results).err
	}
	if mmHideFloating.funcHideFloating != nil {
		return mmHideFloating.funcHideFloating(ctx)
	}
	mmHideFloating.t.Fatalf("Unexpected call to FloatingComponentMock.HideFloating. %v", ctx)
	return
}

// HideFloatingAfterCounter returns a count of finished FloatingComponentMock.HideFloating invocations
func (mmHideFloating *FloatingComponentMock) HideFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHideFloating.afterHideFloatingCounter)
}

// HideFloatingBeforeCounter returns a count of FloatingComponentMock.HideFloating invocations
func (mmHideFloating *FloatingComponentMock) HideFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHideFloating.beforeHideFloatingCounter)
}

// Calls returns a list of arguments used in each call to FloatingComponentMock.HideFloating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHideFloating *mFloatingComponentMockHideFloating) Calls() []*FloatingComponentMockHideFloatingParams {
	mmHideFloating.mutex.RLock()

	argCopy := make([]*FloatingComponentMockHideFloatingParams, len(mmHideFloating.callArgs))
	copy(argCopy, mmHideFloating.callArgs)

	mmHideFloating.mutex.RUnlock()

	return argCopy
}

// MinimockHideFloatingDone returns true if the count of the HideFloating invocations corresponds
// the number of defined expectations
func (m *FloatingComponentMock) MinimockHideFloatingDone() bool {
	if m.HideFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HideFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HideFloatingMock.invocationsDone()
}

// MinimockHideFloatingInspect logs each unmet expectation
func (m *FloatingComponentMock) MinimockHideFloatingInspect() {
	for _, e := range m.HideFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FloatingComponentMock.HideFloating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHideFloatingCounter := mm_atomic.LoadUint64(&m.afterHideFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HideFloatingMock.defaultExpectation != nil && afterHideFloatingCounter < 1 {
		if m.HideFloatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FloatingComponentMock.HideFloating at\n%s", m.HideFloatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FloatingComponentMock.HideFloating at\n%s with params: %#v", m.HideFloatingMock.defaultExpectation.expectationOrigins.origin, *m.HideFloatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHideFloating != nil && afterHideFloatingCounter < 1 {
		m.t.Errorf("Expected call to FloatingComponentMock.HideFloating at\n%s", m.funcHideFloatingOrigin)
	}

	if !m.HideFloatingMock.invocationsDone() && afterHideFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to FloatingComponentMock.HideFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HideFloatingMock.expectedInvocations), m.HideFloatingMock.expectedInvocationsOrigin, afterHideFloatingCounter)
	}
}

type mFloatingComponentMockSelectFloating struct {
	optional           bool
	mock               *FloatingComponentMock
	defaultExpectation *FloatingComponentMockSelectFloatingExpectation
	expectations       []*FloatingComponentMockSelectFloatingExpectation

	callArgs []*FloatingComponentMockSelectFloatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FloatingComponentMockSelectFloatingExpectation specifies expectation struct of the FloatingComponent.SelectFloating
type FloatingComponentMockSelectFloatingExpectation struct {
	mock               *FloatingComponentMock
	params             *FloatingComponentMockSelectFloatingParams
	paramPtrs          *FloatingComponentMockSelectFloatingParamPtrs
	expectationOrigins FloatingComponentMockSelectFloatingExpectationOrigins
	results            *FloatingComponentMockSelectFloatingResults
	returnOrigin       string
	Counter            uint64
}

// FloatingComponentMockSelectFloatingParams contains parameters of the FloatingComponent.SelectFloating
type FloatingComponentMockSelectFloatingParams struct {
	ctx      context.Context
	floating Floating
}

// FloatingComponentMockSelectFloatingParamPtrs contains pointers to parameters of the FloatingComponent.SelectFloating
type FloatingComponentMockSelectFloatingParamPtrs struct {
	ctx      *context.Context
	floating *Floating
}

// FloatingComponentMockSelectFloatingResults contains results of the FloatingComponent.SelectFloating
type FloatingComponentMockSelectFloatingResults struct {
	err error
}

// FloatingComponentMockSelectFloatingOrigins contains origins of expectations of the FloatingComponent.SelectFloating
type FloatingComponentMockSelectFloatingExpectationOrigins struct {
	origin         string
	originCtx      string
	originFloating string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectFloating *mFloatingComponentMockSelectFloating) Optional() *mFloatingComponentMockSelectFloating {
	mmSelectFloating.optional = true
	return mmSelectFloating
}

// Expect sets up expected params for FloatingComponent.SelectFloating
func (mmSelectFloating *mFloatingComponentMockSelectFloating) Expect(ctx context.Context, floating Floating) *mFloatingComponentMockSelectFloating {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("FloatingComponentMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &FloatingComponentMockSelectFloatingExpectation{}
	}

	if mmSelectFloating.defaultExpectation.paramPtrs != nil {
		mmSelectFloating.mock.t.Fatalf("FloatingComponentMock.SelectFloating mock is already set by ExpectParams functions")
	}

	mmSelectFloating.defaultExpectation.params = &FloatingComponentMockSelectFloatingParams{ctx, floating}
	mmSelectFloating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectFloating.expectations {
		if minimock.Equal(e.params, mmSelectFloating.defaultExpectation.params) {
			mmSelectFloating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectFloating.defaultExpectation.params)
		}
	}

	return mmSelectFloating
}

// ExpectCtxParam1 sets up expected param ctx for FloatingComponent.SelectFloating
func (mmSelectFloating *mFloatingComponentMockSelectFloating) ExpectCtxParam1(ctx context.Context) *mFloatingComponentMockSelectFloating {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("FloatingComponentMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &FloatingComponentMockSelectFloatingExpectation{}
	}

	if mmSelectFloating.defaultExpectation.params != nil {
		mmSelectFloating.mock.t.Fatalf("FloatingComponentMock.SelectFloating mock is already set by Expect")
	}

	if mmSelectFloating.defaultExpectation.paramPtrs == nil {
		mmSelectFloating.defaultExpectation.paramPtrs = &FloatingComponentMockSelectFloatingParamPtrs{}
	}
	mmSelectFloating.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectFloating.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectFloating
}

// ExpectFloatingParam2 sets up expected param floating for FloatingComponent.SelectFloating
func (mmSelectFloating *mFloatingComponentMockSelectFloating) ExpectFloatingParam2(floating Floating) *mFloatingComponentMockSelectFloating {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("FloatingComponentMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &FloatingComponentMockSelectFloatingExpectation{}
	}

	if mmSelectFloating.defaultExpectation.params != nil {
		mmSelectFloating.mock.t.Fatalf("FloatingComponentMock.SelectFloating mock is already set by Expect")
	}

	if mmSelectFloating.defaultExpectation.paramPtrs == nil {
		mmSelectFloating.defaultExpectation.paramPtrs = &FloatingComponentMockSelectFloatingParamPtrs{}
	}
	mmSelectFloating.defaultExpectation.paramPtrs.floating = &floating
	mmSelectFloating.defaultExpectation.expectationOrigins.originFloating = minimock.CallerInfo(1)

	return mmSelectFloating
}

// Inspect accepts an inspector function that has same arguments as the FloatingComponent.SelectFloating
func (mmSelectFloating *mFloatingComponentMockSelectFloating) Inspect(f func(ctx context.Context, floating Floating)) *mFloatingComponentMockSelectFloating {
	if mmSelectFloating.mock.inspectFuncSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("Inspect function is already set for FloatingComponentMock.SelectFloating")
	}

	mmSelectFloating.mock.inspectFuncSelectFloating = f

	return mmSelectFloating
}

// Return sets up results that will be returned by FloatingComponent.SelectFloating
func (mmSelectFloating *mFloatingComponentMockSelectFloating) Return(err error) *FloatingComponentMock {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("FloatingComponentMock.SelectFloating mock is already set by Set")
	}

	if mmSelectFloating.defaultExpectation == nil {
		mmSelectFloating.defaultExpectation = &FloatingComponentMockSelectFloatingExpectation{mock: mmSelectFloating.mock}
	}
	mmSelectFloating.defaultExpectation.results = &FloatingComponentMockSelectFloatingResults{err}
	mmSelectFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectFloating.mock
}

// Set uses given function f to mock the FloatingComponent.SelectFloating method
func (mmSelectFloating *mFloatingComponentMockSelectFloating) Set(f func(ctx context.Context, floating Floating) (err error)) *FloatingComponentMock {
	if mmSelectFloating.defaultExpectation != nil {
		mmSelectFloating.mock.t.Fatalf("Default expectation is already set for the FloatingComponent.SelectFloating method")
	}

	if len(mmSelectFloating.expectations) > 0 {
		mmSelectFloating.mock.t.Fatalf("Some expectations are already set for the FloatingComponent.SelectFloating method")
	}

	mmSelectFloating.mock.funcSelectFloating = f
	mmSelectFloating.mock.funcSelectFloatingOrigin = minimock.CallerInfo(1)
	return mmSelectFloating.mock
}

// When sets expectation for the FloatingComponent.SelectFloating which will trigger the result defined by the following
// Then helper
func (mmSelectFloating *mFloatingComponentMockSelectFloating) When(ctx context.Context, floating Floating) *FloatingComponentMockSelectFloatingExpectation {
	if mmSelectFloating.mock.funcSelectFloating != nil {
		mmSelectFloating.mock.t.Fatalf("FloatingComponentMock.SelectFloating mock is already set by Set")
	}

	expectation := &FloatingComponentMockSelectFloatingExpectation{
		mock:               mmSelectFloating.mock,
		params:             &FloatingComponentMockSelectFloatingParams{ctx, floating},
		expectationOrigins: FloatingComponentMockSelectFloatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectFloating.expectations = append(mmSelectFloating.expectations, expectation)
	return expectation
}

// Then sets up FloatingComponent.SelectFloating return parameters for the expectation previously defined by the When method
func (e *FloatingComponentMockSelectFloatingExpectation) Then(err error) *FloatingComponentMock {
	e.results = &FloatingComponentMockSelectFloatingResults{err}
	return e.mock
}

// Times sets number of times FloatingComponent.SelectFloating should be invoked
func (mmSelectFloating *mFloatingComponentMockSelectFloating) Times(n uint64) *mFloatingComponentMockSelectFloating {
	if n == 0 {
		mmSelectFloating.mock.t.Fatalf("Times of FloatingComponentMock.SelectFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectFloating.expectedInvocations, n)
	mmSelectFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectFloating
}

func (mmSelectFloating *mFloatingComponentMockSelectFloating) invocationsDone() bool {
	if len(mmSelectFloating.expectations) == 0 && mmSelectFloating.defaultExpectation == nil && mmSelectFloating.mock.funcSelectFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectFloating.mock.afterSelectFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectFloating implements FloatingComponent
func (mmSelectFloating *FloatingComponentMock) SelectFloating(ctx context.Context, floating Floating) (err error) {
	mm_atomic.AddUint64(&mmSelectFloating.beforeSelectFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectFloating.afterSelectFloatingCounter, 1)

	mmSelectFloating.t.Helper()

	if mmSelectFloating.inspectFuncSelectFloating != nil {
		mmSelectFloating.inspectFuncSelectFloating(ctx, floating)
	}

	mm_params := FloatingComponentMockSelectFloatingParams{ctx, floating}

	// Record call args
	mmSelectFloating.SelectFloatingMock.mutex.Lock()
	mmSelectFloating.SelectFloatingMock.callArgs = append(mmSelectFloating.SelectFloatingMock.callArgs, &mm_params)
	mmSelectFloating.SelectFloatingMock.mutex.Unlock()

	for _, e := range mmSelectFloating.SelectFloatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectFloating.SelectFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectFloating.SelectFloatingMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectFloating.SelectFloatingMock.defaultExpectation.params
		mm_want_ptrs := mmSelectFloating.SelectFloatingMock.defaultExpectation.paramPtrs

		mm_got := FloatingComponentMockSelectFloatingParams{ctx, floating}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectFloating.t.Errorf("FloatingComponentMock.SelectFloating got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectFloating.SelectFloatingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.floating != nil && !minimock.Equal(*mm_want_ptrs.floating, mm_got.floating) {
				mmSelectFloating.t.Errorf("FloatingComponentMock.SelectFloating got unexpected parameter floating, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectFloating.SelectFloatingMock.defaultExpectation.expectationOrigins.originFloating, *mm_want_ptrs.floating, mm_got.floating, minimock.Diff(*mm_want_ptrs.floating, mm_got.floating))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectFloating.t.Errorf("FloatingComponentMock.SelectFloating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectFloating.SelectFloatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectFloating.SelectFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectFloating.t.Fatal("No results are set for the FloatingComponentMock.SelectFloating")
		}
		return (*mm_results).err
	}
	if mmSelectFloating.funcSelectFloating != nil {
		return mmSelectFloating.funcSelectFloating(ctx, floating)
	}
	mmSelectFloating.t.Fatalf("Unexpected call to FloatingComponentMock.SelectFloating. %v %v", ctx, floating)
	return
}

// SelectFloatingAfterCounter returns a count of finished FloatingComponentMock.SelectFloating invocations
func (mmSelectFloating *FloatingComponentMock) SelectFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectFloating.afterSelectFloatingCounter)
}

// SelectFloatingBeforeCounter returns a count of FloatingComponentMock.SelectFloating invocations
func (mmSelectFloating *FloatingComponentMock) SelectFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectFloating.beforeSelectFloatingCounter)
}

// Calls returns a list of arguments used in each call to FloatingComponentMock.SelectFloating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectFloating *mFloatingComponentMockSelectFloating) Calls() []*FloatingComponentMockSelectFloatingParams {
	mmSelectFloating.mutex.RLock()

	argCopy := make([]*FloatingComponentMockSelectFloatingParams, len(mmSelectFloating.callArgs))
	copy(argCopy, mmSelectFloating.callArgs)

	mmSelectFloating.mutex.RUnlock()

	return argCopy
}

// MinimockSelectFloatingDone returns true if the count of the SelectFloating invocations corresponds
// the number of defined expectations
func (m *FloatingComponentMock) MinimockSelectFloatingDone() bool {
	if m.SelectFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectFloatingMock.invocationsDone()
}

// MinimockSelectFloatingInspect logs each unmet expectation
func (m *FloatingComponentMock) MinimockSelectFloatingInspect() {
	for _, e := range m.SelectFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FloatingComponentMock.SelectFloating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectFloatingCounter := mm_atomic.LoadUint64(&m.afterSelectFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectFloatingMock.defaultExpectation != nil && afterSelectFloatingCounter < 1 {
		if m.SelectFloatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FloatingComponentMock.SelectFloating at\n%s", m.SelectFloatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FloatingComponentMock.SelectFloating at\n%s with params: %#v", m.SelectFloatingMock.defaultExpectation.expectationOrigins.origin, *m.SelectFloatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectFloating != nil && afterSelectFloatingCounter < 1 {
		m.t.Errorf("Expected call to FloatingComponentMock.SelectFloating at\n%s", m.funcSelectFloatingOrigin)
	}

	if !m.SelectFloatingMock.invocationsDone() && afterSelectFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to FloatingComponentMock.SelectFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectFloatingMock.expectedInvocations), m.SelectFloatingMock.expectedInvocationsOrigin, afterSelectFloatingCounter)
	}
}

type mFloatingComponentMockSelectedFloating struct {
	optional           bool
	mock               *FloatingComponentMock
	defaultExpectation *FloatingComponentMockSelectedFloatingExpectation
	expectations       []*FloatingComponentMockSelectedFloatingExpectation

	callArgs []*FloatingComponentMockSelectedFloatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FloatingComponentMockSelectedFloatingExpectation specifies expectation struct of the FloatingComponent.SelectedFloating
type FloatingComponentMockSelectedFloatingExpectation struct {
	mock               *FloatingComponentMock
	params             *FloatingComponentMockSelectedFloatingParams
	paramPtrs          *FloatingComponentMockSelectedFloatingParamPtrs
	expectationOrigins FloatingComponentMockSelectedFloatingExpectationOrigins
	results            *FloatingComponentMockSelectedFloatingResults
	returnOrigin       string
	Counter            uint64
}

// FloatingComponentMockSelectedFloatingParams contains parameters of the FloatingComponent.SelectedFloating
type FloatingComponentMockSelectedFloatingParams struct {
	ctx context.Context
}

// FloatingComponentMockSelectedFloatingParamPtrs contains pointers to parameters of the FloatingComponent.SelectedFloating
type FloatingComponentMockSelectedFloatingParamPtrs struct {
	ctx *context.Context
}

// FloatingComponentMockSelectedFloatingResults contains results of the FloatingComponent.SelectedFloating
type FloatingComponentMockSelectedFloatingResults struct {
	f1  Floating
	err error
}

// FloatingComponentMockSelectedFloatingOrigins contains origins of expectations of the FloatingComponent.SelectedFloating
type FloatingComponentMockSelectedFloatingExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedFloating *mFloatingComponentMockSelectedFloating) Optional() *mFloatingComponentMockSelectedFloating {
	mmSelectedFloating.optional = true
	return mmSelectedFloating
}

// Expect sets up expected params for FloatingComponent.SelectedFloating
func (mmSelectedFloating *mFloatingComponentMockSelectedFloating) Expect(ctx context.Context) *mFloatingComponentMockSelectedFloating {
	if mmSelectedFloating.mock.funcSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("FloatingComponentMock.SelectedFloating mock is already set by Set")
	}

	if mmSelectedFloating.defaultExpectation == nil {
		mmSelectedFloating.defaultExpectation = &FloatingComponentMockSelectedFloatingExpectation{}
	}

	if mmSelectedFloating.defaultExpectation.paramPtrs != nil {
		mmSelectedFloating.mock.t.Fatalf("FloatingComponentMock.SelectedFloating mock is already set by ExpectParams functions")
	}

	mmSelectedFloating.defaultExpectation.params = &FloatingComponentMockSelectedFloatingParams{ctx}
	mmSelectedFloating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedFloating.expectations {
		if minimock.Equal(e.params, mmSelectedFloating.defaultExpectation.params) {
			mmSelectedFloating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedFloating.defaultExpectation.params)
		}
	}

	return mmSelectedFloating
}

// ExpectCtxParam1 sets up expected param ctx for FloatingComponent.SelectedFloating
func (mmSelectedFloating *mFloatingComponentMockSelectedFloating) ExpectCtxParam1(ctx context.Context) *mFloatingComponentMockSelectedFloating {
	if mmSelectedFloating.mock.funcSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("FloatingComponentMock.SelectedFloating mock is already set by Set")
	}

	if mmSelectedFloating.defaultExpectation == nil {
		mmSelectedFloating.defaultExpectation = &FloatingComponentMockSelectedFloatingExpectation{}
	}

	if mmSelectedFloating.defaultExpectation.params != nil {
		mmSelectedFloating.mock.t.Fatalf("FloatingComponentMock.SelectedFloating mock is already set by Expect")
	}

	if mmSelectedFloating.defaultExpectation.paramPtrs == nil {
		mmSelectedFloating.defaultExpectation.paramPtrs = &FloatingComponentMockSelectedFloatingParamPtrs{}
	}
	mmSelectedFloating.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedFloating.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedFloating
}

// Inspect accepts an inspector function that has same arguments as the FloatingComponent.SelectedFloating
func (mmSelectedFloating *mFloatingComponentMockSelectedFloating) Inspect(f func(ctx context.Context)) *mFloatingComponentMockSelectedFloating {
	if mmSelectedFloating.mock.inspectFuncSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("Inspect function is already set for FloatingComponentMock.SelectedFloating")
	}

	mmSelectedFloating.mock.inspectFuncSelectedFloating = f

	return mmSelectedFloating
}

// Return sets up results that will be returned by FloatingComponent.SelectedFloating
func (mmSelectedFloating *mFloatingComponentMockSelectedFloating) Return(f1 Floating, err error) *FloatingComponentMock {
	if mmSelectedFloating.mock.funcSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("FloatingComponentMock.SelectedFloating mock is already set by Set")
	}

	if mmSelectedFloating.defaultExpectation == nil {
		mmSelectedFloating.defaultExpectation = &FloatingComponentMockSelectedFloatingExpectation{mock: mmSelectedFloating.mock}
	}
	mmSelectedFloating.defaultExpectation.results = &FloatingComponentMockSelectedFloatingResults{f1, err}
	mmSelectedFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedFloating.mock
}

// Set uses given function f to mock the FloatingComponent.SelectedFloating method
func (mmSelectedFloating *mFloatingComponentMockSelectedFloating) Set(f func(ctx context.Context) (f1 Floating, err error)) *FloatingComponentMock {
	if mmSelectedFloating.defaultExpectation != nil {
		mmSelectedFloating.mock.t.Fatalf("Default expectation is already set for the FloatingComponent.SelectedFloating method")
	}

	if len(mmSelectedFloating.expectations) > 0 {
		mmSelectedFloating.mock.t.Fatalf("Some expectations are already set for the FloatingComponent.SelectedFloating method")
	}

	mmSelectedFloating.mock.funcSelectedFloating = f
	mmSelectedFloating.mock.funcSelectedFloatingOrigin = minimock.CallerInfo(1)
	return mmSelectedFloating.mock
}

// When sets expectation for the FloatingComponent.SelectedFloating which will trigger the result defined by the following
// Then helper
func (mmSelectedFloating *mFloatingComponentMockSelectedFloating) When(ctx context.Context) *FloatingComponentMockSelectedFloatingExpectation {
	if mmSelectedFloating.mock.funcSelectedFloating != nil {
		mmSelectedFloating.mock.t.Fatalf("FloatingComponentMock.SelectedFloating mock is already set by Set")
	}

	expectation := &FloatingComponentMockSelectedFloatingExpectation{
		mock:               mmSelectedFloating.mock,
		params:             &FloatingComponentMockSelectedFloatingParams{ctx},
		expectationOrigins: FloatingComponentMockSelectedFloatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedFloating.expectations = append(mmSelectedFloating.expectations, expectation)
	return expectation
}

// Then sets up FloatingComponent.SelectedFloating return parameters for the expectation previously defined by the When method
func (e *FloatingComponentMockSelectedFloatingExpectation) Then(f1 Floating, err error) *FloatingComponentMock {
	e.results = &FloatingComponentMockSelectedFloatingResults{f1, err}
	return e.mock
}

// Times sets number of times FloatingComponent.SelectedFloating should be invoked
func (mmSelectedFloating *mFloatingComponentMockSelectedFloating) Times(n uint64) *mFloatingComponentMockSelectedFloating {
	if n == 0 {
		mmSelectedFloating.mock.t.Fatalf("Times of FloatingComponentMock.SelectedFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedFloating.expectedInvocations, n)
	mmSelectedFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedFloating
}

func (mmSelectedFloating *mFloatingComponentMockSelectedFloating) invocationsDone() bool {
	if len(mmSelectedFloating.expectations) == 0 && mmSelectedFloating.defaultExpectation == nil && mmSelectedFloating.mock.funcSelectedFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedFloating.mock.afterSelectedFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedFloating implements FloatingComponent
func (mmSelectedFloating *FloatingComponentMock) SelectedFloating(ctx context.Context) (f1 Floating, err error) {
	mm_atomic.AddUint64(&mmSelectedFloating.beforeSelectedFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedFloating.afterSelectedFloatingCounter, 1)

	mmSelectedFloating.t.Helper()

	if mmSelectedFloating.inspectFuncSelectedFloating != nil {
		mmSelectedFloating.inspectFuncSelectedFloating(ctx)
	}

	mm_params := FloatingComponentMockSelectedFloatingParams{ctx}

	// Record call args
	mmSelectedFloating.SelectedFloatingMock.mutex.Lock()
	mmSelectedFloating.SelectedFloatingMock.callArgs = append(mmSelectedFloating.SelectedFloatingMock.callArgs, &mm_params)
	mmSelectedFloating.SelectedFloatingMock.mutex.Unlock()

	for _, e := range mmSelectedFloating.SelectedFloatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmSelectedFloating.SelectedFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedFloating.SelectedFloatingMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedFloating.SelectedFloatingMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedFloating.SelectedFloatingMock.defaultExpectation.paramPtrs

		mm_got := FloatingComponentMockSelectedFloatingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedFloating.t.Errorf("FloatingComponentMock.SelectedFloating got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedFloating.SelectedFloatingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedFloating.t.Errorf("FloatingComponentMock.SelectedFloating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedFloating.SelectedFloatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedFloating.SelectedFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedFloating.t.Fatal("No results are set for the FloatingComponentMock.SelectedFloating")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmSelectedFloating.funcSelectedFloating != nil {
		return mmSelectedFloating.funcSelectedFloating(ctx)
	}
	mmSelectedFloating.t.Fatalf("Unexpected call to FloatingComponentMock.SelectedFloating. %v", ctx)
	return
}

// SelectedFloatingAfterCounter returns a count of finished FloatingComponentMock.SelectedFloating invocations
func (mmSelectedFloating *FloatingComponentMock) SelectedFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedFloating.afterSelectedFloatingCounter)
}

// SelectedFloatingBeforeCounter returns a count of FloatingComponentMock.SelectedFloating invocations
func (mmSelectedFloating *FloatingComponentMock) SelectedFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedFloating.beforeSelectedFloatingCounter)
}

// Calls returns a list of arguments used in each call to FloatingComponentMock.SelectedFloating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedFloating *mFloatingComponentMockSelectedFloating) Calls() []*FloatingComponentMockSelectedFloatingParams {
	mmSelectedFloating.mutex.RLock()

	argCopy := make([]*FloatingComponentMockSelectedFloatingParams, len(mmSelectedFloating.callArgs))
	copy(argCopy, mmSelectedFloating.callArgs)

	mmSelectedFloating.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedFloatingDone returns true if the count of the SelectedFloating invocations corresponds
// the number of defined expectations
func (m *FloatingComponentMock) MinimockSelectedFloatingDone() bool {
	if m.SelectedFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedFloatingMock.invocationsDone()
}

// MinimockSelectedFloatingInspect logs each unmet expectation
func (m *FloatingComponentMock) MinimockSelectedFloatingInspect() {
	for _, e := range m.SelectedFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FloatingComponentMock.SelectedFloating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedFloatingCounter := mm_atomic.LoadUint64(&m.afterSelectedFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedFloatingMock.defaultExpectation != nil && afterSelectedFloatingCounter < 1 {
		if m.SelectedFloatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FloatingComponentMock.SelectedFloating at\n%s", m.SelectedFloatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FloatingComponentMock.SelectedFloating at\n%s with params: %#v", m.SelectedFloatingMock.defaultExpectation.expectationOrigins.origin, *m.SelectedFloatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedFloating != nil && afterSelectedFloatingCounter < 1 {
		m.t.Errorf("Expected call to FloatingComponentMock.SelectedFloating at\n%s", m.funcSelectedFloatingOrigin)
	}

	if !m.SelectedFloatingMock.invocationsDone() && afterSelectedFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to FloatingComponentMock.SelectedFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedFloatingMock.expectedInvocations), m.SelectedFloatingMock.expectedInvocationsOrigin, afterSelectedFloatingCounter)
	}
}

type mFloatingComponentMockShowFloating struct {
	optional           bool
	mock               *FloatingComponentMock
	defaultExpectation *FloatingComponentMockShowFloatingExpectation
	expectations       []*FloatingComponentMockShowFloatingExpectation

	callArgs []*FloatingComponentMockShowFloatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FloatingComponentMockShowFloatingExpectation specifies expectation struct of the FloatingComponent.ShowFloating
type FloatingComponentMockShowFloatingExpectation struct {
	mock               *FloatingComponentMock
	params             *FloatingComponentMockShowFloatingParams
	paramPtrs          *FloatingComponentMockShowFloatingParamPtrs
	expectationOrigins FloatingComponentMockShowFloatingExpectationOrigins
	results            *FloatingComponentMockShowFloatingResults
	returnOrigin       string
	Counter            uint64
}

// FloatingComponentMockShowFloatingParams contains parameters of the FloatingComponent.ShowFloating
type FloatingComponentMockShowFloatingParams struct {
	ctx context.Context
}

// FloatingComponentMockShowFloatingParamPtrs contains pointers to parameters of the FloatingComponent.ShowFloating
type FloatingComponentMockShowFloatingParamPtrs struct {
	ctx *context.Context
}

// FloatingComponentMockShowFloatingResults contains results of the FloatingComponent.ShowFloating
type FloatingComponentMockShowFloatingResults struct {
	err error
}

// FloatingComponentMockShowFloatingOrigins contains origins of expectations of the FloatingComponent.ShowFloating
type FloatingComponentMockShowFloatingExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmShowFloating *mFloatingComponentMockShowFloating) Optional() *mFloatingComponentMockShowFloating {
	mmShowFloating.optional = true
	return mmShowFloating
}

// Expect sets up expected params for FloatingComponent.ShowFloating
func (mmShowFloating *mFloatingComponentMockShowFloating) Expect(ctx context.Context) *mFloatingComponentMockShowFloating {
	if mmShowFloating.mock.funcShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("FloatingComponentMock.ShowFloating mock is already set by Set")
	}

	if mmShowFloating.defaultExpectation == nil {
		mmShowFloating.defaultExpectation = &FloatingComponentMockShowFloatingExpectation{}
	}

	if mmShowFloating.defaultExpectation.paramPtrs != nil {
		mmShowFloating.mock.t.Fatalf("FloatingComponentMock.ShowFloating mock is already set by ExpectParams functions")
	}

	mmShowFloating.defaultExpectation.params = &FloatingComponentMockShowFloatingParams{ctx}
	mmShowFloating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmShowFloating.expectations {
		if minimock.Equal(e.params, mmShowFloating.defaultExpectation.params) {
			mmShowFloating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmShowFloating.defaultExpectation.params)
		}
	}

	return mmShowFloating
}

// ExpectCtxParam1 sets up expected param ctx for FloatingComponent.ShowFloating
func (mmShowFloating *mFloatingComponentMockShowFloating) ExpectCtxParam1(ctx context.Context) *mFloatingComponentMockShowFloating {
	if mmShowFloating.mock.funcShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("FloatingComponentMock.ShowFloating mock is already set by Set")
	}

	if mmShowFloating.defaultExpectation == nil {
		mmShowFloating.defaultExpectation = &FloatingComponentMockShowFloatingExpectation{}
	}

	if mmShowFloating.defaultExpectation.params != nil {
		mmShowFloating.mock.t.Fatalf("FloatingComponentMock.ShowFloating mock is already set by Expect")
	}

	if mmShowFloating.defaultExpectation.paramPtrs == nil {
		mmShowFloating.defaultExpectation.paramPtrs = &FloatingComponentMockShowFloatingParamPtrs{}
	}
	mmShowFloating.defaultExpectation.paramPtrs.ctx = &ctx
	mmShowFloating.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmShowFloating
}

// Inspect accepts an inspector function that has same arguments as the FloatingComponent.ShowFloating
func (mmShowFloating *mFloatingComponentMockShowFloating) Inspect(f func(ctx context.Context)) *mFloatingComponentMockShowFloating {
	if mmShowFloating.mock.inspectFuncShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("Inspect function is already set for FloatingComponentMock.ShowFloating")
	}

	mmShowFloating.mock.inspectFuncShowFloating = f

	return mmShowFloating
}

// Return sets up results that will be returned by FloatingComponent.ShowFloating
func (mmShowFloating *mFloatingComponentMockShowFloating) Return(err error) *FloatingComponentMock {
	if mmShowFloating.mock.funcShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("FloatingComponentMock.ShowFloating mock is already set by Set")
	}

	if mmShowFloating.defaultExpectation == nil {
		mmShowFloating.defaultExpectation = &FloatingComponentMockShowFloatingExpectation{mock: mmShowFloating.mock}
	}
	mmShowFloating.defaultExpectation.results = &FloatingComponentMockShowFloatingResults{err}
	mmShowFloating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmShowFloating.mock
}

// Set uses given function f to mock the FloatingComponent.ShowFloating method
func (mmShowFloating *mFloatingComponentMockShowFloating) Set(f func(ctx context.Context) (err error)) *FloatingComponentMock {
	if mmShowFloating.defaultExpectation != nil {
		mmShowFloating.mock.t.Fatalf("Default expectation is already set for the FloatingComponent.ShowFloating method")
	}

	if len(mmShowFloating.expectations) > 0 {
		mmShowFloating.mock.t.Fatalf("Some expectations are already set for the FloatingComponent.ShowFloating method")
	}

	mmShowFloating.mock.funcShowFloating = f
	mmShowFloating.mock.funcShowFloatingOrigin = minimock.CallerInfo(1)
	return mmShowFloating.mock
}

// When sets expectation for the FloatingComponent.ShowFloating which will trigger the result defined by the following
// Then helper
func (mmShowFloating *mFloatingComponentMockShowFloating) When(ctx context.Context) *FloatingComponentMockShowFloatingExpectation {
	if mmShowFloating.mock.funcShowFloating != nil {
		mmShowFloating.mock.t.Fatalf("FloatingComponentMock.ShowFloating mock is already set by Set")
	}

	expectation := &FloatingComponentMockShowFloatingExpectation{
		mock:               mmShowFloating.mock,
		params:             &FloatingComponentMockShowFloatingParams{ctx},
		expectationOrigins: FloatingComponentMockShowFloatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmShowFloating.expectations = append(mmShowFloating.expectations, expectation)
	return expectation
}

// Then sets up FloatingComponent.ShowFloating return parameters for the expectation previously defined by the When method
func (e *FloatingComponentMockShowFloatingExpectation) Then(err error) *FloatingComponentMock {
	e.results = &FloatingComponentMockShowFloatingResults{err}
	return e.mock
}

// Times sets number of times FloatingComponent.ShowFloating should be invoked
func (mmShowFloating *mFloatingComponentMockShowFloating) Times(n uint64) *mFloatingComponentMockShowFloating {
	if n == 0 {
		mmShowFloating.mock.t.Fatalf("Times of FloatingComponentMock.ShowFloating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmShowFloating.expectedInvocations, n)
	mmShowFloating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmShowFloating
}

func (mmShowFloating *mFloatingComponentMockShowFloating) invocationsDone() bool {
	if len(mmShowFloating.expectations) == 0 && mmShowFloating.defaultExpectation == nil && mmShowFloating.mock.funcShowFloating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmShowFloating.mock.afterShowFloatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmShowFloating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ShowFloating implements FloatingComponent
func (mmShowFloating *FloatingComponentMock) ShowFloating(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmShowFloating.beforeShowFloatingCounter, 1)
	defer mm_atomic.AddUint64(&mmShowFloating.afterShowFloatingCounter, 1)

	mmShowFloating.t.Helper()

	if mmShowFloating.inspectFuncShowFloating != nil {
		mmShowFloating.inspectFuncShowFloating(ctx)
	}

	mm_params := FloatingComponentMockShowFloatingParams{ctx}

	// Record call args
	mmShowFloating.ShowFloatingMock.mutex.Lock()
	mmShowFloating.ShowFloatingMock.callArgs = append(mmShowFloating.ShowFloatingMock.callArgs, &mm_params)
	mmShowFloating.ShowFloatingMock.mutex.Unlock()

	for _, e := range mmShowFloating.ShowFloatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmShowFloating.ShowFloatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShowFloating.ShowFloatingMock.defaultExpectation.Counter, 1)
		mm_want := mmShowFloating.ShowFloatingMock.defaultExpectation.params
		mm_want_ptrs := mmShowFloating.ShowFloatingMock.defaultExpectation.paramPtrs

		mm_got := FloatingComponentMockShowFloatingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmShowFloating.t.Errorf("FloatingComponentMock.ShowFloating got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmShowFloating.ShowFloatingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmShowFloating.t.Errorf("FloatingComponentMock.ShowFloating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmShowFloating.ShowFloatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmShowFloating.ShowFloatingMock.defaultExpectation.results
		if mm_results == nil {
			mmShowFloating.t.Fatal("No results are set for the FloatingComponentMock.ShowFloating")
		}
		return (*mm_results).err
	}
	if mmShowFloating.funcShowFloating != nil {
		return mmShowFloating.funcShowFloating(ctx)
	}
	mmShowFloating.t.Fatalf("Unexpected call to FloatingComponentMock.ShowFloating. %v", ctx)
	return
}

// ShowFloatingAfterCounter returns a count of finished FloatingComponentMock.ShowFloating invocations
func (mmShowFloating *FloatingComponentMock) ShowFloatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShowFloating.afterShowFloatingCounter)
}

// ShowFloatingBeforeCounter returns a count of FloatingComponentMock.ShowFloating invocations
func (mmShowFloating *FloatingComponentMock) ShowFloatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShowFloating.beforeShowFloatingCounter)
}

// Calls returns a list of arguments used in each call to FloatingComponentMock.ShowFloating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmShowFloating *mFloatingComponentMockShowFloating) Calls() []*FloatingComponentMockShowFloatingParams {
	mmShowFloating.mutex.RLock()

	argCopy := make([]*FloatingComponentMockShowFloatingParams, len(mmShowFloating.callArgs))
	copy(argCopy, mmShowFloating.callArgs)

	mmShowFloating.mutex.RUnlock()

	return argCopy
}

// MinimockShowFloatingDone returns true if the count of the ShowFloating invocations corresponds
// the number of defined expectations
func (m *FloatingComponentMock) MinimockShowFloatingDone() bool {
	if m.ShowFloatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ShowFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ShowFloatingMock.invocationsDone()
}

// MinimockShowFloatingInspect logs each unmet expectation
func (m *FloatingComponentMock) MinimockShowFloatingInspect() {
	for _, e := range m.ShowFloatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FloatingComponentMock.ShowFloating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterShowFloatingCounter := mm_atomic.LoadUint64(&m.afterShowFloatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ShowFloatingMock.defaultExpectation != nil && afterShowFloatingCounter < 1 {
		if m.ShowFloatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FloatingComponentMock.ShowFloating at\n%s", m.ShowFloatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FloatingComponentMock.ShowFloating at\n%s with params: %#v", m.ShowFloatingMock.defaultExpectation.expectationOrigins.origin, *m.ShowFloatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShowFloating != nil && afterShowFloatingCounter < 1 {
		m.t.Errorf("Expected call to FloatingComponentMock.ShowFloating at\n%s", m.funcShowFloatingOrigin)
	}

	if !m.ShowFloatingMock.invocationsDone() && afterShowFloatingCounter > 0 {
		m.t.Errorf("Expected %d calls to FloatingComponentMock.ShowFloating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ShowFloatingMock.expectedInvocations), m.ShowFloatingMock.expectedInvocationsOrigin, afterShowFloatingCounter)
	}
}

type mFloatingComponentMockStreamText struct {
	optional           bool
	mock               *FloatingComponentMock
	defaultExpectation *FloatingComponentMockStreamTextExpectation
	expectations       []*FloatingComponentMockStreamTextExpectation

	callArgs []*FloatingComponentMockStreamTextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FloatingComponentMockStreamTextExpectation specifies expectation struct of the FloatingComponent.StreamText
type FloatingComponentMockStreamTextExpectation struct {
	mock               *FloatingComponentMock
	params             *FloatingComponentMockStreamTextParams
	paramPtrs          *FloatingComponentMockStreamTextParamPtrs
	expectationOrigins FloatingComponentMockStreamTextExpectationOrigins
	results            *FloatingComponentMockStreamTextResults
	returnOrigin       string
	Counter            uint64
}

// FloatingComponentMockStreamTextParams contains parameters of the FloatingComponent.StreamText
type FloatingComponentMockStreamTextParams struct {
	ctx context.Context
}

// FloatingComponentMockStreamTextParamPtrs contains pointers to parameters of the FloatingComponent.StreamText
type FloatingComponentMockStreamTextParamPtrs struct {
	ctx *context.Context
}

// FloatingComponentMockStreamTextResults contains results of the FloatingComponent.StreamText
type FloatingComponentMockStreamTextResults struct {
	ch1 <-chan string
	ch2 <-chan error
	err error
}

// FloatingComponentMockStreamTextOrigins contains origins of expectations of the FloatingComponent.StreamText
type FloatingComponentMockStreamTextExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStreamText *mFloatingComponentMockStreamText) Optional() *mFloatingComponentMockStreamText {
	mmStreamText.optional = true
	return mmStreamText
}

// Expect sets up expected params for FloatingComponent.StreamText
func (mmStreamText *mFloatingComponentMockStreamText) Expect(ctx context.Context) *mFloatingComponentMockStreamText {
	if mmStreamText.mock.funcStreamText != nil {
		mmStreamText.mock.t.Fatalf("FloatingComponentMock.StreamText mock is already set by Set")
	}

	if mmStreamText.defaultExpectation == nil {
		mmStreamText.defaultExpectation = &FloatingComponentMockStreamTextExpectation{}
	}

	if mmStreamText.defaultExpectation.paramPtrs != nil {
		mmStreamText.mock.t.Fatalf("FloatingComponentMock.StreamText mock is already set by ExpectParams functions")
	}

	mmStreamText.defaultExpectation.params = &FloatingComponentMockStreamTextParams{ctx}
	mmStreamText.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStreamText.expectations {
		if minimock.Equal(e.params, mmStreamText.defaultExpectation.params) {
			mmStreamText.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStreamText.defaultExpectation.params)
		}
	}

	return mmStreamText
}

// ExpectCtxParam1 sets up expected param ctx for FloatingComponent.StreamText
func (mmStreamText *mFloatingComponentMockStreamText) ExpectCtxParam1(ctx context.Context) *mFloatingComponentMockStreamText {
	if mmStreamText.mock.funcStreamText != nil {
		mmStreamText.mock.t.Fatalf("FloatingComponentMock.StreamText mock is already set by Set")
	}

	if mmStreamText.defaultExpectation == nil {
		mmStreamText.defaultExpectation = &FloatingComponentMockStreamTextExpectation{}
	}

	if mmStreamText.defaultExpectation.params != nil {
		mmStreamText.mock.t.Fatalf("FloatingComponentMock.StreamText mock is already set by Expect")
	}

	if mmStreamText.defaultExpectation.paramPtrs == nil {
		mmStreamText.defaultExpectation.paramPtrs = &FloatingComponentMockStreamTextParamPtrs{}
	}
	mmStreamText.defaultExpectation.paramPtrs.ctx = &ctx
	mmStreamText.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStreamText
}

// Inspect accepts an inspector function that has same arguments as the FloatingComponent.StreamText
func (mmStreamText *mFloatingComponentMockStreamText) Inspect(f func(ctx context.Context)) *mFloatingComponentMockStreamText {
	if mmStreamText.mock.inspectFuncStreamText != nil {
		mmStreamText.mock.t.Fatalf("Inspect function is already set for FloatingComponentMock.StreamText")
	}

	mmStreamText.mock.inspectFuncStreamText = f

	return mmStreamText
}

// Return sets up results that will be returned by FloatingComponent.StreamText
func (mmStreamText *mFloatingComponentMockStreamText) Return(ch1 <-chan string, ch2 <-chan error, err error) *FloatingComponentMock {
	if mmStreamText.mock.funcStreamText != nil {
		mmStreamText.mock.t.Fatalf("FloatingComponentMock.StreamText mock is already set by Set")
	}

	if mmStreamText.defaultExpectation == nil {
		mmStreamText.defaultExpectation = &FloatingComponentMockStreamTextExpectation{mock: mmStreamText.mock}
	}
	mmStreamText.defaultExpectation.results = &FloatingComponentMockStreamTextResults{ch1, ch2, err}
	mmStreamText.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStreamText.mock
}

// Set uses given function f to mock the FloatingComponent.StreamText method
func (mmStreamText *mFloatingComponentMockStreamText) Set(f func(ctx context.Context) (ch1 <-chan string, ch2 <-chan error, err error)) *FloatingComponentMock {
	if mmStreamText.defaultExpectation != nil {
		mmStreamText.mock.t.Fatalf("Default expectation is already set for the FloatingComponent.StreamText method")
	}

	if len(mmStreamText.expectations) > 0 {
		mmStreamText.mock.t.Fatalf("Some expectations are already set for the FloatingComponent.StreamText method")
	}

	mmStreamText.mock.funcStreamText = f
	mmStreamText.mock.funcStreamTextOrigin = minimock.CallerInfo(1)
	return mmStreamText.mock
}

// When sets expectation for the FloatingComponent.StreamText which will trigger the result defined by the following
// Then helper
func (mmStreamText *mFloatingComponentMockStreamText) When(ctx context.Context) *FloatingComponentMockStreamTextExpectation {
	if mmStreamText.mock.funcStreamText != nil {
		mmStreamText.mock.t.Fatalf("FloatingComponentMock.StreamText mock is already set by Set")
	}

	expectation := &FloatingComponentMockStreamTextExpectation{
		mock:               mmStreamText.mock,
		params:             &FloatingComponentMockStreamTextParams{ctx},
		expectationOrigins: FloatingComponentMockStreamTextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStreamText.expectations = append(mmStreamText.expectations, expectation)
	return expectation
}

// Then sets up FloatingComponent.StreamText return parameters for the expectation previously defined by the When method
func (e *FloatingComponentMockStreamTextExpectation) Then(ch1 <-chan string, ch2 <-chan error, err error) *FloatingComponentMock {
	e.results = &FloatingComponentMockStreamTextResults{ch1, ch2, err}
	return e.mock
}

// Times sets number of times FloatingComponent.StreamText should be invoked
func (mmStreamText *mFloatingComponentMockStreamText) Times(n uint64) *mFloatingComponentMockStreamText {
	if n == 0 {
		mmStreamText.mock.t.Fatalf("Times of FloatingComponentMock.StreamText mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStreamText.expectedInvocations, n)
	mmStreamText.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStreamText
}

func (mmStreamText *mFloatingComponentMockStreamText) invocationsDone() bool {
	if len(mmStreamText.expectations) == 0 && mmStreamText.defaultExpectation == nil && mmStreamText.mock.funcStreamText == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStreamText.mock.afterStreamTextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStreamText.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StreamText implements FloatingComponent
func (mmStreamText *FloatingComponentMock) StreamText(ctx context.Context) (ch1 <-chan string, ch2 <-chan error, err error) {
	mm_atomic.AddUint64(&mmStreamText.beforeStreamTextCounter, 1)
	defer mm_atomic.AddUint64(&mmStreamText.afterStreamTextCounter, 1)

	mmStreamText.t.Helper()

	if mmStreamText.inspectFuncStreamText != nil {
		mmStreamText.inspectFuncStreamText(ctx)
	}

	mm_params := FloatingComponentMockStreamTextParams{ctx}

	// Record call args
	mmStreamText.StreamTextMock.mutex.Lock()
	mmStreamText.StreamTextMock.callArgs = append(mmStreamText.StreamTextMock.callArgs, &mm_params)
	mmStreamText.StreamTextMock.mutex.Unlock()

	for _, e := range mmStreamText.StreamTextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ch1, e.results.ch2, e.results.err
		}
	}

	if mmStreamText.StreamTextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStreamText.StreamTextMock.defaultExpectation.Counter, 1)
		mm_want := mmStreamText.StreamTextMock.defaultExpectation.params
		mm_want_ptrs := mmStreamText.StreamTextMock.defaultExpectation.paramPtrs

		mm_got := FloatingComponentMockStreamTextParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStreamText.t.Errorf("FloatingComponentMock.StreamText got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStreamText.StreamTextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStreamText.t.Errorf("FloatingComponentMock.StreamText got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStreamText.StreamTextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStreamText.StreamTextMock.defaultExpectation.results
		if mm_results == nil {
			mmStreamText.t.Fatal("No results are set for the FloatingComponentMock.StreamText")
		}
		return (*mm_results).ch1, (*mm_results).ch2, (*mm_results).err
	}
	if mmStreamText.funcStreamText != nil {
		return mmStreamText.funcStreamText(ctx)
	}
	mmStreamText.t.Fatalf("Unexpected call to FloatingComponentMock.StreamText. %v", ctx)
	return
}

// StreamTextAfterCounter returns a count of finished FloatingComponentMock.StreamText invocations
func (mmStreamText *FloatingComponentMock) StreamTextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStreamText.afterStreamTextCounter)
}

// StreamTextBeforeCounter returns a count of FloatingComponentMock.StreamText invocations
func (mmStreamText *FloatingComponentMock) StreamTextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStreamText.beforeStreamTextCounter)
}

// Calls returns a list of arguments used in each call to FloatingComponentMock.StreamText.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStreamText *mFloatingComponentMockStreamText) Calls() []*FloatingComponentMockStreamTextParams {
	mmStreamText.mutex.RLock()

	argCopy := make([]*FloatingComponentMockStreamTextParams, len(mmStreamText.callArgs))
	copy(argCopy, mmStreamText.callArgs)

	mmStreamText.mutex.RUnlock()

	return argCopy
}

// MinimockStreamTextDone returns true if the count of the StreamText invocations corresponds
// the number of defined expectations
func (m *FloatingComponentMock) MinimockStreamTextDone() bool {
	if m.StreamTextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StreamTextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StreamTextMock.invocationsDone()
}

// MinimockStreamTextInspect logs each unmet expectation
func (m *FloatingComponentMock) MinimockStreamTextInspect() {
	for _, e := range m.StreamTextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FloatingComponentMock.StreamText at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStreamTextCounter := mm_atomic.LoadUint64(&m.afterStreamTextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StreamTextMock.defaultExpectation != nil && afterStreamTextCounter < 1 {
		if m.StreamTextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FloatingComponentMock.StreamText at\n%s", m.StreamTextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FloatingComponentMock.StreamText at\n%s with params: %#v", m.StreamTextMock.defaultExpectation.expectationOrigins.origin, *m.StreamTextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStreamText != nil && afterStreamTextCounter < 1 {
		m.t.Errorf("Expected call to FloatingComponentMock.StreamText at\n%s", m.funcStreamTextOrigin)
	}

	if !m.StreamTextMock.invocationsDone() && afterStreamTextCounter > 0 {
		m.t.Errorf("Expected %d calls to FloatingComponentMock.StreamText at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StreamTextMock.expectedInvocations), m.StreamTextMock.expectedInvocationsOrigin, afterStreamTextCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FloatingComponentMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockFloatingPageInspect()

			m.MinimockHideFloatingInspect()

			m.MinimockSelectFloatingInspect()

			m.MinimockSelectedFloatingInspect()

			m.MinimockShowFloatingInspect()

			m.MinimockStreamTextInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FloatingComponentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FloatingComponentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockFloatingPageDone() &&
		m.MinimockHideFloatingDone() &&
		m.MinimockSelectFloatingDone() &&
		m.MinimockSelectedFloatingDone() &&
		m.MinimockShowFloatingDone() &&
		m.MinimockStreamTextDone()
}
