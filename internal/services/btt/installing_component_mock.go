// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package btt

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// InstallingComponentMock implements InstallingComponent
type InstallingComponentMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcInstall          func(ctx context.Context) (err error)
	funcInstallOrigin    string
	inspectFuncInstall   func(ctx context.Context)
	afterInstallCounter  uint64
	beforeInstallCounter uint64
	InstallMock          mInstallingComponentMockInstall

	funcUninstall          func(ctx context.Context) (err error)
	funcUninstallOrigin    string
	inspectFuncUninstall   func(ctx context.Context)
	afterUninstallCounter  uint64
	beforeUninstallCounter uint64
	UninstallMock          mInstallingComponentMockUninstall
}

// NewInstallingComponentMock returns a mock for InstallingComponent
func NewInstallingComponentMock(t minimock.Tester) *InstallingComponentMock {
	m := &InstallingComponentMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.InstallMock = mInstallingComponentMockInstall{mock: m}
	m.InstallMock.callArgs = []*InstallingComponentMockInstallParams{}

	m.UninstallMock = mInstallingComponentMockUninstall{mock: m}
	m.UninstallMock.callArgs = []*InstallingComponentMockUninstallParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mInstallingComponentMockInstall struct {
	optional           bool
	mock               *InstallingComponentMock
	defaultExpectation *InstallingComponentMockInstallExpectation
	expectations       []*InstallingComponentMockInstallExpectation

	callArgs []*InstallingComponentMockInstallParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// InstallingComponentMockInstallExpectation specifies expectation struct of the InstallingComponent.Install
type InstallingComponentMockInstallExpectation struct {
	mock               *InstallingComponentMock
	params             *InstallingComponentMockInstallParams
	paramPtrs          *InstallingComponentMockInstallParamPtrs
	expectationOrigins InstallingComponentMockInstallExpectationOrigins
	results            *InstallingComponentMockInstallResults
	returnOrigin       string
	Counter            uint64
}

// InstallingComponentMockInstallParams contains parameters of the InstallingComponent.Install
type InstallingComponentMockInstallParams struct {
	ctx context.Context
}

// InstallingComponentMockInstallParamPtrs contains pointers to parameters of the InstallingComponent.Install
type InstallingComponentMockInstallParamPtrs struct {
	ctx *context.Context
}

// InstallingComponentMockInstallResults contains results of the InstallingComponent.Install
type InstallingComponentMockInstallResults struct {
	err error
}

// InstallingComponentMockInstallOrigins contains origins of expectations of the InstallingComponent.Install
type InstallingComponentMockInstallExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInstall *mInstallingComponentMockInstall) Optional() *mInstallingComponentMockInstall {
	mmInstall.optional = true
	return mmInstall
}

// Expect sets up expected params for InstallingComponent.Install
func (mmInstall *mInstallingComponentMockInstall) Expect(ctx context.Context) *mInstallingComponentMockInstall {
	if mmInstall.mock.funcInstall != nil {
		mmInstall.mock.t.Fatalf("InstallingComponentMock.Install mock is already set by Set")
	}

	if mmInstall.defaultExpectation == nil {
		mmInstall.defaultExpectation = &InstallingComponentMockInstallExpectation{}
	}

	if mmInstall.defaultExpectation.paramPtrs != nil {
		mmInstall.mock.t.Fatalf("InstallingComponentMock.Install mock is already set by ExpectParams functions")
	}

	mmInstall.defaultExpectation.params = &InstallingComponentMockInstallParams{ctx}
	mmInstall.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInstall.expectations {
		if minimock.Equal(e.params, mmInstall.defaultExpectation.params) {
			mmInstall.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInstall.defaultExpectation.params)
		}
	}

	return mmInstall
}

// ExpectCtxParam1 sets up expected param ctx for InstallingComponent.Install
func (mmInstall *mInstallingComponentMockInstall) ExpectCtxParam1(ctx context.Context) *mInstallingComponentMockInstall {
	if mmInstall.mock.funcInstall != nil {
		mmInstall.mock.t.Fatalf("InstallingComponentMock.Install mock is already set by Set")
	}

	if mmInstall.defaultExpectation == nil {
		mmInstall.defaultExpectation = &InstallingComponentMockInstallExpectation{}
	}

	if mmInstall.defaultExpectation.params != nil {
		mmInstall.mock.t.Fatalf("InstallingComponentMock.Install mock is already set by Expect")
	}

	if mmInstall.defaultExpectation.paramPtrs == nil {
		mmInstall.defaultExpectation.paramPtrs = &InstallingComponentMockInstallParamPtrs{}
	}
	mmInstall.defaultExpectation.paramPtrs.ctx = &ctx
	mmInstall.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInstall
}

// Inspect accepts an inspector function that has same arguments as the InstallingComponent.Install
func (mmInstall *mInstallingComponentMockInstall) Inspect(f func(ctx context.Context)) *mInstallingComponentMockInstall {
	if mmInstall.mock.inspectFuncInstall != nil {
		mmInstall.mock.t.Fatalf("Inspect function is already set for InstallingComponentMock.Install")
	}

	mmInstall.mock.inspectFuncInstall = f

	return mmInstall
}

// Return sets up results that will be returned by InstallingComponent.Install
func (mmInstall *mInstallingComponentMockInstall) Return(err error) *InstallingComponentMock {
	if mmInstall.mock.funcInstall != nil {
		mmInstall.mock.t.Fatalf("InstallingComponentMock.Install mock is already set by Set")
	}

	if mmInstall.defaultExpectation == nil {
		mmInstall.defaultExpectation = &InstallingComponentMockInstallExpectation{mock: mmInstall.mock}
	}
	mmInstall.defaultExpectation.results = &InstallingComponentMockInstallResults{err}
	mmInstall.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInstall.mock
}

// Set uses given function f to mock the InstallingComponent.Install method
func (mmInstall *mInstallingComponentMockInstall) Set(f func(ctx context.Context) (err error)) *InstallingComponentMock {
	if mmInstall.defaultExpectation != nil {
		mmInstall.mock.t.Fatalf("Default expectation is already set for the InstallingComponent.Install method")
	}

	if len(mmInstall.expectations) > 0 {
		mmInstall.mock.t.Fatalf("Some expectations are already set for the InstallingComponent.Install method")
	}

	mmInstall.mock.funcInstall = f
	mmInstall.mock.funcInstallOrigin = minimock.CallerInfo(1)
	return mmInstall.mock
}

// When sets expectation for the InstallingComponent.Install which will trigger the result defined by the following
// Then helper
func (mmInstall *mInstallingComponentMockInstall) When(ctx context.Context) *InstallingComponentMockInstallExpectation {
	if mmInstall.mock.funcInstall != nil {
		mmInstall.mock.t.Fatalf("InstallingComponentMock.Install mock is already set by Set")
	}

	expectation := &InstallingComponentMockInstallExpectation{
		mock:               mmInstall.mock,
		params:             &InstallingComponentMockInstallParams{ctx},
		expectationOrigins: InstallingComponentMockInstallExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInstall.expectations = append(mmInstall.expectations, expectation)
	return expectation
}

// Then sets up InstallingComponent.Install return parameters for the expectation previously defined by the When method
func (e *InstallingComponentMockInstallExpectation) Then(err error) *InstallingComponentMock {
	e.results = &InstallingComponentMockInstallResults{err}
	return e.mock
}

// Times sets number of times InstallingComponent.Install should be invoked
func (mmInstall *mInstallingComponentMockInstall) Times(n uint64) *mInstallingComponentMockInstall {
	if n == 0 {
		mmInstall.mock.t.Fatalf("Times of InstallingComponentMock.Install mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInstall.expectedInvocations, n)
	mmInstall.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInstall
}

func (mmInstall *mInstallingComponentMockInstall) invocationsDone() bool {
	if len(mmInstall.expectations) == 0 && mmInstall.defaultExpectation == nil && mmInstall.mock.funcInstall == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInstall.mock.afterInstallCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInstall.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Install implements InstallingComponent
func (mmInstall *InstallingComponentMock) Install(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmInstall.beforeInstallCounter, 1)
	defer mm_atomic.AddUint64(&mmInstall.afterInstallCounter, 1)

	mmInstall.t.Helper()

	if mmInstall.inspectFuncInstall != nil {
		mmInstall.inspectFuncInstall(ctx)
	}

	mm_params := InstallingComponentMockInstallParams{ctx}

	// Record call args
	mmInstall.InstallMock.mutex.Lock()
	mmInstall.InstallMock.callArgs = append(mmInstall.InstallMock.callArgs, &mm_params)
	mmInstall.InstallMock.mutex.Unlock()

	for _, e := range mmInstall.InstallMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInstall.InstallMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInstall.InstallMock.defaultExpectation.Counter, 1)
		mm_want := mmInstall.InstallMock.defaultExpectation.params
		mm_want_ptrs := mmInstall.InstallMock.defaultExpectation.paramPtrs

		mm_got := InstallingComponentMockInstallParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInstall.t.Errorf("InstallingComponentMock.Install got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInstall.InstallMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInstall.t.Errorf("InstallingComponentMock.Install got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInstall.InstallMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInstall.InstallMock.defaultExpectation.results
		if mm_results == nil {
			mmInstall.t.Fatal("No results are set for the InstallingComponentMock.Install")
		}
		return (*mm_results).err
	}
	if mmInstall.funcInstall != nil {
		return mmInstall.funcInstall(ctx)
	}
	mmInstall.t.Fatalf("Unexpected call to InstallingComponentMock.Install. %v", ctx)
	return
}

// InstallAfterCounter returns a count of finished InstallingComponentMock.Install invocations
func (mmInstall *InstallingComponentMock) InstallAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInstall.afterInstallCounter)
}

// InstallBeforeCounter returns a count of InstallingComponentMock.Install invocations
func (mmInstall *InstallingComponentMock) InstallBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInstall.beforeInstallCounter)
}

// Calls returns a list of arguments used in each call to InstallingComponentMock.Install.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInstall *mInstallingComponentMockInstall) Calls() []*InstallingComponentMockInstallParams {
	mmInstall.mutex.RLock()

	argCopy := make([]*InstallingComponentMockInstallParams, len(mmInstall.callArgs))
	copy(argCopy, mmInstall.callArgs)

	mmInstall.mutex.RUnlock()

	return argCopy
}

// MinimockInstallDone returns true if the count of the Install invocations corresponds
// the number of defined expectations
func (m *InstallingComponentMock) MinimockInstallDone() bool {
	if m.InstallMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InstallMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InstallMock.invocationsDone()
}

// MinimockInstallInspect logs each unmet expectation
func (m *InstallingComponentMock) MinimockInstallInspect() {
	for _, e := range m.InstallMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InstallingComponentMock.Install at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInstallCounter := mm_atomic.LoadUint64(&m.afterInstallCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InstallMock.defaultExpectation != nil && afterInstallCounter < 1 {
		if m.InstallMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to InstallingComponentMock.Install at\n%s", m.InstallMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to InstallingComponentMock.Install at\n%s with params: %#v", m.InstallMock.defaultExpectation.expectationOrigins.origin, *m.InstallMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInstall != nil && afterInstallCounter < 1 {
		m.t.Errorf("Expected call to InstallingComponentMock.Install at\n%s", m.funcInstallOrigin)
	}

	if !m.InstallMock.invocationsDone() && afterInstallCounter > 0 {
		m.t.Errorf("Expected %d calls to InstallingComponentMock.Install at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InstallMock.expectedInvocations), m.InstallMock.expectedInvocationsOrigin, afterInstallCounter)
	}
}

type mInstallingComponentMockUninstall struct {
	optional           bool
	mock               *InstallingComponentMock
	defaultExpectation *InstallingComponentMockUninstallExpectation
	expectations       []*InstallingComponentMockUninstallExpectation

	callArgs []*InstallingComponentMockUninstallParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// InstallingComponentMockUninstallExpectation specifies expectation struct of the InstallingComponent.Uninstall
type InstallingComponentMockUninstallExpectation struct {
	mock               *InstallingComponentMock
	params             *InstallingComponentMockUninstallParams
	paramPtrs          *InstallingComponentMockUninstallParamPtrs
	expectationOrigins InstallingComponentMockUninstallExpectationOrigins
	results            *InstallingComponentMockUninstallResults
	returnOrigin       string
	Counter            uint64
}

// InstallingComponentMockUninstallParams contains parameters of the InstallingComponent.Uninstall
type InstallingComponentMockUninstallParams struct {
	ctx context.Context
}

// InstallingComponentMockUninstallParamPtrs contains pointers to parameters of the InstallingComponent.Uninstall
type InstallingComponentMockUninstallParamPtrs struct {
	ctx *context.Context
}

// InstallingComponentMockUninstallResults contains results of the InstallingComponent.Uninstall
type InstallingComponentMockUninstallResults struct {
	err error
}

// InstallingComponentMockUninstallOrigins contains origins of expectations of the InstallingComponent.Uninstall
type InstallingComponentMockUninstallExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUninstall *mInstallingComponentMockUninstall) Optional() *mInstallingComponentMockUninstall {
	mmUninstall.optional = true
	return mmUninstall
}

// Expect sets up expected params for InstallingComponent.Uninstall
func (mmUninstall *mInstallingComponentMockUninstall) Expect(ctx context.Context) *mInstallingComponentMockUninstall {
	if mmUninstall.mock.funcUninstall != nil {
		mmUninstall.mock.t.Fatalf("InstallingComponentMock.Uninstall mock is already set by Set")
	}

	if mmUninstall.defaultExpectation == nil {
		mmUninstall.defaultExpectation = &InstallingComponentMockUninstallExpectation{}
	}

	if mmUninstall.defaultExpectation.paramPtrs != nil {
		mmUninstall.mock.t.Fatalf("InstallingComponentMock.Uninstall mock is already set by ExpectParams functions")
	}

	mmUninstall.defaultExpectation.params = &InstallingComponentMockUninstallParams{ctx}
	mmUninstall.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUninstall.expectations {
		if minimock.Equal(e.params, mmUninstall.defaultExpectation.params) {
			mmUninstall.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUninstall.defaultExpectation.params)
		}
	}

	return mmUninstall
}

// ExpectCtxParam1 sets up expected param ctx for InstallingComponent.Uninstall
func (mmUninstall *mInstallingComponentMockUninstall) ExpectCtxParam1(ctx context.Context) *mInstallingComponentMockUninstall {
	if mmUninstall.mock.funcUninstall != nil {
		mmUninstall.mock.t.Fatalf("InstallingComponentMock.Uninstall mock is already set by Set")
	}

	if mmUninstall.defaultExpectation == nil {
		mmUninstall.defaultExpectation = &InstallingComponentMockUninstallExpectation{}
	}

	if mmUninstall.defaultExpectation.params != nil {
		mmUninstall.mock.t.Fatalf("InstallingComponentMock.Uninstall mock is already set by Expect")
	}

	if mmUninstall.defaultExpectation.paramPtrs == nil {
		mmUninstall.defaultExpectation.paramPtrs = &InstallingComponentMockUninstallParamPtrs{}
	}
	mmUninstall.defaultExpectation.paramPtrs.ctx = &ctx
	mmUninstall.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUninstall
}

// Inspect accepts an inspector function that has same arguments as the InstallingComponent.Uninstall
func (mmUninstall *mInstallingComponentMockUninstall) Inspect(f func(ctx context.Context)) *mInstallingComponentMockUninstall {
	if mmUninstall.mock.inspectFuncUninstall != nil {
		mmUninstall.mock.t.Fatalf("Inspect function is already set for InstallingComponentMock.Uninstall")
	}

	mmUninstall.mock.inspectFuncUninstall = f

	return mmUninstall
}

// Return sets up results that will be returned by InstallingComponent.Uninstall
func (mmUninstall *mInstallingComponentMockUninstall) Return(err error) *InstallingComponentMock {
	if mmUninstall.mock.funcUninstall != nil {
		mmUninstall.mock.t.Fatalf("InstallingComponentMock.Uninstall mock is already set by Set")
	}

	if mmUninstall.defaultExpectation == nil {
		mmUninstall.defaultExpectation = &InstallingComponentMockUninstallExpectation{mock: mmUninstall.mock}
	}
	mmUninstall.defaultExpectation.results = &InstallingComponentMockUninstallResults{err}
	mmUninstall.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUninstall.mock
}

// Set uses given function f to mock the InstallingComponent.Uninstall method
func (mmUninstall *mInstallingComponentMockUninstall) Set(f func(ctx context.Context) (err error)) *InstallingComponentMock {
	if mmUninstall.defaultExpectation != nil {
		mmUninstall.mock.t.Fatalf("Default expectation is already set for the InstallingComponent.Uninstall method")
	}

	if len(mmUninstall.expectations) > 0 {
		mmUninstall.mock.t.Fatalf("Some expectations are already set for the InstallingComponent.Uninstall method")
	}

	mmUninstall.mock.funcUninstall = f
	mmUninstall.mock.funcUninstallOrigin = minimock.CallerInfo(1)
	return mmUninstall.mock
}

// When sets expectation for the InstallingComponent.Uninstall which will trigger the result defined by the following
// Then helper
func (mmUninstall *mInstallingComponentMockUninstall) When(ctx context.Context) *InstallingComponentMockUninstallExpectation {
	if mmUninstall.mock.funcUninstall != nil {
		mmUninstall.mock.t.Fatalf("InstallingComponentMock.Uninstall mock is already set by Set")
	}

	expectation := &InstallingComponentMockUninstallExpectation{
		mock:               mmUninstall.mock,
		params:             &InstallingComponentMockUninstallParams{ctx},
		expectationOrigins: InstallingComponentMockUninstallExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUninstall.expectations = append(mmUninstall.expectations, expectation)
	return expectation
}

// Then sets up InstallingComponent.Uninstall return parameters for the expectation previously defined by the When method
func (e *InstallingComponentMockUninstallExpectation) Then(err error) *InstallingComponentMock {
	e.results = &InstallingComponentMockUninstallResults{err}
	return e.mock
}

// Times sets number of times InstallingComponent.Uninstall should be invoked
func (mmUninstall *mInstallingComponentMockUninstall) Times(n uint64) *mInstallingComponentMockUninstall {
	if n == 0 {
		mmUninstall.mock.t.Fatalf("Times of InstallingComponentMock.Uninstall mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUninstall.expectedInvocations, n)
	mmUninstall.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUninstall
}

func (mmUninstall *mInstallingComponentMockUninstall) invocationsDone() bool {
	if len(mmUninstall.expectations) == 0 && mmUninstall.defaultExpectation == nil && mmUninstall.mock.funcUninstall == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUninstall.mock.afterUninstallCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUninstall.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Uninstall implements InstallingComponent
func (mmUninstall *InstallingComponentMock) Uninstall(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmUninstall.beforeUninstallCounter, 1)
	defer mm_atomic.AddUint64(&mmUninstall.afterUninstallCounter, 1)

	mmUninstall.t.Helper()

	if mmUninstall.inspectFuncUninstall != nil {
		mmUninstall.inspectFuncUninstall(ctx)
	}

	mm_params := InstallingComponentMockUninstallParams{ctx}

	// Record call args
	mmUninstall.UninstallMock.mutex.Lock()
	mmUninstall.UninstallMock.callArgs = append(mmUninstall.UninstallMock.callArgs, &mm_params)
	mmUninstall.UninstallMock.mutex.Unlock()

	for _, e := range mmUninstall.UninstallMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUninstall.UninstallMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUninstall.UninstallMock.defaultExpectation.Counter, 1)
		mm_want := mmUninstall.UninstallMock.defaultExpectation.params
		mm_want_ptrs := mmUninstall.UninstallMock.defaultExpectation.paramPtrs

		mm_got := InstallingComponentMockUninstallParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUninstall.t.Errorf("InstallingComponentMock.Uninstall got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUninstall.UninstallMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUninstall.t.Errorf("InstallingComponentMock.Uninstall got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUninstall.UninstallMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUninstall.UninstallMock.defaultExpectation.results
		if mm_results == nil {
			mmUninstall.t.Fatal("No results are set for the InstallingComponentMock.Uninstall")
		}
		return (*mm_results).err
	}
	if mmUninstall.funcUninstall != nil {
		return mmUninstall.funcUninstall(ctx)
	}
	mmUninstall.t.Fatalf("Unexpected call to InstallingComponentMock.Uninstall. %v", ctx)
	return
}

// UninstallAfterCounter returns a count of finished InstallingComponentMock.Uninstall invocations
func (mmUninstall *InstallingComponentMock) UninstallAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUninstall.afterUninstallCounter)
}

// UninstallBeforeCounter returns a count of InstallingComponentMock.Uninstall invocations
func (mmUninstall *InstallingComponentMock) UninstallBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUninstall.beforeUninstallCounter)
}

// Calls returns a list of arguments used in each call to InstallingComponentMock.Uninstall.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUninstall *mInstallingComponentMockUninstall) Calls() []*InstallingComponentMockUninstallParams {
	mmUninstall.mutex.RLock()

	argCopy := make([]*InstallingComponentMockUninstallParams, len(mmUninstall.callArgs))
	copy(argCopy, mmUninstall.callArgs)

	mmUninstall.mutex.RUnlock()

	return argCopy
}

// MinimockUninstallDone returns true if the count of the Uninstall invocations corresponds
// the number of defined expectations
func (m *InstallingComponentMock) MinimockUninstallDone() bool {
	if m.UninstallMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UninstallMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UninstallMock.invocationsDone()
}

// MinimockUninstallInspect logs each unmet expectation
func (m *InstallingComponentMock) MinimockUninstallInspect() {
	for _, e := range m.UninstallMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InstallingComponentMock.Uninstall at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUninstallCounter := mm_atomic.LoadUint64(&m.afterUninstallCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UninstallMock.defaultExpectation != nil && afterUninstallCounter < 1 {
		if m.UninstallMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to InstallingComponentMock.Uninstall at\n%s", m.UninstallMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to InstallingComponentMock.Uninstall at\n%s with params: %#v", m.UninstallMock.defaultExpectation.expectationOrigins.origin, *m.UninstallMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUninstall != nil && afterUninstallCounter < 1 {
		m.t.Errorf("Expected call to InstallingComponentMock.Uninstall at\n%s", m.funcUninstallOrigin)
	}

	if !m.UninstallMock.invocationsDone() && afterUninstallCounter > 0 {
		m.t.Errorf("Expected %d calls to InstallingComponentMock.Uninstall at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UninstallMock.expectedInvocations), m.UninstallMock.expectedInvocationsOrigin, afterUninstallCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *InstallingComponentMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockInstallInspect()

			m.MinimockUninstallInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *InstallingComponentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *InstallingComponentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockInstallDone() &&
		m.MinimockUninstallDone()
}
