// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package btt

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// DeviceComponentMock implements DeviceComponent
type DeviceComponentMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcIsAvailable          func(ctx context.Context, device string) (b1 bool, err error)
	funcIsAvailableOrigin    string
	inspectFuncIsAvailable   func(ctx context.Context, device string)
	afterIsAvailableCounter  uint64
	beforeIsAvailableCounter uint64
	IsAvailableMock          mDeviceComponentMockIsAvailable

	funcLoadDevices          func(ctx context.Context) (err error)
	funcLoadDevicesOrigin    string
	inspectFuncLoadDevices   func(ctx context.Context)
	afterLoadDevicesCounter  uint64
	beforeLoadDevicesCounter uint64
	LoadDevicesMock          mDeviceComponentMockLoadDevices

	funcSelectDevice          func(ctx context.Context, device string) (err error)
	funcSelectDeviceOrigin    string
	inspectFuncSelectDevice   func(ctx context.Context, device string)
	afterSelectDeviceCounter  uint64
	beforeSelectDeviceCounter uint64
	SelectDeviceMock          mDeviceComponentMockSelectDevice

	funcSelectedDevice          func(ctx context.Context) (s1 string, err error)
	funcSelectedDeviceOrigin    string
	inspectFuncSelectedDevice   func(ctx context.Context)
	afterSelectedDeviceCounter  uint64
	beforeSelectedDeviceCounter uint64
	SelectedDeviceMock          mDeviceComponentMockSelectedDevice
}

// NewDeviceComponentMock returns a mock for DeviceComponent
func NewDeviceComponentMock(t minimock.Tester) *DeviceComponentMock {
	m := &DeviceComponentMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IsAvailableMock = mDeviceComponentMockIsAvailable{mock: m}
	m.IsAvailableMock.callArgs = []*DeviceComponentMockIsAvailableParams{}

	m.LoadDevicesMock = mDeviceComponentMockLoadDevices{mock: m}
	m.LoadDevicesMock.callArgs = []*DeviceComponentMockLoadDevicesParams{}

	m.SelectDeviceMock = mDeviceComponentMockSelectDevice{mock: m}
	m.SelectDeviceMock.callArgs = []*DeviceComponentMockSelectDeviceParams{}

	m.SelectedDeviceMock = mDeviceComponentMockSelectedDevice{mock: m}
	m.SelectedDeviceMock.callArgs = []*DeviceComponentMockSelectedDeviceParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mDeviceComponentMockIsAvailable struct {
	optional           bool
	mock               *DeviceComponentMock
	defaultExpectation *DeviceComponentMockIsAvailableExpectation
	expectations       []*DeviceComponentMockIsAvailableExpectation

	callArgs []*DeviceComponentMockIsAvailableParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceComponentMockIsAvailableExpectation specifies expectation struct of the DeviceComponent.IsAvailable
type DeviceComponentMockIsAvailableExpectation struct {
	mock               *DeviceComponentMock
	params             *DeviceComponentMockIsAvailableParams
	paramPtrs          *DeviceComponentMockIsAvailableParamPtrs
	expectationOrigins DeviceComponentMockIsAvailableExpectationOrigins
	results            *DeviceComponentMockIsAvailableResults
	returnOrigin       string
	Counter            uint64
}

// DeviceComponentMockIsAvailableParams contains parameters of the DeviceComponent.IsAvailable
type DeviceComponentMockIsAvailableParams struct {
	ctx    context.Context
	device string
}

// DeviceComponentMockIsAvailableParamPtrs contains pointers to parameters of the DeviceComponent.IsAvailable
type DeviceComponentMockIsAvailableParamPtrs struct {
	ctx    *context.Context
	device *string
}

// DeviceComponentMockIsAvailableResults contains results of the DeviceComponent.IsAvailable
type DeviceComponentMockIsAvailableResults struct {
	b1  bool
	err error
}

// DeviceComponentMockIsAvailableOrigins contains origins of expectations of the DeviceComponent.IsAvailable
type DeviceComponentMockIsAvailableExpectationOrigins struct {
	origin       string
	originCtx    string
	originDevice string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsAvailable *mDeviceComponentMockIsAvailable) Optional() *mDeviceComponentMockIsAvailable {
	mmIsAvailable.optional = true
	return mmIsAvailable
}

// Expect sets up expected params for DeviceComponent.IsAvailable
func (mmIsAvailable *mDeviceComponentMockIsAvailable) Expect(ctx context.Context, device string) *mDeviceComponentMockIsAvailable {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("DeviceComponentMock.IsAvailable mock is already set by Set")
	}

	if mmIsAvailable.defaultExpectation == nil {
		mmIsAvailable.defaultExpectation = &DeviceComponentMockIsAvailableExpectation{}
	}

	if mmIsAvailable.defaultExpectation.paramPtrs != nil {
		mmIsAvailable.mock.t.Fatalf("DeviceComponentMock.IsAvailable mock is already set by ExpectParams functions")
	}

	mmIsAvailable.defaultExpectation.params = &DeviceComponentMockIsAvailableParams{ctx, device}
	mmIsAvailable.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsAvailable.expectations {
		if minimock.Equal(e.params, mmIsAvailable.defaultExpectation.params) {
			mmIsAvailable.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsAvailable.defaultExpectation.params)
		}
	}

	return mmIsAvailable
}

// ExpectCtxParam1 sets up expected param ctx for DeviceComponent.IsAvailable
func (mmIsAvailable *mDeviceComponentMockIsAvailable) ExpectCtxParam1(ctx context.Context) *mDeviceComponentMockIsAvailable {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("DeviceComponentMock.IsAvailable mock is already set by Set")
	}

	if mmIsAvailable.defaultExpectation == nil {
		mmIsAvailable.defaultExpectation = &DeviceComponentMockIsAvailableExpectation{}
	}

	if mmIsAvailable.defaultExpectation.params != nil {
		mmIsAvailable.mock.t.Fatalf("DeviceComponentMock.IsAvailable mock is already set by Expect")
	}

	if mmIsAvailable.defaultExpectation.paramPtrs == nil {
		mmIsAvailable.defaultExpectation.paramPtrs = &DeviceComponentMockIsAvailableParamPtrs{}
	}
	mmIsAvailable.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsAvailable.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsAvailable
}

// ExpectDeviceParam2 sets up expected param device for DeviceComponent.IsAvailable
func (mmIsAvailable *mDeviceComponentMockIsAvailable) ExpectDeviceParam2(device string) *mDeviceComponentMockIsAvailable {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("DeviceComponentMock.IsAvailable mock is already set by Set")
	}

	if mmIsAvailable.defaultExpectation == nil {
		mmIsAvailable.defaultExpectation = &DeviceComponentMockIsAvailableExpectation{}
	}

	if mmIsAvailable.defaultExpectation.params != nil {
		mmIsAvailable.mock.t.Fatalf("DeviceComponentMock.IsAvailable mock is already set by Expect")
	}

	if mmIsAvailable.defaultExpectation.paramPtrs == nil {
		mmIsAvailable.defaultExpectation.paramPtrs = &DeviceComponentMockIsAvailableParamPtrs{}
	}
	mmIsAvailable.defaultExpectation.paramPtrs.device = &device
	mmIsAvailable.defaultExpectation.expectationOrigins.originDevice = minimock.CallerInfo(1)

	return mmIsAvailable
}

// Inspect accepts an inspector function that has same arguments as the DeviceComponent.IsAvailable
func (mmIsAvailable *mDeviceComponentMockIsAvailable) Inspect(f func(ctx context.Context, device string)) *mDeviceComponentMockIsAvailable {
	if mmIsAvailable.mock.inspectFuncIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("Inspect function is already set for DeviceComponentMock.IsAvailable")
	}

	mmIsAvailable.mock.inspectFuncIsAvailable = f

	return mmIsAvailable
}

// Return sets up results that will be returned by DeviceComponent.IsAvailable
func (mmIsAvailable *mDeviceComponentMockIsAvailable) Return(b1 bool, err error) *DeviceComponentMock {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("DeviceComponentMock.IsAvailable mock is already set by Set")
	}

	if mmIsAvailable.defaultExpectation == nil {
		mmIsAvailable.defaultExpectation = &DeviceComponentMockIsAvailableExpectation{mock: mmIsAvailable.mock}
	}
	mmIsAvailable.defaultExpectation.results = &DeviceComponentMockIsAvailableResults{b1, err}
	mmIsAvailable.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsAvailable.mock
}

// Set uses given function f to mock the DeviceComponent.IsAvailable method
func (mmIsAvailable *mDeviceComponentMockIsAvailable) Set(f func(ctx context.Context, device string) (b1 bool, err error)) *DeviceComponentMock {
	if mmIsAvailable.defaultExpectation != nil {
		mmIsAvailable.mock.t.Fatalf("Default expectation is already set for the DeviceComponent.IsAvailable method")
	}

	if len(mmIsAvailable.expectations) > 0 {
		mmIsAvailable.mock.t.Fatalf("Some expectations are already set for the DeviceComponent.IsAvailable method")
	}

	mmIsAvailable.mock.funcIsAvailable = f
	mmIsAvailable.mock.funcIsAvailableOrigin = minimock.CallerInfo(1)
	return mmIsAvailable.mock
}

// When sets expectation for the DeviceComponent.IsAvailable which will trigger the result defined by the following
// Then helper
func (mmIsAvailable *mDeviceComponentMockIsAvailable) When(ctx context.Context, device string) *DeviceComponentMockIsAvailableExpectation {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("DeviceComponentMock.IsAvailable mock is already set by Set")
	}

	expectation := &DeviceComponentMockIsAvailableExpectation{
		mock:               mmIsAvailable.mock,
		params:             &DeviceComponentMockIsAvailableParams{ctx, device},
		expectationOrigins: DeviceComponentMockIsAvailableExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsAvailable.expectations = append(mmIsAvailable.expectations, expectation)
	return expectation
}

// Then sets up DeviceComponent.IsAvailable return parameters for the expectation previously defined by the When method
func (e *DeviceComponentMockIsAvailableExpectation) Then(b1 bool, err error) *DeviceComponentMock {
	e.results = &DeviceComponentMockIsAvailableResults{b1, err}
	return e.mock
}

// Times sets number of times DeviceComponent.IsAvailable should be invoked
func (mmIsAvailable *mDeviceComponentMockIsAvailable) Times(n uint64) *mDeviceComponentMockIsAvailable {
	if n == 0 {
		mmIsAvailable.mock.t.Fatalf("Times of DeviceComponentMock.IsAvailable mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsAvailable.expectedInvocations, n)
	mmIsAvailable.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsAvailable
}

func (mmIsAvailable *mDeviceComponentMockIsAvailable) invocationsDone() bool {
	if len(mmIsAvailable.expectations) == 0 && mmIsAvailable.defaultExpectation == nil && mmIsAvailable.mock.funcIsAvailable == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsAvailable.mock.afterIsAvailableCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsAvailable.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsAvailable implements DeviceComponent
func (mmIsAvailable *DeviceComponentMock) IsAvailable(ctx context.Context, device string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsAvailable.beforeIsAvailableCounter, 1)
	defer mm_atomic.AddUint64(&mmIsAvailable.afterIsAvailableCounter, 1)

	mmIsAvailable.t.Helper()

	if mmIsAvailable.inspectFuncIsAvailable != nil {
		mmIsAvailable.inspectFuncIsAvailable(ctx, device)
	}

	mm_params := DeviceComponentMockIsAvailableParams{ctx, device}

	// Record call args
	mmIsAvailable.IsAvailableMock.mutex.Lock()
	mmIsAvailable.IsAvailableMock.callArgs = append(mmIsAvailable.IsAvailableMock.callArgs, &mm_params)
	mmIsAvailable.IsAvailableMock.mutex.Unlock()

	for _, e := range mmIsAvailable.IsAvailableMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsAvailable.IsAvailableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsAvailable.IsAvailableMock.defaultExpectation.Counter, 1)
		mm_want := mmIsAvailable.IsAvailableMock.defaultExpectation.params
		mm_want_ptrs := mmIsAvailable.IsAvailableMock.defaultExpectation.paramPtrs

		mm_got := DeviceComponentMockIsAvailableParams{ctx, device}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsAvailable.t.Errorf("DeviceComponentMock.IsAvailable got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsAvailable.IsAvailableMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.device != nil && !minimock.Equal(*mm_want_ptrs.device, mm_got.device) {
				mmIsAvailable.t.Errorf("DeviceComponentMock.IsAvailable got unexpected parameter device, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsAvailable.IsAvailableMock.defaultExpectation.expectationOrigins.originDevice, *mm_want_ptrs.device, mm_got.device, minimock.Diff(*mm_want_ptrs.device, mm_got.device))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsAvailable.t.Errorf("DeviceComponentMock.IsAvailable got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsAvailable.IsAvailableMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsAvailable.IsAvailableMock.defaultExpectation.results
		if mm_results == nil {
			mmIsAvailable.t.Fatal("No results are set for the DeviceComponentMock.IsAvailable")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsAvailable.funcIsAvailable != nil {
		return mmIsAvailable.funcIsAvailable(ctx, device)
	}
	mmIsAvailable.t.Fatalf("Unexpected call to DeviceComponentMock.IsAvailable. %v %v", ctx, device)
	return
}

// IsAvailableAfterCounter returns a count of finished DeviceComponentMock.IsAvailable invocations
func (mmIsAvailable *DeviceComponentMock) IsAvailableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAvailable.afterIsAvailableCounter)
}

// IsAvailableBeforeCounter returns a count of DeviceComponentMock.IsAvailable invocations
func (mmIsAvailable *DeviceComponentMock) IsAvailableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAvailable.beforeIsAvailableCounter)
}

// Calls returns a list of arguments used in each call to DeviceComponentMock.IsAvailable.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsAvailable *mDeviceComponentMockIsAvailable) Calls() []*DeviceComponentMockIsAvailableParams {
	mmIsAvailable.mutex.RLock()

	argCopy := make([]*DeviceComponentMockIsAvailableParams, len(mmIsAvailable.callArgs))
	copy(argCopy, mmIsAvailable.callArgs)

	mmIsAvailable.mutex.RUnlock()

	return argCopy
}

// MinimockIsAvailableDone returns true if the count of the IsAvailable invocations corresponds
// the number of defined expectations
func (m *DeviceComponentMock) MinimockIsAvailableDone() bool {
	if m.IsAvailableMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsAvailableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsAvailableMock.invocationsDone()
}

// MinimockIsAvailableInspect logs each unmet expectation
func (m *DeviceComponentMock) MinimockIsAvailableInspect() {
	for _, e := range m.IsAvailableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceComponentMock.IsAvailable at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsAvailableCounter := mm_atomic.LoadUint64(&m.afterIsAvailableCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsAvailableMock.defaultExpectation != nil && afterIsAvailableCounter < 1 {
		if m.IsAvailableMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceComponentMock.IsAvailable at\n%s", m.IsAvailableMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceComponentMock.IsAvailable at\n%s with params: %#v", m.IsAvailableMock.defaultExpectation.expectationOrigins.origin, *m.IsAvailableMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsAvailable != nil && afterIsAvailableCounter < 1 {
		m.t.Errorf("Expected call to DeviceComponentMock.IsAvailable at\n%s", m.funcIsAvailableOrigin)
	}

	if !m.IsAvailableMock.invocationsDone() && afterIsAvailableCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceComponentMock.IsAvailable at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsAvailableMock.expectedInvocations), m.IsAvailableMock.expectedInvocationsOrigin, afterIsAvailableCounter)
	}
}

type mDeviceComponentMockLoadDevices struct {
	optional           bool
	mock               *DeviceComponentMock
	defaultExpectation *DeviceComponentMockLoadDevicesExpectation
	expectations       []*DeviceComponentMockLoadDevicesExpectation

	callArgs []*DeviceComponentMockLoadDevicesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceComponentMockLoadDevicesExpectation specifies expectation struct of the DeviceComponent.LoadDevices
type DeviceComponentMockLoadDevicesExpectation struct {
	mock               *DeviceComponentMock
	params             *DeviceComponentMockLoadDevicesParams
	paramPtrs          *DeviceComponentMockLoadDevicesParamPtrs
	expectationOrigins DeviceComponentMockLoadDevicesExpectationOrigins
	results            *DeviceComponentMockLoadDevicesResults
	returnOrigin       string
	Counter            uint64
}

// DeviceComponentMockLoadDevicesParams contains parameters of the DeviceComponent.LoadDevices
type DeviceComponentMockLoadDevicesParams struct {
	ctx context.Context
}

// DeviceComponentMockLoadDevicesParamPtrs contains pointers to parameters of the DeviceComponent.LoadDevices
type DeviceComponentMockLoadDevicesParamPtrs struct {
	ctx *context.Context
}

// DeviceComponentMockLoadDevicesResults contains results of the DeviceComponent.LoadDevices
type DeviceComponentMockLoadDevicesResults struct {
	err error
}

// DeviceComponentMockLoadDevicesOrigins contains origins of expectations of the DeviceComponent.LoadDevices
type DeviceComponentMockLoadDevicesExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLoadDevices *mDeviceComponentMockLoadDevices) Optional() *mDeviceComponentMockLoadDevices {
	mmLoadDevices.optional = true
	return mmLoadDevices
}

// Expect sets up expected params for DeviceComponent.LoadDevices
func (mmLoadDevices *mDeviceComponentMockLoadDevices) Expect(ctx context.Context) *mDeviceComponentMockLoadDevices {
	if mmLoadDevices.mock.funcLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("DeviceComponentMock.LoadDevices mock is already set by Set")
	}

	if mmLoadDevices.defaultExpectation == nil {
		mmLoadDevices.defaultExpectation = &DeviceComponentMockLoadDevicesExpectation{}
	}

	if mmLoadDevices.defaultExpectation.paramPtrs != nil {
		mmLoadDevices.mock.t.Fatalf("DeviceComponentMock.LoadDevices mock is already set by ExpectParams functions")
	}

	mmLoadDevices.defaultExpectation.params = &DeviceComponentMockLoadDevicesParams{ctx}
	mmLoadDevices.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLoadDevices.expectations {
		if minimock.Equal(e.params, mmLoadDevices.defaultExpectation.params) {
			mmLoadDevices.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLoadDevices.defaultExpectation.params)
		}
	}

	return mmLoadDevices
}

// ExpectCtxParam1 sets up expected param ctx for DeviceComponent.LoadDevices
func (mmLoadDevices *mDeviceComponentMockLoadDevices) ExpectCtxParam1(ctx context.Context) *mDeviceComponentMockLoadDevices {
	if mmLoadDevices.mock.funcLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("DeviceComponentMock.LoadDevices mock is already set by Set")
	}

	if mmLoadDevices.defaultExpectation == nil {
		mmLoadDevices.defaultExpectation = &DeviceComponentMockLoadDevicesExpectation{}
	}

	if mmLoadDevices.defaultExpectation.params != nil {
		mmLoadDevices.mock.t.Fatalf("DeviceComponentMock.LoadDevices mock is already set by Expect")
	}

	if mmLoadDevices.defaultExpectation.paramPtrs == nil {
		mmLoadDevices.defaultExpectation.paramPtrs = &DeviceComponentMockLoadDevicesParamPtrs{}
	}
	mmLoadDevices.defaultExpectation.paramPtrs.ctx = &ctx
	mmLoadDevices.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLoadDevices
}

// Inspect accepts an inspector function that has same arguments as the DeviceComponent.LoadDevices
func (mmLoadDevices *mDeviceComponentMockLoadDevices) Inspect(f func(ctx context.Context)) *mDeviceComponentMockLoadDevices {
	if mmLoadDevices.mock.inspectFuncLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("Inspect function is already set for DeviceComponentMock.LoadDevices")
	}

	mmLoadDevices.mock.inspectFuncLoadDevices = f

	return mmLoadDevices
}

// Return sets up results that will be returned by DeviceComponent.LoadDevices
func (mmLoadDevices *mDeviceComponentMockLoadDevices) Return(err error) *DeviceComponentMock {
	if mmLoadDevices.mock.funcLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("DeviceComponentMock.LoadDevices mock is already set by Set")
	}

	if mmLoadDevices.defaultExpectation == nil {
		mmLoadDevices.defaultExpectation = &DeviceComponentMockLoadDevicesExpectation{mock: mmLoadDevices.mock}
	}
	mmLoadDevices.defaultExpectation.results = &DeviceComponentMockLoadDevicesResults{err}
	mmLoadDevices.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLoadDevices.mock
}

// Set uses given function f to mock the DeviceComponent.LoadDevices method
func (mmLoadDevices *mDeviceComponentMockLoadDevices) Set(f func(ctx context.Context) (err error)) *DeviceComponentMock {
	if mmLoadDevices.defaultExpectation != nil {
		mmLoadDevices.mock.t.Fatalf("Default expectation is already set for the DeviceComponent.LoadDevices method")
	}

	if len(mmLoadDevices.expectations) > 0 {
		mmLoadDevices.mock.t.Fatalf("Some expectations are already set for the DeviceComponent.LoadDevices method")
	}

	mmLoadDevices.mock.funcLoadDevices = f
	mmLoadDevices.mock.funcLoadDevicesOrigin = minimock.CallerInfo(1)
	return mmLoadDevices.mock
}

// When sets expectation for the DeviceComponent.LoadDevices which will trigger the result defined by the following
// Then helper
func (mmLoadDevices *mDeviceComponentMockLoadDevices) When(ctx context.Context) *DeviceComponentMockLoadDevicesExpectation {
	if mmLoadDevices.mock.funcLoadDevices != nil {
		mmLoadDevices.mock.t.Fatalf("DeviceComponentMock.LoadDevices mock is already set by Set")
	}

	expectation := &DeviceComponentMockLoadDevicesExpectation{
		mock:               mmLoadDevices.mock,
		params:             &DeviceComponentMockLoadDevicesParams{ctx},
		expectationOrigins: DeviceComponentMockLoadDevicesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLoadDevices.expectations = append(mmLoadDevices.expectations, expectation)
	return expectation
}

// Then sets up DeviceComponent.LoadDevices return parameters for the expectation previously defined by the When method
func (e *DeviceComponentMockLoadDevicesExpectation) Then(err error) *DeviceComponentMock {
	e.results = &DeviceComponentMockLoadDevicesResults{err}
	return e.mock
}

// Times sets number of times DeviceComponent.LoadDevices should be invoked
func (mmLoadDevices *mDeviceComponentMockLoadDevices) Times(n uint64) *mDeviceComponentMockLoadDevices {
	if n == 0 {
		mmLoadDevices.mock.t.Fatalf("Times of DeviceComponentMock.LoadDevices mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLoadDevices.expectedInvocations, n)
	mmLoadDevices.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLoadDevices
}

func (mmLoadDevices *mDeviceComponentMockLoadDevices) invocationsDone() bool {
	if len(mmLoadDevices.expectations) == 0 && mmLoadDevices.defaultExpectation == nil && mmLoadDevices.mock.funcLoadDevices == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLoadDevices.mock.afterLoadDevicesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLoadDevices.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LoadDevices implements DeviceComponent
func (mmLoadDevices *DeviceComponentMock) LoadDevices(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmLoadDevices.beforeLoadDevicesCounter, 1)
	defer mm_atomic.AddUint64(&mmLoadDevices.afterLoadDevicesCounter, 1)

	mmLoadDevices.t.Helper()

	if mmLoadDevices.inspectFuncLoadDevices != nil {
		mmLoadDevices.inspectFuncLoadDevices(ctx)
	}

	mm_params := DeviceComponentMockLoadDevicesParams{ctx}

	// Record call args
	mmLoadDevices.LoadDevicesMock.mutex.Lock()
	mmLoadDevices.LoadDevicesMock.callArgs = append(mmLoadDevices.LoadDevicesMock.callArgs, &mm_params)
	mmLoadDevices.LoadDevicesMock.mutex.Unlock()

	for _, e := range mmLoadDevices.LoadDevicesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLoadDevices.LoadDevicesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLoadDevices.LoadDevicesMock.defaultExpectation.Counter, 1)
		mm_want := mmLoadDevices.LoadDevicesMock.defaultExpectation.params
		mm_want_ptrs := mmLoadDevices.LoadDevicesMock.defaultExpectation.paramPtrs

		mm_got := DeviceComponentMockLoadDevicesParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLoadDevices.t.Errorf("DeviceComponentMock.LoadDevices got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLoadDevices.LoadDevicesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLoadDevices.t.Errorf("DeviceComponentMock.LoadDevices got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLoadDevices.LoadDevicesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLoadDevices.LoadDevicesMock.defaultExpectation.results
		if mm_results == nil {
			mmLoadDevices.t.Fatal("No results are set for the DeviceComponentMock.LoadDevices")
		}
		return (*mm_results).err
	}
	if mmLoadDevices.funcLoadDevices != nil {
		return mmLoadDevices.funcLoadDevices(ctx)
	}
	mmLoadDevices.t.Fatalf("Unexpected call to DeviceComponentMock.LoadDevices. %v", ctx)
	return
}

// LoadDevicesAfterCounter returns a count of finished DeviceComponentMock.LoadDevices invocations
func (mmLoadDevices *DeviceComponentMock) LoadDevicesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadDevices.afterLoadDevicesCounter)
}

// LoadDevicesBeforeCounter returns a count of DeviceComponentMock.LoadDevices invocations
func (mmLoadDevices *DeviceComponentMock) LoadDevicesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadDevices.beforeLoadDevicesCounter)
}

// Calls returns a list of arguments used in each call to DeviceComponentMock.LoadDevices.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLoadDevices *mDeviceComponentMockLoadDevices) Calls() []*DeviceComponentMockLoadDevicesParams {
	mmLoadDevices.mutex.RLock()

	argCopy := make([]*DeviceComponentMockLoadDevicesParams, len(mmLoadDevices.callArgs))
	copy(argCopy, mmLoadDevices.callArgs)

	mmLoadDevices.mutex.RUnlock()

	return argCopy
}

// MinimockLoadDevicesDone returns true if the count of the LoadDevices invocations corresponds
// the number of defined expectations
func (m *DeviceComponentMock) MinimockLoadDevicesDone() bool {
	if m.LoadDevicesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoadDevicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoadDevicesMock.invocationsDone()
}

// MinimockLoadDevicesInspect logs each unmet expectation
func (m *DeviceComponentMock) MinimockLoadDevicesInspect() {
	for _, e := range m.LoadDevicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceComponentMock.LoadDevices at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoadDevicesCounter := mm_atomic.LoadUint64(&m.afterLoadDevicesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoadDevicesMock.defaultExpectation != nil && afterLoadDevicesCounter < 1 {
		if m.LoadDevicesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceComponentMock.LoadDevices at\n%s", m.LoadDevicesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceComponentMock.LoadDevices at\n%s with params: %#v", m.LoadDevicesMock.defaultExpectation.expectationOrigins.origin, *m.LoadDevicesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoadDevices != nil && afterLoadDevicesCounter < 1 {
		m.t.Errorf("Expected call to DeviceComponentMock.LoadDevices at\n%s", m.funcLoadDevicesOrigin)
	}

	if !m.LoadDevicesMock.invocationsDone() && afterLoadDevicesCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceComponentMock.LoadDevices at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoadDevicesMock.expectedInvocations), m.LoadDevicesMock.expectedInvocationsOrigin, afterLoadDevicesCounter)
	}
}

type mDeviceComponentMockSelectDevice struct {
	optional           bool
	mock               *DeviceComponentMock
	defaultExpectation *DeviceComponentMockSelectDeviceExpectation
	expectations       []*DeviceComponentMockSelectDeviceExpectation

	callArgs []*DeviceComponentMockSelectDeviceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceComponentMockSelectDeviceExpectation specifies expectation struct of the DeviceComponent.SelectDevice
type DeviceComponentMockSelectDeviceExpectation struct {
	mock               *DeviceComponentMock
	params             *DeviceComponentMockSelectDeviceParams
	paramPtrs          *DeviceComponentMockSelectDeviceParamPtrs
	expectationOrigins DeviceComponentMockSelectDeviceExpectationOrigins
	results            *DeviceComponentMockSelectDeviceResults
	returnOrigin       string
	Counter            uint64
}

// DeviceComponentMockSelectDeviceParams contains parameters of the DeviceComponent.SelectDevice
type DeviceComponentMockSelectDeviceParams struct {
	ctx    context.Context
	device string
}

// DeviceComponentMockSelectDeviceParamPtrs contains pointers to parameters of the DeviceComponent.SelectDevice
type DeviceComponentMockSelectDeviceParamPtrs struct {
	ctx    *context.Context
	device *string
}

// DeviceComponentMockSelectDeviceResults contains results of the DeviceComponent.SelectDevice
type DeviceComponentMockSelectDeviceResults struct {
	err error
}

// DeviceComponentMockSelectDeviceOrigins contains origins of expectations of the DeviceComponent.SelectDevice
type DeviceComponentMockSelectDeviceExpectationOrigins struct {
	origin       string
	originCtx    string
	originDevice string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectDevice *mDeviceComponentMockSelectDevice) Optional() *mDeviceComponentMockSelectDevice {
	mmSelectDevice.optional = true
	return mmSelectDevice
}

// Expect sets up expected params for DeviceComponent.SelectDevice
func (mmSelectDevice *mDeviceComponentMockSelectDevice) Expect(ctx context.Context, device string) *mDeviceComponentMockSelectDevice {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("DeviceComponentMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &DeviceComponentMockSelectDeviceExpectation{}
	}

	if mmSelectDevice.defaultExpectation.paramPtrs != nil {
		mmSelectDevice.mock.t.Fatalf("DeviceComponentMock.SelectDevice mock is already set by ExpectParams functions")
	}

	mmSelectDevice.defaultExpectation.params = &DeviceComponentMockSelectDeviceParams{ctx, device}
	mmSelectDevice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectDevice.expectations {
		if minimock.Equal(e.params, mmSelectDevice.defaultExpectation.params) {
			mmSelectDevice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectDevice.defaultExpectation.params)
		}
	}

	return mmSelectDevice
}

// ExpectCtxParam1 sets up expected param ctx for DeviceComponent.SelectDevice
func (mmSelectDevice *mDeviceComponentMockSelectDevice) ExpectCtxParam1(ctx context.Context) *mDeviceComponentMockSelectDevice {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("DeviceComponentMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &DeviceComponentMockSelectDeviceExpectation{}
	}

	if mmSelectDevice.defaultExpectation.params != nil {
		mmSelectDevice.mock.t.Fatalf("DeviceComponentMock.SelectDevice mock is already set by Expect")
	}

	if mmSelectDevice.defaultExpectation.paramPtrs == nil {
		mmSelectDevice.defaultExpectation.paramPtrs = &DeviceComponentMockSelectDeviceParamPtrs{}
	}
	mmSelectDevice.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectDevice.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectDevice
}

// ExpectDeviceParam2 sets up expected param device for DeviceComponent.SelectDevice
func (mmSelectDevice *mDeviceComponentMockSelectDevice) ExpectDeviceParam2(device string) *mDeviceComponentMockSelectDevice {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("DeviceComponentMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &DeviceComponentMockSelectDeviceExpectation{}
	}

	if mmSelectDevice.defaultExpectation.params != nil {
		mmSelectDevice.mock.t.Fatalf("DeviceComponentMock.SelectDevice mock is already set by Expect")
	}

	if mmSelectDevice.defaultExpectation.paramPtrs == nil {
		mmSelectDevice.defaultExpectation.paramPtrs = &DeviceComponentMockSelectDeviceParamPtrs{}
	}
	mmSelectDevice.defaultExpectation.paramPtrs.device = &device
	mmSelectDevice.defaultExpectation.expectationOrigins.originDevice = minimock.CallerInfo(1)

	return mmSelectDevice
}

// Inspect accepts an inspector function that has same arguments as the DeviceComponent.SelectDevice
func (mmSelectDevice *mDeviceComponentMockSelectDevice) Inspect(f func(ctx context.Context, device string)) *mDeviceComponentMockSelectDevice {
	if mmSelectDevice.mock.inspectFuncSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("Inspect function is already set for DeviceComponentMock.SelectDevice")
	}

	mmSelectDevice.mock.inspectFuncSelectDevice = f

	return mmSelectDevice
}

// Return sets up results that will be returned by DeviceComponent.SelectDevice
func (mmSelectDevice *mDeviceComponentMockSelectDevice) Return(err error) *DeviceComponentMock {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("DeviceComponentMock.SelectDevice mock is already set by Set")
	}

	if mmSelectDevice.defaultExpectation == nil {
		mmSelectDevice.defaultExpectation = &DeviceComponentMockSelectDeviceExpectation{mock: mmSelectDevice.mock}
	}
	mmSelectDevice.defaultExpectation.results = &DeviceComponentMockSelectDeviceResults{err}
	mmSelectDevice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectDevice.mock
}

// Set uses given function f to mock the DeviceComponent.SelectDevice method
func (mmSelectDevice *mDeviceComponentMockSelectDevice) Set(f func(ctx context.Context, device string) (err error)) *DeviceComponentMock {
	if mmSelectDevice.defaultExpectation != nil {
		mmSelectDevice.mock.t.Fatalf("Default expectation is already set for the DeviceComponent.SelectDevice method")
	}

	if len(mmSelectDevice.expectations) > 0 {
		mmSelectDevice.mock.t.Fatalf("Some expectations are already set for the DeviceComponent.SelectDevice method")
	}

	mmSelectDevice.mock.funcSelectDevice = f
	mmSelectDevice.mock.funcSelectDeviceOrigin = minimock.CallerInfo(1)
	return mmSelectDevice.mock
}

// When sets expectation for the DeviceComponent.SelectDevice which will trigger the result defined by the following
// Then helper
func (mmSelectDevice *mDeviceComponentMockSelectDevice) When(ctx context.Context, device string) *DeviceComponentMockSelectDeviceExpectation {
	if mmSelectDevice.mock.funcSelectDevice != nil {
		mmSelectDevice.mock.t.Fatalf("DeviceComponentMock.SelectDevice mock is already set by Set")
	}

	expectation := &DeviceComponentMockSelectDeviceExpectation{
		mock:               mmSelectDevice.mock,
		params:             &DeviceComponentMockSelectDeviceParams{ctx, device},
		expectationOrigins: DeviceComponentMockSelectDeviceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectDevice.expectations = append(mmSelectDevice.expectations, expectation)
	return expectation
}

// Then sets up DeviceComponent.SelectDevice return parameters for the expectation previously defined by the When method
func (e *DeviceComponentMockSelectDeviceExpectation) Then(err error) *DeviceComponentMock {
	e.results = &DeviceComponentMockSelectDeviceResults{err}
	return e.mock
}

// Times sets number of times DeviceComponent.SelectDevice should be invoked
func (mmSelectDevice *mDeviceComponentMockSelectDevice) Times(n uint64) *mDeviceComponentMockSelectDevice {
	if n == 0 {
		mmSelectDevice.mock.t.Fatalf("Times of DeviceComponentMock.SelectDevice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectDevice.expectedInvocations, n)
	mmSelectDevice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectDevice
}

func (mmSelectDevice *mDeviceComponentMockSelectDevice) invocationsDone() bool {
	if len(mmSelectDevice.expectations) == 0 && mmSelectDevice.defaultExpectation == nil && mmSelectDevice.mock.funcSelectDevice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectDevice.mock.afterSelectDeviceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectDevice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectDevice implements DeviceComponent
func (mmSelectDevice *DeviceComponentMock) SelectDevice(ctx context.Context, device string) (err error) {
	mm_atomic.AddUint64(&mmSelectDevice.beforeSelectDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectDevice.afterSelectDeviceCounter, 1)

	mmSelectDevice.t.Helper()

	if mmSelectDevice.inspectFuncSelectDevice != nil {
		mmSelectDevice.inspectFuncSelectDevice(ctx, device)
	}

	mm_params := DeviceComponentMockSelectDeviceParams{ctx, device}

	// Record call args
	mmSelectDevice.SelectDeviceMock.mutex.Lock()
	mmSelectDevice.SelectDeviceMock.callArgs = append(mmSelectDevice.SelectDeviceMock.callArgs, &mm_params)
	mmSelectDevice.SelectDeviceMock.mutex.Unlock()

	for _, e := range mmSelectDevice.SelectDeviceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelectDevice.SelectDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectDevice.SelectDeviceMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectDevice.SelectDeviceMock.defaultExpectation.params
		mm_want_ptrs := mmSelectDevice.SelectDeviceMock.defaultExpectation.paramPtrs

		mm_got := DeviceComponentMockSelectDeviceParams{ctx, device}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectDevice.t.Errorf("DeviceComponentMock.SelectDevice got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectDevice.SelectDeviceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.device != nil && !minimock.Equal(*mm_want_ptrs.device, mm_got.device) {
				mmSelectDevice.t.Errorf("DeviceComponentMock.SelectDevice got unexpected parameter device, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectDevice.SelectDeviceMock.defaultExpectation.expectationOrigins.originDevice, *mm_want_ptrs.device, mm_got.device, minimock.Diff(*mm_want_ptrs.device, mm_got.device))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectDevice.t.Errorf("DeviceComponentMock.SelectDevice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectDevice.SelectDeviceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectDevice.SelectDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectDevice.t.Fatal("No results are set for the DeviceComponentMock.SelectDevice")
		}
		return (*mm_results).err
	}
	if mmSelectDevice.funcSelectDevice != nil {
		return mmSelectDevice.funcSelectDevice(ctx, device)
	}
	mmSelectDevice.t.Fatalf("Unexpected call to DeviceComponentMock.SelectDevice. %v %v", ctx, device)
	return
}

// SelectDeviceAfterCounter returns a count of finished DeviceComponentMock.SelectDevice invocations
func (mmSelectDevice *DeviceComponentMock) SelectDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectDevice.afterSelectDeviceCounter)
}

// SelectDeviceBeforeCounter returns a count of DeviceComponentMock.SelectDevice invocations
func (mmSelectDevice *DeviceComponentMock) SelectDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectDevice.beforeSelectDeviceCounter)
}

// Calls returns a list of arguments used in each call to DeviceComponentMock.SelectDevice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectDevice *mDeviceComponentMockSelectDevice) Calls() []*DeviceComponentMockSelectDeviceParams {
	mmSelectDevice.mutex.RLock()

	argCopy := make([]*DeviceComponentMockSelectDeviceParams, len(mmSelectDevice.callArgs))
	copy(argCopy, mmSelectDevice.callArgs)

	mmSelectDevice.mutex.RUnlock()

	return argCopy
}

// MinimockSelectDeviceDone returns true if the count of the SelectDevice invocations corresponds
// the number of defined expectations
func (m *DeviceComponentMock) MinimockSelectDeviceDone() bool {
	if m.SelectDeviceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectDeviceMock.invocationsDone()
}

// MinimockSelectDeviceInspect logs each unmet expectation
func (m *DeviceComponentMock) MinimockSelectDeviceInspect() {
	for _, e := range m.SelectDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceComponentMock.SelectDevice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectDeviceCounter := mm_atomic.LoadUint64(&m.afterSelectDeviceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectDeviceMock.defaultExpectation != nil && afterSelectDeviceCounter < 1 {
		if m.SelectDeviceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceComponentMock.SelectDevice at\n%s", m.SelectDeviceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceComponentMock.SelectDevice at\n%s with params: %#v", m.SelectDeviceMock.defaultExpectation.expectationOrigins.origin, *m.SelectDeviceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectDevice != nil && afterSelectDeviceCounter < 1 {
		m.t.Errorf("Expected call to DeviceComponentMock.SelectDevice at\n%s", m.funcSelectDeviceOrigin)
	}

	if !m.SelectDeviceMock.invocationsDone() && afterSelectDeviceCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceComponentMock.SelectDevice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectDeviceMock.expectedInvocations), m.SelectDeviceMock.expectedInvocationsOrigin, afterSelectDeviceCounter)
	}
}

type mDeviceComponentMockSelectedDevice struct {
	optional           bool
	mock               *DeviceComponentMock
	defaultExpectation *DeviceComponentMockSelectedDeviceExpectation
	expectations       []*DeviceComponentMockSelectedDeviceExpectation

	callArgs []*DeviceComponentMockSelectedDeviceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceComponentMockSelectedDeviceExpectation specifies expectation struct of the DeviceComponent.SelectedDevice
type DeviceComponentMockSelectedDeviceExpectation struct {
	mock               *DeviceComponentMock
	params             *DeviceComponentMockSelectedDeviceParams
	paramPtrs          *DeviceComponentMockSelectedDeviceParamPtrs
	expectationOrigins DeviceComponentMockSelectedDeviceExpectationOrigins
	results            *DeviceComponentMockSelectedDeviceResults
	returnOrigin       string
	Counter            uint64
}

// DeviceComponentMockSelectedDeviceParams contains parameters of the DeviceComponent.SelectedDevice
type DeviceComponentMockSelectedDeviceParams struct {
	ctx context.Context
}

// DeviceComponentMockSelectedDeviceParamPtrs contains pointers to parameters of the DeviceComponent.SelectedDevice
type DeviceComponentMockSelectedDeviceParamPtrs struct {
	ctx *context.Context
}

// DeviceComponentMockSelectedDeviceResults contains results of the DeviceComponent.SelectedDevice
type DeviceComponentMockSelectedDeviceResults struct {
	s1  string
	err error
}

// DeviceComponentMockSelectedDeviceOrigins contains origins of expectations of the DeviceComponent.SelectedDevice
type DeviceComponentMockSelectedDeviceExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectedDevice *mDeviceComponentMockSelectedDevice) Optional() *mDeviceComponentMockSelectedDevice {
	mmSelectedDevice.optional = true
	return mmSelectedDevice
}

// Expect sets up expected params for DeviceComponent.SelectedDevice
func (mmSelectedDevice *mDeviceComponentMockSelectedDevice) Expect(ctx context.Context) *mDeviceComponentMockSelectedDevice {
	if mmSelectedDevice.mock.funcSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("DeviceComponentMock.SelectedDevice mock is already set by Set")
	}

	if mmSelectedDevice.defaultExpectation == nil {
		mmSelectedDevice.defaultExpectation = &DeviceComponentMockSelectedDeviceExpectation{}
	}

	if mmSelectedDevice.defaultExpectation.paramPtrs != nil {
		mmSelectedDevice.mock.t.Fatalf("DeviceComponentMock.SelectedDevice mock is already set by ExpectParams functions")
	}

	mmSelectedDevice.defaultExpectation.params = &DeviceComponentMockSelectedDeviceParams{ctx}
	mmSelectedDevice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectedDevice.expectations {
		if minimock.Equal(e.params, mmSelectedDevice.defaultExpectation.params) {
			mmSelectedDevice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectedDevice.defaultExpectation.params)
		}
	}

	return mmSelectedDevice
}

// ExpectCtxParam1 sets up expected param ctx for DeviceComponent.SelectedDevice
func (mmSelectedDevice *mDeviceComponentMockSelectedDevice) ExpectCtxParam1(ctx context.Context) *mDeviceComponentMockSelectedDevice {
	if mmSelectedDevice.mock.funcSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("DeviceComponentMock.SelectedDevice mock is already set by Set")
	}

	if mmSelectedDevice.defaultExpectation == nil {
		mmSelectedDevice.defaultExpectation = &DeviceComponentMockSelectedDeviceExpectation{}
	}

	if mmSelectedDevice.defaultExpectation.params != nil {
		mmSelectedDevice.mock.t.Fatalf("DeviceComponentMock.SelectedDevice mock is already set by Expect")
	}

	if mmSelectedDevice.defaultExpectation.paramPtrs == nil {
		mmSelectedDevice.defaultExpectation.paramPtrs = &DeviceComponentMockSelectedDeviceParamPtrs{}
	}
	mmSelectedDevice.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectedDevice.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectedDevice
}

// Inspect accepts an inspector function that has same arguments as the DeviceComponent.SelectedDevice
func (mmSelectedDevice *mDeviceComponentMockSelectedDevice) Inspect(f func(ctx context.Context)) *mDeviceComponentMockSelectedDevice {
	if mmSelectedDevice.mock.inspectFuncSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("Inspect function is already set for DeviceComponentMock.SelectedDevice")
	}

	mmSelectedDevice.mock.inspectFuncSelectedDevice = f

	return mmSelectedDevice
}

// Return sets up results that will be returned by DeviceComponent.SelectedDevice
func (mmSelectedDevice *mDeviceComponentMockSelectedDevice) Return(s1 string, err error) *DeviceComponentMock {
	if mmSelectedDevice.mock.funcSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("DeviceComponentMock.SelectedDevice mock is already set by Set")
	}

	if mmSelectedDevice.defaultExpectation == nil {
		mmSelectedDevice.defaultExpectation = &DeviceComponentMockSelectedDeviceExpectation{mock: mmSelectedDevice.mock}
	}
	mmSelectedDevice.defaultExpectation.results = &DeviceComponentMockSelectedDeviceResults{s1, err}
	mmSelectedDevice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectedDevice.mock
}

// Set uses given function f to mock the DeviceComponent.SelectedDevice method
func (mmSelectedDevice *mDeviceComponentMockSelectedDevice) Set(f func(ctx context.Context) (s1 string, err error)) *DeviceComponentMock {
	if mmSelectedDevice.defaultExpectation != nil {
		mmSelectedDevice.mock.t.Fatalf("Default expectation is already set for the DeviceComponent.SelectedDevice method")
	}

	if len(mmSelectedDevice.expectations) > 0 {
		mmSelectedDevice.mock.t.Fatalf("Some expectations are already set for the DeviceComponent.SelectedDevice method")
	}

	mmSelectedDevice.mock.funcSelectedDevice = f
	mmSelectedDevice.mock.funcSelectedDeviceOrigin = minimock.CallerInfo(1)
	return mmSelectedDevice.mock
}

// When sets expectation for the DeviceComponent.SelectedDevice which will trigger the result defined by the following
// Then helper
func (mmSelectedDevice *mDeviceComponentMockSelectedDevice) When(ctx context.Context) *DeviceComponentMockSelectedDeviceExpectation {
	if mmSelectedDevice.mock.funcSelectedDevice != nil {
		mmSelectedDevice.mock.t.Fatalf("DeviceComponentMock.SelectedDevice mock is already set by Set")
	}

	expectation := &DeviceComponentMockSelectedDeviceExpectation{
		mock:               mmSelectedDevice.mock,
		params:             &DeviceComponentMockSelectedDeviceParams{ctx},
		expectationOrigins: DeviceComponentMockSelectedDeviceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectedDevice.expectations = append(mmSelectedDevice.expectations, expectation)
	return expectation
}

// Then sets up DeviceComponent.SelectedDevice return parameters for the expectation previously defined by the When method
func (e *DeviceComponentMockSelectedDeviceExpectation) Then(s1 string, err error) *DeviceComponentMock {
	e.results = &DeviceComponentMockSelectedDeviceResults{s1, err}
	return e.mock
}

// Times sets number of times DeviceComponent.SelectedDevice should be invoked
func (mmSelectedDevice *mDeviceComponentMockSelectedDevice) Times(n uint64) *mDeviceComponentMockSelectedDevice {
	if n == 0 {
		mmSelectedDevice.mock.t.Fatalf("Times of DeviceComponentMock.SelectedDevice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectedDevice.expectedInvocations, n)
	mmSelectedDevice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectedDevice
}

func (mmSelectedDevice *mDeviceComponentMockSelectedDevice) invocationsDone() bool {
	if len(mmSelectedDevice.expectations) == 0 && mmSelectedDevice.defaultExpectation == nil && mmSelectedDevice.mock.funcSelectedDevice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectedDevice.mock.afterSelectedDeviceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectedDevice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectedDevice implements DeviceComponent
func (mmSelectedDevice *DeviceComponentMock) SelectedDevice(ctx context.Context) (s1 string, err error) {
	mm_atomic.AddUint64(&mmSelectedDevice.beforeSelectedDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectedDevice.afterSelectedDeviceCounter, 1)

	mmSelectedDevice.t.Helper()

	if mmSelectedDevice.inspectFuncSelectedDevice != nil {
		mmSelectedDevice.inspectFuncSelectedDevice(ctx)
	}

	mm_params := DeviceComponentMockSelectedDeviceParams{ctx}

	// Record call args
	mmSelectedDevice.SelectedDeviceMock.mutex.Lock()
	mmSelectedDevice.SelectedDeviceMock.callArgs = append(mmSelectedDevice.SelectedDeviceMock.callArgs, &mm_params)
	mmSelectedDevice.SelectedDeviceMock.mutex.Unlock()

	for _, e := range mmSelectedDevice.SelectedDeviceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmSelectedDevice.SelectedDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectedDevice.SelectedDeviceMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectedDevice.SelectedDeviceMock.defaultExpectation.params
		mm_want_ptrs := mmSelectedDevice.SelectedDeviceMock.defaultExpectation.paramPtrs

		mm_got := DeviceComponentMockSelectedDeviceParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectedDevice.t.Errorf("DeviceComponentMock.SelectedDevice got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectedDevice.SelectedDeviceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectedDevice.t.Errorf("DeviceComponentMock.SelectedDevice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectedDevice.SelectedDeviceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectedDevice.SelectedDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectedDevice.t.Fatal("No results are set for the DeviceComponentMock.SelectedDevice")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmSelectedDevice.funcSelectedDevice != nil {
		return mmSelectedDevice.funcSelectedDevice(ctx)
	}
	mmSelectedDevice.t.Fatalf("Unexpected call to DeviceComponentMock.SelectedDevice. %v", ctx)
	return
}

// SelectedDeviceAfterCounter returns a count of finished DeviceComponentMock.SelectedDevice invocations
func (mmSelectedDevice *DeviceComponentMock) SelectedDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedDevice.afterSelectedDeviceCounter)
}

// SelectedDeviceBeforeCounter returns a count of DeviceComponentMock.SelectedDevice invocations
func (mmSelectedDevice *DeviceComponentMock) SelectedDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectedDevice.beforeSelectedDeviceCounter)
}

// Calls returns a list of arguments used in each call to DeviceComponentMock.SelectedDevice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectedDevice *mDeviceComponentMockSelectedDevice) Calls() []*DeviceComponentMockSelectedDeviceParams {
	mmSelectedDevice.mutex.RLock()

	argCopy := make([]*DeviceComponentMockSelectedDeviceParams, len(mmSelectedDevice.callArgs))
	copy(argCopy, mmSelectedDevice.callArgs)

	mmSelectedDevice.mutex.RUnlock()

	return argCopy
}

// MinimockSelectedDeviceDone returns true if the count of the SelectedDevice invocations corresponds
// the number of defined expectations
func (m *DeviceComponentMock) MinimockSelectedDeviceDone() bool {
	if m.SelectedDeviceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectedDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectedDeviceMock.invocationsDone()
}

// MinimockSelectedDeviceInspect logs each unmet expectation
func (m *DeviceComponentMock) MinimockSelectedDeviceInspect() {
	for _, e := range m.SelectedDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceComponentMock.SelectedDevice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectedDeviceCounter := mm_atomic.LoadUint64(&m.afterSelectedDeviceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectedDeviceMock.defaultExpectation != nil && afterSelectedDeviceCounter < 1 {
		if m.SelectedDeviceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceComponentMock.SelectedDevice at\n%s", m.SelectedDeviceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceComponentMock.SelectedDevice at\n%s with params: %#v", m.SelectedDeviceMock.defaultExpectation.expectationOrigins.origin, *m.SelectedDeviceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectedDevice != nil && afterSelectedDeviceCounter < 1 {
		m.t.Errorf("Expected call to DeviceComponentMock.SelectedDevice at\n%s", m.funcSelectedDeviceOrigin)
	}

	if !m.SelectedDeviceMock.invocationsDone() && afterSelectedDeviceCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceComponentMock.SelectedDevice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectedDeviceMock.expectedInvocations), m.SelectedDeviceMock.expectedInvocationsOrigin, afterSelectedDeviceCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DeviceComponentMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockIsAvailableInspect()

			m.MinimockLoadDevicesInspect()

			m.MinimockSelectDeviceInspect()

			m.MinimockSelectedDeviceInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DeviceComponentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DeviceComponentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIsAvailableDone() &&
		m.MinimockLoadDevicesDone() &&
		m.MinimockSelectDeviceDone() &&
		m.MinimockSelectedDeviceDone()
}
