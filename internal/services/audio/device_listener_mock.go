// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package audio

import (
	"context"
	audiowrapper "github.com/roboloop/live2text/internal/services/audio_wrapper"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// DeviceListenerMock implements DeviceListener
type DeviceListenerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetChannel          func() (ch1 <-chan []int16)
	funcGetChannelOrigin    string
	inspectFuncGetChannel   func()
	afterGetChannelCounter  uint64
	beforeGetChannelCounter uint64
	GetChannelMock          mDeviceListenerMockGetChannel

	funcGetParameters          func() (sp1 *audiowrapper.StreamParameters)
	funcGetParametersOrigin    string
	inspectFuncGetParameters   func()
	afterGetParametersCounter  uint64
	beforeGetParametersCounter uint64
	GetParametersMock          mDeviceListenerMockGetParameters

	funcListen          func(ctx context.Context) (err error)
	funcListenOrigin    string
	inspectFuncListen   func(ctx context.Context)
	afterListenCounter  uint64
	beforeListenCounter uint64
	ListenMock          mDeviceListenerMockListen
}

// NewDeviceListenerMock returns a mock for DeviceListener
func NewDeviceListenerMock(t minimock.Tester) *DeviceListenerMock {
	m := &DeviceListenerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetChannelMock = mDeviceListenerMockGetChannel{mock: m}

	m.GetParametersMock = mDeviceListenerMockGetParameters{mock: m}

	m.ListenMock = mDeviceListenerMockListen{mock: m}
	m.ListenMock.callArgs = []*DeviceListenerMockListenParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mDeviceListenerMockGetChannel struct {
	optional           bool
	mock               *DeviceListenerMock
	defaultExpectation *DeviceListenerMockGetChannelExpectation
	expectations       []*DeviceListenerMockGetChannelExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceListenerMockGetChannelExpectation specifies expectation struct of the DeviceListener.GetChannel
type DeviceListenerMockGetChannelExpectation struct {
	mock *DeviceListenerMock

	results      *DeviceListenerMockGetChannelResults
	returnOrigin string
	Counter      uint64
}

// DeviceListenerMockGetChannelResults contains results of the DeviceListener.GetChannel
type DeviceListenerMockGetChannelResults struct {
	ch1 <-chan []int16
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChannel *mDeviceListenerMockGetChannel) Optional() *mDeviceListenerMockGetChannel {
	mmGetChannel.optional = true
	return mmGetChannel
}

// Expect sets up expected params for DeviceListener.GetChannel
func (mmGetChannel *mDeviceListenerMockGetChannel) Expect() *mDeviceListenerMockGetChannel {
	if mmGetChannel.mock.funcGetChannel != nil {
		mmGetChannel.mock.t.Fatalf("DeviceListenerMock.GetChannel mock is already set by Set")
	}

	if mmGetChannel.defaultExpectation == nil {
		mmGetChannel.defaultExpectation = &DeviceListenerMockGetChannelExpectation{}
	}

	return mmGetChannel
}

// Inspect accepts an inspector function that has same arguments as the DeviceListener.GetChannel
func (mmGetChannel *mDeviceListenerMockGetChannel) Inspect(f func()) *mDeviceListenerMockGetChannel {
	if mmGetChannel.mock.inspectFuncGetChannel != nil {
		mmGetChannel.mock.t.Fatalf("Inspect function is already set for DeviceListenerMock.GetChannel")
	}

	mmGetChannel.mock.inspectFuncGetChannel = f

	return mmGetChannel
}

// Return sets up results that will be returned by DeviceListener.GetChannel
func (mmGetChannel *mDeviceListenerMockGetChannel) Return(ch1 <-chan []int16) *DeviceListenerMock {
	if mmGetChannel.mock.funcGetChannel != nil {
		mmGetChannel.mock.t.Fatalf("DeviceListenerMock.GetChannel mock is already set by Set")
	}

	if mmGetChannel.defaultExpectation == nil {
		mmGetChannel.defaultExpectation = &DeviceListenerMockGetChannelExpectation{mock: mmGetChannel.mock}
	}
	mmGetChannel.defaultExpectation.results = &DeviceListenerMockGetChannelResults{ch1}
	mmGetChannel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChannel.mock
}

// Set uses given function f to mock the DeviceListener.GetChannel method
func (mmGetChannel *mDeviceListenerMockGetChannel) Set(f func() (ch1 <-chan []int16)) *DeviceListenerMock {
	if mmGetChannel.defaultExpectation != nil {
		mmGetChannel.mock.t.Fatalf("Default expectation is already set for the DeviceListener.GetChannel method")
	}

	if len(mmGetChannel.expectations) > 0 {
		mmGetChannel.mock.t.Fatalf("Some expectations are already set for the DeviceListener.GetChannel method")
	}

	mmGetChannel.mock.funcGetChannel = f
	mmGetChannel.mock.funcGetChannelOrigin = minimock.CallerInfo(1)
	return mmGetChannel.mock
}

// Times sets number of times DeviceListener.GetChannel should be invoked
func (mmGetChannel *mDeviceListenerMockGetChannel) Times(n uint64) *mDeviceListenerMockGetChannel {
	if n == 0 {
		mmGetChannel.mock.t.Fatalf("Times of DeviceListenerMock.GetChannel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChannel.expectedInvocations, n)
	mmGetChannel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChannel
}

func (mmGetChannel *mDeviceListenerMockGetChannel) invocationsDone() bool {
	if len(mmGetChannel.expectations) == 0 && mmGetChannel.defaultExpectation == nil && mmGetChannel.mock.funcGetChannel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChannel.mock.afterGetChannelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChannel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChannel implements DeviceListener
func (mmGetChannel *DeviceListenerMock) GetChannel() (ch1 <-chan []int16) {
	mm_atomic.AddUint64(&mmGetChannel.beforeGetChannelCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChannel.afterGetChannelCounter, 1)

	mmGetChannel.t.Helper()

	if mmGetChannel.inspectFuncGetChannel != nil {
		mmGetChannel.inspectFuncGetChannel()
	}

	if mmGetChannel.GetChannelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChannel.GetChannelMock.defaultExpectation.Counter, 1)

		mm_results := mmGetChannel.GetChannelMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChannel.t.Fatal("No results are set for the DeviceListenerMock.GetChannel")
		}
		return (*mm_results).ch1
	}
	if mmGetChannel.funcGetChannel != nil {
		return mmGetChannel.funcGetChannel()
	}
	mmGetChannel.t.Fatalf("Unexpected call to DeviceListenerMock.GetChannel.")
	return
}

// GetChannelAfterCounter returns a count of finished DeviceListenerMock.GetChannel invocations
func (mmGetChannel *DeviceListenerMock) GetChannelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChannel.afterGetChannelCounter)
}

// GetChannelBeforeCounter returns a count of DeviceListenerMock.GetChannel invocations
func (mmGetChannel *DeviceListenerMock) GetChannelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChannel.beforeGetChannelCounter)
}

// MinimockGetChannelDone returns true if the count of the GetChannel invocations corresponds
// the number of defined expectations
func (m *DeviceListenerMock) MinimockGetChannelDone() bool {
	if m.GetChannelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChannelMock.invocationsDone()
}

// MinimockGetChannelInspect logs each unmet expectation
func (m *DeviceListenerMock) MinimockGetChannelInspect() {
	for _, e := range m.GetChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DeviceListenerMock.GetChannel")
		}
	}

	afterGetChannelCounter := mm_atomic.LoadUint64(&m.afterGetChannelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChannelMock.defaultExpectation != nil && afterGetChannelCounter < 1 {
		m.t.Errorf("Expected call to DeviceListenerMock.GetChannel at\n%s", m.GetChannelMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChannel != nil && afterGetChannelCounter < 1 {
		m.t.Errorf("Expected call to DeviceListenerMock.GetChannel at\n%s", m.funcGetChannelOrigin)
	}

	if !m.GetChannelMock.invocationsDone() && afterGetChannelCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceListenerMock.GetChannel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChannelMock.expectedInvocations), m.GetChannelMock.expectedInvocationsOrigin, afterGetChannelCounter)
	}
}

type mDeviceListenerMockGetParameters struct {
	optional           bool
	mock               *DeviceListenerMock
	defaultExpectation *DeviceListenerMockGetParametersExpectation
	expectations       []*DeviceListenerMockGetParametersExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceListenerMockGetParametersExpectation specifies expectation struct of the DeviceListener.GetParameters
type DeviceListenerMockGetParametersExpectation struct {
	mock *DeviceListenerMock

	results      *DeviceListenerMockGetParametersResults
	returnOrigin string
	Counter      uint64
}

// DeviceListenerMockGetParametersResults contains results of the DeviceListener.GetParameters
type DeviceListenerMockGetParametersResults struct {
	sp1 *audiowrapper.StreamParameters
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetParameters *mDeviceListenerMockGetParameters) Optional() *mDeviceListenerMockGetParameters {
	mmGetParameters.optional = true
	return mmGetParameters
}

// Expect sets up expected params for DeviceListener.GetParameters
func (mmGetParameters *mDeviceListenerMockGetParameters) Expect() *mDeviceListenerMockGetParameters {
	if mmGetParameters.mock.funcGetParameters != nil {
		mmGetParameters.mock.t.Fatalf("DeviceListenerMock.GetParameters mock is already set by Set")
	}

	if mmGetParameters.defaultExpectation == nil {
		mmGetParameters.defaultExpectation = &DeviceListenerMockGetParametersExpectation{}
	}

	return mmGetParameters
}

// Inspect accepts an inspector function that has same arguments as the DeviceListener.GetParameters
func (mmGetParameters *mDeviceListenerMockGetParameters) Inspect(f func()) *mDeviceListenerMockGetParameters {
	if mmGetParameters.mock.inspectFuncGetParameters != nil {
		mmGetParameters.mock.t.Fatalf("Inspect function is already set for DeviceListenerMock.GetParameters")
	}

	mmGetParameters.mock.inspectFuncGetParameters = f

	return mmGetParameters
}

// Return sets up results that will be returned by DeviceListener.GetParameters
func (mmGetParameters *mDeviceListenerMockGetParameters) Return(sp1 *audiowrapper.StreamParameters) *DeviceListenerMock {
	if mmGetParameters.mock.funcGetParameters != nil {
		mmGetParameters.mock.t.Fatalf("DeviceListenerMock.GetParameters mock is already set by Set")
	}

	if mmGetParameters.defaultExpectation == nil {
		mmGetParameters.defaultExpectation = &DeviceListenerMockGetParametersExpectation{mock: mmGetParameters.mock}
	}
	mmGetParameters.defaultExpectation.results = &DeviceListenerMockGetParametersResults{sp1}
	mmGetParameters.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetParameters.mock
}

// Set uses given function f to mock the DeviceListener.GetParameters method
func (mmGetParameters *mDeviceListenerMockGetParameters) Set(f func() (sp1 *audiowrapper.StreamParameters)) *DeviceListenerMock {
	if mmGetParameters.defaultExpectation != nil {
		mmGetParameters.mock.t.Fatalf("Default expectation is already set for the DeviceListener.GetParameters method")
	}

	if len(mmGetParameters.expectations) > 0 {
		mmGetParameters.mock.t.Fatalf("Some expectations are already set for the DeviceListener.GetParameters method")
	}

	mmGetParameters.mock.funcGetParameters = f
	mmGetParameters.mock.funcGetParametersOrigin = minimock.CallerInfo(1)
	return mmGetParameters.mock
}

// Times sets number of times DeviceListener.GetParameters should be invoked
func (mmGetParameters *mDeviceListenerMockGetParameters) Times(n uint64) *mDeviceListenerMockGetParameters {
	if n == 0 {
		mmGetParameters.mock.t.Fatalf("Times of DeviceListenerMock.GetParameters mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetParameters.expectedInvocations, n)
	mmGetParameters.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetParameters
}

func (mmGetParameters *mDeviceListenerMockGetParameters) invocationsDone() bool {
	if len(mmGetParameters.expectations) == 0 && mmGetParameters.defaultExpectation == nil && mmGetParameters.mock.funcGetParameters == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetParameters.mock.afterGetParametersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetParameters.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetParameters implements DeviceListener
func (mmGetParameters *DeviceListenerMock) GetParameters() (sp1 *audiowrapper.StreamParameters) {
	mm_atomic.AddUint64(&mmGetParameters.beforeGetParametersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetParameters.afterGetParametersCounter, 1)

	mmGetParameters.t.Helper()

	if mmGetParameters.inspectFuncGetParameters != nil {
		mmGetParameters.inspectFuncGetParameters()
	}

	if mmGetParameters.GetParametersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetParameters.GetParametersMock.defaultExpectation.Counter, 1)

		mm_results := mmGetParameters.GetParametersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetParameters.t.Fatal("No results are set for the DeviceListenerMock.GetParameters")
		}
		return (*mm_results).sp1
	}
	if mmGetParameters.funcGetParameters != nil {
		return mmGetParameters.funcGetParameters()
	}
	mmGetParameters.t.Fatalf("Unexpected call to DeviceListenerMock.GetParameters.")
	return
}

// GetParametersAfterCounter returns a count of finished DeviceListenerMock.GetParameters invocations
func (mmGetParameters *DeviceListenerMock) GetParametersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetParameters.afterGetParametersCounter)
}

// GetParametersBeforeCounter returns a count of DeviceListenerMock.GetParameters invocations
func (mmGetParameters *DeviceListenerMock) GetParametersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetParameters.beforeGetParametersCounter)
}

// MinimockGetParametersDone returns true if the count of the GetParameters invocations corresponds
// the number of defined expectations
func (m *DeviceListenerMock) MinimockGetParametersDone() bool {
	if m.GetParametersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetParametersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetParametersMock.invocationsDone()
}

// MinimockGetParametersInspect logs each unmet expectation
func (m *DeviceListenerMock) MinimockGetParametersInspect() {
	for _, e := range m.GetParametersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DeviceListenerMock.GetParameters")
		}
	}

	afterGetParametersCounter := mm_atomic.LoadUint64(&m.afterGetParametersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetParametersMock.defaultExpectation != nil && afterGetParametersCounter < 1 {
		m.t.Errorf("Expected call to DeviceListenerMock.GetParameters at\n%s", m.GetParametersMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetParameters != nil && afterGetParametersCounter < 1 {
		m.t.Errorf("Expected call to DeviceListenerMock.GetParameters at\n%s", m.funcGetParametersOrigin)
	}

	if !m.GetParametersMock.invocationsDone() && afterGetParametersCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceListenerMock.GetParameters at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetParametersMock.expectedInvocations), m.GetParametersMock.expectedInvocationsOrigin, afterGetParametersCounter)
	}
}

type mDeviceListenerMockListen struct {
	optional           bool
	mock               *DeviceListenerMock
	defaultExpectation *DeviceListenerMockListenExpectation
	expectations       []*DeviceListenerMockListenExpectation

	callArgs []*DeviceListenerMockListenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceListenerMockListenExpectation specifies expectation struct of the DeviceListener.Listen
type DeviceListenerMockListenExpectation struct {
	mock               *DeviceListenerMock
	params             *DeviceListenerMockListenParams
	paramPtrs          *DeviceListenerMockListenParamPtrs
	expectationOrigins DeviceListenerMockListenExpectationOrigins
	results            *DeviceListenerMockListenResults
	returnOrigin       string
	Counter            uint64
}

// DeviceListenerMockListenParams contains parameters of the DeviceListener.Listen
type DeviceListenerMockListenParams struct {
	ctx context.Context
}

// DeviceListenerMockListenParamPtrs contains pointers to parameters of the DeviceListener.Listen
type DeviceListenerMockListenParamPtrs struct {
	ctx *context.Context
}

// DeviceListenerMockListenResults contains results of the DeviceListener.Listen
type DeviceListenerMockListenResults struct {
	err error
}

// DeviceListenerMockListenOrigins contains origins of expectations of the DeviceListener.Listen
type DeviceListenerMockListenExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListen *mDeviceListenerMockListen) Optional() *mDeviceListenerMockListen {
	mmListen.optional = true
	return mmListen
}

// Expect sets up expected params for DeviceListener.Listen
func (mmListen *mDeviceListenerMockListen) Expect(ctx context.Context) *mDeviceListenerMockListen {
	if mmListen.mock.funcListen != nil {
		mmListen.mock.t.Fatalf("DeviceListenerMock.Listen mock is already set by Set")
	}

	if mmListen.defaultExpectation == nil {
		mmListen.defaultExpectation = &DeviceListenerMockListenExpectation{}
	}

	if mmListen.defaultExpectation.paramPtrs != nil {
		mmListen.mock.t.Fatalf("DeviceListenerMock.Listen mock is already set by ExpectParams functions")
	}

	mmListen.defaultExpectation.params = &DeviceListenerMockListenParams{ctx}
	mmListen.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListen.expectations {
		if minimock.Equal(e.params, mmListen.defaultExpectation.params) {
			mmListen.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListen.defaultExpectation.params)
		}
	}

	return mmListen
}

// ExpectCtxParam1 sets up expected param ctx for DeviceListener.Listen
func (mmListen *mDeviceListenerMockListen) ExpectCtxParam1(ctx context.Context) *mDeviceListenerMockListen {
	if mmListen.mock.funcListen != nil {
		mmListen.mock.t.Fatalf("DeviceListenerMock.Listen mock is already set by Set")
	}

	if mmListen.defaultExpectation == nil {
		mmListen.defaultExpectation = &DeviceListenerMockListenExpectation{}
	}

	if mmListen.defaultExpectation.params != nil {
		mmListen.mock.t.Fatalf("DeviceListenerMock.Listen mock is already set by Expect")
	}

	if mmListen.defaultExpectation.paramPtrs == nil {
		mmListen.defaultExpectation.paramPtrs = &DeviceListenerMockListenParamPtrs{}
	}
	mmListen.defaultExpectation.paramPtrs.ctx = &ctx
	mmListen.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListen
}

// Inspect accepts an inspector function that has same arguments as the DeviceListener.Listen
func (mmListen *mDeviceListenerMockListen) Inspect(f func(ctx context.Context)) *mDeviceListenerMockListen {
	if mmListen.mock.inspectFuncListen != nil {
		mmListen.mock.t.Fatalf("Inspect function is already set for DeviceListenerMock.Listen")
	}

	mmListen.mock.inspectFuncListen = f

	return mmListen
}

// Return sets up results that will be returned by DeviceListener.Listen
func (mmListen *mDeviceListenerMockListen) Return(err error) *DeviceListenerMock {
	if mmListen.mock.funcListen != nil {
		mmListen.mock.t.Fatalf("DeviceListenerMock.Listen mock is already set by Set")
	}

	if mmListen.defaultExpectation == nil {
		mmListen.defaultExpectation = &DeviceListenerMockListenExpectation{mock: mmListen.mock}
	}
	mmListen.defaultExpectation.results = &DeviceListenerMockListenResults{err}
	mmListen.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListen.mock
}

// Set uses given function f to mock the DeviceListener.Listen method
func (mmListen *mDeviceListenerMockListen) Set(f func(ctx context.Context) (err error)) *DeviceListenerMock {
	if mmListen.defaultExpectation != nil {
		mmListen.mock.t.Fatalf("Default expectation is already set for the DeviceListener.Listen method")
	}

	if len(mmListen.expectations) > 0 {
		mmListen.mock.t.Fatalf("Some expectations are already set for the DeviceListener.Listen method")
	}

	mmListen.mock.funcListen = f
	mmListen.mock.funcListenOrigin = minimock.CallerInfo(1)
	return mmListen.mock
}

// When sets expectation for the DeviceListener.Listen which will trigger the result defined by the following
// Then helper
func (mmListen *mDeviceListenerMockListen) When(ctx context.Context) *DeviceListenerMockListenExpectation {
	if mmListen.mock.funcListen != nil {
		mmListen.mock.t.Fatalf("DeviceListenerMock.Listen mock is already set by Set")
	}

	expectation := &DeviceListenerMockListenExpectation{
		mock:               mmListen.mock,
		params:             &DeviceListenerMockListenParams{ctx},
		expectationOrigins: DeviceListenerMockListenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListen.expectations = append(mmListen.expectations, expectation)
	return expectation
}

// Then sets up DeviceListener.Listen return parameters for the expectation previously defined by the When method
func (e *DeviceListenerMockListenExpectation) Then(err error) *DeviceListenerMock {
	e.results = &DeviceListenerMockListenResults{err}
	return e.mock
}

// Times sets number of times DeviceListener.Listen should be invoked
func (mmListen *mDeviceListenerMockListen) Times(n uint64) *mDeviceListenerMockListen {
	if n == 0 {
		mmListen.mock.t.Fatalf("Times of DeviceListenerMock.Listen mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListen.expectedInvocations, n)
	mmListen.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListen
}

func (mmListen *mDeviceListenerMockListen) invocationsDone() bool {
	if len(mmListen.expectations) == 0 && mmListen.defaultExpectation == nil && mmListen.mock.funcListen == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListen.mock.afterListenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListen.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Listen implements DeviceListener
func (mmListen *DeviceListenerMock) Listen(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmListen.beforeListenCounter, 1)
	defer mm_atomic.AddUint64(&mmListen.afterListenCounter, 1)

	mmListen.t.Helper()

	if mmListen.inspectFuncListen != nil {
		mmListen.inspectFuncListen(ctx)
	}

	mm_params := DeviceListenerMockListenParams{ctx}

	// Record call args
	mmListen.ListenMock.mutex.Lock()
	mmListen.ListenMock.callArgs = append(mmListen.ListenMock.callArgs, &mm_params)
	mmListen.ListenMock.mutex.Unlock()

	for _, e := range mmListen.ListenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmListen.ListenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListen.ListenMock.defaultExpectation.Counter, 1)
		mm_want := mmListen.ListenMock.defaultExpectation.params
		mm_want_ptrs := mmListen.ListenMock.defaultExpectation.paramPtrs

		mm_got := DeviceListenerMockListenParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListen.t.Errorf("DeviceListenerMock.Listen got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListen.ListenMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListen.t.Errorf("DeviceListenerMock.Listen got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListen.ListenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListen.ListenMock.defaultExpectation.results
		if mm_results == nil {
			mmListen.t.Fatal("No results are set for the DeviceListenerMock.Listen")
		}
		return (*mm_results).err
	}
	if mmListen.funcListen != nil {
		return mmListen.funcListen(ctx)
	}
	mmListen.t.Fatalf("Unexpected call to DeviceListenerMock.Listen. %v", ctx)
	return
}

// ListenAfterCounter returns a count of finished DeviceListenerMock.Listen invocations
func (mmListen *DeviceListenerMock) ListenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListen.afterListenCounter)
}

// ListenBeforeCounter returns a count of DeviceListenerMock.Listen invocations
func (mmListen *DeviceListenerMock) ListenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListen.beforeListenCounter)
}

// Calls returns a list of arguments used in each call to DeviceListenerMock.Listen.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListen *mDeviceListenerMockListen) Calls() []*DeviceListenerMockListenParams {
	mmListen.mutex.RLock()

	argCopy := make([]*DeviceListenerMockListenParams, len(mmListen.callArgs))
	copy(argCopy, mmListen.callArgs)

	mmListen.mutex.RUnlock()

	return argCopy
}

// MinimockListenDone returns true if the count of the Listen invocations corresponds
// the number of defined expectations
func (m *DeviceListenerMock) MinimockListenDone() bool {
	if m.ListenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListenMock.invocationsDone()
}

// MinimockListenInspect logs each unmet expectation
func (m *DeviceListenerMock) MinimockListenInspect() {
	for _, e := range m.ListenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceListenerMock.Listen at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListenCounter := mm_atomic.LoadUint64(&m.afterListenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListenMock.defaultExpectation != nil && afterListenCounter < 1 {
		if m.ListenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceListenerMock.Listen at\n%s", m.ListenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceListenerMock.Listen at\n%s with params: %#v", m.ListenMock.defaultExpectation.expectationOrigins.origin, *m.ListenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListen != nil && afterListenCounter < 1 {
		m.t.Errorf("Expected call to DeviceListenerMock.Listen at\n%s", m.funcListenOrigin)
	}

	if !m.ListenMock.invocationsDone() && afterListenCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceListenerMock.Listen at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListenMock.expectedInvocations), m.ListenMock.expectedInvocationsOrigin, afterListenCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DeviceListenerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetChannelInspect()

			m.MinimockGetParametersInspect()

			m.MinimockListenInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DeviceListenerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DeviceListenerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetChannelDone() &&
		m.MinimockGetParametersDone() &&
		m.MinimockListenDone()
}
