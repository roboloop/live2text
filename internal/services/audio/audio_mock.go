// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package audio

import (
	audiowrapper "github.com/roboloop/live2text/internal/services/audio_wrapper"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AudioMock implements Audio
type AudioMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcFindInputDevice          func(deviceName string) (dp1 *audiowrapper.DeviceInfo, err error)
	funcFindInputDeviceOrigin    string
	inspectFuncFindInputDevice   func(deviceName string)
	afterFindInputDeviceCounter  uint64
	beforeFindInputDeviceCounter uint64
	FindInputDeviceMock          mAudioMockFindInputDevice

	funcListOfNames          func() (sa1 []string, err error)
	funcListOfNamesOrigin    string
	inspectFuncListOfNames   func()
	afterListOfNamesCounter  uint64
	beforeListOfNamesCounter uint64
	ListOfNamesMock          mAudioMockListOfNames

	funcListenDevice          func(deviceName string) (d1 DeviceListener, err error)
	funcListenDeviceOrigin    string
	inspectFuncListenDevice   func(deviceName string)
	afterListenDeviceCounter  uint64
	beforeListenDeviceCounter uint64
	ListenDeviceMock          mAudioMockListenDevice
}

// NewAudioMock returns a mock for Audio
func NewAudioMock(t minimock.Tester) *AudioMock {
	m := &AudioMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.FindInputDeviceMock = mAudioMockFindInputDevice{mock: m}
	m.FindInputDeviceMock.callArgs = []*AudioMockFindInputDeviceParams{}

	m.ListOfNamesMock = mAudioMockListOfNames{mock: m}

	m.ListenDeviceMock = mAudioMockListenDevice{mock: m}
	m.ListenDeviceMock.callArgs = []*AudioMockListenDeviceParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAudioMockFindInputDevice struct {
	optional           bool
	mock               *AudioMock
	defaultExpectation *AudioMockFindInputDeviceExpectation
	expectations       []*AudioMockFindInputDeviceExpectation

	callArgs []*AudioMockFindInputDeviceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AudioMockFindInputDeviceExpectation specifies expectation struct of the Audio.FindInputDevice
type AudioMockFindInputDeviceExpectation struct {
	mock               *AudioMock
	params             *AudioMockFindInputDeviceParams
	paramPtrs          *AudioMockFindInputDeviceParamPtrs
	expectationOrigins AudioMockFindInputDeviceExpectationOrigins
	results            *AudioMockFindInputDeviceResults
	returnOrigin       string
	Counter            uint64
}

// AudioMockFindInputDeviceParams contains parameters of the Audio.FindInputDevice
type AudioMockFindInputDeviceParams struct {
	deviceName string
}

// AudioMockFindInputDeviceParamPtrs contains pointers to parameters of the Audio.FindInputDevice
type AudioMockFindInputDeviceParamPtrs struct {
	deviceName *string
}

// AudioMockFindInputDeviceResults contains results of the Audio.FindInputDevice
type AudioMockFindInputDeviceResults struct {
	dp1 *audiowrapper.DeviceInfo
	err error
}

// AudioMockFindInputDeviceOrigins contains origins of expectations of the Audio.FindInputDevice
type AudioMockFindInputDeviceExpectationOrigins struct {
	origin           string
	originDeviceName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindInputDevice *mAudioMockFindInputDevice) Optional() *mAudioMockFindInputDevice {
	mmFindInputDevice.optional = true
	return mmFindInputDevice
}

// Expect sets up expected params for Audio.FindInputDevice
func (mmFindInputDevice *mAudioMockFindInputDevice) Expect(deviceName string) *mAudioMockFindInputDevice {
	if mmFindInputDevice.mock.funcFindInputDevice != nil {
		mmFindInputDevice.mock.t.Fatalf("AudioMock.FindInputDevice mock is already set by Set")
	}

	if mmFindInputDevice.defaultExpectation == nil {
		mmFindInputDevice.defaultExpectation = &AudioMockFindInputDeviceExpectation{}
	}

	if mmFindInputDevice.defaultExpectation.paramPtrs != nil {
		mmFindInputDevice.mock.t.Fatalf("AudioMock.FindInputDevice mock is already set by ExpectParams functions")
	}

	mmFindInputDevice.defaultExpectation.params = &AudioMockFindInputDeviceParams{deviceName}
	mmFindInputDevice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindInputDevice.expectations {
		if minimock.Equal(e.params, mmFindInputDevice.defaultExpectation.params) {
			mmFindInputDevice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindInputDevice.defaultExpectation.params)
		}
	}

	return mmFindInputDevice
}

// ExpectDeviceNameParam1 sets up expected param deviceName for Audio.FindInputDevice
func (mmFindInputDevice *mAudioMockFindInputDevice) ExpectDeviceNameParam1(deviceName string) *mAudioMockFindInputDevice {
	if mmFindInputDevice.mock.funcFindInputDevice != nil {
		mmFindInputDevice.mock.t.Fatalf("AudioMock.FindInputDevice mock is already set by Set")
	}

	if mmFindInputDevice.defaultExpectation == nil {
		mmFindInputDevice.defaultExpectation = &AudioMockFindInputDeviceExpectation{}
	}

	if mmFindInputDevice.defaultExpectation.params != nil {
		mmFindInputDevice.mock.t.Fatalf("AudioMock.FindInputDevice mock is already set by Expect")
	}

	if mmFindInputDevice.defaultExpectation.paramPtrs == nil {
		mmFindInputDevice.defaultExpectation.paramPtrs = &AudioMockFindInputDeviceParamPtrs{}
	}
	mmFindInputDevice.defaultExpectation.paramPtrs.deviceName = &deviceName
	mmFindInputDevice.defaultExpectation.expectationOrigins.originDeviceName = minimock.CallerInfo(1)

	return mmFindInputDevice
}

// Inspect accepts an inspector function that has same arguments as the Audio.FindInputDevice
func (mmFindInputDevice *mAudioMockFindInputDevice) Inspect(f func(deviceName string)) *mAudioMockFindInputDevice {
	if mmFindInputDevice.mock.inspectFuncFindInputDevice != nil {
		mmFindInputDevice.mock.t.Fatalf("Inspect function is already set for AudioMock.FindInputDevice")
	}

	mmFindInputDevice.mock.inspectFuncFindInputDevice = f

	return mmFindInputDevice
}

// Return sets up results that will be returned by Audio.FindInputDevice
func (mmFindInputDevice *mAudioMockFindInputDevice) Return(dp1 *audiowrapper.DeviceInfo, err error) *AudioMock {
	if mmFindInputDevice.mock.funcFindInputDevice != nil {
		mmFindInputDevice.mock.t.Fatalf("AudioMock.FindInputDevice mock is already set by Set")
	}

	if mmFindInputDevice.defaultExpectation == nil {
		mmFindInputDevice.defaultExpectation = &AudioMockFindInputDeviceExpectation{mock: mmFindInputDevice.mock}
	}
	mmFindInputDevice.defaultExpectation.results = &AudioMockFindInputDeviceResults{dp1, err}
	mmFindInputDevice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindInputDevice.mock
}

// Set uses given function f to mock the Audio.FindInputDevice method
func (mmFindInputDevice *mAudioMockFindInputDevice) Set(f func(deviceName string) (dp1 *audiowrapper.DeviceInfo, err error)) *AudioMock {
	if mmFindInputDevice.defaultExpectation != nil {
		mmFindInputDevice.mock.t.Fatalf("Default expectation is already set for the Audio.FindInputDevice method")
	}

	if len(mmFindInputDevice.expectations) > 0 {
		mmFindInputDevice.mock.t.Fatalf("Some expectations are already set for the Audio.FindInputDevice method")
	}

	mmFindInputDevice.mock.funcFindInputDevice = f
	mmFindInputDevice.mock.funcFindInputDeviceOrigin = minimock.CallerInfo(1)
	return mmFindInputDevice.mock
}

// When sets expectation for the Audio.FindInputDevice which will trigger the result defined by the following
// Then helper
func (mmFindInputDevice *mAudioMockFindInputDevice) When(deviceName string) *AudioMockFindInputDeviceExpectation {
	if mmFindInputDevice.mock.funcFindInputDevice != nil {
		mmFindInputDevice.mock.t.Fatalf("AudioMock.FindInputDevice mock is already set by Set")
	}

	expectation := &AudioMockFindInputDeviceExpectation{
		mock:               mmFindInputDevice.mock,
		params:             &AudioMockFindInputDeviceParams{deviceName},
		expectationOrigins: AudioMockFindInputDeviceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindInputDevice.expectations = append(mmFindInputDevice.expectations, expectation)
	return expectation
}

// Then sets up Audio.FindInputDevice return parameters for the expectation previously defined by the When method
func (e *AudioMockFindInputDeviceExpectation) Then(dp1 *audiowrapper.DeviceInfo, err error) *AudioMock {
	e.results = &AudioMockFindInputDeviceResults{dp1, err}
	return e.mock
}

// Times sets number of times Audio.FindInputDevice should be invoked
func (mmFindInputDevice *mAudioMockFindInputDevice) Times(n uint64) *mAudioMockFindInputDevice {
	if n == 0 {
		mmFindInputDevice.mock.t.Fatalf("Times of AudioMock.FindInputDevice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindInputDevice.expectedInvocations, n)
	mmFindInputDevice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindInputDevice
}

func (mmFindInputDevice *mAudioMockFindInputDevice) invocationsDone() bool {
	if len(mmFindInputDevice.expectations) == 0 && mmFindInputDevice.defaultExpectation == nil && mmFindInputDevice.mock.funcFindInputDevice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindInputDevice.mock.afterFindInputDeviceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindInputDevice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindInputDevice implements Audio
func (mmFindInputDevice *AudioMock) FindInputDevice(deviceName string) (dp1 *audiowrapper.DeviceInfo, err error) {
	mm_atomic.AddUint64(&mmFindInputDevice.beforeFindInputDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmFindInputDevice.afterFindInputDeviceCounter, 1)

	mmFindInputDevice.t.Helper()

	if mmFindInputDevice.inspectFuncFindInputDevice != nil {
		mmFindInputDevice.inspectFuncFindInputDevice(deviceName)
	}

	mm_params := AudioMockFindInputDeviceParams{deviceName}

	// Record call args
	mmFindInputDevice.FindInputDeviceMock.mutex.Lock()
	mmFindInputDevice.FindInputDeviceMock.callArgs = append(mmFindInputDevice.FindInputDeviceMock.callArgs, &mm_params)
	mmFindInputDevice.FindInputDeviceMock.mutex.Unlock()

	for _, e := range mmFindInputDevice.FindInputDeviceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmFindInputDevice.FindInputDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindInputDevice.FindInputDeviceMock.defaultExpectation.Counter, 1)
		mm_want := mmFindInputDevice.FindInputDeviceMock.defaultExpectation.params
		mm_want_ptrs := mmFindInputDevice.FindInputDeviceMock.defaultExpectation.paramPtrs

		mm_got := AudioMockFindInputDeviceParams{deviceName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.deviceName != nil && !minimock.Equal(*mm_want_ptrs.deviceName, mm_got.deviceName) {
				mmFindInputDevice.t.Errorf("AudioMock.FindInputDevice got unexpected parameter deviceName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindInputDevice.FindInputDeviceMock.defaultExpectation.expectationOrigins.originDeviceName, *mm_want_ptrs.deviceName, mm_got.deviceName, minimock.Diff(*mm_want_ptrs.deviceName, mm_got.deviceName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindInputDevice.t.Errorf("AudioMock.FindInputDevice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindInputDevice.FindInputDeviceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindInputDevice.FindInputDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmFindInputDevice.t.Fatal("No results are set for the AudioMock.FindInputDevice")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmFindInputDevice.funcFindInputDevice != nil {
		return mmFindInputDevice.funcFindInputDevice(deviceName)
	}
	mmFindInputDevice.t.Fatalf("Unexpected call to AudioMock.FindInputDevice. %v", deviceName)
	return
}

// FindInputDeviceAfterCounter returns a count of finished AudioMock.FindInputDevice invocations
func (mmFindInputDevice *AudioMock) FindInputDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindInputDevice.afterFindInputDeviceCounter)
}

// FindInputDeviceBeforeCounter returns a count of AudioMock.FindInputDevice invocations
func (mmFindInputDevice *AudioMock) FindInputDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindInputDevice.beforeFindInputDeviceCounter)
}

// Calls returns a list of arguments used in each call to AudioMock.FindInputDevice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindInputDevice *mAudioMockFindInputDevice) Calls() []*AudioMockFindInputDeviceParams {
	mmFindInputDevice.mutex.RLock()

	argCopy := make([]*AudioMockFindInputDeviceParams, len(mmFindInputDevice.callArgs))
	copy(argCopy, mmFindInputDevice.callArgs)

	mmFindInputDevice.mutex.RUnlock()

	return argCopy
}

// MinimockFindInputDeviceDone returns true if the count of the FindInputDevice invocations corresponds
// the number of defined expectations
func (m *AudioMock) MinimockFindInputDeviceDone() bool {
	if m.FindInputDeviceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindInputDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindInputDeviceMock.invocationsDone()
}

// MinimockFindInputDeviceInspect logs each unmet expectation
func (m *AudioMock) MinimockFindInputDeviceInspect() {
	for _, e := range m.FindInputDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AudioMock.FindInputDevice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindInputDeviceCounter := mm_atomic.LoadUint64(&m.afterFindInputDeviceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindInputDeviceMock.defaultExpectation != nil && afterFindInputDeviceCounter < 1 {
		if m.FindInputDeviceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AudioMock.FindInputDevice at\n%s", m.FindInputDeviceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AudioMock.FindInputDevice at\n%s with params: %#v", m.FindInputDeviceMock.defaultExpectation.expectationOrigins.origin, *m.FindInputDeviceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindInputDevice != nil && afterFindInputDeviceCounter < 1 {
		m.t.Errorf("Expected call to AudioMock.FindInputDevice at\n%s", m.funcFindInputDeviceOrigin)
	}

	if !m.FindInputDeviceMock.invocationsDone() && afterFindInputDeviceCounter > 0 {
		m.t.Errorf("Expected %d calls to AudioMock.FindInputDevice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindInputDeviceMock.expectedInvocations), m.FindInputDeviceMock.expectedInvocationsOrigin, afterFindInputDeviceCounter)
	}
}

type mAudioMockListOfNames struct {
	optional           bool
	mock               *AudioMock
	defaultExpectation *AudioMockListOfNamesExpectation
	expectations       []*AudioMockListOfNamesExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AudioMockListOfNamesExpectation specifies expectation struct of the Audio.ListOfNames
type AudioMockListOfNamesExpectation struct {
	mock *AudioMock

	results      *AudioMockListOfNamesResults
	returnOrigin string
	Counter      uint64
}

// AudioMockListOfNamesResults contains results of the Audio.ListOfNames
type AudioMockListOfNamesResults struct {
	sa1 []string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListOfNames *mAudioMockListOfNames) Optional() *mAudioMockListOfNames {
	mmListOfNames.optional = true
	return mmListOfNames
}

// Expect sets up expected params for Audio.ListOfNames
func (mmListOfNames *mAudioMockListOfNames) Expect() *mAudioMockListOfNames {
	if mmListOfNames.mock.funcListOfNames != nil {
		mmListOfNames.mock.t.Fatalf("AudioMock.ListOfNames mock is already set by Set")
	}

	if mmListOfNames.defaultExpectation == nil {
		mmListOfNames.defaultExpectation = &AudioMockListOfNamesExpectation{}
	}

	return mmListOfNames
}

// Inspect accepts an inspector function that has same arguments as the Audio.ListOfNames
func (mmListOfNames *mAudioMockListOfNames) Inspect(f func()) *mAudioMockListOfNames {
	if mmListOfNames.mock.inspectFuncListOfNames != nil {
		mmListOfNames.mock.t.Fatalf("Inspect function is already set for AudioMock.ListOfNames")
	}

	mmListOfNames.mock.inspectFuncListOfNames = f

	return mmListOfNames
}

// Return sets up results that will be returned by Audio.ListOfNames
func (mmListOfNames *mAudioMockListOfNames) Return(sa1 []string, err error) *AudioMock {
	if mmListOfNames.mock.funcListOfNames != nil {
		mmListOfNames.mock.t.Fatalf("AudioMock.ListOfNames mock is already set by Set")
	}

	if mmListOfNames.defaultExpectation == nil {
		mmListOfNames.defaultExpectation = &AudioMockListOfNamesExpectation{mock: mmListOfNames.mock}
	}
	mmListOfNames.defaultExpectation.results = &AudioMockListOfNamesResults{sa1, err}
	mmListOfNames.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListOfNames.mock
}

// Set uses given function f to mock the Audio.ListOfNames method
func (mmListOfNames *mAudioMockListOfNames) Set(f func() (sa1 []string, err error)) *AudioMock {
	if mmListOfNames.defaultExpectation != nil {
		mmListOfNames.mock.t.Fatalf("Default expectation is already set for the Audio.ListOfNames method")
	}

	if len(mmListOfNames.expectations) > 0 {
		mmListOfNames.mock.t.Fatalf("Some expectations are already set for the Audio.ListOfNames method")
	}

	mmListOfNames.mock.funcListOfNames = f
	mmListOfNames.mock.funcListOfNamesOrigin = minimock.CallerInfo(1)
	return mmListOfNames.mock
}

// Times sets number of times Audio.ListOfNames should be invoked
func (mmListOfNames *mAudioMockListOfNames) Times(n uint64) *mAudioMockListOfNames {
	if n == 0 {
		mmListOfNames.mock.t.Fatalf("Times of AudioMock.ListOfNames mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListOfNames.expectedInvocations, n)
	mmListOfNames.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListOfNames
}

func (mmListOfNames *mAudioMockListOfNames) invocationsDone() bool {
	if len(mmListOfNames.expectations) == 0 && mmListOfNames.defaultExpectation == nil && mmListOfNames.mock.funcListOfNames == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListOfNames.mock.afterListOfNamesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListOfNames.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListOfNames implements Audio
func (mmListOfNames *AudioMock) ListOfNames() (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListOfNames.beforeListOfNamesCounter, 1)
	defer mm_atomic.AddUint64(&mmListOfNames.afterListOfNamesCounter, 1)

	mmListOfNames.t.Helper()

	if mmListOfNames.inspectFuncListOfNames != nil {
		mmListOfNames.inspectFuncListOfNames()
	}

	if mmListOfNames.ListOfNamesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOfNames.ListOfNamesMock.defaultExpectation.Counter, 1)

		mm_results := mmListOfNames.ListOfNamesMock.defaultExpectation.results
		if mm_results == nil {
			mmListOfNames.t.Fatal("No results are set for the AudioMock.ListOfNames")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListOfNames.funcListOfNames != nil {
		return mmListOfNames.funcListOfNames()
	}
	mmListOfNames.t.Fatalf("Unexpected call to AudioMock.ListOfNames.")
	return
}

// ListOfNamesAfterCounter returns a count of finished AudioMock.ListOfNames invocations
func (mmListOfNames *AudioMock) ListOfNamesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOfNames.afterListOfNamesCounter)
}

// ListOfNamesBeforeCounter returns a count of AudioMock.ListOfNames invocations
func (mmListOfNames *AudioMock) ListOfNamesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOfNames.beforeListOfNamesCounter)
}

// MinimockListOfNamesDone returns true if the count of the ListOfNames invocations corresponds
// the number of defined expectations
func (m *AudioMock) MinimockListOfNamesDone() bool {
	if m.ListOfNamesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListOfNamesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListOfNamesMock.invocationsDone()
}

// MinimockListOfNamesInspect logs each unmet expectation
func (m *AudioMock) MinimockListOfNamesInspect() {
	for _, e := range m.ListOfNamesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AudioMock.ListOfNames")
		}
	}

	afterListOfNamesCounter := mm_atomic.LoadUint64(&m.afterListOfNamesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListOfNamesMock.defaultExpectation != nil && afterListOfNamesCounter < 1 {
		m.t.Errorf("Expected call to AudioMock.ListOfNames at\n%s", m.ListOfNamesMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOfNames != nil && afterListOfNamesCounter < 1 {
		m.t.Errorf("Expected call to AudioMock.ListOfNames at\n%s", m.funcListOfNamesOrigin)
	}

	if !m.ListOfNamesMock.invocationsDone() && afterListOfNamesCounter > 0 {
		m.t.Errorf("Expected %d calls to AudioMock.ListOfNames at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListOfNamesMock.expectedInvocations), m.ListOfNamesMock.expectedInvocationsOrigin, afterListOfNamesCounter)
	}
}

type mAudioMockListenDevice struct {
	optional           bool
	mock               *AudioMock
	defaultExpectation *AudioMockListenDeviceExpectation
	expectations       []*AudioMockListenDeviceExpectation

	callArgs []*AudioMockListenDeviceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AudioMockListenDeviceExpectation specifies expectation struct of the Audio.ListenDevice
type AudioMockListenDeviceExpectation struct {
	mock               *AudioMock
	params             *AudioMockListenDeviceParams
	paramPtrs          *AudioMockListenDeviceParamPtrs
	expectationOrigins AudioMockListenDeviceExpectationOrigins
	results            *AudioMockListenDeviceResults
	returnOrigin       string
	Counter            uint64
}

// AudioMockListenDeviceParams contains parameters of the Audio.ListenDevice
type AudioMockListenDeviceParams struct {
	deviceName string
}

// AudioMockListenDeviceParamPtrs contains pointers to parameters of the Audio.ListenDevice
type AudioMockListenDeviceParamPtrs struct {
	deviceName *string
}

// AudioMockListenDeviceResults contains results of the Audio.ListenDevice
type AudioMockListenDeviceResults struct {
	d1  DeviceListener
	err error
}

// AudioMockListenDeviceOrigins contains origins of expectations of the Audio.ListenDevice
type AudioMockListenDeviceExpectationOrigins struct {
	origin           string
	originDeviceName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListenDevice *mAudioMockListenDevice) Optional() *mAudioMockListenDevice {
	mmListenDevice.optional = true
	return mmListenDevice
}

// Expect sets up expected params for Audio.ListenDevice
func (mmListenDevice *mAudioMockListenDevice) Expect(deviceName string) *mAudioMockListenDevice {
	if mmListenDevice.mock.funcListenDevice != nil {
		mmListenDevice.mock.t.Fatalf("AudioMock.ListenDevice mock is already set by Set")
	}

	if mmListenDevice.defaultExpectation == nil {
		mmListenDevice.defaultExpectation = &AudioMockListenDeviceExpectation{}
	}

	if mmListenDevice.defaultExpectation.paramPtrs != nil {
		mmListenDevice.mock.t.Fatalf("AudioMock.ListenDevice mock is already set by ExpectParams functions")
	}

	mmListenDevice.defaultExpectation.params = &AudioMockListenDeviceParams{deviceName}
	mmListenDevice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListenDevice.expectations {
		if minimock.Equal(e.params, mmListenDevice.defaultExpectation.params) {
			mmListenDevice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListenDevice.defaultExpectation.params)
		}
	}

	return mmListenDevice
}

// ExpectDeviceNameParam1 sets up expected param deviceName for Audio.ListenDevice
func (mmListenDevice *mAudioMockListenDevice) ExpectDeviceNameParam1(deviceName string) *mAudioMockListenDevice {
	if mmListenDevice.mock.funcListenDevice != nil {
		mmListenDevice.mock.t.Fatalf("AudioMock.ListenDevice mock is already set by Set")
	}

	if mmListenDevice.defaultExpectation == nil {
		mmListenDevice.defaultExpectation = &AudioMockListenDeviceExpectation{}
	}

	if mmListenDevice.defaultExpectation.params != nil {
		mmListenDevice.mock.t.Fatalf("AudioMock.ListenDevice mock is already set by Expect")
	}

	if mmListenDevice.defaultExpectation.paramPtrs == nil {
		mmListenDevice.defaultExpectation.paramPtrs = &AudioMockListenDeviceParamPtrs{}
	}
	mmListenDevice.defaultExpectation.paramPtrs.deviceName = &deviceName
	mmListenDevice.defaultExpectation.expectationOrigins.originDeviceName = minimock.CallerInfo(1)

	return mmListenDevice
}

// Inspect accepts an inspector function that has same arguments as the Audio.ListenDevice
func (mmListenDevice *mAudioMockListenDevice) Inspect(f func(deviceName string)) *mAudioMockListenDevice {
	if mmListenDevice.mock.inspectFuncListenDevice != nil {
		mmListenDevice.mock.t.Fatalf("Inspect function is already set for AudioMock.ListenDevice")
	}

	mmListenDevice.mock.inspectFuncListenDevice = f

	return mmListenDevice
}

// Return sets up results that will be returned by Audio.ListenDevice
func (mmListenDevice *mAudioMockListenDevice) Return(d1 DeviceListener, err error) *AudioMock {
	if mmListenDevice.mock.funcListenDevice != nil {
		mmListenDevice.mock.t.Fatalf("AudioMock.ListenDevice mock is already set by Set")
	}

	if mmListenDevice.defaultExpectation == nil {
		mmListenDevice.defaultExpectation = &AudioMockListenDeviceExpectation{mock: mmListenDevice.mock}
	}
	mmListenDevice.defaultExpectation.results = &AudioMockListenDeviceResults{d1, err}
	mmListenDevice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListenDevice.mock
}

// Set uses given function f to mock the Audio.ListenDevice method
func (mmListenDevice *mAudioMockListenDevice) Set(f func(deviceName string) (d1 DeviceListener, err error)) *AudioMock {
	if mmListenDevice.defaultExpectation != nil {
		mmListenDevice.mock.t.Fatalf("Default expectation is already set for the Audio.ListenDevice method")
	}

	if len(mmListenDevice.expectations) > 0 {
		mmListenDevice.mock.t.Fatalf("Some expectations are already set for the Audio.ListenDevice method")
	}

	mmListenDevice.mock.funcListenDevice = f
	mmListenDevice.mock.funcListenDeviceOrigin = minimock.CallerInfo(1)
	return mmListenDevice.mock
}

// When sets expectation for the Audio.ListenDevice which will trigger the result defined by the following
// Then helper
func (mmListenDevice *mAudioMockListenDevice) When(deviceName string) *AudioMockListenDeviceExpectation {
	if mmListenDevice.mock.funcListenDevice != nil {
		mmListenDevice.mock.t.Fatalf("AudioMock.ListenDevice mock is already set by Set")
	}

	expectation := &AudioMockListenDeviceExpectation{
		mock:               mmListenDevice.mock,
		params:             &AudioMockListenDeviceParams{deviceName},
		expectationOrigins: AudioMockListenDeviceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListenDevice.expectations = append(mmListenDevice.expectations, expectation)
	return expectation
}

// Then sets up Audio.ListenDevice return parameters for the expectation previously defined by the When method
func (e *AudioMockListenDeviceExpectation) Then(d1 DeviceListener, err error) *AudioMock {
	e.results = &AudioMockListenDeviceResults{d1, err}
	return e.mock
}

// Times sets number of times Audio.ListenDevice should be invoked
func (mmListenDevice *mAudioMockListenDevice) Times(n uint64) *mAudioMockListenDevice {
	if n == 0 {
		mmListenDevice.mock.t.Fatalf("Times of AudioMock.ListenDevice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListenDevice.expectedInvocations, n)
	mmListenDevice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListenDevice
}

func (mmListenDevice *mAudioMockListenDevice) invocationsDone() bool {
	if len(mmListenDevice.expectations) == 0 && mmListenDevice.defaultExpectation == nil && mmListenDevice.mock.funcListenDevice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListenDevice.mock.afterListenDeviceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListenDevice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListenDevice implements Audio
func (mmListenDevice *AudioMock) ListenDevice(deviceName string) (d1 DeviceListener, err error) {
	mm_atomic.AddUint64(&mmListenDevice.beforeListenDeviceCounter, 1)
	defer mm_atomic.AddUint64(&mmListenDevice.afterListenDeviceCounter, 1)

	mmListenDevice.t.Helper()

	if mmListenDevice.inspectFuncListenDevice != nil {
		mmListenDevice.inspectFuncListenDevice(deviceName)
	}

	mm_params := AudioMockListenDeviceParams{deviceName}

	// Record call args
	mmListenDevice.ListenDeviceMock.mutex.Lock()
	mmListenDevice.ListenDeviceMock.callArgs = append(mmListenDevice.ListenDeviceMock.callArgs, &mm_params)
	mmListenDevice.ListenDeviceMock.mutex.Unlock()

	for _, e := range mmListenDevice.ListenDeviceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1, e.results.err
		}
	}

	if mmListenDevice.ListenDeviceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListenDevice.ListenDeviceMock.defaultExpectation.Counter, 1)
		mm_want := mmListenDevice.ListenDeviceMock.defaultExpectation.params
		mm_want_ptrs := mmListenDevice.ListenDeviceMock.defaultExpectation.paramPtrs

		mm_got := AudioMockListenDeviceParams{deviceName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.deviceName != nil && !minimock.Equal(*mm_want_ptrs.deviceName, mm_got.deviceName) {
				mmListenDevice.t.Errorf("AudioMock.ListenDevice got unexpected parameter deviceName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListenDevice.ListenDeviceMock.defaultExpectation.expectationOrigins.originDeviceName, *mm_want_ptrs.deviceName, mm_got.deviceName, minimock.Diff(*mm_want_ptrs.deviceName, mm_got.deviceName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListenDevice.t.Errorf("AudioMock.ListenDevice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListenDevice.ListenDeviceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListenDevice.ListenDeviceMock.defaultExpectation.results
		if mm_results == nil {
			mmListenDevice.t.Fatal("No results are set for the AudioMock.ListenDevice")
		}
		return (*mm_results).d1, (*mm_results).err
	}
	if mmListenDevice.funcListenDevice != nil {
		return mmListenDevice.funcListenDevice(deviceName)
	}
	mmListenDevice.t.Fatalf("Unexpected call to AudioMock.ListenDevice. %v", deviceName)
	return
}

// ListenDeviceAfterCounter returns a count of finished AudioMock.ListenDevice invocations
func (mmListenDevice *AudioMock) ListenDeviceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListenDevice.afterListenDeviceCounter)
}

// ListenDeviceBeforeCounter returns a count of AudioMock.ListenDevice invocations
func (mmListenDevice *AudioMock) ListenDeviceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListenDevice.beforeListenDeviceCounter)
}

// Calls returns a list of arguments used in each call to AudioMock.ListenDevice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListenDevice *mAudioMockListenDevice) Calls() []*AudioMockListenDeviceParams {
	mmListenDevice.mutex.RLock()

	argCopy := make([]*AudioMockListenDeviceParams, len(mmListenDevice.callArgs))
	copy(argCopy, mmListenDevice.callArgs)

	mmListenDevice.mutex.RUnlock()

	return argCopy
}

// MinimockListenDeviceDone returns true if the count of the ListenDevice invocations corresponds
// the number of defined expectations
func (m *AudioMock) MinimockListenDeviceDone() bool {
	if m.ListenDeviceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListenDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListenDeviceMock.invocationsDone()
}

// MinimockListenDeviceInspect logs each unmet expectation
func (m *AudioMock) MinimockListenDeviceInspect() {
	for _, e := range m.ListenDeviceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AudioMock.ListenDevice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListenDeviceCounter := mm_atomic.LoadUint64(&m.afterListenDeviceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListenDeviceMock.defaultExpectation != nil && afterListenDeviceCounter < 1 {
		if m.ListenDeviceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AudioMock.ListenDevice at\n%s", m.ListenDeviceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AudioMock.ListenDevice at\n%s with params: %#v", m.ListenDeviceMock.defaultExpectation.expectationOrigins.origin, *m.ListenDeviceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListenDevice != nil && afterListenDeviceCounter < 1 {
		m.t.Errorf("Expected call to AudioMock.ListenDevice at\n%s", m.funcListenDeviceOrigin)
	}

	if !m.ListenDeviceMock.invocationsDone() && afterListenDeviceCounter > 0 {
		m.t.Errorf("Expected %d calls to AudioMock.ListenDevice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListenDeviceMock.expectedInvocations), m.ListenDeviceMock.expectedInvocationsOrigin, afterListenDeviceCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AudioMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockFindInputDeviceInspect()

			m.MinimockListOfNamesInspect()

			m.MinimockListenDeviceInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AudioMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AudioMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockFindInputDeviceDone() &&
		m.MinimockListOfNamesDone() &&
		m.MinimockListenDeviceDone()
}
