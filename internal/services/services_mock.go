// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package services

import (
	"live2text/internal/services/audio"
	audiowrapper "live2text/internal/services/audio_wrapper"
	"live2text/internal/services/btt"
	"live2text/internal/services/burner"
	"live2text/internal/services/metrics"
	"live2text/internal/services/recognition"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ServicesMock implements Services
type ServicesMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAudio          func() (a1 audio.Audio)
	funcAudioOrigin    string
	inspectFuncAudio   func()
	afterAudioCounter  uint64
	beforeAudioCounter uint64
	AudioMock          mServicesMockAudio

	funcAudioWrapper          func() (a1 audiowrapper.Audio)
	funcAudioWrapperOrigin    string
	inspectFuncAudioWrapper   func()
	afterAudioWrapperCounter  uint64
	beforeAudioWrapperCounter uint64
	AudioWrapperMock          mServicesMockAudioWrapper

	funcBtt          func() (b1 btt.Btt)
	funcBttOrigin    string
	inspectFuncBtt   func()
	afterBttCounter  uint64
	beforeBttCounter uint64
	BttMock          mServicesMockBtt

	funcBurner          func() (b1 burner.Burner)
	funcBurnerOrigin    string
	inspectFuncBurner   func()
	afterBurnerCounter  uint64
	beforeBurnerCounter uint64
	BurnerMock          mServicesMockBurner

	funcMetrics          func() (m1 metrics.Metrics)
	funcMetricsOrigin    string
	inspectFuncMetrics   func()
	afterMetricsCounter  uint64
	beforeMetricsCounter uint64
	MetricsMock          mServicesMockMetrics

	funcRecognition          func() (r1 recognition.Recognition)
	funcRecognitionOrigin    string
	inspectFuncRecognition   func()
	afterRecognitionCounter  uint64
	beforeRecognitionCounter uint64
	RecognitionMock          mServicesMockRecognition
}

// NewServicesMock returns a mock for Services
func NewServicesMock(t minimock.Tester) *ServicesMock {
	m := &ServicesMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AudioMock = mServicesMockAudio{mock: m}

	m.AudioWrapperMock = mServicesMockAudioWrapper{mock: m}

	m.BttMock = mServicesMockBtt{mock: m}

	m.BurnerMock = mServicesMockBurner{mock: m}

	m.MetricsMock = mServicesMockMetrics{mock: m}

	m.RecognitionMock = mServicesMockRecognition{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServicesMockAudio struct {
	optional           bool
	mock               *ServicesMock
	defaultExpectation *ServicesMockAudioExpectation
	expectations       []*ServicesMockAudioExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServicesMockAudioExpectation specifies expectation struct of the Services.Audio
type ServicesMockAudioExpectation struct {
	mock *ServicesMock

	results      *ServicesMockAudioResults
	returnOrigin string
	Counter      uint64
}

// ServicesMockAudioResults contains results of the Services.Audio
type ServicesMockAudioResults struct {
	a1 audio.Audio
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAudio *mServicesMockAudio) Optional() *mServicesMockAudio {
	mmAudio.optional = true
	return mmAudio
}

// Expect sets up expected params for Services.Audio
func (mmAudio *mServicesMockAudio) Expect() *mServicesMockAudio {
	if mmAudio.mock.funcAudio != nil {
		mmAudio.mock.t.Fatalf("ServicesMock.Audio mock is already set by Set")
	}

	if mmAudio.defaultExpectation == nil {
		mmAudio.defaultExpectation = &ServicesMockAudioExpectation{}
	}

	return mmAudio
}

// Inspect accepts an inspector function that has same arguments as the Services.Audio
func (mmAudio *mServicesMockAudio) Inspect(f func()) *mServicesMockAudio {
	if mmAudio.mock.inspectFuncAudio != nil {
		mmAudio.mock.t.Fatalf("Inspect function is already set for ServicesMock.Audio")
	}

	mmAudio.mock.inspectFuncAudio = f

	return mmAudio
}

// Return sets up results that will be returned by Services.Audio
func (mmAudio *mServicesMockAudio) Return(a1 audio.Audio) *ServicesMock {
	if mmAudio.mock.funcAudio != nil {
		mmAudio.mock.t.Fatalf("ServicesMock.Audio mock is already set by Set")
	}

	if mmAudio.defaultExpectation == nil {
		mmAudio.defaultExpectation = &ServicesMockAudioExpectation{mock: mmAudio.mock}
	}
	mmAudio.defaultExpectation.results = &ServicesMockAudioResults{a1}
	mmAudio.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAudio.mock
}

// Set uses given function f to mock the Services.Audio method
func (mmAudio *mServicesMockAudio) Set(f func() (a1 audio.Audio)) *ServicesMock {
	if mmAudio.defaultExpectation != nil {
		mmAudio.mock.t.Fatalf("Default expectation is already set for the Services.Audio method")
	}

	if len(mmAudio.expectations) > 0 {
		mmAudio.mock.t.Fatalf("Some expectations are already set for the Services.Audio method")
	}

	mmAudio.mock.funcAudio = f
	mmAudio.mock.funcAudioOrigin = minimock.CallerInfo(1)
	return mmAudio.mock
}

// Times sets number of times Services.Audio should be invoked
func (mmAudio *mServicesMockAudio) Times(n uint64) *mServicesMockAudio {
	if n == 0 {
		mmAudio.mock.t.Fatalf("Times of ServicesMock.Audio mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAudio.expectedInvocations, n)
	mmAudio.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAudio
}

func (mmAudio *mServicesMockAudio) invocationsDone() bool {
	if len(mmAudio.expectations) == 0 && mmAudio.defaultExpectation == nil && mmAudio.mock.funcAudio == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAudio.mock.afterAudioCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAudio.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Audio implements Services
func (mmAudio *ServicesMock) Audio() (a1 audio.Audio) {
	mm_atomic.AddUint64(&mmAudio.beforeAudioCounter, 1)
	defer mm_atomic.AddUint64(&mmAudio.afterAudioCounter, 1)

	mmAudio.t.Helper()

	if mmAudio.inspectFuncAudio != nil {
		mmAudio.inspectFuncAudio()
	}

	if mmAudio.AudioMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAudio.AudioMock.defaultExpectation.Counter, 1)

		mm_results := mmAudio.AudioMock.defaultExpectation.results
		if mm_results == nil {
			mmAudio.t.Fatal("No results are set for the ServicesMock.Audio")
		}
		return (*mm_results).a1
	}
	if mmAudio.funcAudio != nil {
		return mmAudio.funcAudio()
	}
	mmAudio.t.Fatalf("Unexpected call to ServicesMock.Audio.")
	return
}

// AudioAfterCounter returns a count of finished ServicesMock.Audio invocations
func (mmAudio *ServicesMock) AudioAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAudio.afterAudioCounter)
}

// AudioBeforeCounter returns a count of ServicesMock.Audio invocations
func (mmAudio *ServicesMock) AudioBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAudio.beforeAudioCounter)
}

// MinimockAudioDone returns true if the count of the Audio invocations corresponds
// the number of defined expectations
func (m *ServicesMock) MinimockAudioDone() bool {
	if m.AudioMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AudioMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AudioMock.invocationsDone()
}

// MinimockAudioInspect logs each unmet expectation
func (m *ServicesMock) MinimockAudioInspect() {
	for _, e := range m.AudioMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServicesMock.Audio")
		}
	}

	afterAudioCounter := mm_atomic.LoadUint64(&m.afterAudioCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AudioMock.defaultExpectation != nil && afterAudioCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Audio at\n%s", m.AudioMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAudio != nil && afterAudioCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Audio at\n%s", m.funcAudioOrigin)
	}

	if !m.AudioMock.invocationsDone() && afterAudioCounter > 0 {
		m.t.Errorf("Expected %d calls to ServicesMock.Audio at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AudioMock.expectedInvocations), m.AudioMock.expectedInvocationsOrigin, afterAudioCounter)
	}
}

type mServicesMockAudioWrapper struct {
	optional           bool
	mock               *ServicesMock
	defaultExpectation *ServicesMockAudioWrapperExpectation
	expectations       []*ServicesMockAudioWrapperExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServicesMockAudioWrapperExpectation specifies expectation struct of the Services.AudioWrapper
type ServicesMockAudioWrapperExpectation struct {
	mock *ServicesMock

	results      *ServicesMockAudioWrapperResults
	returnOrigin string
	Counter      uint64
}

// ServicesMockAudioWrapperResults contains results of the Services.AudioWrapper
type ServicesMockAudioWrapperResults struct {
	a1 audiowrapper.Audio
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAudioWrapper *mServicesMockAudioWrapper) Optional() *mServicesMockAudioWrapper {
	mmAudioWrapper.optional = true
	return mmAudioWrapper
}

// Expect sets up expected params for Services.AudioWrapper
func (mmAudioWrapper *mServicesMockAudioWrapper) Expect() *mServicesMockAudioWrapper {
	if mmAudioWrapper.mock.funcAudioWrapper != nil {
		mmAudioWrapper.mock.t.Fatalf("ServicesMock.AudioWrapper mock is already set by Set")
	}

	if mmAudioWrapper.defaultExpectation == nil {
		mmAudioWrapper.defaultExpectation = &ServicesMockAudioWrapperExpectation{}
	}

	return mmAudioWrapper
}

// Inspect accepts an inspector function that has same arguments as the Services.AudioWrapper
func (mmAudioWrapper *mServicesMockAudioWrapper) Inspect(f func()) *mServicesMockAudioWrapper {
	if mmAudioWrapper.mock.inspectFuncAudioWrapper != nil {
		mmAudioWrapper.mock.t.Fatalf("Inspect function is already set for ServicesMock.AudioWrapper")
	}

	mmAudioWrapper.mock.inspectFuncAudioWrapper = f

	return mmAudioWrapper
}

// Return sets up results that will be returned by Services.AudioWrapper
func (mmAudioWrapper *mServicesMockAudioWrapper) Return(a1 audiowrapper.Audio) *ServicesMock {
	if mmAudioWrapper.mock.funcAudioWrapper != nil {
		mmAudioWrapper.mock.t.Fatalf("ServicesMock.AudioWrapper mock is already set by Set")
	}

	if mmAudioWrapper.defaultExpectation == nil {
		mmAudioWrapper.defaultExpectation = &ServicesMockAudioWrapperExpectation{mock: mmAudioWrapper.mock}
	}
	mmAudioWrapper.defaultExpectation.results = &ServicesMockAudioWrapperResults{a1}
	mmAudioWrapper.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAudioWrapper.mock
}

// Set uses given function f to mock the Services.AudioWrapper method
func (mmAudioWrapper *mServicesMockAudioWrapper) Set(f func() (a1 audiowrapper.Audio)) *ServicesMock {
	if mmAudioWrapper.defaultExpectation != nil {
		mmAudioWrapper.mock.t.Fatalf("Default expectation is already set for the Services.AudioWrapper method")
	}

	if len(mmAudioWrapper.expectations) > 0 {
		mmAudioWrapper.mock.t.Fatalf("Some expectations are already set for the Services.AudioWrapper method")
	}

	mmAudioWrapper.mock.funcAudioWrapper = f
	mmAudioWrapper.mock.funcAudioWrapperOrigin = minimock.CallerInfo(1)
	return mmAudioWrapper.mock
}

// Times sets number of times Services.AudioWrapper should be invoked
func (mmAudioWrapper *mServicesMockAudioWrapper) Times(n uint64) *mServicesMockAudioWrapper {
	if n == 0 {
		mmAudioWrapper.mock.t.Fatalf("Times of ServicesMock.AudioWrapper mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAudioWrapper.expectedInvocations, n)
	mmAudioWrapper.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAudioWrapper
}

func (mmAudioWrapper *mServicesMockAudioWrapper) invocationsDone() bool {
	if len(mmAudioWrapper.expectations) == 0 && mmAudioWrapper.defaultExpectation == nil && mmAudioWrapper.mock.funcAudioWrapper == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAudioWrapper.mock.afterAudioWrapperCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAudioWrapper.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AudioWrapper implements Services
func (mmAudioWrapper *ServicesMock) AudioWrapper() (a1 audiowrapper.Audio) {
	mm_atomic.AddUint64(&mmAudioWrapper.beforeAudioWrapperCounter, 1)
	defer mm_atomic.AddUint64(&mmAudioWrapper.afterAudioWrapperCounter, 1)

	mmAudioWrapper.t.Helper()

	if mmAudioWrapper.inspectFuncAudioWrapper != nil {
		mmAudioWrapper.inspectFuncAudioWrapper()
	}

	if mmAudioWrapper.AudioWrapperMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAudioWrapper.AudioWrapperMock.defaultExpectation.Counter, 1)

		mm_results := mmAudioWrapper.AudioWrapperMock.defaultExpectation.results
		if mm_results == nil {
			mmAudioWrapper.t.Fatal("No results are set for the ServicesMock.AudioWrapper")
		}
		return (*mm_results).a1
	}
	if mmAudioWrapper.funcAudioWrapper != nil {
		return mmAudioWrapper.funcAudioWrapper()
	}
	mmAudioWrapper.t.Fatalf("Unexpected call to ServicesMock.AudioWrapper.")
	return
}

// AudioWrapperAfterCounter returns a count of finished ServicesMock.AudioWrapper invocations
func (mmAudioWrapper *ServicesMock) AudioWrapperAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAudioWrapper.afterAudioWrapperCounter)
}

// AudioWrapperBeforeCounter returns a count of ServicesMock.AudioWrapper invocations
func (mmAudioWrapper *ServicesMock) AudioWrapperBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAudioWrapper.beforeAudioWrapperCounter)
}

// MinimockAudioWrapperDone returns true if the count of the AudioWrapper invocations corresponds
// the number of defined expectations
func (m *ServicesMock) MinimockAudioWrapperDone() bool {
	if m.AudioWrapperMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AudioWrapperMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AudioWrapperMock.invocationsDone()
}

// MinimockAudioWrapperInspect logs each unmet expectation
func (m *ServicesMock) MinimockAudioWrapperInspect() {
	for _, e := range m.AudioWrapperMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServicesMock.AudioWrapper")
		}
	}

	afterAudioWrapperCounter := mm_atomic.LoadUint64(&m.afterAudioWrapperCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AudioWrapperMock.defaultExpectation != nil && afterAudioWrapperCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.AudioWrapper at\n%s", m.AudioWrapperMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAudioWrapper != nil && afterAudioWrapperCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.AudioWrapper at\n%s", m.funcAudioWrapperOrigin)
	}

	if !m.AudioWrapperMock.invocationsDone() && afterAudioWrapperCounter > 0 {
		m.t.Errorf("Expected %d calls to ServicesMock.AudioWrapper at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AudioWrapperMock.expectedInvocations), m.AudioWrapperMock.expectedInvocationsOrigin, afterAudioWrapperCounter)
	}
}

type mServicesMockBtt struct {
	optional           bool
	mock               *ServicesMock
	defaultExpectation *ServicesMockBttExpectation
	expectations       []*ServicesMockBttExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServicesMockBttExpectation specifies expectation struct of the Services.Btt
type ServicesMockBttExpectation struct {
	mock *ServicesMock

	results      *ServicesMockBttResults
	returnOrigin string
	Counter      uint64
}

// ServicesMockBttResults contains results of the Services.Btt
type ServicesMockBttResults struct {
	b1 btt.Btt
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBtt *mServicesMockBtt) Optional() *mServicesMockBtt {
	mmBtt.optional = true
	return mmBtt
}

// Expect sets up expected params for Services.Btt
func (mmBtt *mServicesMockBtt) Expect() *mServicesMockBtt {
	if mmBtt.mock.funcBtt != nil {
		mmBtt.mock.t.Fatalf("ServicesMock.Btt mock is already set by Set")
	}

	if mmBtt.defaultExpectation == nil {
		mmBtt.defaultExpectation = &ServicesMockBttExpectation{}
	}

	return mmBtt
}

// Inspect accepts an inspector function that has same arguments as the Services.Btt
func (mmBtt *mServicesMockBtt) Inspect(f func()) *mServicesMockBtt {
	if mmBtt.mock.inspectFuncBtt != nil {
		mmBtt.mock.t.Fatalf("Inspect function is already set for ServicesMock.Btt")
	}

	mmBtt.mock.inspectFuncBtt = f

	return mmBtt
}

// Return sets up results that will be returned by Services.Btt
func (mmBtt *mServicesMockBtt) Return(b1 btt.Btt) *ServicesMock {
	if mmBtt.mock.funcBtt != nil {
		mmBtt.mock.t.Fatalf("ServicesMock.Btt mock is already set by Set")
	}

	if mmBtt.defaultExpectation == nil {
		mmBtt.defaultExpectation = &ServicesMockBttExpectation{mock: mmBtt.mock}
	}
	mmBtt.defaultExpectation.results = &ServicesMockBttResults{b1}
	mmBtt.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBtt.mock
}

// Set uses given function f to mock the Services.Btt method
func (mmBtt *mServicesMockBtt) Set(f func() (b1 btt.Btt)) *ServicesMock {
	if mmBtt.defaultExpectation != nil {
		mmBtt.mock.t.Fatalf("Default expectation is already set for the Services.Btt method")
	}

	if len(mmBtt.expectations) > 0 {
		mmBtt.mock.t.Fatalf("Some expectations are already set for the Services.Btt method")
	}

	mmBtt.mock.funcBtt = f
	mmBtt.mock.funcBttOrigin = minimock.CallerInfo(1)
	return mmBtt.mock
}

// Times sets number of times Services.Btt should be invoked
func (mmBtt *mServicesMockBtt) Times(n uint64) *mServicesMockBtt {
	if n == 0 {
		mmBtt.mock.t.Fatalf("Times of ServicesMock.Btt mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBtt.expectedInvocations, n)
	mmBtt.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBtt
}

func (mmBtt *mServicesMockBtt) invocationsDone() bool {
	if len(mmBtt.expectations) == 0 && mmBtt.defaultExpectation == nil && mmBtt.mock.funcBtt == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBtt.mock.afterBttCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBtt.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Btt implements Services
func (mmBtt *ServicesMock) Btt() (b1 btt.Btt) {
	mm_atomic.AddUint64(&mmBtt.beforeBttCounter, 1)
	defer mm_atomic.AddUint64(&mmBtt.afterBttCounter, 1)

	mmBtt.t.Helper()

	if mmBtt.inspectFuncBtt != nil {
		mmBtt.inspectFuncBtt()
	}

	if mmBtt.BttMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBtt.BttMock.defaultExpectation.Counter, 1)

		mm_results := mmBtt.BttMock.defaultExpectation.results
		if mm_results == nil {
			mmBtt.t.Fatal("No results are set for the ServicesMock.Btt")
		}
		return (*mm_results).b1
	}
	if mmBtt.funcBtt != nil {
		return mmBtt.funcBtt()
	}
	mmBtt.t.Fatalf("Unexpected call to ServicesMock.Btt.")
	return
}

// BttAfterCounter returns a count of finished ServicesMock.Btt invocations
func (mmBtt *ServicesMock) BttAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBtt.afterBttCounter)
}

// BttBeforeCounter returns a count of ServicesMock.Btt invocations
func (mmBtt *ServicesMock) BttBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBtt.beforeBttCounter)
}

// MinimockBttDone returns true if the count of the Btt invocations corresponds
// the number of defined expectations
func (m *ServicesMock) MinimockBttDone() bool {
	if m.BttMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BttMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BttMock.invocationsDone()
}

// MinimockBttInspect logs each unmet expectation
func (m *ServicesMock) MinimockBttInspect() {
	for _, e := range m.BttMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServicesMock.Btt")
		}
	}

	afterBttCounter := mm_atomic.LoadUint64(&m.afterBttCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BttMock.defaultExpectation != nil && afterBttCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Btt at\n%s", m.BttMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBtt != nil && afterBttCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Btt at\n%s", m.funcBttOrigin)
	}

	if !m.BttMock.invocationsDone() && afterBttCounter > 0 {
		m.t.Errorf("Expected %d calls to ServicesMock.Btt at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BttMock.expectedInvocations), m.BttMock.expectedInvocationsOrigin, afterBttCounter)
	}
}

type mServicesMockBurner struct {
	optional           bool
	mock               *ServicesMock
	defaultExpectation *ServicesMockBurnerExpectation
	expectations       []*ServicesMockBurnerExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServicesMockBurnerExpectation specifies expectation struct of the Services.Burner
type ServicesMockBurnerExpectation struct {
	mock *ServicesMock

	results      *ServicesMockBurnerResults
	returnOrigin string
	Counter      uint64
}

// ServicesMockBurnerResults contains results of the Services.Burner
type ServicesMockBurnerResults struct {
	b1 burner.Burner
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBurner *mServicesMockBurner) Optional() *mServicesMockBurner {
	mmBurner.optional = true
	return mmBurner
}

// Expect sets up expected params for Services.Burner
func (mmBurner *mServicesMockBurner) Expect() *mServicesMockBurner {
	if mmBurner.mock.funcBurner != nil {
		mmBurner.mock.t.Fatalf("ServicesMock.Burner mock is already set by Set")
	}

	if mmBurner.defaultExpectation == nil {
		mmBurner.defaultExpectation = &ServicesMockBurnerExpectation{}
	}

	return mmBurner
}

// Inspect accepts an inspector function that has same arguments as the Services.Burner
func (mmBurner *mServicesMockBurner) Inspect(f func()) *mServicesMockBurner {
	if mmBurner.mock.inspectFuncBurner != nil {
		mmBurner.mock.t.Fatalf("Inspect function is already set for ServicesMock.Burner")
	}

	mmBurner.mock.inspectFuncBurner = f

	return mmBurner
}

// Return sets up results that will be returned by Services.Burner
func (mmBurner *mServicesMockBurner) Return(b1 burner.Burner) *ServicesMock {
	if mmBurner.mock.funcBurner != nil {
		mmBurner.mock.t.Fatalf("ServicesMock.Burner mock is already set by Set")
	}

	if mmBurner.defaultExpectation == nil {
		mmBurner.defaultExpectation = &ServicesMockBurnerExpectation{mock: mmBurner.mock}
	}
	mmBurner.defaultExpectation.results = &ServicesMockBurnerResults{b1}
	mmBurner.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBurner.mock
}

// Set uses given function f to mock the Services.Burner method
func (mmBurner *mServicesMockBurner) Set(f func() (b1 burner.Burner)) *ServicesMock {
	if mmBurner.defaultExpectation != nil {
		mmBurner.mock.t.Fatalf("Default expectation is already set for the Services.Burner method")
	}

	if len(mmBurner.expectations) > 0 {
		mmBurner.mock.t.Fatalf("Some expectations are already set for the Services.Burner method")
	}

	mmBurner.mock.funcBurner = f
	mmBurner.mock.funcBurnerOrigin = minimock.CallerInfo(1)
	return mmBurner.mock
}

// Times sets number of times Services.Burner should be invoked
func (mmBurner *mServicesMockBurner) Times(n uint64) *mServicesMockBurner {
	if n == 0 {
		mmBurner.mock.t.Fatalf("Times of ServicesMock.Burner mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBurner.expectedInvocations, n)
	mmBurner.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBurner
}

func (mmBurner *mServicesMockBurner) invocationsDone() bool {
	if len(mmBurner.expectations) == 0 && mmBurner.defaultExpectation == nil && mmBurner.mock.funcBurner == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBurner.mock.afterBurnerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBurner.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Burner implements Services
func (mmBurner *ServicesMock) Burner() (b1 burner.Burner) {
	mm_atomic.AddUint64(&mmBurner.beforeBurnerCounter, 1)
	defer mm_atomic.AddUint64(&mmBurner.afterBurnerCounter, 1)

	mmBurner.t.Helper()

	if mmBurner.inspectFuncBurner != nil {
		mmBurner.inspectFuncBurner()
	}

	if mmBurner.BurnerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBurner.BurnerMock.defaultExpectation.Counter, 1)

		mm_results := mmBurner.BurnerMock.defaultExpectation.results
		if mm_results == nil {
			mmBurner.t.Fatal("No results are set for the ServicesMock.Burner")
		}
		return (*mm_results).b1
	}
	if mmBurner.funcBurner != nil {
		return mmBurner.funcBurner()
	}
	mmBurner.t.Fatalf("Unexpected call to ServicesMock.Burner.")
	return
}

// BurnerAfterCounter returns a count of finished ServicesMock.Burner invocations
func (mmBurner *ServicesMock) BurnerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBurner.afterBurnerCounter)
}

// BurnerBeforeCounter returns a count of ServicesMock.Burner invocations
func (mmBurner *ServicesMock) BurnerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBurner.beforeBurnerCounter)
}

// MinimockBurnerDone returns true if the count of the Burner invocations corresponds
// the number of defined expectations
func (m *ServicesMock) MinimockBurnerDone() bool {
	if m.BurnerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BurnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BurnerMock.invocationsDone()
}

// MinimockBurnerInspect logs each unmet expectation
func (m *ServicesMock) MinimockBurnerInspect() {
	for _, e := range m.BurnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServicesMock.Burner")
		}
	}

	afterBurnerCounter := mm_atomic.LoadUint64(&m.afterBurnerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BurnerMock.defaultExpectation != nil && afterBurnerCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Burner at\n%s", m.BurnerMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBurner != nil && afterBurnerCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Burner at\n%s", m.funcBurnerOrigin)
	}

	if !m.BurnerMock.invocationsDone() && afterBurnerCounter > 0 {
		m.t.Errorf("Expected %d calls to ServicesMock.Burner at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BurnerMock.expectedInvocations), m.BurnerMock.expectedInvocationsOrigin, afterBurnerCounter)
	}
}

type mServicesMockMetrics struct {
	optional           bool
	mock               *ServicesMock
	defaultExpectation *ServicesMockMetricsExpectation
	expectations       []*ServicesMockMetricsExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServicesMockMetricsExpectation specifies expectation struct of the Services.Metrics
type ServicesMockMetricsExpectation struct {
	mock *ServicesMock

	results      *ServicesMockMetricsResults
	returnOrigin string
	Counter      uint64
}

// ServicesMockMetricsResults contains results of the Services.Metrics
type ServicesMockMetricsResults struct {
	m1 metrics.Metrics
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMetrics *mServicesMockMetrics) Optional() *mServicesMockMetrics {
	mmMetrics.optional = true
	return mmMetrics
}

// Expect sets up expected params for Services.Metrics
func (mmMetrics *mServicesMockMetrics) Expect() *mServicesMockMetrics {
	if mmMetrics.mock.funcMetrics != nil {
		mmMetrics.mock.t.Fatalf("ServicesMock.Metrics mock is already set by Set")
	}

	if mmMetrics.defaultExpectation == nil {
		mmMetrics.defaultExpectation = &ServicesMockMetricsExpectation{}
	}

	return mmMetrics
}

// Inspect accepts an inspector function that has same arguments as the Services.Metrics
func (mmMetrics *mServicesMockMetrics) Inspect(f func()) *mServicesMockMetrics {
	if mmMetrics.mock.inspectFuncMetrics != nil {
		mmMetrics.mock.t.Fatalf("Inspect function is already set for ServicesMock.Metrics")
	}

	mmMetrics.mock.inspectFuncMetrics = f

	return mmMetrics
}

// Return sets up results that will be returned by Services.Metrics
func (mmMetrics *mServicesMockMetrics) Return(m1 metrics.Metrics) *ServicesMock {
	if mmMetrics.mock.funcMetrics != nil {
		mmMetrics.mock.t.Fatalf("ServicesMock.Metrics mock is already set by Set")
	}

	if mmMetrics.defaultExpectation == nil {
		mmMetrics.defaultExpectation = &ServicesMockMetricsExpectation{mock: mmMetrics.mock}
	}
	mmMetrics.defaultExpectation.results = &ServicesMockMetricsResults{m1}
	mmMetrics.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMetrics.mock
}

// Set uses given function f to mock the Services.Metrics method
func (mmMetrics *mServicesMockMetrics) Set(f func() (m1 metrics.Metrics)) *ServicesMock {
	if mmMetrics.defaultExpectation != nil {
		mmMetrics.mock.t.Fatalf("Default expectation is already set for the Services.Metrics method")
	}

	if len(mmMetrics.expectations) > 0 {
		mmMetrics.mock.t.Fatalf("Some expectations are already set for the Services.Metrics method")
	}

	mmMetrics.mock.funcMetrics = f
	mmMetrics.mock.funcMetricsOrigin = minimock.CallerInfo(1)
	return mmMetrics.mock
}

// Times sets number of times Services.Metrics should be invoked
func (mmMetrics *mServicesMockMetrics) Times(n uint64) *mServicesMockMetrics {
	if n == 0 {
		mmMetrics.mock.t.Fatalf("Times of ServicesMock.Metrics mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMetrics.expectedInvocations, n)
	mmMetrics.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMetrics
}

func (mmMetrics *mServicesMockMetrics) invocationsDone() bool {
	if len(mmMetrics.expectations) == 0 && mmMetrics.defaultExpectation == nil && mmMetrics.mock.funcMetrics == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMetrics.mock.afterMetricsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMetrics.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Metrics implements Services
func (mmMetrics *ServicesMock) Metrics() (m1 metrics.Metrics) {
	mm_atomic.AddUint64(&mmMetrics.beforeMetricsCounter, 1)
	defer mm_atomic.AddUint64(&mmMetrics.afterMetricsCounter, 1)

	mmMetrics.t.Helper()

	if mmMetrics.inspectFuncMetrics != nil {
		mmMetrics.inspectFuncMetrics()
	}

	if mmMetrics.MetricsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMetrics.MetricsMock.defaultExpectation.Counter, 1)

		mm_results := mmMetrics.MetricsMock.defaultExpectation.results
		if mm_results == nil {
			mmMetrics.t.Fatal("No results are set for the ServicesMock.Metrics")
		}
		return (*mm_results).m1
	}
	if mmMetrics.funcMetrics != nil {
		return mmMetrics.funcMetrics()
	}
	mmMetrics.t.Fatalf("Unexpected call to ServicesMock.Metrics.")
	return
}

// MetricsAfterCounter returns a count of finished ServicesMock.Metrics invocations
func (mmMetrics *ServicesMock) MetricsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMetrics.afterMetricsCounter)
}

// MetricsBeforeCounter returns a count of ServicesMock.Metrics invocations
func (mmMetrics *ServicesMock) MetricsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMetrics.beforeMetricsCounter)
}

// MinimockMetricsDone returns true if the count of the Metrics invocations corresponds
// the number of defined expectations
func (m *ServicesMock) MinimockMetricsDone() bool {
	if m.MetricsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MetricsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MetricsMock.invocationsDone()
}

// MinimockMetricsInspect logs each unmet expectation
func (m *ServicesMock) MinimockMetricsInspect() {
	for _, e := range m.MetricsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServicesMock.Metrics")
		}
	}

	afterMetricsCounter := mm_atomic.LoadUint64(&m.afterMetricsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MetricsMock.defaultExpectation != nil && afterMetricsCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Metrics at\n%s", m.MetricsMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMetrics != nil && afterMetricsCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Metrics at\n%s", m.funcMetricsOrigin)
	}

	if !m.MetricsMock.invocationsDone() && afterMetricsCounter > 0 {
		m.t.Errorf("Expected %d calls to ServicesMock.Metrics at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MetricsMock.expectedInvocations), m.MetricsMock.expectedInvocationsOrigin, afterMetricsCounter)
	}
}

type mServicesMockRecognition struct {
	optional           bool
	mock               *ServicesMock
	defaultExpectation *ServicesMockRecognitionExpectation
	expectations       []*ServicesMockRecognitionExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServicesMockRecognitionExpectation specifies expectation struct of the Services.Recognition
type ServicesMockRecognitionExpectation struct {
	mock *ServicesMock

	results      *ServicesMockRecognitionResults
	returnOrigin string
	Counter      uint64
}

// ServicesMockRecognitionResults contains results of the Services.Recognition
type ServicesMockRecognitionResults struct {
	r1 recognition.Recognition
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRecognition *mServicesMockRecognition) Optional() *mServicesMockRecognition {
	mmRecognition.optional = true
	return mmRecognition
}

// Expect sets up expected params for Services.Recognition
func (mmRecognition *mServicesMockRecognition) Expect() *mServicesMockRecognition {
	if mmRecognition.mock.funcRecognition != nil {
		mmRecognition.mock.t.Fatalf("ServicesMock.Recognition mock is already set by Set")
	}

	if mmRecognition.defaultExpectation == nil {
		mmRecognition.defaultExpectation = &ServicesMockRecognitionExpectation{}
	}

	return mmRecognition
}

// Inspect accepts an inspector function that has same arguments as the Services.Recognition
func (mmRecognition *mServicesMockRecognition) Inspect(f func()) *mServicesMockRecognition {
	if mmRecognition.mock.inspectFuncRecognition != nil {
		mmRecognition.mock.t.Fatalf("Inspect function is already set for ServicesMock.Recognition")
	}

	mmRecognition.mock.inspectFuncRecognition = f

	return mmRecognition
}

// Return sets up results that will be returned by Services.Recognition
func (mmRecognition *mServicesMockRecognition) Return(r1 recognition.Recognition) *ServicesMock {
	if mmRecognition.mock.funcRecognition != nil {
		mmRecognition.mock.t.Fatalf("ServicesMock.Recognition mock is already set by Set")
	}

	if mmRecognition.defaultExpectation == nil {
		mmRecognition.defaultExpectation = &ServicesMockRecognitionExpectation{mock: mmRecognition.mock}
	}
	mmRecognition.defaultExpectation.results = &ServicesMockRecognitionResults{r1}
	mmRecognition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRecognition.mock
}

// Set uses given function f to mock the Services.Recognition method
func (mmRecognition *mServicesMockRecognition) Set(f func() (r1 recognition.Recognition)) *ServicesMock {
	if mmRecognition.defaultExpectation != nil {
		mmRecognition.mock.t.Fatalf("Default expectation is already set for the Services.Recognition method")
	}

	if len(mmRecognition.expectations) > 0 {
		mmRecognition.mock.t.Fatalf("Some expectations are already set for the Services.Recognition method")
	}

	mmRecognition.mock.funcRecognition = f
	mmRecognition.mock.funcRecognitionOrigin = minimock.CallerInfo(1)
	return mmRecognition.mock
}

// Times sets number of times Services.Recognition should be invoked
func (mmRecognition *mServicesMockRecognition) Times(n uint64) *mServicesMockRecognition {
	if n == 0 {
		mmRecognition.mock.t.Fatalf("Times of ServicesMock.Recognition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRecognition.expectedInvocations, n)
	mmRecognition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRecognition
}

func (mmRecognition *mServicesMockRecognition) invocationsDone() bool {
	if len(mmRecognition.expectations) == 0 && mmRecognition.defaultExpectation == nil && mmRecognition.mock.funcRecognition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRecognition.mock.afterRecognitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRecognition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Recognition implements Services
func (mmRecognition *ServicesMock) Recognition() (r1 recognition.Recognition) {
	mm_atomic.AddUint64(&mmRecognition.beforeRecognitionCounter, 1)
	defer mm_atomic.AddUint64(&mmRecognition.afterRecognitionCounter, 1)

	mmRecognition.t.Helper()

	if mmRecognition.inspectFuncRecognition != nil {
		mmRecognition.inspectFuncRecognition()
	}

	if mmRecognition.RecognitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecognition.RecognitionMock.defaultExpectation.Counter, 1)

		mm_results := mmRecognition.RecognitionMock.defaultExpectation.results
		if mm_results == nil {
			mmRecognition.t.Fatal("No results are set for the ServicesMock.Recognition")
		}
		return (*mm_results).r1
	}
	if mmRecognition.funcRecognition != nil {
		return mmRecognition.funcRecognition()
	}
	mmRecognition.t.Fatalf("Unexpected call to ServicesMock.Recognition.")
	return
}

// RecognitionAfterCounter returns a count of finished ServicesMock.Recognition invocations
func (mmRecognition *ServicesMock) RecognitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecognition.afterRecognitionCounter)
}

// RecognitionBeforeCounter returns a count of ServicesMock.Recognition invocations
func (mmRecognition *ServicesMock) RecognitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecognition.beforeRecognitionCounter)
}

// MinimockRecognitionDone returns true if the count of the Recognition invocations corresponds
// the number of defined expectations
func (m *ServicesMock) MinimockRecognitionDone() bool {
	if m.RecognitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RecognitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RecognitionMock.invocationsDone()
}

// MinimockRecognitionInspect logs each unmet expectation
func (m *ServicesMock) MinimockRecognitionInspect() {
	for _, e := range m.RecognitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServicesMock.Recognition")
		}
	}

	afterRecognitionCounter := mm_atomic.LoadUint64(&m.afterRecognitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RecognitionMock.defaultExpectation != nil && afterRecognitionCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Recognition at\n%s", m.RecognitionMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecognition != nil && afterRecognitionCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Recognition at\n%s", m.funcRecognitionOrigin)
	}

	if !m.RecognitionMock.invocationsDone() && afterRecognitionCounter > 0 {
		m.t.Errorf("Expected %d calls to ServicesMock.Recognition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RecognitionMock.expectedInvocations), m.RecognitionMock.expectedInvocationsOrigin, afterRecognitionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServicesMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAudioInspect()

			m.MinimockAudioWrapperInspect()

			m.MinimockBttInspect()

			m.MinimockBurnerInspect()

			m.MinimockMetricsInspect()

			m.MinimockRecognitionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServicesMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServicesMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAudioDone() &&
		m.MinimockAudioWrapperDone() &&
		m.MinimockBttDone() &&
		m.MinimockBurnerDone() &&
		m.MinimockMetricsDone() &&
		m.MinimockRecognitionDone()
}
