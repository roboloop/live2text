// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package speechwrapper

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SpeechClientMock implements SpeechClient
type SpeechClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mSpeechClientMockClose

	funcStreamingRecognize          func(ctx context.Context) (s1 StreamingRecognizeClient, err error)
	funcStreamingRecognizeOrigin    string
	inspectFuncStreamingRecognize   func(ctx context.Context)
	afterStreamingRecognizeCounter  uint64
	beforeStreamingRecognizeCounter uint64
	StreamingRecognizeMock          mSpeechClientMockStreamingRecognize
}

// NewSpeechClientMock returns a mock for SpeechClient
func NewSpeechClientMock(t minimock.Tester) *SpeechClientMock {
	m := &SpeechClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mSpeechClientMockClose{mock: m}

	m.StreamingRecognizeMock = mSpeechClientMockStreamingRecognize{mock: m}
	m.StreamingRecognizeMock.callArgs = []*SpeechClientMockStreamingRecognizeParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSpeechClientMockClose struct {
	optional           bool
	mock               *SpeechClientMock
	defaultExpectation *SpeechClientMockCloseExpectation
	expectations       []*SpeechClientMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SpeechClientMockCloseExpectation specifies expectation struct of the SpeechClient.Close
type SpeechClientMockCloseExpectation struct {
	mock *SpeechClientMock

	results      *SpeechClientMockCloseResults
	returnOrigin string
	Counter      uint64
}

// SpeechClientMockCloseResults contains results of the SpeechClient.Close
type SpeechClientMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mSpeechClientMockClose) Optional() *mSpeechClientMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for SpeechClient.Close
func (mmClose *mSpeechClientMockClose) Expect() *mSpeechClientMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("SpeechClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &SpeechClientMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the SpeechClient.Close
func (mmClose *mSpeechClientMockClose) Inspect(f func()) *mSpeechClientMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for SpeechClientMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by SpeechClient.Close
func (mmClose *mSpeechClientMockClose) Return(err error) *SpeechClientMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("SpeechClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &SpeechClientMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &SpeechClientMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the SpeechClient.Close method
func (mmClose *mSpeechClientMockClose) Set(f func() (err error)) *SpeechClientMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the SpeechClient.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the SpeechClient.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times SpeechClient.Close should be invoked
func (mmClose *mSpeechClientMockClose) Times(n uint64) *mSpeechClientMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of SpeechClientMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mSpeechClientMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements SpeechClient
func (mmClose *SpeechClientMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the SpeechClientMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to SpeechClientMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished SpeechClientMock.Close invocations
func (mmClose *SpeechClientMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of SpeechClientMock.Close invocations
func (mmClose *SpeechClientMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *SpeechClientMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *SpeechClientMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SpeechClientMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to SpeechClientMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to SpeechClientMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to SpeechClientMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mSpeechClientMockStreamingRecognize struct {
	optional           bool
	mock               *SpeechClientMock
	defaultExpectation *SpeechClientMockStreamingRecognizeExpectation
	expectations       []*SpeechClientMockStreamingRecognizeExpectation

	callArgs []*SpeechClientMockStreamingRecognizeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SpeechClientMockStreamingRecognizeExpectation specifies expectation struct of the SpeechClient.StreamingRecognize
type SpeechClientMockStreamingRecognizeExpectation struct {
	mock               *SpeechClientMock
	params             *SpeechClientMockStreamingRecognizeParams
	paramPtrs          *SpeechClientMockStreamingRecognizeParamPtrs
	expectationOrigins SpeechClientMockStreamingRecognizeExpectationOrigins
	results            *SpeechClientMockStreamingRecognizeResults
	returnOrigin       string
	Counter            uint64
}

// SpeechClientMockStreamingRecognizeParams contains parameters of the SpeechClient.StreamingRecognize
type SpeechClientMockStreamingRecognizeParams struct {
	ctx context.Context
}

// SpeechClientMockStreamingRecognizeParamPtrs contains pointers to parameters of the SpeechClient.StreamingRecognize
type SpeechClientMockStreamingRecognizeParamPtrs struct {
	ctx *context.Context
}

// SpeechClientMockStreamingRecognizeResults contains results of the SpeechClient.StreamingRecognize
type SpeechClientMockStreamingRecognizeResults struct {
	s1  StreamingRecognizeClient
	err error
}

// SpeechClientMockStreamingRecognizeOrigins contains origins of expectations of the SpeechClient.StreamingRecognize
type SpeechClientMockStreamingRecognizeExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStreamingRecognize *mSpeechClientMockStreamingRecognize) Optional() *mSpeechClientMockStreamingRecognize {
	mmStreamingRecognize.optional = true
	return mmStreamingRecognize
}

// Expect sets up expected params for SpeechClient.StreamingRecognize
func (mmStreamingRecognize *mSpeechClientMockStreamingRecognize) Expect(ctx context.Context) *mSpeechClientMockStreamingRecognize {
	if mmStreamingRecognize.mock.funcStreamingRecognize != nil {
		mmStreamingRecognize.mock.t.Fatalf("SpeechClientMock.StreamingRecognize mock is already set by Set")
	}

	if mmStreamingRecognize.defaultExpectation == nil {
		mmStreamingRecognize.defaultExpectation = &SpeechClientMockStreamingRecognizeExpectation{}
	}

	if mmStreamingRecognize.defaultExpectation.paramPtrs != nil {
		mmStreamingRecognize.mock.t.Fatalf("SpeechClientMock.StreamingRecognize mock is already set by ExpectParams functions")
	}

	mmStreamingRecognize.defaultExpectation.params = &SpeechClientMockStreamingRecognizeParams{ctx}
	mmStreamingRecognize.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStreamingRecognize.expectations {
		if minimock.Equal(e.params, mmStreamingRecognize.defaultExpectation.params) {
			mmStreamingRecognize.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStreamingRecognize.defaultExpectation.params)
		}
	}

	return mmStreamingRecognize
}

// ExpectCtxParam1 sets up expected param ctx for SpeechClient.StreamingRecognize
func (mmStreamingRecognize *mSpeechClientMockStreamingRecognize) ExpectCtxParam1(ctx context.Context) *mSpeechClientMockStreamingRecognize {
	if mmStreamingRecognize.mock.funcStreamingRecognize != nil {
		mmStreamingRecognize.mock.t.Fatalf("SpeechClientMock.StreamingRecognize mock is already set by Set")
	}

	if mmStreamingRecognize.defaultExpectation == nil {
		mmStreamingRecognize.defaultExpectation = &SpeechClientMockStreamingRecognizeExpectation{}
	}

	if mmStreamingRecognize.defaultExpectation.params != nil {
		mmStreamingRecognize.mock.t.Fatalf("SpeechClientMock.StreamingRecognize mock is already set by Expect")
	}

	if mmStreamingRecognize.defaultExpectation.paramPtrs == nil {
		mmStreamingRecognize.defaultExpectation.paramPtrs = &SpeechClientMockStreamingRecognizeParamPtrs{}
	}
	mmStreamingRecognize.defaultExpectation.paramPtrs.ctx = &ctx
	mmStreamingRecognize.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStreamingRecognize
}

// Inspect accepts an inspector function that has same arguments as the SpeechClient.StreamingRecognize
func (mmStreamingRecognize *mSpeechClientMockStreamingRecognize) Inspect(f func(ctx context.Context)) *mSpeechClientMockStreamingRecognize {
	if mmStreamingRecognize.mock.inspectFuncStreamingRecognize != nil {
		mmStreamingRecognize.mock.t.Fatalf("Inspect function is already set for SpeechClientMock.StreamingRecognize")
	}

	mmStreamingRecognize.mock.inspectFuncStreamingRecognize = f

	return mmStreamingRecognize
}

// Return sets up results that will be returned by SpeechClient.StreamingRecognize
func (mmStreamingRecognize *mSpeechClientMockStreamingRecognize) Return(s1 StreamingRecognizeClient, err error) *SpeechClientMock {
	if mmStreamingRecognize.mock.funcStreamingRecognize != nil {
		mmStreamingRecognize.mock.t.Fatalf("SpeechClientMock.StreamingRecognize mock is already set by Set")
	}

	if mmStreamingRecognize.defaultExpectation == nil {
		mmStreamingRecognize.defaultExpectation = &SpeechClientMockStreamingRecognizeExpectation{mock: mmStreamingRecognize.mock}
	}
	mmStreamingRecognize.defaultExpectation.results = &SpeechClientMockStreamingRecognizeResults{s1, err}
	mmStreamingRecognize.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStreamingRecognize.mock
}

// Set uses given function f to mock the SpeechClient.StreamingRecognize method
func (mmStreamingRecognize *mSpeechClientMockStreamingRecognize) Set(f func(ctx context.Context) (s1 StreamingRecognizeClient, err error)) *SpeechClientMock {
	if mmStreamingRecognize.defaultExpectation != nil {
		mmStreamingRecognize.mock.t.Fatalf("Default expectation is already set for the SpeechClient.StreamingRecognize method")
	}

	if len(mmStreamingRecognize.expectations) > 0 {
		mmStreamingRecognize.mock.t.Fatalf("Some expectations are already set for the SpeechClient.StreamingRecognize method")
	}

	mmStreamingRecognize.mock.funcStreamingRecognize = f
	mmStreamingRecognize.mock.funcStreamingRecognizeOrigin = minimock.CallerInfo(1)
	return mmStreamingRecognize.mock
}

// When sets expectation for the SpeechClient.StreamingRecognize which will trigger the result defined by the following
// Then helper
func (mmStreamingRecognize *mSpeechClientMockStreamingRecognize) When(ctx context.Context) *SpeechClientMockStreamingRecognizeExpectation {
	if mmStreamingRecognize.mock.funcStreamingRecognize != nil {
		mmStreamingRecognize.mock.t.Fatalf("SpeechClientMock.StreamingRecognize mock is already set by Set")
	}

	expectation := &SpeechClientMockStreamingRecognizeExpectation{
		mock:               mmStreamingRecognize.mock,
		params:             &SpeechClientMockStreamingRecognizeParams{ctx},
		expectationOrigins: SpeechClientMockStreamingRecognizeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStreamingRecognize.expectations = append(mmStreamingRecognize.expectations, expectation)
	return expectation
}

// Then sets up SpeechClient.StreamingRecognize return parameters for the expectation previously defined by the When method
func (e *SpeechClientMockStreamingRecognizeExpectation) Then(s1 StreamingRecognizeClient, err error) *SpeechClientMock {
	e.results = &SpeechClientMockStreamingRecognizeResults{s1, err}
	return e.mock
}

// Times sets number of times SpeechClient.StreamingRecognize should be invoked
func (mmStreamingRecognize *mSpeechClientMockStreamingRecognize) Times(n uint64) *mSpeechClientMockStreamingRecognize {
	if n == 0 {
		mmStreamingRecognize.mock.t.Fatalf("Times of SpeechClientMock.StreamingRecognize mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStreamingRecognize.expectedInvocations, n)
	mmStreamingRecognize.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStreamingRecognize
}

func (mmStreamingRecognize *mSpeechClientMockStreamingRecognize) invocationsDone() bool {
	if len(mmStreamingRecognize.expectations) == 0 && mmStreamingRecognize.defaultExpectation == nil && mmStreamingRecognize.mock.funcStreamingRecognize == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStreamingRecognize.mock.afterStreamingRecognizeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStreamingRecognize.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StreamingRecognize implements SpeechClient
func (mmStreamingRecognize *SpeechClientMock) StreamingRecognize(ctx context.Context) (s1 StreamingRecognizeClient, err error) {
	mm_atomic.AddUint64(&mmStreamingRecognize.beforeStreamingRecognizeCounter, 1)
	defer mm_atomic.AddUint64(&mmStreamingRecognize.afterStreamingRecognizeCounter, 1)

	mmStreamingRecognize.t.Helper()

	if mmStreamingRecognize.inspectFuncStreamingRecognize != nil {
		mmStreamingRecognize.inspectFuncStreamingRecognize(ctx)
	}

	mm_params := SpeechClientMockStreamingRecognizeParams{ctx}

	// Record call args
	mmStreamingRecognize.StreamingRecognizeMock.mutex.Lock()
	mmStreamingRecognize.StreamingRecognizeMock.callArgs = append(mmStreamingRecognize.StreamingRecognizeMock.callArgs, &mm_params)
	mmStreamingRecognize.StreamingRecognizeMock.mutex.Unlock()

	for _, e := range mmStreamingRecognize.StreamingRecognizeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmStreamingRecognize.StreamingRecognizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStreamingRecognize.StreamingRecognizeMock.defaultExpectation.Counter, 1)
		mm_want := mmStreamingRecognize.StreamingRecognizeMock.defaultExpectation.params
		mm_want_ptrs := mmStreamingRecognize.StreamingRecognizeMock.defaultExpectation.paramPtrs

		mm_got := SpeechClientMockStreamingRecognizeParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStreamingRecognize.t.Errorf("SpeechClientMock.StreamingRecognize got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStreamingRecognize.StreamingRecognizeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStreamingRecognize.t.Errorf("SpeechClientMock.StreamingRecognize got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStreamingRecognize.StreamingRecognizeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStreamingRecognize.StreamingRecognizeMock.defaultExpectation.results
		if mm_results == nil {
			mmStreamingRecognize.t.Fatal("No results are set for the SpeechClientMock.StreamingRecognize")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmStreamingRecognize.funcStreamingRecognize != nil {
		return mmStreamingRecognize.funcStreamingRecognize(ctx)
	}
	mmStreamingRecognize.t.Fatalf("Unexpected call to SpeechClientMock.StreamingRecognize. %v", ctx)
	return
}

// StreamingRecognizeAfterCounter returns a count of finished SpeechClientMock.StreamingRecognize invocations
func (mmStreamingRecognize *SpeechClientMock) StreamingRecognizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStreamingRecognize.afterStreamingRecognizeCounter)
}

// StreamingRecognizeBeforeCounter returns a count of SpeechClientMock.StreamingRecognize invocations
func (mmStreamingRecognize *SpeechClientMock) StreamingRecognizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStreamingRecognize.beforeStreamingRecognizeCounter)
}

// Calls returns a list of arguments used in each call to SpeechClientMock.StreamingRecognize.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStreamingRecognize *mSpeechClientMockStreamingRecognize) Calls() []*SpeechClientMockStreamingRecognizeParams {
	mmStreamingRecognize.mutex.RLock()

	argCopy := make([]*SpeechClientMockStreamingRecognizeParams, len(mmStreamingRecognize.callArgs))
	copy(argCopy, mmStreamingRecognize.callArgs)

	mmStreamingRecognize.mutex.RUnlock()

	return argCopy
}

// MinimockStreamingRecognizeDone returns true if the count of the StreamingRecognize invocations corresponds
// the number of defined expectations
func (m *SpeechClientMock) MinimockStreamingRecognizeDone() bool {
	if m.StreamingRecognizeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StreamingRecognizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StreamingRecognizeMock.invocationsDone()
}

// MinimockStreamingRecognizeInspect logs each unmet expectation
func (m *SpeechClientMock) MinimockStreamingRecognizeInspect() {
	for _, e := range m.StreamingRecognizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpeechClientMock.StreamingRecognize at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStreamingRecognizeCounter := mm_atomic.LoadUint64(&m.afterStreamingRecognizeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StreamingRecognizeMock.defaultExpectation != nil && afterStreamingRecognizeCounter < 1 {
		if m.StreamingRecognizeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SpeechClientMock.StreamingRecognize at\n%s", m.StreamingRecognizeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SpeechClientMock.StreamingRecognize at\n%s with params: %#v", m.StreamingRecognizeMock.defaultExpectation.expectationOrigins.origin, *m.StreamingRecognizeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStreamingRecognize != nil && afterStreamingRecognizeCounter < 1 {
		m.t.Errorf("Expected call to SpeechClientMock.StreamingRecognize at\n%s", m.funcStreamingRecognizeOrigin)
	}

	if !m.StreamingRecognizeMock.invocationsDone() && afterStreamingRecognizeCounter > 0 {
		m.t.Errorf("Expected %d calls to SpeechClientMock.StreamingRecognize at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StreamingRecognizeMock.expectedInvocations), m.StreamingRecognizeMock.expectedInvocationsOrigin, afterStreamingRecognizeCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SpeechClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockStreamingRecognizeInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SpeechClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SpeechClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockStreamingRecognizeDone()
}
