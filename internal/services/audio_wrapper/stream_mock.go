// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package audiowrapper

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StreamMock implements Stream
type StreamMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mStreamMockClose

	funcRead          func() (ia1 []int16, err error)
	funcReadOrigin    string
	inspectFuncRead   func()
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mStreamMockRead

	funcStart          func() (err error)
	funcStartOrigin    string
	inspectFuncStart   func()
	afterStartCounter  uint64
	beforeStartCounter uint64
	StartMock          mStreamMockStart

	funcStop          func() (err error)
	funcStopOrigin    string
	inspectFuncStop   func()
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mStreamMockStop
}

// NewStreamMock returns a mock for Stream
func NewStreamMock(t minimock.Tester) *StreamMock {
	m := &StreamMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mStreamMockClose{mock: m}

	m.ReadMock = mStreamMockRead{mock: m}

	m.StartMock = mStreamMockStart{mock: m}

	m.StopMock = mStreamMockStop{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStreamMockClose struct {
	optional           bool
	mock               *StreamMock
	defaultExpectation *StreamMockCloseExpectation
	expectations       []*StreamMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StreamMockCloseExpectation specifies expectation struct of the Stream.Close
type StreamMockCloseExpectation struct {
	mock *StreamMock

	results      *StreamMockCloseResults
	returnOrigin string
	Counter      uint64
}

// StreamMockCloseResults contains results of the Stream.Close
type StreamMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mStreamMockClose) Optional() *mStreamMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Stream.Close
func (mmClose *mStreamMockClose) Expect() *mStreamMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("StreamMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &StreamMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Stream.Close
func (mmClose *mStreamMockClose) Inspect(f func()) *mStreamMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for StreamMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Stream.Close
func (mmClose *mStreamMockClose) Return(err error) *StreamMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("StreamMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &StreamMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &StreamMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the Stream.Close method
func (mmClose *mStreamMockClose) Set(f func() (err error)) *StreamMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Stream.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Stream.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times Stream.Close should be invoked
func (mmClose *mStreamMockClose) Times(n uint64) *mStreamMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of StreamMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mStreamMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements Stream
func (mmClose *StreamMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the StreamMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to StreamMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished StreamMock.Close invocations
func (mmClose *StreamMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of StreamMock.Close invocations
func (mmClose *StreamMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *StreamMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *StreamMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StreamMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to StreamMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to StreamMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to StreamMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mStreamMockRead struct {
	optional           bool
	mock               *StreamMock
	defaultExpectation *StreamMockReadExpectation
	expectations       []*StreamMockReadExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StreamMockReadExpectation specifies expectation struct of the Stream.Read
type StreamMockReadExpectation struct {
	mock *StreamMock

	results      *StreamMockReadResults
	returnOrigin string
	Counter      uint64
}

// StreamMockReadResults contains results of the Stream.Read
type StreamMockReadResults struct {
	ia1 []int16
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRead *mStreamMockRead) Optional() *mStreamMockRead {
	mmRead.optional = true
	return mmRead
}

// Expect sets up expected params for Stream.Read
func (mmRead *mStreamMockRead) Expect() *mStreamMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("StreamMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &StreamMockReadExpectation{}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the Stream.Read
func (mmRead *mStreamMockRead) Inspect(f func()) *mStreamMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for StreamMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by Stream.Read
func (mmRead *mStreamMockRead) Return(ia1 []int16, err error) *StreamMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("StreamMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &StreamMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &StreamMockReadResults{ia1, err}
	mmRead.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRead.mock
}

// Set uses given function f to mock the Stream.Read method
func (mmRead *mStreamMockRead) Set(f func() (ia1 []int16, err error)) *StreamMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the Stream.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the Stream.Read method")
	}

	mmRead.mock.funcRead = f
	mmRead.mock.funcReadOrigin = minimock.CallerInfo(1)
	return mmRead.mock
}

// Times sets number of times Stream.Read should be invoked
func (mmRead *mStreamMockRead) Times(n uint64) *mStreamMockRead {
	if n == 0 {
		mmRead.mock.t.Fatalf("Times of StreamMock.Read mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRead.expectedInvocations, n)
	mmRead.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRead
}

func (mmRead *mStreamMockRead) invocationsDone() bool {
	if len(mmRead.expectations) == 0 && mmRead.defaultExpectation == nil && mmRead.mock.funcRead == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRead.mock.afterReadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRead.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Read implements Stream
func (mmRead *StreamMock) Read() (ia1 []int16, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	mmRead.t.Helper()

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead()
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)

		mm_results := mmRead.ReadMock.defaultExpectation.results
		if mm_results == nil {
			mmRead.t.Fatal("No results are set for the StreamMock.Read")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead()
	}
	mmRead.t.Fatalf("Unexpected call to StreamMock.Read.")
	return
}

// ReadAfterCounter returns a count of finished StreamMock.Read invocations
func (mmRead *StreamMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of StreamMock.Read invocations
func (mmRead *StreamMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *StreamMock) MinimockReadDone() bool {
	if m.ReadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadMock.invocationsDone()
}

// MinimockReadInspect logs each unmet expectation
func (m *StreamMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StreamMock.Read")
		}
	}

	afterReadCounter := mm_atomic.LoadUint64(&m.afterReadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && afterReadCounter < 1 {
		m.t.Errorf("Expected call to StreamMock.Read at\n%s", m.ReadMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && afterReadCounter < 1 {
		m.t.Errorf("Expected call to StreamMock.Read at\n%s", m.funcReadOrigin)
	}

	if !m.ReadMock.invocationsDone() && afterReadCounter > 0 {
		m.t.Errorf("Expected %d calls to StreamMock.Read at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadMock.expectedInvocations), m.ReadMock.expectedInvocationsOrigin, afterReadCounter)
	}
}

type mStreamMockStart struct {
	optional           bool
	mock               *StreamMock
	defaultExpectation *StreamMockStartExpectation
	expectations       []*StreamMockStartExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StreamMockStartExpectation specifies expectation struct of the Stream.Start
type StreamMockStartExpectation struct {
	mock *StreamMock

	results      *StreamMockStartResults
	returnOrigin string
	Counter      uint64
}

// StreamMockStartResults contains results of the Stream.Start
type StreamMockStartResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStart *mStreamMockStart) Optional() *mStreamMockStart {
	mmStart.optional = true
	return mmStart
}

// Expect sets up expected params for Stream.Start
func (mmStart *mStreamMockStart) Expect() *mStreamMockStart {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("StreamMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &StreamMockStartExpectation{}
	}

	return mmStart
}

// Inspect accepts an inspector function that has same arguments as the Stream.Start
func (mmStart *mStreamMockStart) Inspect(f func()) *mStreamMockStart {
	if mmStart.mock.inspectFuncStart != nil {
		mmStart.mock.t.Fatalf("Inspect function is already set for StreamMock.Start")
	}

	mmStart.mock.inspectFuncStart = f

	return mmStart
}

// Return sets up results that will be returned by Stream.Start
func (mmStart *mStreamMockStart) Return(err error) *StreamMock {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("StreamMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &StreamMockStartExpectation{mock: mmStart.mock}
	}
	mmStart.defaultExpectation.results = &StreamMockStartResults{err}
	mmStart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStart.mock
}

// Set uses given function f to mock the Stream.Start method
func (mmStart *mStreamMockStart) Set(f func() (err error)) *StreamMock {
	if mmStart.defaultExpectation != nil {
		mmStart.mock.t.Fatalf("Default expectation is already set for the Stream.Start method")
	}

	if len(mmStart.expectations) > 0 {
		mmStart.mock.t.Fatalf("Some expectations are already set for the Stream.Start method")
	}

	mmStart.mock.funcStart = f
	mmStart.mock.funcStartOrigin = minimock.CallerInfo(1)
	return mmStart.mock
}

// Times sets number of times Stream.Start should be invoked
func (mmStart *mStreamMockStart) Times(n uint64) *mStreamMockStart {
	if n == 0 {
		mmStart.mock.t.Fatalf("Times of StreamMock.Start mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStart.expectedInvocations, n)
	mmStart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStart
}

func (mmStart *mStreamMockStart) invocationsDone() bool {
	if len(mmStart.expectations) == 0 && mmStart.defaultExpectation == nil && mmStart.mock.funcStart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStart.mock.afterStartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Start implements Stream
func (mmStart *StreamMock) Start() (err error) {
	mm_atomic.AddUint64(&mmStart.beforeStartCounter, 1)
	defer mm_atomic.AddUint64(&mmStart.afterStartCounter, 1)

	mmStart.t.Helper()

	if mmStart.inspectFuncStart != nil {
		mmStart.inspectFuncStart()
	}

	if mmStart.StartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStart.StartMock.defaultExpectation.Counter, 1)

		mm_results := mmStart.StartMock.defaultExpectation.results
		if mm_results == nil {
			mmStart.t.Fatal("No results are set for the StreamMock.Start")
		}
		return (*mm_results).err
	}
	if mmStart.funcStart != nil {
		return mmStart.funcStart()
	}
	mmStart.t.Fatalf("Unexpected call to StreamMock.Start.")
	return
}

// StartAfterCounter returns a count of finished StreamMock.Start invocations
func (mmStart *StreamMock) StartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.afterStartCounter)
}

// StartBeforeCounter returns a count of StreamMock.Start invocations
func (mmStart *StreamMock) StartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.beforeStartCounter)
}

// MinimockStartDone returns true if the count of the Start invocations corresponds
// the number of defined expectations
func (m *StreamMock) MinimockStartDone() bool {
	if m.StartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StartMock.invocationsDone()
}

// MinimockStartInspect logs each unmet expectation
func (m *StreamMock) MinimockStartInspect() {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StreamMock.Start")
		}
	}

	afterStartCounter := mm_atomic.LoadUint64(&m.afterStartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && afterStartCounter < 1 {
		m.t.Errorf("Expected call to StreamMock.Start at\n%s", m.StartMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && afterStartCounter < 1 {
		m.t.Errorf("Expected call to StreamMock.Start at\n%s", m.funcStartOrigin)
	}

	if !m.StartMock.invocationsDone() && afterStartCounter > 0 {
		m.t.Errorf("Expected %d calls to StreamMock.Start at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StartMock.expectedInvocations), m.StartMock.expectedInvocationsOrigin, afterStartCounter)
	}
}

type mStreamMockStop struct {
	optional           bool
	mock               *StreamMock
	defaultExpectation *StreamMockStopExpectation
	expectations       []*StreamMockStopExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StreamMockStopExpectation specifies expectation struct of the Stream.Stop
type StreamMockStopExpectation struct {
	mock *StreamMock

	results      *StreamMockStopResults
	returnOrigin string
	Counter      uint64
}

// StreamMockStopResults contains results of the Stream.Stop
type StreamMockStopResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStop *mStreamMockStop) Optional() *mStreamMockStop {
	mmStop.optional = true
	return mmStop
}

// Expect sets up expected params for Stream.Stop
func (mmStop *mStreamMockStop) Expect() *mStreamMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("StreamMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &StreamMockStopExpectation{}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the Stream.Stop
func (mmStop *mStreamMockStop) Inspect(f func()) *mStreamMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for StreamMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by Stream.Stop
func (mmStop *mStreamMockStop) Return(err error) *StreamMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("StreamMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &StreamMockStopExpectation{mock: mmStop.mock}
	}
	mmStop.defaultExpectation.results = &StreamMockStopResults{err}
	mmStop.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStop.mock
}

// Set uses given function f to mock the Stream.Stop method
func (mmStop *mStreamMockStop) Set(f func() (err error)) *StreamMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the Stream.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the Stream.Stop method")
	}

	mmStop.mock.funcStop = f
	mmStop.mock.funcStopOrigin = minimock.CallerInfo(1)
	return mmStop.mock
}

// Times sets number of times Stream.Stop should be invoked
func (mmStop *mStreamMockStop) Times(n uint64) *mStreamMockStop {
	if n == 0 {
		mmStop.mock.t.Fatalf("Times of StreamMock.Stop mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStop.expectedInvocations, n)
	mmStop.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStop
}

func (mmStop *mStreamMockStop) invocationsDone() bool {
	if len(mmStop.expectations) == 0 && mmStop.defaultExpectation == nil && mmStop.mock.funcStop == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStop.mock.afterStopCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStop.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Stop implements Stream
func (mmStop *StreamMock) Stop() (err error) {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	mmStop.t.Helper()

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop()
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)

		mm_results := mmStop.StopMock.defaultExpectation.results
		if mm_results == nil {
			mmStop.t.Fatal("No results are set for the StreamMock.Stop")
		}
		return (*mm_results).err
	}
	if mmStop.funcStop != nil {
		return mmStop.funcStop()
	}
	mmStop.t.Fatalf("Unexpected call to StreamMock.Stop.")
	return
}

// StopAfterCounter returns a count of finished StreamMock.Stop invocations
func (mmStop *StreamMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of StreamMock.Stop invocations
func (mmStop *StreamMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *StreamMock) MinimockStopDone() bool {
	if m.StopMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StopMock.invocationsDone()
}

// MinimockStopInspect logs each unmet expectation
func (m *StreamMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StreamMock.Stop")
		}
	}

	afterStopCounter := mm_atomic.LoadUint64(&m.afterStopCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && afterStopCounter < 1 {
		m.t.Errorf("Expected call to StreamMock.Stop at\n%s", m.StopMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && afterStopCounter < 1 {
		m.t.Errorf("Expected call to StreamMock.Stop at\n%s", m.funcStopOrigin)
	}

	if !m.StopMock.invocationsDone() && afterStopCounter > 0 {
		m.t.Errorf("Expected %d calls to StreamMock.Stop at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StopMock.expectedInvocations), m.StopMock.expectedInvocationsOrigin, afterStopCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StreamMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockReadInspect()

			m.MinimockStartInspect()

			m.MinimockStopInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StreamMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StreamMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockReadDone() &&
		m.MinimockStartDone() &&
		m.MinimockStopDone()
}
