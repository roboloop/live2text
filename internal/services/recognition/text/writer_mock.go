// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package text

import (
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// WriterMock implements Writer
type WriterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcFinalize          func() (err error)
	funcFinalizeOrigin    string
	inspectFuncFinalize   func()
	afterFinalizeCounter  uint64
	beforeFinalizeCounter uint64
	FinalizeMock          mWriterMockFinalize

	funcPrintCandidate          func(duration time.Duration, text string) (err error)
	funcPrintCandidateOrigin    string
	inspectFuncPrintCandidate   func(duration time.Duration, text string)
	afterPrintCandidateCounter  uint64
	beforePrintCandidateCounter uint64
	PrintCandidateMock          mWriterMockPrintCandidate

	funcPrintFinal          func(duration time.Duration, text string) (err error)
	funcPrintFinalOrigin    string
	inspectFuncPrintFinal   func(duration time.Duration, text string)
	afterPrintFinalCounter  uint64
	beforePrintFinalCounter uint64
	PrintFinalMock          mWriterMockPrintFinal
}

// NewWriterMock returns a mock for Writer
func NewWriterMock(t minimock.Tester) *WriterMock {
	m := &WriterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.FinalizeMock = mWriterMockFinalize{mock: m}

	m.PrintCandidateMock = mWriterMockPrintCandidate{mock: m}
	m.PrintCandidateMock.callArgs = []*WriterMockPrintCandidateParams{}

	m.PrintFinalMock = mWriterMockPrintFinal{mock: m}
	m.PrintFinalMock.callArgs = []*WriterMockPrintFinalParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mWriterMockFinalize struct {
	optional           bool
	mock               *WriterMock
	defaultExpectation *WriterMockFinalizeExpectation
	expectations       []*WriterMockFinalizeExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// WriterMockFinalizeExpectation specifies expectation struct of the Writer.Finalize
type WriterMockFinalizeExpectation struct {
	mock *WriterMock

	results      *WriterMockFinalizeResults
	returnOrigin string
	Counter      uint64
}

// WriterMockFinalizeResults contains results of the Writer.Finalize
type WriterMockFinalizeResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFinalize *mWriterMockFinalize) Optional() *mWriterMockFinalize {
	mmFinalize.optional = true
	return mmFinalize
}

// Expect sets up expected params for Writer.Finalize
func (mmFinalize *mWriterMockFinalize) Expect() *mWriterMockFinalize {
	if mmFinalize.mock.funcFinalize != nil {
		mmFinalize.mock.t.Fatalf("WriterMock.Finalize mock is already set by Set")
	}

	if mmFinalize.defaultExpectation == nil {
		mmFinalize.defaultExpectation = &WriterMockFinalizeExpectation{}
	}

	return mmFinalize
}

// Inspect accepts an inspector function that has same arguments as the Writer.Finalize
func (mmFinalize *mWriterMockFinalize) Inspect(f func()) *mWriterMockFinalize {
	if mmFinalize.mock.inspectFuncFinalize != nil {
		mmFinalize.mock.t.Fatalf("Inspect function is already set for WriterMock.Finalize")
	}

	mmFinalize.mock.inspectFuncFinalize = f

	return mmFinalize
}

// Return sets up results that will be returned by Writer.Finalize
func (mmFinalize *mWriterMockFinalize) Return(err error) *WriterMock {
	if mmFinalize.mock.funcFinalize != nil {
		mmFinalize.mock.t.Fatalf("WriterMock.Finalize mock is already set by Set")
	}

	if mmFinalize.defaultExpectation == nil {
		mmFinalize.defaultExpectation = &WriterMockFinalizeExpectation{mock: mmFinalize.mock}
	}
	mmFinalize.defaultExpectation.results = &WriterMockFinalizeResults{err}
	mmFinalize.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFinalize.mock
}

// Set uses given function f to mock the Writer.Finalize method
func (mmFinalize *mWriterMockFinalize) Set(f func() (err error)) *WriterMock {
	if mmFinalize.defaultExpectation != nil {
		mmFinalize.mock.t.Fatalf("Default expectation is already set for the Writer.Finalize method")
	}

	if len(mmFinalize.expectations) > 0 {
		mmFinalize.mock.t.Fatalf("Some expectations are already set for the Writer.Finalize method")
	}

	mmFinalize.mock.funcFinalize = f
	mmFinalize.mock.funcFinalizeOrigin = minimock.CallerInfo(1)
	return mmFinalize.mock
}

// Times sets number of times Writer.Finalize should be invoked
func (mmFinalize *mWriterMockFinalize) Times(n uint64) *mWriterMockFinalize {
	if n == 0 {
		mmFinalize.mock.t.Fatalf("Times of WriterMock.Finalize mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFinalize.expectedInvocations, n)
	mmFinalize.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFinalize
}

func (mmFinalize *mWriterMockFinalize) invocationsDone() bool {
	if len(mmFinalize.expectations) == 0 && mmFinalize.defaultExpectation == nil && mmFinalize.mock.funcFinalize == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFinalize.mock.afterFinalizeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFinalize.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Finalize implements Writer
func (mmFinalize *WriterMock) Finalize() (err error) {
	mm_atomic.AddUint64(&mmFinalize.beforeFinalizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFinalize.afterFinalizeCounter, 1)

	mmFinalize.t.Helper()

	if mmFinalize.inspectFuncFinalize != nil {
		mmFinalize.inspectFuncFinalize()
	}

	if mmFinalize.FinalizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFinalize.FinalizeMock.defaultExpectation.Counter, 1)

		mm_results := mmFinalize.FinalizeMock.defaultExpectation.results
		if mm_results == nil {
			mmFinalize.t.Fatal("No results are set for the WriterMock.Finalize")
		}
		return (*mm_results).err
	}
	if mmFinalize.funcFinalize != nil {
		return mmFinalize.funcFinalize()
	}
	mmFinalize.t.Fatalf("Unexpected call to WriterMock.Finalize.")
	return
}

// FinalizeAfterCounter returns a count of finished WriterMock.Finalize invocations
func (mmFinalize *WriterMock) FinalizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFinalize.afterFinalizeCounter)
}

// FinalizeBeforeCounter returns a count of WriterMock.Finalize invocations
func (mmFinalize *WriterMock) FinalizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFinalize.beforeFinalizeCounter)
}

// MinimockFinalizeDone returns true if the count of the Finalize invocations corresponds
// the number of defined expectations
func (m *WriterMock) MinimockFinalizeDone() bool {
	if m.FinalizeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FinalizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FinalizeMock.invocationsDone()
}

// MinimockFinalizeInspect logs each unmet expectation
func (m *WriterMock) MinimockFinalizeInspect() {
	for _, e := range m.FinalizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to WriterMock.Finalize")
		}
	}

	afterFinalizeCounter := mm_atomic.LoadUint64(&m.afterFinalizeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FinalizeMock.defaultExpectation != nil && afterFinalizeCounter < 1 {
		m.t.Errorf("Expected call to WriterMock.Finalize at\n%s", m.FinalizeMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFinalize != nil && afterFinalizeCounter < 1 {
		m.t.Errorf("Expected call to WriterMock.Finalize at\n%s", m.funcFinalizeOrigin)
	}

	if !m.FinalizeMock.invocationsDone() && afterFinalizeCounter > 0 {
		m.t.Errorf("Expected %d calls to WriterMock.Finalize at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FinalizeMock.expectedInvocations), m.FinalizeMock.expectedInvocationsOrigin, afterFinalizeCounter)
	}
}

type mWriterMockPrintCandidate struct {
	optional           bool
	mock               *WriterMock
	defaultExpectation *WriterMockPrintCandidateExpectation
	expectations       []*WriterMockPrintCandidateExpectation

	callArgs []*WriterMockPrintCandidateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// WriterMockPrintCandidateExpectation specifies expectation struct of the Writer.PrintCandidate
type WriterMockPrintCandidateExpectation struct {
	mock               *WriterMock
	params             *WriterMockPrintCandidateParams
	paramPtrs          *WriterMockPrintCandidateParamPtrs
	expectationOrigins WriterMockPrintCandidateExpectationOrigins
	results            *WriterMockPrintCandidateResults
	returnOrigin       string
	Counter            uint64
}

// WriterMockPrintCandidateParams contains parameters of the Writer.PrintCandidate
type WriterMockPrintCandidateParams struct {
	duration time.Duration
	text     string
}

// WriterMockPrintCandidateParamPtrs contains pointers to parameters of the Writer.PrintCandidate
type WriterMockPrintCandidateParamPtrs struct {
	duration *time.Duration
	text     *string
}

// WriterMockPrintCandidateResults contains results of the Writer.PrintCandidate
type WriterMockPrintCandidateResults struct {
	err error
}

// WriterMockPrintCandidateOrigins contains origins of expectations of the Writer.PrintCandidate
type WriterMockPrintCandidateExpectationOrigins struct {
	origin         string
	originDuration string
	originText     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrintCandidate *mWriterMockPrintCandidate) Optional() *mWriterMockPrintCandidate {
	mmPrintCandidate.optional = true
	return mmPrintCandidate
}

// Expect sets up expected params for Writer.PrintCandidate
func (mmPrintCandidate *mWriterMockPrintCandidate) Expect(duration time.Duration, text string) *mWriterMockPrintCandidate {
	if mmPrintCandidate.mock.funcPrintCandidate != nil {
		mmPrintCandidate.mock.t.Fatalf("WriterMock.PrintCandidate mock is already set by Set")
	}

	if mmPrintCandidate.defaultExpectation == nil {
		mmPrintCandidate.defaultExpectation = &WriterMockPrintCandidateExpectation{}
	}

	if mmPrintCandidate.defaultExpectation.paramPtrs != nil {
		mmPrintCandidate.mock.t.Fatalf("WriterMock.PrintCandidate mock is already set by ExpectParams functions")
	}

	mmPrintCandidate.defaultExpectation.params = &WriterMockPrintCandidateParams{duration, text}
	mmPrintCandidate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPrintCandidate.expectations {
		if minimock.Equal(e.params, mmPrintCandidate.defaultExpectation.params) {
			mmPrintCandidate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrintCandidate.defaultExpectation.params)
		}
	}

	return mmPrintCandidate
}

// ExpectDurationParam1 sets up expected param duration for Writer.PrintCandidate
func (mmPrintCandidate *mWriterMockPrintCandidate) ExpectDurationParam1(duration time.Duration) *mWriterMockPrintCandidate {
	if mmPrintCandidate.mock.funcPrintCandidate != nil {
		mmPrintCandidate.mock.t.Fatalf("WriterMock.PrintCandidate mock is already set by Set")
	}

	if mmPrintCandidate.defaultExpectation == nil {
		mmPrintCandidate.defaultExpectation = &WriterMockPrintCandidateExpectation{}
	}

	if mmPrintCandidate.defaultExpectation.params != nil {
		mmPrintCandidate.mock.t.Fatalf("WriterMock.PrintCandidate mock is already set by Expect")
	}

	if mmPrintCandidate.defaultExpectation.paramPtrs == nil {
		mmPrintCandidate.defaultExpectation.paramPtrs = &WriterMockPrintCandidateParamPtrs{}
	}
	mmPrintCandidate.defaultExpectation.paramPtrs.duration = &duration
	mmPrintCandidate.defaultExpectation.expectationOrigins.originDuration = minimock.CallerInfo(1)

	return mmPrintCandidate
}

// ExpectTextParam2 sets up expected param text for Writer.PrintCandidate
func (mmPrintCandidate *mWriterMockPrintCandidate) ExpectTextParam2(text string) *mWriterMockPrintCandidate {
	if mmPrintCandidate.mock.funcPrintCandidate != nil {
		mmPrintCandidate.mock.t.Fatalf("WriterMock.PrintCandidate mock is already set by Set")
	}

	if mmPrintCandidate.defaultExpectation == nil {
		mmPrintCandidate.defaultExpectation = &WriterMockPrintCandidateExpectation{}
	}

	if mmPrintCandidate.defaultExpectation.params != nil {
		mmPrintCandidate.mock.t.Fatalf("WriterMock.PrintCandidate mock is already set by Expect")
	}

	if mmPrintCandidate.defaultExpectation.paramPtrs == nil {
		mmPrintCandidate.defaultExpectation.paramPtrs = &WriterMockPrintCandidateParamPtrs{}
	}
	mmPrintCandidate.defaultExpectation.paramPtrs.text = &text
	mmPrintCandidate.defaultExpectation.expectationOrigins.originText = minimock.CallerInfo(1)

	return mmPrintCandidate
}

// Inspect accepts an inspector function that has same arguments as the Writer.PrintCandidate
func (mmPrintCandidate *mWriterMockPrintCandidate) Inspect(f func(duration time.Duration, text string)) *mWriterMockPrintCandidate {
	if mmPrintCandidate.mock.inspectFuncPrintCandidate != nil {
		mmPrintCandidate.mock.t.Fatalf("Inspect function is already set for WriterMock.PrintCandidate")
	}

	mmPrintCandidate.mock.inspectFuncPrintCandidate = f

	return mmPrintCandidate
}

// Return sets up results that will be returned by Writer.PrintCandidate
func (mmPrintCandidate *mWriterMockPrintCandidate) Return(err error) *WriterMock {
	if mmPrintCandidate.mock.funcPrintCandidate != nil {
		mmPrintCandidate.mock.t.Fatalf("WriterMock.PrintCandidate mock is already set by Set")
	}

	if mmPrintCandidate.defaultExpectation == nil {
		mmPrintCandidate.defaultExpectation = &WriterMockPrintCandidateExpectation{mock: mmPrintCandidate.mock}
	}
	mmPrintCandidate.defaultExpectation.results = &WriterMockPrintCandidateResults{err}
	mmPrintCandidate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrintCandidate.mock
}

// Set uses given function f to mock the Writer.PrintCandidate method
func (mmPrintCandidate *mWriterMockPrintCandidate) Set(f func(duration time.Duration, text string) (err error)) *WriterMock {
	if mmPrintCandidate.defaultExpectation != nil {
		mmPrintCandidate.mock.t.Fatalf("Default expectation is already set for the Writer.PrintCandidate method")
	}

	if len(mmPrintCandidate.expectations) > 0 {
		mmPrintCandidate.mock.t.Fatalf("Some expectations are already set for the Writer.PrintCandidate method")
	}

	mmPrintCandidate.mock.funcPrintCandidate = f
	mmPrintCandidate.mock.funcPrintCandidateOrigin = minimock.CallerInfo(1)
	return mmPrintCandidate.mock
}

// When sets expectation for the Writer.PrintCandidate which will trigger the result defined by the following
// Then helper
func (mmPrintCandidate *mWriterMockPrintCandidate) When(duration time.Duration, text string) *WriterMockPrintCandidateExpectation {
	if mmPrintCandidate.mock.funcPrintCandidate != nil {
		mmPrintCandidate.mock.t.Fatalf("WriterMock.PrintCandidate mock is already set by Set")
	}

	expectation := &WriterMockPrintCandidateExpectation{
		mock:               mmPrintCandidate.mock,
		params:             &WriterMockPrintCandidateParams{duration, text},
		expectationOrigins: WriterMockPrintCandidateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPrintCandidate.expectations = append(mmPrintCandidate.expectations, expectation)
	return expectation
}

// Then sets up Writer.PrintCandidate return parameters for the expectation previously defined by the When method
func (e *WriterMockPrintCandidateExpectation) Then(err error) *WriterMock {
	e.results = &WriterMockPrintCandidateResults{err}
	return e.mock
}

// Times sets number of times Writer.PrintCandidate should be invoked
func (mmPrintCandidate *mWriterMockPrintCandidate) Times(n uint64) *mWriterMockPrintCandidate {
	if n == 0 {
		mmPrintCandidate.mock.t.Fatalf("Times of WriterMock.PrintCandidate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrintCandidate.expectedInvocations, n)
	mmPrintCandidate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrintCandidate
}

func (mmPrintCandidate *mWriterMockPrintCandidate) invocationsDone() bool {
	if len(mmPrintCandidate.expectations) == 0 && mmPrintCandidate.defaultExpectation == nil && mmPrintCandidate.mock.funcPrintCandidate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrintCandidate.mock.afterPrintCandidateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrintCandidate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PrintCandidate implements Writer
func (mmPrintCandidate *WriterMock) PrintCandidate(duration time.Duration, text string) (err error) {
	mm_atomic.AddUint64(&mmPrintCandidate.beforePrintCandidateCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintCandidate.afterPrintCandidateCounter, 1)

	mmPrintCandidate.t.Helper()

	if mmPrintCandidate.inspectFuncPrintCandidate != nil {
		mmPrintCandidate.inspectFuncPrintCandidate(duration, text)
	}

	mm_params := WriterMockPrintCandidateParams{duration, text}

	// Record call args
	mmPrintCandidate.PrintCandidateMock.mutex.Lock()
	mmPrintCandidate.PrintCandidateMock.callArgs = append(mmPrintCandidate.PrintCandidateMock.callArgs, &mm_params)
	mmPrintCandidate.PrintCandidateMock.mutex.Unlock()

	for _, e := range mmPrintCandidate.PrintCandidateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPrintCandidate.PrintCandidateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintCandidate.PrintCandidateMock.defaultExpectation.Counter, 1)
		mm_want := mmPrintCandidate.PrintCandidateMock.defaultExpectation.params
		mm_want_ptrs := mmPrintCandidate.PrintCandidateMock.defaultExpectation.paramPtrs

		mm_got := WriterMockPrintCandidateParams{duration, text}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.duration != nil && !minimock.Equal(*mm_want_ptrs.duration, mm_got.duration) {
				mmPrintCandidate.t.Errorf("WriterMock.PrintCandidate got unexpected parameter duration, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrintCandidate.PrintCandidateMock.defaultExpectation.expectationOrigins.originDuration, *mm_want_ptrs.duration, mm_got.duration, minimock.Diff(*mm_want_ptrs.duration, mm_got.duration))
			}

			if mm_want_ptrs.text != nil && !minimock.Equal(*mm_want_ptrs.text, mm_got.text) {
				mmPrintCandidate.t.Errorf("WriterMock.PrintCandidate got unexpected parameter text, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrintCandidate.PrintCandidateMock.defaultExpectation.expectationOrigins.originText, *mm_want_ptrs.text, mm_got.text, minimock.Diff(*mm_want_ptrs.text, mm_got.text))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrintCandidate.t.Errorf("WriterMock.PrintCandidate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPrintCandidate.PrintCandidateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrintCandidate.PrintCandidateMock.defaultExpectation.results
		if mm_results == nil {
			mmPrintCandidate.t.Fatal("No results are set for the WriterMock.PrintCandidate")
		}
		return (*mm_results).err
	}
	if mmPrintCandidate.funcPrintCandidate != nil {
		return mmPrintCandidate.funcPrintCandidate(duration, text)
	}
	mmPrintCandidate.t.Fatalf("Unexpected call to WriterMock.PrintCandidate. %v %v", duration, text)
	return
}

// PrintCandidateAfterCounter returns a count of finished WriterMock.PrintCandidate invocations
func (mmPrintCandidate *WriterMock) PrintCandidateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintCandidate.afterPrintCandidateCounter)
}

// PrintCandidateBeforeCounter returns a count of WriterMock.PrintCandidate invocations
func (mmPrintCandidate *WriterMock) PrintCandidateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintCandidate.beforePrintCandidateCounter)
}

// Calls returns a list of arguments used in each call to WriterMock.PrintCandidate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrintCandidate *mWriterMockPrintCandidate) Calls() []*WriterMockPrintCandidateParams {
	mmPrintCandidate.mutex.RLock()

	argCopy := make([]*WriterMockPrintCandidateParams, len(mmPrintCandidate.callArgs))
	copy(argCopy, mmPrintCandidate.callArgs)

	mmPrintCandidate.mutex.RUnlock()

	return argCopy
}

// MinimockPrintCandidateDone returns true if the count of the PrintCandidate invocations corresponds
// the number of defined expectations
func (m *WriterMock) MinimockPrintCandidateDone() bool {
	if m.PrintCandidateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintCandidateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintCandidateMock.invocationsDone()
}

// MinimockPrintCandidateInspect logs each unmet expectation
func (m *WriterMock) MinimockPrintCandidateInspect() {
	for _, e := range m.PrintCandidateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WriterMock.PrintCandidate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPrintCandidateCounter := mm_atomic.LoadUint64(&m.afterPrintCandidateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintCandidateMock.defaultExpectation != nil && afterPrintCandidateCounter < 1 {
		if m.PrintCandidateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to WriterMock.PrintCandidate at\n%s", m.PrintCandidateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to WriterMock.PrintCandidate at\n%s with params: %#v", m.PrintCandidateMock.defaultExpectation.expectationOrigins.origin, *m.PrintCandidateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintCandidate != nil && afterPrintCandidateCounter < 1 {
		m.t.Errorf("Expected call to WriterMock.PrintCandidate at\n%s", m.funcPrintCandidateOrigin)
	}

	if !m.PrintCandidateMock.invocationsDone() && afterPrintCandidateCounter > 0 {
		m.t.Errorf("Expected %d calls to WriterMock.PrintCandidate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrintCandidateMock.expectedInvocations), m.PrintCandidateMock.expectedInvocationsOrigin, afterPrintCandidateCounter)
	}
}

type mWriterMockPrintFinal struct {
	optional           bool
	mock               *WriterMock
	defaultExpectation *WriterMockPrintFinalExpectation
	expectations       []*WriterMockPrintFinalExpectation

	callArgs []*WriterMockPrintFinalParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// WriterMockPrintFinalExpectation specifies expectation struct of the Writer.PrintFinal
type WriterMockPrintFinalExpectation struct {
	mock               *WriterMock
	params             *WriterMockPrintFinalParams
	paramPtrs          *WriterMockPrintFinalParamPtrs
	expectationOrigins WriterMockPrintFinalExpectationOrigins
	results            *WriterMockPrintFinalResults
	returnOrigin       string
	Counter            uint64
}

// WriterMockPrintFinalParams contains parameters of the Writer.PrintFinal
type WriterMockPrintFinalParams struct {
	duration time.Duration
	text     string
}

// WriterMockPrintFinalParamPtrs contains pointers to parameters of the Writer.PrintFinal
type WriterMockPrintFinalParamPtrs struct {
	duration *time.Duration
	text     *string
}

// WriterMockPrintFinalResults contains results of the Writer.PrintFinal
type WriterMockPrintFinalResults struct {
	err error
}

// WriterMockPrintFinalOrigins contains origins of expectations of the Writer.PrintFinal
type WriterMockPrintFinalExpectationOrigins struct {
	origin         string
	originDuration string
	originText     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrintFinal *mWriterMockPrintFinal) Optional() *mWriterMockPrintFinal {
	mmPrintFinal.optional = true
	return mmPrintFinal
}

// Expect sets up expected params for Writer.PrintFinal
func (mmPrintFinal *mWriterMockPrintFinal) Expect(duration time.Duration, text string) *mWriterMockPrintFinal {
	if mmPrintFinal.mock.funcPrintFinal != nil {
		mmPrintFinal.mock.t.Fatalf("WriterMock.PrintFinal mock is already set by Set")
	}

	if mmPrintFinal.defaultExpectation == nil {
		mmPrintFinal.defaultExpectation = &WriterMockPrintFinalExpectation{}
	}

	if mmPrintFinal.defaultExpectation.paramPtrs != nil {
		mmPrintFinal.mock.t.Fatalf("WriterMock.PrintFinal mock is already set by ExpectParams functions")
	}

	mmPrintFinal.defaultExpectation.params = &WriterMockPrintFinalParams{duration, text}
	mmPrintFinal.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPrintFinal.expectations {
		if minimock.Equal(e.params, mmPrintFinal.defaultExpectation.params) {
			mmPrintFinal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrintFinal.defaultExpectation.params)
		}
	}

	return mmPrintFinal
}

// ExpectDurationParam1 sets up expected param duration for Writer.PrintFinal
func (mmPrintFinal *mWriterMockPrintFinal) ExpectDurationParam1(duration time.Duration) *mWriterMockPrintFinal {
	if mmPrintFinal.mock.funcPrintFinal != nil {
		mmPrintFinal.mock.t.Fatalf("WriterMock.PrintFinal mock is already set by Set")
	}

	if mmPrintFinal.defaultExpectation == nil {
		mmPrintFinal.defaultExpectation = &WriterMockPrintFinalExpectation{}
	}

	if mmPrintFinal.defaultExpectation.params != nil {
		mmPrintFinal.mock.t.Fatalf("WriterMock.PrintFinal mock is already set by Expect")
	}

	if mmPrintFinal.defaultExpectation.paramPtrs == nil {
		mmPrintFinal.defaultExpectation.paramPtrs = &WriterMockPrintFinalParamPtrs{}
	}
	mmPrintFinal.defaultExpectation.paramPtrs.duration = &duration
	mmPrintFinal.defaultExpectation.expectationOrigins.originDuration = minimock.CallerInfo(1)

	return mmPrintFinal
}

// ExpectTextParam2 sets up expected param text for Writer.PrintFinal
func (mmPrintFinal *mWriterMockPrintFinal) ExpectTextParam2(text string) *mWriterMockPrintFinal {
	if mmPrintFinal.mock.funcPrintFinal != nil {
		mmPrintFinal.mock.t.Fatalf("WriterMock.PrintFinal mock is already set by Set")
	}

	if mmPrintFinal.defaultExpectation == nil {
		mmPrintFinal.defaultExpectation = &WriterMockPrintFinalExpectation{}
	}

	if mmPrintFinal.defaultExpectation.params != nil {
		mmPrintFinal.mock.t.Fatalf("WriterMock.PrintFinal mock is already set by Expect")
	}

	if mmPrintFinal.defaultExpectation.paramPtrs == nil {
		mmPrintFinal.defaultExpectation.paramPtrs = &WriterMockPrintFinalParamPtrs{}
	}
	mmPrintFinal.defaultExpectation.paramPtrs.text = &text
	mmPrintFinal.defaultExpectation.expectationOrigins.originText = minimock.CallerInfo(1)

	return mmPrintFinal
}

// Inspect accepts an inspector function that has same arguments as the Writer.PrintFinal
func (mmPrintFinal *mWriterMockPrintFinal) Inspect(f func(duration time.Duration, text string)) *mWriterMockPrintFinal {
	if mmPrintFinal.mock.inspectFuncPrintFinal != nil {
		mmPrintFinal.mock.t.Fatalf("Inspect function is already set for WriterMock.PrintFinal")
	}

	mmPrintFinal.mock.inspectFuncPrintFinal = f

	return mmPrintFinal
}

// Return sets up results that will be returned by Writer.PrintFinal
func (mmPrintFinal *mWriterMockPrintFinal) Return(err error) *WriterMock {
	if mmPrintFinal.mock.funcPrintFinal != nil {
		mmPrintFinal.mock.t.Fatalf("WriterMock.PrintFinal mock is already set by Set")
	}

	if mmPrintFinal.defaultExpectation == nil {
		mmPrintFinal.defaultExpectation = &WriterMockPrintFinalExpectation{mock: mmPrintFinal.mock}
	}
	mmPrintFinal.defaultExpectation.results = &WriterMockPrintFinalResults{err}
	mmPrintFinal.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrintFinal.mock
}

// Set uses given function f to mock the Writer.PrintFinal method
func (mmPrintFinal *mWriterMockPrintFinal) Set(f func(duration time.Duration, text string) (err error)) *WriterMock {
	if mmPrintFinal.defaultExpectation != nil {
		mmPrintFinal.mock.t.Fatalf("Default expectation is already set for the Writer.PrintFinal method")
	}

	if len(mmPrintFinal.expectations) > 0 {
		mmPrintFinal.mock.t.Fatalf("Some expectations are already set for the Writer.PrintFinal method")
	}

	mmPrintFinal.mock.funcPrintFinal = f
	mmPrintFinal.mock.funcPrintFinalOrigin = minimock.CallerInfo(1)
	return mmPrintFinal.mock
}

// When sets expectation for the Writer.PrintFinal which will trigger the result defined by the following
// Then helper
func (mmPrintFinal *mWriterMockPrintFinal) When(duration time.Duration, text string) *WriterMockPrintFinalExpectation {
	if mmPrintFinal.mock.funcPrintFinal != nil {
		mmPrintFinal.mock.t.Fatalf("WriterMock.PrintFinal mock is already set by Set")
	}

	expectation := &WriterMockPrintFinalExpectation{
		mock:               mmPrintFinal.mock,
		params:             &WriterMockPrintFinalParams{duration, text},
		expectationOrigins: WriterMockPrintFinalExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPrintFinal.expectations = append(mmPrintFinal.expectations, expectation)
	return expectation
}

// Then sets up Writer.PrintFinal return parameters for the expectation previously defined by the When method
func (e *WriterMockPrintFinalExpectation) Then(err error) *WriterMock {
	e.results = &WriterMockPrintFinalResults{err}
	return e.mock
}

// Times sets number of times Writer.PrintFinal should be invoked
func (mmPrintFinal *mWriterMockPrintFinal) Times(n uint64) *mWriterMockPrintFinal {
	if n == 0 {
		mmPrintFinal.mock.t.Fatalf("Times of WriterMock.PrintFinal mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrintFinal.expectedInvocations, n)
	mmPrintFinal.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrintFinal
}

func (mmPrintFinal *mWriterMockPrintFinal) invocationsDone() bool {
	if len(mmPrintFinal.expectations) == 0 && mmPrintFinal.defaultExpectation == nil && mmPrintFinal.mock.funcPrintFinal == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrintFinal.mock.afterPrintFinalCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrintFinal.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PrintFinal implements Writer
func (mmPrintFinal *WriterMock) PrintFinal(duration time.Duration, text string) (err error) {
	mm_atomic.AddUint64(&mmPrintFinal.beforePrintFinalCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintFinal.afterPrintFinalCounter, 1)

	mmPrintFinal.t.Helper()

	if mmPrintFinal.inspectFuncPrintFinal != nil {
		mmPrintFinal.inspectFuncPrintFinal(duration, text)
	}

	mm_params := WriterMockPrintFinalParams{duration, text}

	// Record call args
	mmPrintFinal.PrintFinalMock.mutex.Lock()
	mmPrintFinal.PrintFinalMock.callArgs = append(mmPrintFinal.PrintFinalMock.callArgs, &mm_params)
	mmPrintFinal.PrintFinalMock.mutex.Unlock()

	for _, e := range mmPrintFinal.PrintFinalMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPrintFinal.PrintFinalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintFinal.PrintFinalMock.defaultExpectation.Counter, 1)
		mm_want := mmPrintFinal.PrintFinalMock.defaultExpectation.params
		mm_want_ptrs := mmPrintFinal.PrintFinalMock.defaultExpectation.paramPtrs

		mm_got := WriterMockPrintFinalParams{duration, text}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.duration != nil && !minimock.Equal(*mm_want_ptrs.duration, mm_got.duration) {
				mmPrintFinal.t.Errorf("WriterMock.PrintFinal got unexpected parameter duration, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrintFinal.PrintFinalMock.defaultExpectation.expectationOrigins.originDuration, *mm_want_ptrs.duration, mm_got.duration, minimock.Diff(*mm_want_ptrs.duration, mm_got.duration))
			}

			if mm_want_ptrs.text != nil && !minimock.Equal(*mm_want_ptrs.text, mm_got.text) {
				mmPrintFinal.t.Errorf("WriterMock.PrintFinal got unexpected parameter text, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrintFinal.PrintFinalMock.defaultExpectation.expectationOrigins.originText, *mm_want_ptrs.text, mm_got.text, minimock.Diff(*mm_want_ptrs.text, mm_got.text))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrintFinal.t.Errorf("WriterMock.PrintFinal got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPrintFinal.PrintFinalMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrintFinal.PrintFinalMock.defaultExpectation.results
		if mm_results == nil {
			mmPrintFinal.t.Fatal("No results are set for the WriterMock.PrintFinal")
		}
		return (*mm_results).err
	}
	if mmPrintFinal.funcPrintFinal != nil {
		return mmPrintFinal.funcPrintFinal(duration, text)
	}
	mmPrintFinal.t.Fatalf("Unexpected call to WriterMock.PrintFinal. %v %v", duration, text)
	return
}

// PrintFinalAfterCounter returns a count of finished WriterMock.PrintFinal invocations
func (mmPrintFinal *WriterMock) PrintFinalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintFinal.afterPrintFinalCounter)
}

// PrintFinalBeforeCounter returns a count of WriterMock.PrintFinal invocations
func (mmPrintFinal *WriterMock) PrintFinalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintFinal.beforePrintFinalCounter)
}

// Calls returns a list of arguments used in each call to WriterMock.PrintFinal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrintFinal *mWriterMockPrintFinal) Calls() []*WriterMockPrintFinalParams {
	mmPrintFinal.mutex.RLock()

	argCopy := make([]*WriterMockPrintFinalParams, len(mmPrintFinal.callArgs))
	copy(argCopy, mmPrintFinal.callArgs)

	mmPrintFinal.mutex.RUnlock()

	return argCopy
}

// MinimockPrintFinalDone returns true if the count of the PrintFinal invocations corresponds
// the number of defined expectations
func (m *WriterMock) MinimockPrintFinalDone() bool {
	if m.PrintFinalMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintFinalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintFinalMock.invocationsDone()
}

// MinimockPrintFinalInspect logs each unmet expectation
func (m *WriterMock) MinimockPrintFinalInspect() {
	for _, e := range m.PrintFinalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WriterMock.PrintFinal at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPrintFinalCounter := mm_atomic.LoadUint64(&m.afterPrintFinalCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintFinalMock.defaultExpectation != nil && afterPrintFinalCounter < 1 {
		if m.PrintFinalMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to WriterMock.PrintFinal at\n%s", m.PrintFinalMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to WriterMock.PrintFinal at\n%s with params: %#v", m.PrintFinalMock.defaultExpectation.expectationOrigins.origin, *m.PrintFinalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintFinal != nil && afterPrintFinalCounter < 1 {
		m.t.Errorf("Expected call to WriterMock.PrintFinal at\n%s", m.funcPrintFinalOrigin)
	}

	if !m.PrintFinalMock.invocationsDone() && afterPrintFinalCounter > 0 {
		m.t.Errorf("Expected %d calls to WriterMock.PrintFinal at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrintFinalMock.expectedInvocations), m.PrintFinalMock.expectedInvocationsOrigin, afterPrintFinalCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *WriterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockFinalizeInspect()

			m.MinimockPrintCandidateInspect()

			m.MinimockPrintFinalInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *WriterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *WriterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockFinalizeDone() &&
		m.MinimockPrintCandidateDone() &&
		m.MinimockPrintFinalDone()
}
