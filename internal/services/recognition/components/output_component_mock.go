// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package components

import (
	"context"
	"live2text/internal/services/recognition/text"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OutputComponentMock implements OutputComponent
type OutputComponentMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcPrint          func(ctx context.Context, writer text.Writer, inputCh <-chan Recognized) (err error)
	funcPrintOrigin    string
	inspectFuncPrint   func(ctx context.Context, writer text.Writer, inputCh <-chan Recognized)
	afterPrintCounter  uint64
	beforePrintCounter uint64
	PrintMock          mOutputComponentMockPrint

	funcToConsole          func(ctx context.Context, inputCh <-chan Recognized) (err error)
	funcToConsoleOrigin    string
	inspectFuncToConsole   func(ctx context.Context, inputCh <-chan Recognized)
	afterToConsoleCounter  uint64
	beforeToConsoleCounter uint64
	ToConsoleMock          mOutputComponentMockToConsole

	funcToFile          func(ctx context.Context, inputCh <-chan Recognized) (err error)
	funcToFileOrigin    string
	inspectFuncToFile   func(ctx context.Context, inputCh <-chan Recognized)
	afterToFileCounter  uint64
	beforeToFileCounter uint64
	ToFileMock          mOutputComponentMockToFile
}

// NewOutputComponentMock returns a mock for OutputComponent
func NewOutputComponentMock(t minimock.Tester) *OutputComponentMock {
	m := &OutputComponentMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.PrintMock = mOutputComponentMockPrint{mock: m}
	m.PrintMock.callArgs = []*OutputComponentMockPrintParams{}

	m.ToConsoleMock = mOutputComponentMockToConsole{mock: m}
	m.ToConsoleMock.callArgs = []*OutputComponentMockToConsoleParams{}

	m.ToFileMock = mOutputComponentMockToFile{mock: m}
	m.ToFileMock.callArgs = []*OutputComponentMockToFileParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOutputComponentMockPrint struct {
	optional           bool
	mock               *OutputComponentMock
	defaultExpectation *OutputComponentMockPrintExpectation
	expectations       []*OutputComponentMockPrintExpectation

	callArgs []*OutputComponentMockPrintParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutputComponentMockPrintExpectation specifies expectation struct of the OutputComponent.Print
type OutputComponentMockPrintExpectation struct {
	mock               *OutputComponentMock
	params             *OutputComponentMockPrintParams
	paramPtrs          *OutputComponentMockPrintParamPtrs
	expectationOrigins OutputComponentMockPrintExpectationOrigins
	results            *OutputComponentMockPrintResults
	returnOrigin       string
	Counter            uint64
}

// OutputComponentMockPrintParams contains parameters of the OutputComponent.Print
type OutputComponentMockPrintParams struct {
	ctx     context.Context
	writer  text.Writer
	inputCh <-chan Recognized
}

// OutputComponentMockPrintParamPtrs contains pointers to parameters of the OutputComponent.Print
type OutputComponentMockPrintParamPtrs struct {
	ctx     *context.Context
	writer  *text.Writer
	inputCh *<-chan Recognized
}

// OutputComponentMockPrintResults contains results of the OutputComponent.Print
type OutputComponentMockPrintResults struct {
	err error
}

// OutputComponentMockPrintOrigins contains origins of expectations of the OutputComponent.Print
type OutputComponentMockPrintExpectationOrigins struct {
	origin        string
	originCtx     string
	originWriter  string
	originInputCh string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrint *mOutputComponentMockPrint) Optional() *mOutputComponentMockPrint {
	mmPrint.optional = true
	return mmPrint
}

// Expect sets up expected params for OutputComponent.Print
func (mmPrint *mOutputComponentMockPrint) Expect(ctx context.Context, writer text.Writer, inputCh <-chan Recognized) *mOutputComponentMockPrint {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("OutputComponentMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &OutputComponentMockPrintExpectation{}
	}

	if mmPrint.defaultExpectation.paramPtrs != nil {
		mmPrint.mock.t.Fatalf("OutputComponentMock.Print mock is already set by ExpectParams functions")
	}

	mmPrint.defaultExpectation.params = &OutputComponentMockPrintParams{ctx, writer, inputCh}
	mmPrint.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPrint.expectations {
		if minimock.Equal(e.params, mmPrint.defaultExpectation.params) {
			mmPrint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrint.defaultExpectation.params)
		}
	}

	return mmPrint
}

// ExpectCtxParam1 sets up expected param ctx for OutputComponent.Print
func (mmPrint *mOutputComponentMockPrint) ExpectCtxParam1(ctx context.Context) *mOutputComponentMockPrint {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("OutputComponentMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &OutputComponentMockPrintExpectation{}
	}

	if mmPrint.defaultExpectation.params != nil {
		mmPrint.mock.t.Fatalf("OutputComponentMock.Print mock is already set by Expect")
	}

	if mmPrint.defaultExpectation.paramPtrs == nil {
		mmPrint.defaultExpectation.paramPtrs = &OutputComponentMockPrintParamPtrs{}
	}
	mmPrint.defaultExpectation.paramPtrs.ctx = &ctx
	mmPrint.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPrint
}

// ExpectWriterParam2 sets up expected param writer for OutputComponent.Print
func (mmPrint *mOutputComponentMockPrint) ExpectWriterParam2(writer text.Writer) *mOutputComponentMockPrint {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("OutputComponentMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &OutputComponentMockPrintExpectation{}
	}

	if mmPrint.defaultExpectation.params != nil {
		mmPrint.mock.t.Fatalf("OutputComponentMock.Print mock is already set by Expect")
	}

	if mmPrint.defaultExpectation.paramPtrs == nil {
		mmPrint.defaultExpectation.paramPtrs = &OutputComponentMockPrintParamPtrs{}
	}
	mmPrint.defaultExpectation.paramPtrs.writer = &writer
	mmPrint.defaultExpectation.expectationOrigins.originWriter = minimock.CallerInfo(1)

	return mmPrint
}

// ExpectInputChParam3 sets up expected param inputCh for OutputComponent.Print
func (mmPrint *mOutputComponentMockPrint) ExpectInputChParam3(inputCh <-chan Recognized) *mOutputComponentMockPrint {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("OutputComponentMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &OutputComponentMockPrintExpectation{}
	}

	if mmPrint.defaultExpectation.params != nil {
		mmPrint.mock.t.Fatalf("OutputComponentMock.Print mock is already set by Expect")
	}

	if mmPrint.defaultExpectation.paramPtrs == nil {
		mmPrint.defaultExpectation.paramPtrs = &OutputComponentMockPrintParamPtrs{}
	}
	mmPrint.defaultExpectation.paramPtrs.inputCh = &inputCh
	mmPrint.defaultExpectation.expectationOrigins.originInputCh = minimock.CallerInfo(1)

	return mmPrint
}

// Inspect accepts an inspector function that has same arguments as the OutputComponent.Print
func (mmPrint *mOutputComponentMockPrint) Inspect(f func(ctx context.Context, writer text.Writer, inputCh <-chan Recognized)) *mOutputComponentMockPrint {
	if mmPrint.mock.inspectFuncPrint != nil {
		mmPrint.mock.t.Fatalf("Inspect function is already set for OutputComponentMock.Print")
	}

	mmPrint.mock.inspectFuncPrint = f

	return mmPrint
}

// Return sets up results that will be returned by OutputComponent.Print
func (mmPrint *mOutputComponentMockPrint) Return(err error) *OutputComponentMock {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("OutputComponentMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &OutputComponentMockPrintExpectation{mock: mmPrint.mock}
	}
	mmPrint.defaultExpectation.results = &OutputComponentMockPrintResults{err}
	mmPrint.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrint.mock
}

// Set uses given function f to mock the OutputComponent.Print method
func (mmPrint *mOutputComponentMockPrint) Set(f func(ctx context.Context, writer text.Writer, inputCh <-chan Recognized) (err error)) *OutputComponentMock {
	if mmPrint.defaultExpectation != nil {
		mmPrint.mock.t.Fatalf("Default expectation is already set for the OutputComponent.Print method")
	}

	if len(mmPrint.expectations) > 0 {
		mmPrint.mock.t.Fatalf("Some expectations are already set for the OutputComponent.Print method")
	}

	mmPrint.mock.funcPrint = f
	mmPrint.mock.funcPrintOrigin = minimock.CallerInfo(1)
	return mmPrint.mock
}

// When sets expectation for the OutputComponent.Print which will trigger the result defined by the following
// Then helper
func (mmPrint *mOutputComponentMockPrint) When(ctx context.Context, writer text.Writer, inputCh <-chan Recognized) *OutputComponentMockPrintExpectation {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("OutputComponentMock.Print mock is already set by Set")
	}

	expectation := &OutputComponentMockPrintExpectation{
		mock:               mmPrint.mock,
		params:             &OutputComponentMockPrintParams{ctx, writer, inputCh},
		expectationOrigins: OutputComponentMockPrintExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPrint.expectations = append(mmPrint.expectations, expectation)
	return expectation
}

// Then sets up OutputComponent.Print return parameters for the expectation previously defined by the When method
func (e *OutputComponentMockPrintExpectation) Then(err error) *OutputComponentMock {
	e.results = &OutputComponentMockPrintResults{err}
	return e.mock
}

// Times sets number of times OutputComponent.Print should be invoked
func (mmPrint *mOutputComponentMockPrint) Times(n uint64) *mOutputComponentMockPrint {
	if n == 0 {
		mmPrint.mock.t.Fatalf("Times of OutputComponentMock.Print mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrint.expectedInvocations, n)
	mmPrint.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrint
}

func (mmPrint *mOutputComponentMockPrint) invocationsDone() bool {
	if len(mmPrint.expectations) == 0 && mmPrint.defaultExpectation == nil && mmPrint.mock.funcPrint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrint.mock.afterPrintCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Print implements OutputComponent
func (mmPrint *OutputComponentMock) Print(ctx context.Context, writer text.Writer, inputCh <-chan Recognized) (err error) {
	mm_atomic.AddUint64(&mmPrint.beforePrintCounter, 1)
	defer mm_atomic.AddUint64(&mmPrint.afterPrintCounter, 1)

	mmPrint.t.Helper()

	if mmPrint.inspectFuncPrint != nil {
		mmPrint.inspectFuncPrint(ctx, writer, inputCh)
	}

	mm_params := OutputComponentMockPrintParams{ctx, writer, inputCh}

	// Record call args
	mmPrint.PrintMock.mutex.Lock()
	mmPrint.PrintMock.callArgs = append(mmPrint.PrintMock.callArgs, &mm_params)
	mmPrint.PrintMock.mutex.Unlock()

	for _, e := range mmPrint.PrintMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPrint.PrintMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrint.PrintMock.defaultExpectation.Counter, 1)
		mm_want := mmPrint.PrintMock.defaultExpectation.params
		mm_want_ptrs := mmPrint.PrintMock.defaultExpectation.paramPtrs

		mm_got := OutputComponentMockPrintParams{ctx, writer, inputCh}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPrint.t.Errorf("OutputComponentMock.Print got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrint.PrintMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.writer != nil && !minimock.Equal(*mm_want_ptrs.writer, mm_got.writer) {
				mmPrint.t.Errorf("OutputComponentMock.Print got unexpected parameter writer, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrint.PrintMock.defaultExpectation.expectationOrigins.originWriter, *mm_want_ptrs.writer, mm_got.writer, minimock.Diff(*mm_want_ptrs.writer, mm_got.writer))
			}

			if mm_want_ptrs.inputCh != nil && !minimock.Equal(*mm_want_ptrs.inputCh, mm_got.inputCh) {
				mmPrint.t.Errorf("OutputComponentMock.Print got unexpected parameter inputCh, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrint.PrintMock.defaultExpectation.expectationOrigins.originInputCh, *mm_want_ptrs.inputCh, mm_got.inputCh, minimock.Diff(*mm_want_ptrs.inputCh, mm_got.inputCh))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrint.t.Errorf("OutputComponentMock.Print got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPrint.PrintMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrint.PrintMock.defaultExpectation.results
		if mm_results == nil {
			mmPrint.t.Fatal("No results are set for the OutputComponentMock.Print")
		}
		return (*mm_results).err
	}
	if mmPrint.funcPrint != nil {
		return mmPrint.funcPrint(ctx, writer, inputCh)
	}
	mmPrint.t.Fatalf("Unexpected call to OutputComponentMock.Print. %v %v %v", ctx, writer, inputCh)
	return
}

// PrintAfterCounter returns a count of finished OutputComponentMock.Print invocations
func (mmPrint *OutputComponentMock) PrintAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrint.afterPrintCounter)
}

// PrintBeforeCounter returns a count of OutputComponentMock.Print invocations
func (mmPrint *OutputComponentMock) PrintBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrint.beforePrintCounter)
}

// Calls returns a list of arguments used in each call to OutputComponentMock.Print.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrint *mOutputComponentMockPrint) Calls() []*OutputComponentMockPrintParams {
	mmPrint.mutex.RLock()

	argCopy := make([]*OutputComponentMockPrintParams, len(mmPrint.callArgs))
	copy(argCopy, mmPrint.callArgs)

	mmPrint.mutex.RUnlock()

	return argCopy
}

// MinimockPrintDone returns true if the count of the Print invocations corresponds
// the number of defined expectations
func (m *OutputComponentMock) MinimockPrintDone() bool {
	if m.PrintMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintMock.invocationsDone()
}

// MinimockPrintInspect logs each unmet expectation
func (m *OutputComponentMock) MinimockPrintInspect() {
	for _, e := range m.PrintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutputComponentMock.Print at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPrintCounter := mm_atomic.LoadUint64(&m.afterPrintCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintMock.defaultExpectation != nil && afterPrintCounter < 1 {
		if m.PrintMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutputComponentMock.Print at\n%s", m.PrintMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutputComponentMock.Print at\n%s with params: %#v", m.PrintMock.defaultExpectation.expectationOrigins.origin, *m.PrintMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrint != nil && afterPrintCounter < 1 {
		m.t.Errorf("Expected call to OutputComponentMock.Print at\n%s", m.funcPrintOrigin)
	}

	if !m.PrintMock.invocationsDone() && afterPrintCounter > 0 {
		m.t.Errorf("Expected %d calls to OutputComponentMock.Print at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrintMock.expectedInvocations), m.PrintMock.expectedInvocationsOrigin, afterPrintCounter)
	}
}

type mOutputComponentMockToConsole struct {
	optional           bool
	mock               *OutputComponentMock
	defaultExpectation *OutputComponentMockToConsoleExpectation
	expectations       []*OutputComponentMockToConsoleExpectation

	callArgs []*OutputComponentMockToConsoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutputComponentMockToConsoleExpectation specifies expectation struct of the OutputComponent.ToConsole
type OutputComponentMockToConsoleExpectation struct {
	mock               *OutputComponentMock
	params             *OutputComponentMockToConsoleParams
	paramPtrs          *OutputComponentMockToConsoleParamPtrs
	expectationOrigins OutputComponentMockToConsoleExpectationOrigins
	results            *OutputComponentMockToConsoleResults
	returnOrigin       string
	Counter            uint64
}

// OutputComponentMockToConsoleParams contains parameters of the OutputComponent.ToConsole
type OutputComponentMockToConsoleParams struct {
	ctx     context.Context
	inputCh <-chan Recognized
}

// OutputComponentMockToConsoleParamPtrs contains pointers to parameters of the OutputComponent.ToConsole
type OutputComponentMockToConsoleParamPtrs struct {
	ctx     *context.Context
	inputCh *<-chan Recognized
}

// OutputComponentMockToConsoleResults contains results of the OutputComponent.ToConsole
type OutputComponentMockToConsoleResults struct {
	err error
}

// OutputComponentMockToConsoleOrigins contains origins of expectations of the OutputComponent.ToConsole
type OutputComponentMockToConsoleExpectationOrigins struct {
	origin        string
	originCtx     string
	originInputCh string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToConsole *mOutputComponentMockToConsole) Optional() *mOutputComponentMockToConsole {
	mmToConsole.optional = true
	return mmToConsole
}

// Expect sets up expected params for OutputComponent.ToConsole
func (mmToConsole *mOutputComponentMockToConsole) Expect(ctx context.Context, inputCh <-chan Recognized) *mOutputComponentMockToConsole {
	if mmToConsole.mock.funcToConsole != nil {
		mmToConsole.mock.t.Fatalf("OutputComponentMock.ToConsole mock is already set by Set")
	}

	if mmToConsole.defaultExpectation == nil {
		mmToConsole.defaultExpectation = &OutputComponentMockToConsoleExpectation{}
	}

	if mmToConsole.defaultExpectation.paramPtrs != nil {
		mmToConsole.mock.t.Fatalf("OutputComponentMock.ToConsole mock is already set by ExpectParams functions")
	}

	mmToConsole.defaultExpectation.params = &OutputComponentMockToConsoleParams{ctx, inputCh}
	mmToConsole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToConsole.expectations {
		if minimock.Equal(e.params, mmToConsole.defaultExpectation.params) {
			mmToConsole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToConsole.defaultExpectation.params)
		}
	}

	return mmToConsole
}

// ExpectCtxParam1 sets up expected param ctx for OutputComponent.ToConsole
func (mmToConsole *mOutputComponentMockToConsole) ExpectCtxParam1(ctx context.Context) *mOutputComponentMockToConsole {
	if mmToConsole.mock.funcToConsole != nil {
		mmToConsole.mock.t.Fatalf("OutputComponentMock.ToConsole mock is already set by Set")
	}

	if mmToConsole.defaultExpectation == nil {
		mmToConsole.defaultExpectation = &OutputComponentMockToConsoleExpectation{}
	}

	if mmToConsole.defaultExpectation.params != nil {
		mmToConsole.mock.t.Fatalf("OutputComponentMock.ToConsole mock is already set by Expect")
	}

	if mmToConsole.defaultExpectation.paramPtrs == nil {
		mmToConsole.defaultExpectation.paramPtrs = &OutputComponentMockToConsoleParamPtrs{}
	}
	mmToConsole.defaultExpectation.paramPtrs.ctx = &ctx
	mmToConsole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmToConsole
}

// ExpectInputChParam2 sets up expected param inputCh for OutputComponent.ToConsole
func (mmToConsole *mOutputComponentMockToConsole) ExpectInputChParam2(inputCh <-chan Recognized) *mOutputComponentMockToConsole {
	if mmToConsole.mock.funcToConsole != nil {
		mmToConsole.mock.t.Fatalf("OutputComponentMock.ToConsole mock is already set by Set")
	}

	if mmToConsole.defaultExpectation == nil {
		mmToConsole.defaultExpectation = &OutputComponentMockToConsoleExpectation{}
	}

	if mmToConsole.defaultExpectation.params != nil {
		mmToConsole.mock.t.Fatalf("OutputComponentMock.ToConsole mock is already set by Expect")
	}

	if mmToConsole.defaultExpectation.paramPtrs == nil {
		mmToConsole.defaultExpectation.paramPtrs = &OutputComponentMockToConsoleParamPtrs{}
	}
	mmToConsole.defaultExpectation.paramPtrs.inputCh = &inputCh
	mmToConsole.defaultExpectation.expectationOrigins.originInputCh = minimock.CallerInfo(1)

	return mmToConsole
}

// Inspect accepts an inspector function that has same arguments as the OutputComponent.ToConsole
func (mmToConsole *mOutputComponentMockToConsole) Inspect(f func(ctx context.Context, inputCh <-chan Recognized)) *mOutputComponentMockToConsole {
	if mmToConsole.mock.inspectFuncToConsole != nil {
		mmToConsole.mock.t.Fatalf("Inspect function is already set for OutputComponentMock.ToConsole")
	}

	mmToConsole.mock.inspectFuncToConsole = f

	return mmToConsole
}

// Return sets up results that will be returned by OutputComponent.ToConsole
func (mmToConsole *mOutputComponentMockToConsole) Return(err error) *OutputComponentMock {
	if mmToConsole.mock.funcToConsole != nil {
		mmToConsole.mock.t.Fatalf("OutputComponentMock.ToConsole mock is already set by Set")
	}

	if mmToConsole.defaultExpectation == nil {
		mmToConsole.defaultExpectation = &OutputComponentMockToConsoleExpectation{mock: mmToConsole.mock}
	}
	mmToConsole.defaultExpectation.results = &OutputComponentMockToConsoleResults{err}
	mmToConsole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToConsole.mock
}

// Set uses given function f to mock the OutputComponent.ToConsole method
func (mmToConsole *mOutputComponentMockToConsole) Set(f func(ctx context.Context, inputCh <-chan Recognized) (err error)) *OutputComponentMock {
	if mmToConsole.defaultExpectation != nil {
		mmToConsole.mock.t.Fatalf("Default expectation is already set for the OutputComponent.ToConsole method")
	}

	if len(mmToConsole.expectations) > 0 {
		mmToConsole.mock.t.Fatalf("Some expectations are already set for the OutputComponent.ToConsole method")
	}

	mmToConsole.mock.funcToConsole = f
	mmToConsole.mock.funcToConsoleOrigin = minimock.CallerInfo(1)
	return mmToConsole.mock
}

// When sets expectation for the OutputComponent.ToConsole which will trigger the result defined by the following
// Then helper
func (mmToConsole *mOutputComponentMockToConsole) When(ctx context.Context, inputCh <-chan Recognized) *OutputComponentMockToConsoleExpectation {
	if mmToConsole.mock.funcToConsole != nil {
		mmToConsole.mock.t.Fatalf("OutputComponentMock.ToConsole mock is already set by Set")
	}

	expectation := &OutputComponentMockToConsoleExpectation{
		mock:               mmToConsole.mock,
		params:             &OutputComponentMockToConsoleParams{ctx, inputCh},
		expectationOrigins: OutputComponentMockToConsoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToConsole.expectations = append(mmToConsole.expectations, expectation)
	return expectation
}

// Then sets up OutputComponent.ToConsole return parameters for the expectation previously defined by the When method
func (e *OutputComponentMockToConsoleExpectation) Then(err error) *OutputComponentMock {
	e.results = &OutputComponentMockToConsoleResults{err}
	return e.mock
}

// Times sets number of times OutputComponent.ToConsole should be invoked
func (mmToConsole *mOutputComponentMockToConsole) Times(n uint64) *mOutputComponentMockToConsole {
	if n == 0 {
		mmToConsole.mock.t.Fatalf("Times of OutputComponentMock.ToConsole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToConsole.expectedInvocations, n)
	mmToConsole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToConsole
}

func (mmToConsole *mOutputComponentMockToConsole) invocationsDone() bool {
	if len(mmToConsole.expectations) == 0 && mmToConsole.defaultExpectation == nil && mmToConsole.mock.funcToConsole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToConsole.mock.afterToConsoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToConsole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToConsole implements OutputComponent
func (mmToConsole *OutputComponentMock) ToConsole(ctx context.Context, inputCh <-chan Recognized) (err error) {
	mm_atomic.AddUint64(&mmToConsole.beforeToConsoleCounter, 1)
	defer mm_atomic.AddUint64(&mmToConsole.afterToConsoleCounter, 1)

	mmToConsole.t.Helper()

	if mmToConsole.inspectFuncToConsole != nil {
		mmToConsole.inspectFuncToConsole(ctx, inputCh)
	}

	mm_params := OutputComponentMockToConsoleParams{ctx, inputCh}

	// Record call args
	mmToConsole.ToConsoleMock.mutex.Lock()
	mmToConsole.ToConsoleMock.callArgs = append(mmToConsole.ToConsoleMock.callArgs, &mm_params)
	mmToConsole.ToConsoleMock.mutex.Unlock()

	for _, e := range mmToConsole.ToConsoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmToConsole.ToConsoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToConsole.ToConsoleMock.defaultExpectation.Counter, 1)
		mm_want := mmToConsole.ToConsoleMock.defaultExpectation.params
		mm_want_ptrs := mmToConsole.ToConsoleMock.defaultExpectation.paramPtrs

		mm_got := OutputComponentMockToConsoleParams{ctx, inputCh}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmToConsole.t.Errorf("OutputComponentMock.ToConsole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToConsole.ToConsoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.inputCh != nil && !minimock.Equal(*mm_want_ptrs.inputCh, mm_got.inputCh) {
				mmToConsole.t.Errorf("OutputComponentMock.ToConsole got unexpected parameter inputCh, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToConsole.ToConsoleMock.defaultExpectation.expectationOrigins.originInputCh, *mm_want_ptrs.inputCh, mm_got.inputCh, minimock.Diff(*mm_want_ptrs.inputCh, mm_got.inputCh))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToConsole.t.Errorf("OutputComponentMock.ToConsole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToConsole.ToConsoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToConsole.ToConsoleMock.defaultExpectation.results
		if mm_results == nil {
			mmToConsole.t.Fatal("No results are set for the OutputComponentMock.ToConsole")
		}
		return (*mm_results).err
	}
	if mmToConsole.funcToConsole != nil {
		return mmToConsole.funcToConsole(ctx, inputCh)
	}
	mmToConsole.t.Fatalf("Unexpected call to OutputComponentMock.ToConsole. %v %v", ctx, inputCh)
	return
}

// ToConsoleAfterCounter returns a count of finished OutputComponentMock.ToConsole invocations
func (mmToConsole *OutputComponentMock) ToConsoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToConsole.afterToConsoleCounter)
}

// ToConsoleBeforeCounter returns a count of OutputComponentMock.ToConsole invocations
func (mmToConsole *OutputComponentMock) ToConsoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToConsole.beforeToConsoleCounter)
}

// Calls returns a list of arguments used in each call to OutputComponentMock.ToConsole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToConsole *mOutputComponentMockToConsole) Calls() []*OutputComponentMockToConsoleParams {
	mmToConsole.mutex.RLock()

	argCopy := make([]*OutputComponentMockToConsoleParams, len(mmToConsole.callArgs))
	copy(argCopy, mmToConsole.callArgs)

	mmToConsole.mutex.RUnlock()

	return argCopy
}

// MinimockToConsoleDone returns true if the count of the ToConsole invocations corresponds
// the number of defined expectations
func (m *OutputComponentMock) MinimockToConsoleDone() bool {
	if m.ToConsoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToConsoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToConsoleMock.invocationsDone()
}

// MinimockToConsoleInspect logs each unmet expectation
func (m *OutputComponentMock) MinimockToConsoleInspect() {
	for _, e := range m.ToConsoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutputComponentMock.ToConsole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToConsoleCounter := mm_atomic.LoadUint64(&m.afterToConsoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToConsoleMock.defaultExpectation != nil && afterToConsoleCounter < 1 {
		if m.ToConsoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutputComponentMock.ToConsole at\n%s", m.ToConsoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutputComponentMock.ToConsole at\n%s with params: %#v", m.ToConsoleMock.defaultExpectation.expectationOrigins.origin, *m.ToConsoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToConsole != nil && afterToConsoleCounter < 1 {
		m.t.Errorf("Expected call to OutputComponentMock.ToConsole at\n%s", m.funcToConsoleOrigin)
	}

	if !m.ToConsoleMock.invocationsDone() && afterToConsoleCounter > 0 {
		m.t.Errorf("Expected %d calls to OutputComponentMock.ToConsole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToConsoleMock.expectedInvocations), m.ToConsoleMock.expectedInvocationsOrigin, afterToConsoleCounter)
	}
}

type mOutputComponentMockToFile struct {
	optional           bool
	mock               *OutputComponentMock
	defaultExpectation *OutputComponentMockToFileExpectation
	expectations       []*OutputComponentMockToFileExpectation

	callArgs []*OutputComponentMockToFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutputComponentMockToFileExpectation specifies expectation struct of the OutputComponent.ToFile
type OutputComponentMockToFileExpectation struct {
	mock               *OutputComponentMock
	params             *OutputComponentMockToFileParams
	paramPtrs          *OutputComponentMockToFileParamPtrs
	expectationOrigins OutputComponentMockToFileExpectationOrigins
	results            *OutputComponentMockToFileResults
	returnOrigin       string
	Counter            uint64
}

// OutputComponentMockToFileParams contains parameters of the OutputComponent.ToFile
type OutputComponentMockToFileParams struct {
	ctx     context.Context
	inputCh <-chan Recognized
}

// OutputComponentMockToFileParamPtrs contains pointers to parameters of the OutputComponent.ToFile
type OutputComponentMockToFileParamPtrs struct {
	ctx     *context.Context
	inputCh *<-chan Recognized
}

// OutputComponentMockToFileResults contains results of the OutputComponent.ToFile
type OutputComponentMockToFileResults struct {
	err error
}

// OutputComponentMockToFileOrigins contains origins of expectations of the OutputComponent.ToFile
type OutputComponentMockToFileExpectationOrigins struct {
	origin        string
	originCtx     string
	originInputCh string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToFile *mOutputComponentMockToFile) Optional() *mOutputComponentMockToFile {
	mmToFile.optional = true
	return mmToFile
}

// Expect sets up expected params for OutputComponent.ToFile
func (mmToFile *mOutputComponentMockToFile) Expect(ctx context.Context, inputCh <-chan Recognized) *mOutputComponentMockToFile {
	if mmToFile.mock.funcToFile != nil {
		mmToFile.mock.t.Fatalf("OutputComponentMock.ToFile mock is already set by Set")
	}

	if mmToFile.defaultExpectation == nil {
		mmToFile.defaultExpectation = &OutputComponentMockToFileExpectation{}
	}

	if mmToFile.defaultExpectation.paramPtrs != nil {
		mmToFile.mock.t.Fatalf("OutputComponentMock.ToFile mock is already set by ExpectParams functions")
	}

	mmToFile.defaultExpectation.params = &OutputComponentMockToFileParams{ctx, inputCh}
	mmToFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToFile.expectations {
		if minimock.Equal(e.params, mmToFile.defaultExpectation.params) {
			mmToFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToFile.defaultExpectation.params)
		}
	}

	return mmToFile
}

// ExpectCtxParam1 sets up expected param ctx for OutputComponent.ToFile
func (mmToFile *mOutputComponentMockToFile) ExpectCtxParam1(ctx context.Context) *mOutputComponentMockToFile {
	if mmToFile.mock.funcToFile != nil {
		mmToFile.mock.t.Fatalf("OutputComponentMock.ToFile mock is already set by Set")
	}

	if mmToFile.defaultExpectation == nil {
		mmToFile.defaultExpectation = &OutputComponentMockToFileExpectation{}
	}

	if mmToFile.defaultExpectation.params != nil {
		mmToFile.mock.t.Fatalf("OutputComponentMock.ToFile mock is already set by Expect")
	}

	if mmToFile.defaultExpectation.paramPtrs == nil {
		mmToFile.defaultExpectation.paramPtrs = &OutputComponentMockToFileParamPtrs{}
	}
	mmToFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmToFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmToFile
}

// ExpectInputChParam2 sets up expected param inputCh for OutputComponent.ToFile
func (mmToFile *mOutputComponentMockToFile) ExpectInputChParam2(inputCh <-chan Recognized) *mOutputComponentMockToFile {
	if mmToFile.mock.funcToFile != nil {
		mmToFile.mock.t.Fatalf("OutputComponentMock.ToFile mock is already set by Set")
	}

	if mmToFile.defaultExpectation == nil {
		mmToFile.defaultExpectation = &OutputComponentMockToFileExpectation{}
	}

	if mmToFile.defaultExpectation.params != nil {
		mmToFile.mock.t.Fatalf("OutputComponentMock.ToFile mock is already set by Expect")
	}

	if mmToFile.defaultExpectation.paramPtrs == nil {
		mmToFile.defaultExpectation.paramPtrs = &OutputComponentMockToFileParamPtrs{}
	}
	mmToFile.defaultExpectation.paramPtrs.inputCh = &inputCh
	mmToFile.defaultExpectation.expectationOrigins.originInputCh = minimock.CallerInfo(1)

	return mmToFile
}

// Inspect accepts an inspector function that has same arguments as the OutputComponent.ToFile
func (mmToFile *mOutputComponentMockToFile) Inspect(f func(ctx context.Context, inputCh <-chan Recognized)) *mOutputComponentMockToFile {
	if mmToFile.mock.inspectFuncToFile != nil {
		mmToFile.mock.t.Fatalf("Inspect function is already set for OutputComponentMock.ToFile")
	}

	mmToFile.mock.inspectFuncToFile = f

	return mmToFile
}

// Return sets up results that will be returned by OutputComponent.ToFile
func (mmToFile *mOutputComponentMockToFile) Return(err error) *OutputComponentMock {
	if mmToFile.mock.funcToFile != nil {
		mmToFile.mock.t.Fatalf("OutputComponentMock.ToFile mock is already set by Set")
	}

	if mmToFile.defaultExpectation == nil {
		mmToFile.defaultExpectation = &OutputComponentMockToFileExpectation{mock: mmToFile.mock}
	}
	mmToFile.defaultExpectation.results = &OutputComponentMockToFileResults{err}
	mmToFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToFile.mock
}

// Set uses given function f to mock the OutputComponent.ToFile method
func (mmToFile *mOutputComponentMockToFile) Set(f func(ctx context.Context, inputCh <-chan Recognized) (err error)) *OutputComponentMock {
	if mmToFile.defaultExpectation != nil {
		mmToFile.mock.t.Fatalf("Default expectation is already set for the OutputComponent.ToFile method")
	}

	if len(mmToFile.expectations) > 0 {
		mmToFile.mock.t.Fatalf("Some expectations are already set for the OutputComponent.ToFile method")
	}

	mmToFile.mock.funcToFile = f
	mmToFile.mock.funcToFileOrigin = minimock.CallerInfo(1)
	return mmToFile.mock
}

// When sets expectation for the OutputComponent.ToFile which will trigger the result defined by the following
// Then helper
func (mmToFile *mOutputComponentMockToFile) When(ctx context.Context, inputCh <-chan Recognized) *OutputComponentMockToFileExpectation {
	if mmToFile.mock.funcToFile != nil {
		mmToFile.mock.t.Fatalf("OutputComponentMock.ToFile mock is already set by Set")
	}

	expectation := &OutputComponentMockToFileExpectation{
		mock:               mmToFile.mock,
		params:             &OutputComponentMockToFileParams{ctx, inputCh},
		expectationOrigins: OutputComponentMockToFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToFile.expectations = append(mmToFile.expectations, expectation)
	return expectation
}

// Then sets up OutputComponent.ToFile return parameters for the expectation previously defined by the When method
func (e *OutputComponentMockToFileExpectation) Then(err error) *OutputComponentMock {
	e.results = &OutputComponentMockToFileResults{err}
	return e.mock
}

// Times sets number of times OutputComponent.ToFile should be invoked
func (mmToFile *mOutputComponentMockToFile) Times(n uint64) *mOutputComponentMockToFile {
	if n == 0 {
		mmToFile.mock.t.Fatalf("Times of OutputComponentMock.ToFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToFile.expectedInvocations, n)
	mmToFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToFile
}

func (mmToFile *mOutputComponentMockToFile) invocationsDone() bool {
	if len(mmToFile.expectations) == 0 && mmToFile.defaultExpectation == nil && mmToFile.mock.funcToFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToFile.mock.afterToFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToFile implements OutputComponent
func (mmToFile *OutputComponentMock) ToFile(ctx context.Context, inputCh <-chan Recognized) (err error) {
	mm_atomic.AddUint64(&mmToFile.beforeToFileCounter, 1)
	defer mm_atomic.AddUint64(&mmToFile.afterToFileCounter, 1)

	mmToFile.t.Helper()

	if mmToFile.inspectFuncToFile != nil {
		mmToFile.inspectFuncToFile(ctx, inputCh)
	}

	mm_params := OutputComponentMockToFileParams{ctx, inputCh}

	// Record call args
	mmToFile.ToFileMock.mutex.Lock()
	mmToFile.ToFileMock.callArgs = append(mmToFile.ToFileMock.callArgs, &mm_params)
	mmToFile.ToFileMock.mutex.Unlock()

	for _, e := range mmToFile.ToFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmToFile.ToFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToFile.ToFileMock.defaultExpectation.Counter, 1)
		mm_want := mmToFile.ToFileMock.defaultExpectation.params
		mm_want_ptrs := mmToFile.ToFileMock.defaultExpectation.paramPtrs

		mm_got := OutputComponentMockToFileParams{ctx, inputCh}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmToFile.t.Errorf("OutputComponentMock.ToFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToFile.ToFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.inputCh != nil && !minimock.Equal(*mm_want_ptrs.inputCh, mm_got.inputCh) {
				mmToFile.t.Errorf("OutputComponentMock.ToFile got unexpected parameter inputCh, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToFile.ToFileMock.defaultExpectation.expectationOrigins.originInputCh, *mm_want_ptrs.inputCh, mm_got.inputCh, minimock.Diff(*mm_want_ptrs.inputCh, mm_got.inputCh))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToFile.t.Errorf("OutputComponentMock.ToFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToFile.ToFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToFile.ToFileMock.defaultExpectation.results
		if mm_results == nil {
			mmToFile.t.Fatal("No results are set for the OutputComponentMock.ToFile")
		}
		return (*mm_results).err
	}
	if mmToFile.funcToFile != nil {
		return mmToFile.funcToFile(ctx, inputCh)
	}
	mmToFile.t.Fatalf("Unexpected call to OutputComponentMock.ToFile. %v %v", ctx, inputCh)
	return
}

// ToFileAfterCounter returns a count of finished OutputComponentMock.ToFile invocations
func (mmToFile *OutputComponentMock) ToFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToFile.afterToFileCounter)
}

// ToFileBeforeCounter returns a count of OutputComponentMock.ToFile invocations
func (mmToFile *OutputComponentMock) ToFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToFile.beforeToFileCounter)
}

// Calls returns a list of arguments used in each call to OutputComponentMock.ToFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToFile *mOutputComponentMockToFile) Calls() []*OutputComponentMockToFileParams {
	mmToFile.mutex.RLock()

	argCopy := make([]*OutputComponentMockToFileParams, len(mmToFile.callArgs))
	copy(argCopy, mmToFile.callArgs)

	mmToFile.mutex.RUnlock()

	return argCopy
}

// MinimockToFileDone returns true if the count of the ToFile invocations corresponds
// the number of defined expectations
func (m *OutputComponentMock) MinimockToFileDone() bool {
	if m.ToFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToFileMock.invocationsDone()
}

// MinimockToFileInspect logs each unmet expectation
func (m *OutputComponentMock) MinimockToFileInspect() {
	for _, e := range m.ToFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutputComponentMock.ToFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToFileCounter := mm_atomic.LoadUint64(&m.afterToFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToFileMock.defaultExpectation != nil && afterToFileCounter < 1 {
		if m.ToFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutputComponentMock.ToFile at\n%s", m.ToFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutputComponentMock.ToFile at\n%s with params: %#v", m.ToFileMock.defaultExpectation.expectationOrigins.origin, *m.ToFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToFile != nil && afterToFileCounter < 1 {
		m.t.Errorf("Expected call to OutputComponentMock.ToFile at\n%s", m.funcToFileOrigin)
	}

	if !m.ToFileMock.invocationsDone() && afterToFileCounter > 0 {
		m.t.Errorf("Expected %d calls to OutputComponentMock.ToFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToFileMock.expectedInvocations), m.ToFileMock.expectedInvocationsOrigin, afterToFileCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OutputComponentMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockPrintInspect()

			m.MinimockToConsoleInspect()

			m.MinimockToFileInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OutputComponentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OutputComponentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockPrintDone() &&
		m.MinimockToConsoleDone() &&
		m.MinimockToFileDone()
}
