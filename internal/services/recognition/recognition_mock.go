// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package recognition

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RecognitionMock implements Recognition
type RecognitionMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcHas          func(id string) (b1 bool)
	funcHasOrigin    string
	inspectFuncHas   func(id string)
	afterHasCounter  uint64
	beforeHasCounter uint64
	HasMock          mRecognitionMockHas

	funcStart          func(ctx context.Context, device string, language string) (id string, socketPath string, err error)
	funcStartOrigin    string
	inspectFuncStart   func(ctx context.Context, device string, language string)
	afterStartCounter  uint64
	beforeStartCounter uint64
	StartMock          mRecognitionMockStart

	funcStop          func(ctx context.Context, id string) (err error)
	funcStopOrigin    string
	inspectFuncStop   func(ctx context.Context, id string)
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mRecognitionMockStop

	funcText          func(ctx context.Context, id string) (s1 string, err error)
	funcTextOrigin    string
	inspectFuncText   func(ctx context.Context, id string)
	afterTextCounter  uint64
	beforeTextCounter uint64
	TextMock          mRecognitionMockText
}

// NewRecognitionMock returns a mock for Recognition
func NewRecognitionMock(t minimock.Tester) *RecognitionMock {
	m := &RecognitionMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.HasMock = mRecognitionMockHas{mock: m}
	m.HasMock.callArgs = []*RecognitionMockHasParams{}

	m.StartMock = mRecognitionMockStart{mock: m}
	m.StartMock.callArgs = []*RecognitionMockStartParams{}

	m.StopMock = mRecognitionMockStop{mock: m}
	m.StopMock.callArgs = []*RecognitionMockStopParams{}

	m.TextMock = mRecognitionMockText{mock: m}
	m.TextMock.callArgs = []*RecognitionMockTextParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRecognitionMockHas struct {
	optional           bool
	mock               *RecognitionMock
	defaultExpectation *RecognitionMockHasExpectation
	expectations       []*RecognitionMockHasExpectation

	callArgs []*RecognitionMockHasParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RecognitionMockHasExpectation specifies expectation struct of the Recognition.Has
type RecognitionMockHasExpectation struct {
	mock               *RecognitionMock
	params             *RecognitionMockHasParams
	paramPtrs          *RecognitionMockHasParamPtrs
	expectationOrigins RecognitionMockHasExpectationOrigins
	results            *RecognitionMockHasResults
	returnOrigin       string
	Counter            uint64
}

// RecognitionMockHasParams contains parameters of the Recognition.Has
type RecognitionMockHasParams struct {
	id string
}

// RecognitionMockHasParamPtrs contains pointers to parameters of the Recognition.Has
type RecognitionMockHasParamPtrs struct {
	id *string
}

// RecognitionMockHasResults contains results of the Recognition.Has
type RecognitionMockHasResults struct {
	b1 bool
}

// RecognitionMockHasOrigins contains origins of expectations of the Recognition.Has
type RecognitionMockHasExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHas *mRecognitionMockHas) Optional() *mRecognitionMockHas {
	mmHas.optional = true
	return mmHas
}

// Expect sets up expected params for Recognition.Has
func (mmHas *mRecognitionMockHas) Expect(id string) *mRecognitionMockHas {
	if mmHas.mock.funcHas != nil {
		mmHas.mock.t.Fatalf("RecognitionMock.Has mock is already set by Set")
	}

	if mmHas.defaultExpectation == nil {
		mmHas.defaultExpectation = &RecognitionMockHasExpectation{}
	}

	if mmHas.defaultExpectation.paramPtrs != nil {
		mmHas.mock.t.Fatalf("RecognitionMock.Has mock is already set by ExpectParams functions")
	}

	mmHas.defaultExpectation.params = &RecognitionMockHasParams{id}
	mmHas.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHas.expectations {
		if minimock.Equal(e.params, mmHas.defaultExpectation.params) {
			mmHas.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHas.defaultExpectation.params)
		}
	}

	return mmHas
}

// ExpectIdParam1 sets up expected param id for Recognition.Has
func (mmHas *mRecognitionMockHas) ExpectIdParam1(id string) *mRecognitionMockHas {
	if mmHas.mock.funcHas != nil {
		mmHas.mock.t.Fatalf("RecognitionMock.Has mock is already set by Set")
	}

	if mmHas.defaultExpectation == nil {
		mmHas.defaultExpectation = &RecognitionMockHasExpectation{}
	}

	if mmHas.defaultExpectation.params != nil {
		mmHas.mock.t.Fatalf("RecognitionMock.Has mock is already set by Expect")
	}

	if mmHas.defaultExpectation.paramPtrs == nil {
		mmHas.defaultExpectation.paramPtrs = &RecognitionMockHasParamPtrs{}
	}
	mmHas.defaultExpectation.paramPtrs.id = &id
	mmHas.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmHas
}

// Inspect accepts an inspector function that has same arguments as the Recognition.Has
func (mmHas *mRecognitionMockHas) Inspect(f func(id string)) *mRecognitionMockHas {
	if mmHas.mock.inspectFuncHas != nil {
		mmHas.mock.t.Fatalf("Inspect function is already set for RecognitionMock.Has")
	}

	mmHas.mock.inspectFuncHas = f

	return mmHas
}

// Return sets up results that will be returned by Recognition.Has
func (mmHas *mRecognitionMockHas) Return(b1 bool) *RecognitionMock {
	if mmHas.mock.funcHas != nil {
		mmHas.mock.t.Fatalf("RecognitionMock.Has mock is already set by Set")
	}

	if mmHas.defaultExpectation == nil {
		mmHas.defaultExpectation = &RecognitionMockHasExpectation{mock: mmHas.mock}
	}
	mmHas.defaultExpectation.results = &RecognitionMockHasResults{b1}
	mmHas.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHas.mock
}

// Set uses given function f to mock the Recognition.Has method
func (mmHas *mRecognitionMockHas) Set(f func(id string) (b1 bool)) *RecognitionMock {
	if mmHas.defaultExpectation != nil {
		mmHas.mock.t.Fatalf("Default expectation is already set for the Recognition.Has method")
	}

	if len(mmHas.expectations) > 0 {
		mmHas.mock.t.Fatalf("Some expectations are already set for the Recognition.Has method")
	}

	mmHas.mock.funcHas = f
	mmHas.mock.funcHasOrigin = minimock.CallerInfo(1)
	return mmHas.mock
}

// When sets expectation for the Recognition.Has which will trigger the result defined by the following
// Then helper
func (mmHas *mRecognitionMockHas) When(id string) *RecognitionMockHasExpectation {
	if mmHas.mock.funcHas != nil {
		mmHas.mock.t.Fatalf("RecognitionMock.Has mock is already set by Set")
	}

	expectation := &RecognitionMockHasExpectation{
		mock:               mmHas.mock,
		params:             &RecognitionMockHasParams{id},
		expectationOrigins: RecognitionMockHasExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHas.expectations = append(mmHas.expectations, expectation)
	return expectation
}

// Then sets up Recognition.Has return parameters for the expectation previously defined by the When method
func (e *RecognitionMockHasExpectation) Then(b1 bool) *RecognitionMock {
	e.results = &RecognitionMockHasResults{b1}
	return e.mock
}

// Times sets number of times Recognition.Has should be invoked
func (mmHas *mRecognitionMockHas) Times(n uint64) *mRecognitionMockHas {
	if n == 0 {
		mmHas.mock.t.Fatalf("Times of RecognitionMock.Has mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHas.expectedInvocations, n)
	mmHas.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHas
}

func (mmHas *mRecognitionMockHas) invocationsDone() bool {
	if len(mmHas.expectations) == 0 && mmHas.defaultExpectation == nil && mmHas.mock.funcHas == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHas.mock.afterHasCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHas.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Has implements Recognition
func (mmHas *RecognitionMock) Has(id string) (b1 bool) {
	mm_atomic.AddUint64(&mmHas.beforeHasCounter, 1)
	defer mm_atomic.AddUint64(&mmHas.afterHasCounter, 1)

	mmHas.t.Helper()

	if mmHas.inspectFuncHas != nil {
		mmHas.inspectFuncHas(id)
	}

	mm_params := RecognitionMockHasParams{id}

	// Record call args
	mmHas.HasMock.mutex.Lock()
	mmHas.HasMock.callArgs = append(mmHas.HasMock.callArgs, &mm_params)
	mmHas.HasMock.mutex.Unlock()

	for _, e := range mmHas.HasMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmHas.HasMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHas.HasMock.defaultExpectation.Counter, 1)
		mm_want := mmHas.HasMock.defaultExpectation.params
		mm_want_ptrs := mmHas.HasMock.defaultExpectation.paramPtrs

		mm_got := RecognitionMockHasParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmHas.t.Errorf("RecognitionMock.Has got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHas.HasMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHas.t.Errorf("RecognitionMock.Has got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHas.HasMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHas.HasMock.defaultExpectation.results
		if mm_results == nil {
			mmHas.t.Fatal("No results are set for the RecognitionMock.Has")
		}
		return (*mm_results).b1
	}
	if mmHas.funcHas != nil {
		return mmHas.funcHas(id)
	}
	mmHas.t.Fatalf("Unexpected call to RecognitionMock.Has. %v", id)
	return
}

// HasAfterCounter returns a count of finished RecognitionMock.Has invocations
func (mmHas *RecognitionMock) HasAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHas.afterHasCounter)
}

// HasBeforeCounter returns a count of RecognitionMock.Has invocations
func (mmHas *RecognitionMock) HasBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHas.beforeHasCounter)
}

// Calls returns a list of arguments used in each call to RecognitionMock.Has.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHas *mRecognitionMockHas) Calls() []*RecognitionMockHasParams {
	mmHas.mutex.RLock()

	argCopy := make([]*RecognitionMockHasParams, len(mmHas.callArgs))
	copy(argCopy, mmHas.callArgs)

	mmHas.mutex.RUnlock()

	return argCopy
}

// MinimockHasDone returns true if the count of the Has invocations corresponds
// the number of defined expectations
func (m *RecognitionMock) MinimockHasDone() bool {
	if m.HasMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HasMock.invocationsDone()
}

// MinimockHasInspect logs each unmet expectation
func (m *RecognitionMock) MinimockHasInspect() {
	for _, e := range m.HasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecognitionMock.Has at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHasCounter := mm_atomic.LoadUint64(&m.afterHasCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HasMock.defaultExpectation != nil && afterHasCounter < 1 {
		if m.HasMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RecognitionMock.Has at\n%s", m.HasMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RecognitionMock.Has at\n%s with params: %#v", m.HasMock.defaultExpectation.expectationOrigins.origin, *m.HasMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHas != nil && afterHasCounter < 1 {
		m.t.Errorf("Expected call to RecognitionMock.Has at\n%s", m.funcHasOrigin)
	}

	if !m.HasMock.invocationsDone() && afterHasCounter > 0 {
		m.t.Errorf("Expected %d calls to RecognitionMock.Has at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HasMock.expectedInvocations), m.HasMock.expectedInvocationsOrigin, afterHasCounter)
	}
}

type mRecognitionMockStart struct {
	optional           bool
	mock               *RecognitionMock
	defaultExpectation *RecognitionMockStartExpectation
	expectations       []*RecognitionMockStartExpectation

	callArgs []*RecognitionMockStartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RecognitionMockStartExpectation specifies expectation struct of the Recognition.Start
type RecognitionMockStartExpectation struct {
	mock               *RecognitionMock
	params             *RecognitionMockStartParams
	paramPtrs          *RecognitionMockStartParamPtrs
	expectationOrigins RecognitionMockStartExpectationOrigins
	results            *RecognitionMockStartResults
	returnOrigin       string
	Counter            uint64
}

// RecognitionMockStartParams contains parameters of the Recognition.Start
type RecognitionMockStartParams struct {
	ctx      context.Context
	device   string
	language string
}

// RecognitionMockStartParamPtrs contains pointers to parameters of the Recognition.Start
type RecognitionMockStartParamPtrs struct {
	ctx      *context.Context
	device   *string
	language *string
}

// RecognitionMockStartResults contains results of the Recognition.Start
type RecognitionMockStartResults struct {
	id         string
	socketPath string
	err        error
}

// RecognitionMockStartOrigins contains origins of expectations of the Recognition.Start
type RecognitionMockStartExpectationOrigins struct {
	origin         string
	originCtx      string
	originDevice   string
	originLanguage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStart *mRecognitionMockStart) Optional() *mRecognitionMockStart {
	mmStart.optional = true
	return mmStart
}

// Expect sets up expected params for Recognition.Start
func (mmStart *mRecognitionMockStart) Expect(ctx context.Context, device string, language string) *mRecognitionMockStart {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("RecognitionMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &RecognitionMockStartExpectation{}
	}

	if mmStart.defaultExpectation.paramPtrs != nil {
		mmStart.mock.t.Fatalf("RecognitionMock.Start mock is already set by ExpectParams functions")
	}

	mmStart.defaultExpectation.params = &RecognitionMockStartParams{ctx, device, language}
	mmStart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStart.expectations {
		if minimock.Equal(e.params, mmStart.defaultExpectation.params) {
			mmStart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStart.defaultExpectation.params)
		}
	}

	return mmStart
}

// ExpectCtxParam1 sets up expected param ctx for Recognition.Start
func (mmStart *mRecognitionMockStart) ExpectCtxParam1(ctx context.Context) *mRecognitionMockStart {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("RecognitionMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &RecognitionMockStartExpectation{}
	}

	if mmStart.defaultExpectation.params != nil {
		mmStart.mock.t.Fatalf("RecognitionMock.Start mock is already set by Expect")
	}

	if mmStart.defaultExpectation.paramPtrs == nil {
		mmStart.defaultExpectation.paramPtrs = &RecognitionMockStartParamPtrs{}
	}
	mmStart.defaultExpectation.paramPtrs.ctx = &ctx
	mmStart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStart
}

// ExpectDeviceParam2 sets up expected param device for Recognition.Start
func (mmStart *mRecognitionMockStart) ExpectDeviceParam2(device string) *mRecognitionMockStart {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("RecognitionMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &RecognitionMockStartExpectation{}
	}

	if mmStart.defaultExpectation.params != nil {
		mmStart.mock.t.Fatalf("RecognitionMock.Start mock is already set by Expect")
	}

	if mmStart.defaultExpectation.paramPtrs == nil {
		mmStart.defaultExpectation.paramPtrs = &RecognitionMockStartParamPtrs{}
	}
	mmStart.defaultExpectation.paramPtrs.device = &device
	mmStart.defaultExpectation.expectationOrigins.originDevice = minimock.CallerInfo(1)

	return mmStart
}

// ExpectLanguageParam3 sets up expected param language for Recognition.Start
func (mmStart *mRecognitionMockStart) ExpectLanguageParam3(language string) *mRecognitionMockStart {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("RecognitionMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &RecognitionMockStartExpectation{}
	}

	if mmStart.defaultExpectation.params != nil {
		mmStart.mock.t.Fatalf("RecognitionMock.Start mock is already set by Expect")
	}

	if mmStart.defaultExpectation.paramPtrs == nil {
		mmStart.defaultExpectation.paramPtrs = &RecognitionMockStartParamPtrs{}
	}
	mmStart.defaultExpectation.paramPtrs.language = &language
	mmStart.defaultExpectation.expectationOrigins.originLanguage = minimock.CallerInfo(1)

	return mmStart
}

// Inspect accepts an inspector function that has same arguments as the Recognition.Start
func (mmStart *mRecognitionMockStart) Inspect(f func(ctx context.Context, device string, language string)) *mRecognitionMockStart {
	if mmStart.mock.inspectFuncStart != nil {
		mmStart.mock.t.Fatalf("Inspect function is already set for RecognitionMock.Start")
	}

	mmStart.mock.inspectFuncStart = f

	return mmStart
}

// Return sets up results that will be returned by Recognition.Start
func (mmStart *mRecognitionMockStart) Return(id string, socketPath string, err error) *RecognitionMock {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("RecognitionMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &RecognitionMockStartExpectation{mock: mmStart.mock}
	}
	mmStart.defaultExpectation.results = &RecognitionMockStartResults{id, socketPath, err}
	mmStart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStart.mock
}

// Set uses given function f to mock the Recognition.Start method
func (mmStart *mRecognitionMockStart) Set(f func(ctx context.Context, device string, language string) (id string, socketPath string, err error)) *RecognitionMock {
	if mmStart.defaultExpectation != nil {
		mmStart.mock.t.Fatalf("Default expectation is already set for the Recognition.Start method")
	}

	if len(mmStart.expectations) > 0 {
		mmStart.mock.t.Fatalf("Some expectations are already set for the Recognition.Start method")
	}

	mmStart.mock.funcStart = f
	mmStart.mock.funcStartOrigin = minimock.CallerInfo(1)
	return mmStart.mock
}

// When sets expectation for the Recognition.Start which will trigger the result defined by the following
// Then helper
func (mmStart *mRecognitionMockStart) When(ctx context.Context, device string, language string) *RecognitionMockStartExpectation {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("RecognitionMock.Start mock is already set by Set")
	}

	expectation := &RecognitionMockStartExpectation{
		mock:               mmStart.mock,
		params:             &RecognitionMockStartParams{ctx, device, language},
		expectationOrigins: RecognitionMockStartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStart.expectations = append(mmStart.expectations, expectation)
	return expectation
}

// Then sets up Recognition.Start return parameters for the expectation previously defined by the When method
func (e *RecognitionMockStartExpectation) Then(id string, socketPath string, err error) *RecognitionMock {
	e.results = &RecognitionMockStartResults{id, socketPath, err}
	return e.mock
}

// Times sets number of times Recognition.Start should be invoked
func (mmStart *mRecognitionMockStart) Times(n uint64) *mRecognitionMockStart {
	if n == 0 {
		mmStart.mock.t.Fatalf("Times of RecognitionMock.Start mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStart.expectedInvocations, n)
	mmStart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStart
}

func (mmStart *mRecognitionMockStart) invocationsDone() bool {
	if len(mmStart.expectations) == 0 && mmStart.defaultExpectation == nil && mmStart.mock.funcStart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStart.mock.afterStartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Start implements Recognition
func (mmStart *RecognitionMock) Start(ctx context.Context, device string, language string) (id string, socketPath string, err error) {
	mm_atomic.AddUint64(&mmStart.beforeStartCounter, 1)
	defer mm_atomic.AddUint64(&mmStart.afterStartCounter, 1)

	mmStart.t.Helper()

	if mmStart.inspectFuncStart != nil {
		mmStart.inspectFuncStart(ctx, device, language)
	}

	mm_params := RecognitionMockStartParams{ctx, device, language}

	// Record call args
	mmStart.StartMock.mutex.Lock()
	mmStart.StartMock.callArgs = append(mmStart.StartMock.callArgs, &mm_params)
	mmStart.StartMock.mutex.Unlock()

	for _, e := range mmStart.StartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.id, e.results.socketPath, e.results.err
		}
	}

	if mmStart.StartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStart.StartMock.defaultExpectation.Counter, 1)
		mm_want := mmStart.StartMock.defaultExpectation.params
		mm_want_ptrs := mmStart.StartMock.defaultExpectation.paramPtrs

		mm_got := RecognitionMockStartParams{ctx, device, language}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStart.t.Errorf("RecognitionMock.Start got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStart.StartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.device != nil && !minimock.Equal(*mm_want_ptrs.device, mm_got.device) {
				mmStart.t.Errorf("RecognitionMock.Start got unexpected parameter device, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStart.StartMock.defaultExpectation.expectationOrigins.originDevice, *mm_want_ptrs.device, mm_got.device, minimock.Diff(*mm_want_ptrs.device, mm_got.device))
			}

			if mm_want_ptrs.language != nil && !minimock.Equal(*mm_want_ptrs.language, mm_got.language) {
				mmStart.t.Errorf("RecognitionMock.Start got unexpected parameter language, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStart.StartMock.defaultExpectation.expectationOrigins.originLanguage, *mm_want_ptrs.language, mm_got.language, minimock.Diff(*mm_want_ptrs.language, mm_got.language))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStart.t.Errorf("RecognitionMock.Start got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStart.StartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStart.StartMock.defaultExpectation.results
		if mm_results == nil {
			mmStart.t.Fatal("No results are set for the RecognitionMock.Start")
		}
		return (*mm_results).id, (*mm_results).socketPath, (*mm_results).err
	}
	if mmStart.funcStart != nil {
		return mmStart.funcStart(ctx, device, language)
	}
	mmStart.t.Fatalf("Unexpected call to RecognitionMock.Start. %v %v %v", ctx, device, language)
	return
}

// StartAfterCounter returns a count of finished RecognitionMock.Start invocations
func (mmStart *RecognitionMock) StartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.afterStartCounter)
}

// StartBeforeCounter returns a count of RecognitionMock.Start invocations
func (mmStart *RecognitionMock) StartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.beforeStartCounter)
}

// Calls returns a list of arguments used in each call to RecognitionMock.Start.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStart *mRecognitionMockStart) Calls() []*RecognitionMockStartParams {
	mmStart.mutex.RLock()

	argCopy := make([]*RecognitionMockStartParams, len(mmStart.callArgs))
	copy(argCopy, mmStart.callArgs)

	mmStart.mutex.RUnlock()

	return argCopy
}

// MinimockStartDone returns true if the count of the Start invocations corresponds
// the number of defined expectations
func (m *RecognitionMock) MinimockStartDone() bool {
	if m.StartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StartMock.invocationsDone()
}

// MinimockStartInspect logs each unmet expectation
func (m *RecognitionMock) MinimockStartInspect() {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecognitionMock.Start at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStartCounter := mm_atomic.LoadUint64(&m.afterStartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && afterStartCounter < 1 {
		if m.StartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RecognitionMock.Start at\n%s", m.StartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RecognitionMock.Start at\n%s with params: %#v", m.StartMock.defaultExpectation.expectationOrigins.origin, *m.StartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && afterStartCounter < 1 {
		m.t.Errorf("Expected call to RecognitionMock.Start at\n%s", m.funcStartOrigin)
	}

	if !m.StartMock.invocationsDone() && afterStartCounter > 0 {
		m.t.Errorf("Expected %d calls to RecognitionMock.Start at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StartMock.expectedInvocations), m.StartMock.expectedInvocationsOrigin, afterStartCounter)
	}
}

type mRecognitionMockStop struct {
	optional           bool
	mock               *RecognitionMock
	defaultExpectation *RecognitionMockStopExpectation
	expectations       []*RecognitionMockStopExpectation

	callArgs []*RecognitionMockStopParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RecognitionMockStopExpectation specifies expectation struct of the Recognition.Stop
type RecognitionMockStopExpectation struct {
	mock               *RecognitionMock
	params             *RecognitionMockStopParams
	paramPtrs          *RecognitionMockStopParamPtrs
	expectationOrigins RecognitionMockStopExpectationOrigins
	results            *RecognitionMockStopResults
	returnOrigin       string
	Counter            uint64
}

// RecognitionMockStopParams contains parameters of the Recognition.Stop
type RecognitionMockStopParams struct {
	ctx context.Context
	id  string
}

// RecognitionMockStopParamPtrs contains pointers to parameters of the Recognition.Stop
type RecognitionMockStopParamPtrs struct {
	ctx *context.Context
	id  *string
}

// RecognitionMockStopResults contains results of the Recognition.Stop
type RecognitionMockStopResults struct {
	err error
}

// RecognitionMockStopOrigins contains origins of expectations of the Recognition.Stop
type RecognitionMockStopExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStop *mRecognitionMockStop) Optional() *mRecognitionMockStop {
	mmStop.optional = true
	return mmStop
}

// Expect sets up expected params for Recognition.Stop
func (mmStop *mRecognitionMockStop) Expect(ctx context.Context, id string) *mRecognitionMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("RecognitionMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &RecognitionMockStopExpectation{}
	}

	if mmStop.defaultExpectation.paramPtrs != nil {
		mmStop.mock.t.Fatalf("RecognitionMock.Stop mock is already set by ExpectParams functions")
	}

	mmStop.defaultExpectation.params = &RecognitionMockStopParams{ctx, id}
	mmStop.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStop.expectations {
		if minimock.Equal(e.params, mmStop.defaultExpectation.params) {
			mmStop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStop.defaultExpectation.params)
		}
	}

	return mmStop
}

// ExpectCtxParam1 sets up expected param ctx for Recognition.Stop
func (mmStop *mRecognitionMockStop) ExpectCtxParam1(ctx context.Context) *mRecognitionMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("RecognitionMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &RecognitionMockStopExpectation{}
	}

	if mmStop.defaultExpectation.params != nil {
		mmStop.mock.t.Fatalf("RecognitionMock.Stop mock is already set by Expect")
	}

	if mmStop.defaultExpectation.paramPtrs == nil {
		mmStop.defaultExpectation.paramPtrs = &RecognitionMockStopParamPtrs{}
	}
	mmStop.defaultExpectation.paramPtrs.ctx = &ctx
	mmStop.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStop
}

// ExpectIdParam2 sets up expected param id for Recognition.Stop
func (mmStop *mRecognitionMockStop) ExpectIdParam2(id string) *mRecognitionMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("RecognitionMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &RecognitionMockStopExpectation{}
	}

	if mmStop.defaultExpectation.params != nil {
		mmStop.mock.t.Fatalf("RecognitionMock.Stop mock is already set by Expect")
	}

	if mmStop.defaultExpectation.paramPtrs == nil {
		mmStop.defaultExpectation.paramPtrs = &RecognitionMockStopParamPtrs{}
	}
	mmStop.defaultExpectation.paramPtrs.id = &id
	mmStop.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the Recognition.Stop
func (mmStop *mRecognitionMockStop) Inspect(f func(ctx context.Context, id string)) *mRecognitionMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for RecognitionMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by Recognition.Stop
func (mmStop *mRecognitionMockStop) Return(err error) *RecognitionMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("RecognitionMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &RecognitionMockStopExpectation{mock: mmStop.mock}
	}
	mmStop.defaultExpectation.results = &RecognitionMockStopResults{err}
	mmStop.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStop.mock
}

// Set uses given function f to mock the Recognition.Stop method
func (mmStop *mRecognitionMockStop) Set(f func(ctx context.Context, id string) (err error)) *RecognitionMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the Recognition.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the Recognition.Stop method")
	}

	mmStop.mock.funcStop = f
	mmStop.mock.funcStopOrigin = minimock.CallerInfo(1)
	return mmStop.mock
}

// When sets expectation for the Recognition.Stop which will trigger the result defined by the following
// Then helper
func (mmStop *mRecognitionMockStop) When(ctx context.Context, id string) *RecognitionMockStopExpectation {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("RecognitionMock.Stop mock is already set by Set")
	}

	expectation := &RecognitionMockStopExpectation{
		mock:               mmStop.mock,
		params:             &RecognitionMockStopParams{ctx, id},
		expectationOrigins: RecognitionMockStopExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStop.expectations = append(mmStop.expectations, expectation)
	return expectation
}

// Then sets up Recognition.Stop return parameters for the expectation previously defined by the When method
func (e *RecognitionMockStopExpectation) Then(err error) *RecognitionMock {
	e.results = &RecognitionMockStopResults{err}
	return e.mock
}

// Times sets number of times Recognition.Stop should be invoked
func (mmStop *mRecognitionMockStop) Times(n uint64) *mRecognitionMockStop {
	if n == 0 {
		mmStop.mock.t.Fatalf("Times of RecognitionMock.Stop mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStop.expectedInvocations, n)
	mmStop.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStop
}

func (mmStop *mRecognitionMockStop) invocationsDone() bool {
	if len(mmStop.expectations) == 0 && mmStop.defaultExpectation == nil && mmStop.mock.funcStop == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStop.mock.afterStopCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStop.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Stop implements Recognition
func (mmStop *RecognitionMock) Stop(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	mmStop.t.Helper()

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop(ctx, id)
	}

	mm_params := RecognitionMockStopParams{ctx, id}

	// Record call args
	mmStop.StopMock.mutex.Lock()
	mmStop.StopMock.callArgs = append(mmStop.StopMock.callArgs, &mm_params)
	mmStop.StopMock.mutex.Unlock()

	for _, e := range mmStop.StopMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)
		mm_want := mmStop.StopMock.defaultExpectation.params
		mm_want_ptrs := mmStop.StopMock.defaultExpectation.paramPtrs

		mm_got := RecognitionMockStopParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStop.t.Errorf("RecognitionMock.Stop got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStop.StopMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmStop.t.Errorf("RecognitionMock.Stop got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStop.StopMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStop.t.Errorf("RecognitionMock.Stop got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStop.StopMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStop.StopMock.defaultExpectation.results
		if mm_results == nil {
			mmStop.t.Fatal("No results are set for the RecognitionMock.Stop")
		}
		return (*mm_results).err
	}
	if mmStop.funcStop != nil {
		return mmStop.funcStop(ctx, id)
	}
	mmStop.t.Fatalf("Unexpected call to RecognitionMock.Stop. %v %v", ctx, id)
	return
}

// StopAfterCounter returns a count of finished RecognitionMock.Stop invocations
func (mmStop *RecognitionMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of RecognitionMock.Stop invocations
func (mmStop *RecognitionMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// Calls returns a list of arguments used in each call to RecognitionMock.Stop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStop *mRecognitionMockStop) Calls() []*RecognitionMockStopParams {
	mmStop.mutex.RLock()

	argCopy := make([]*RecognitionMockStopParams, len(mmStop.callArgs))
	copy(argCopy, mmStop.callArgs)

	mmStop.mutex.RUnlock()

	return argCopy
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *RecognitionMock) MinimockStopDone() bool {
	if m.StopMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StopMock.invocationsDone()
}

// MinimockStopInspect logs each unmet expectation
func (m *RecognitionMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecognitionMock.Stop at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStopCounter := mm_atomic.LoadUint64(&m.afterStopCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && afterStopCounter < 1 {
		if m.StopMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RecognitionMock.Stop at\n%s", m.StopMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RecognitionMock.Stop at\n%s with params: %#v", m.StopMock.defaultExpectation.expectationOrigins.origin, *m.StopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && afterStopCounter < 1 {
		m.t.Errorf("Expected call to RecognitionMock.Stop at\n%s", m.funcStopOrigin)
	}

	if !m.StopMock.invocationsDone() && afterStopCounter > 0 {
		m.t.Errorf("Expected %d calls to RecognitionMock.Stop at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StopMock.expectedInvocations), m.StopMock.expectedInvocationsOrigin, afterStopCounter)
	}
}

type mRecognitionMockText struct {
	optional           bool
	mock               *RecognitionMock
	defaultExpectation *RecognitionMockTextExpectation
	expectations       []*RecognitionMockTextExpectation

	callArgs []*RecognitionMockTextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RecognitionMockTextExpectation specifies expectation struct of the Recognition.Text
type RecognitionMockTextExpectation struct {
	mock               *RecognitionMock
	params             *RecognitionMockTextParams
	paramPtrs          *RecognitionMockTextParamPtrs
	expectationOrigins RecognitionMockTextExpectationOrigins
	results            *RecognitionMockTextResults
	returnOrigin       string
	Counter            uint64
}

// RecognitionMockTextParams contains parameters of the Recognition.Text
type RecognitionMockTextParams struct {
	ctx context.Context
	id  string
}

// RecognitionMockTextParamPtrs contains pointers to parameters of the Recognition.Text
type RecognitionMockTextParamPtrs struct {
	ctx *context.Context
	id  *string
}

// RecognitionMockTextResults contains results of the Recognition.Text
type RecognitionMockTextResults struct {
	s1  string
	err error
}

// RecognitionMockTextOrigins contains origins of expectations of the Recognition.Text
type RecognitionMockTextExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmText *mRecognitionMockText) Optional() *mRecognitionMockText {
	mmText.optional = true
	return mmText
}

// Expect sets up expected params for Recognition.Text
func (mmText *mRecognitionMockText) Expect(ctx context.Context, id string) *mRecognitionMockText {
	if mmText.mock.funcText != nil {
		mmText.mock.t.Fatalf("RecognitionMock.Text mock is already set by Set")
	}

	if mmText.defaultExpectation == nil {
		mmText.defaultExpectation = &RecognitionMockTextExpectation{}
	}

	if mmText.defaultExpectation.paramPtrs != nil {
		mmText.mock.t.Fatalf("RecognitionMock.Text mock is already set by ExpectParams functions")
	}

	mmText.defaultExpectation.params = &RecognitionMockTextParams{ctx, id}
	mmText.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmText.expectations {
		if minimock.Equal(e.params, mmText.defaultExpectation.params) {
			mmText.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmText.defaultExpectation.params)
		}
	}

	return mmText
}

// ExpectCtxParam1 sets up expected param ctx for Recognition.Text
func (mmText *mRecognitionMockText) ExpectCtxParam1(ctx context.Context) *mRecognitionMockText {
	if mmText.mock.funcText != nil {
		mmText.mock.t.Fatalf("RecognitionMock.Text mock is already set by Set")
	}

	if mmText.defaultExpectation == nil {
		mmText.defaultExpectation = &RecognitionMockTextExpectation{}
	}

	if mmText.defaultExpectation.params != nil {
		mmText.mock.t.Fatalf("RecognitionMock.Text mock is already set by Expect")
	}

	if mmText.defaultExpectation.paramPtrs == nil {
		mmText.defaultExpectation.paramPtrs = &RecognitionMockTextParamPtrs{}
	}
	mmText.defaultExpectation.paramPtrs.ctx = &ctx
	mmText.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmText
}

// ExpectIdParam2 sets up expected param id for Recognition.Text
func (mmText *mRecognitionMockText) ExpectIdParam2(id string) *mRecognitionMockText {
	if mmText.mock.funcText != nil {
		mmText.mock.t.Fatalf("RecognitionMock.Text mock is already set by Set")
	}

	if mmText.defaultExpectation == nil {
		mmText.defaultExpectation = &RecognitionMockTextExpectation{}
	}

	if mmText.defaultExpectation.params != nil {
		mmText.mock.t.Fatalf("RecognitionMock.Text mock is already set by Expect")
	}

	if mmText.defaultExpectation.paramPtrs == nil {
		mmText.defaultExpectation.paramPtrs = &RecognitionMockTextParamPtrs{}
	}
	mmText.defaultExpectation.paramPtrs.id = &id
	mmText.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmText
}

// Inspect accepts an inspector function that has same arguments as the Recognition.Text
func (mmText *mRecognitionMockText) Inspect(f func(ctx context.Context, id string)) *mRecognitionMockText {
	if mmText.mock.inspectFuncText != nil {
		mmText.mock.t.Fatalf("Inspect function is already set for RecognitionMock.Text")
	}

	mmText.mock.inspectFuncText = f

	return mmText
}

// Return sets up results that will be returned by Recognition.Text
func (mmText *mRecognitionMockText) Return(s1 string, err error) *RecognitionMock {
	if mmText.mock.funcText != nil {
		mmText.mock.t.Fatalf("RecognitionMock.Text mock is already set by Set")
	}

	if mmText.defaultExpectation == nil {
		mmText.defaultExpectation = &RecognitionMockTextExpectation{mock: mmText.mock}
	}
	mmText.defaultExpectation.results = &RecognitionMockTextResults{s1, err}
	mmText.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmText.mock
}

// Set uses given function f to mock the Recognition.Text method
func (mmText *mRecognitionMockText) Set(f func(ctx context.Context, id string) (s1 string, err error)) *RecognitionMock {
	if mmText.defaultExpectation != nil {
		mmText.mock.t.Fatalf("Default expectation is already set for the Recognition.Text method")
	}

	if len(mmText.expectations) > 0 {
		mmText.mock.t.Fatalf("Some expectations are already set for the Recognition.Text method")
	}

	mmText.mock.funcText = f
	mmText.mock.funcTextOrigin = minimock.CallerInfo(1)
	return mmText.mock
}

// When sets expectation for the Recognition.Text which will trigger the result defined by the following
// Then helper
func (mmText *mRecognitionMockText) When(ctx context.Context, id string) *RecognitionMockTextExpectation {
	if mmText.mock.funcText != nil {
		mmText.mock.t.Fatalf("RecognitionMock.Text mock is already set by Set")
	}

	expectation := &RecognitionMockTextExpectation{
		mock:               mmText.mock,
		params:             &RecognitionMockTextParams{ctx, id},
		expectationOrigins: RecognitionMockTextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmText.expectations = append(mmText.expectations, expectation)
	return expectation
}

// Then sets up Recognition.Text return parameters for the expectation previously defined by the When method
func (e *RecognitionMockTextExpectation) Then(s1 string, err error) *RecognitionMock {
	e.results = &RecognitionMockTextResults{s1, err}
	return e.mock
}

// Times sets number of times Recognition.Text should be invoked
func (mmText *mRecognitionMockText) Times(n uint64) *mRecognitionMockText {
	if n == 0 {
		mmText.mock.t.Fatalf("Times of RecognitionMock.Text mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmText.expectedInvocations, n)
	mmText.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmText
}

func (mmText *mRecognitionMockText) invocationsDone() bool {
	if len(mmText.expectations) == 0 && mmText.defaultExpectation == nil && mmText.mock.funcText == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmText.mock.afterTextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmText.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Text implements Recognition
func (mmText *RecognitionMock) Text(ctx context.Context, id string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmText.beforeTextCounter, 1)
	defer mm_atomic.AddUint64(&mmText.afterTextCounter, 1)

	mmText.t.Helper()

	if mmText.inspectFuncText != nil {
		mmText.inspectFuncText(ctx, id)
	}

	mm_params := RecognitionMockTextParams{ctx, id}

	// Record call args
	mmText.TextMock.mutex.Lock()
	mmText.TextMock.callArgs = append(mmText.TextMock.callArgs, &mm_params)
	mmText.TextMock.mutex.Unlock()

	for _, e := range mmText.TextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmText.TextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmText.TextMock.defaultExpectation.Counter, 1)
		mm_want := mmText.TextMock.defaultExpectation.params
		mm_want_ptrs := mmText.TextMock.defaultExpectation.paramPtrs

		mm_got := RecognitionMockTextParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmText.t.Errorf("RecognitionMock.Text got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmText.TextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmText.t.Errorf("RecognitionMock.Text got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmText.TextMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmText.t.Errorf("RecognitionMock.Text got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmText.TextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmText.TextMock.defaultExpectation.results
		if mm_results == nil {
			mmText.t.Fatal("No results are set for the RecognitionMock.Text")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmText.funcText != nil {
		return mmText.funcText(ctx, id)
	}
	mmText.t.Fatalf("Unexpected call to RecognitionMock.Text. %v %v", ctx, id)
	return
}

// TextAfterCounter returns a count of finished RecognitionMock.Text invocations
func (mmText *RecognitionMock) TextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmText.afterTextCounter)
}

// TextBeforeCounter returns a count of RecognitionMock.Text invocations
func (mmText *RecognitionMock) TextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmText.beforeTextCounter)
}

// Calls returns a list of arguments used in each call to RecognitionMock.Text.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmText *mRecognitionMockText) Calls() []*RecognitionMockTextParams {
	mmText.mutex.RLock()

	argCopy := make([]*RecognitionMockTextParams, len(mmText.callArgs))
	copy(argCopy, mmText.callArgs)

	mmText.mutex.RUnlock()

	return argCopy
}

// MinimockTextDone returns true if the count of the Text invocations corresponds
// the number of defined expectations
func (m *RecognitionMock) MinimockTextDone() bool {
	if m.TextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TextMock.invocationsDone()
}

// MinimockTextInspect logs each unmet expectation
func (m *RecognitionMock) MinimockTextInspect() {
	for _, e := range m.TextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecognitionMock.Text at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTextCounter := mm_atomic.LoadUint64(&m.afterTextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TextMock.defaultExpectation != nil && afterTextCounter < 1 {
		if m.TextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RecognitionMock.Text at\n%s", m.TextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RecognitionMock.Text at\n%s with params: %#v", m.TextMock.defaultExpectation.expectationOrigins.origin, *m.TextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcText != nil && afterTextCounter < 1 {
		m.t.Errorf("Expected call to RecognitionMock.Text at\n%s", m.funcTextOrigin)
	}

	if !m.TextMock.invocationsDone() && afterTextCounter > 0 {
		m.t.Errorf("Expected %d calls to RecognitionMock.Text at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TextMock.expectedInvocations), m.TextMock.expectedInvocationsOrigin, afterTextCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RecognitionMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockHasInspect()

			m.MinimockStartInspect()

			m.MinimockStopInspect()

			m.MinimockTextInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RecognitionMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RecognitionMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockHasDone() &&
		m.MinimockStartDone() &&
		m.MinimockStopDone() &&
		m.MinimockTextDone()
}
